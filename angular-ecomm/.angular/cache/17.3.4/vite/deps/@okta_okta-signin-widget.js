import {
  BroadcastChannel,
  JSONPath,
  api,
  createLeaderElection,
  require_browser_ponyfill,
  require_p_cancelable,
  require_tiny_emitter
} from "./chunk-DJVU3HQQ.js";
import {
  __async,
  __commonJS,
  __export,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-CPNXOV62.js";

// node_modules/q/q.js
var require_q = __commonJS({
  "node_modules/q/q.js"(exports, module) {
    (function(definition) {
      "use strict";
      if (typeof bootstrap === "function") {
        bootstrap("promise", definition);
      } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();
      } else if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        var global2 = typeof window !== "undefined" ? window : self;
        var previousQ = global2.Q;
        global2.Q = definition();
        global2.Q.noConflict = function() {
          global2.Q = previousQ;
          return this;
        };
      } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
      }
    })(function() {
      "use strict";
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var qStartingLine = captureLine();
      var qFileName;
      var noop3 = function() {
      };
      var nextTick = function() {
        var head = { task: void 0, next: null };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        var laterQueue = [];
        function flush() {
          var task, domain;
          while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;
            if (domain) {
              head.domain = void 0;
              domain.enter();
            }
            runSingle(task, domain);
          }
          while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
          }
          flushing = false;
        }
        function runSingle(task, domain) {
          try {
            task();
          } catch (e) {
            if (isNodeJS) {
              if (domain) {
                domain.exit();
              }
              setTimeout(flush, 0);
              if (domain) {
                domain.enter();
              }
              throw e;
            } else {
              setTimeout(function() {
                throw e;
              }, 0);
            }
          }
          if (domain) {
            domain.exit();
          }
        }
        nextTick = function(task) {
          tail = tail.next = {
            task,
            domain: isNodeJS && process.domain,
            next: null
          };
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
          isNodeJS = true;
          requestTick = function() {
            process.nextTick(flush);
          };
        } else if (typeof setImmediate === "function") {
          if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
          } else {
            requestTick = function() {
              setImmediate(flush);
            };
          }
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          channel.port1.onmessage = function() {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
          };
          var requestPortTick = function() {
            channel.port2.postMessage(0);
          };
          requestTick = function() {
            setTimeout(flush, 0);
            requestPortTick();
          };
        } else {
          requestTick = function() {
            setTimeout(flush, 0);
          };
        }
        nextTick.runAfter = function(task) {
          laterQueue.push(task);
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        return nextTick;
      }();
      var call = Function.call;
      function uncurryThis(f) {
        return function() {
          return call.apply(f, arguments);
        };
      }
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(
        Array.prototype.reduce || function(callback, basis) {
          var index = 0, length = this.length;
          if (arguments.length === 1) {
            do {
              if (index in this) {
                basis = this[index++];
                break;
              }
              if (++index >= length) {
                throw new TypeError();
              }
            } while (1);
          }
          for (; index < length; index++) {
            if (index in this) {
              basis = callback(basis, this[index], index);
            }
          }
          return basis;
        }
      );
      var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function(value) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
              return i;
            }
          }
          return -1;
        }
      );
      var array_map = uncurryThis(
        Array.prototype.map || function(callback, thisp) {
          var self2 = this;
          var collect = [];
          array_reduce(self2, function(undefined2, value, index) {
            collect.push(callback.call(thisp, value, index, self2));
          }, void 0);
          return collect;
        }
      );
      var object_create = Object.create || function(prototype) {
        function Type() {
        }
        Type.prototype = prototype;
        return new Type();
      };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function(object) {
        var keys = [];
        for (var key in object) {
          if (object_hasOwnProperty(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isObject3(value) {
        return value === Object(value);
      }
      function isStopIteration(exception2) {
        return object_toString(exception2) === "[object StopIteration]" || exception2 instanceof QReturnValue;
      }
      var QReturnValue;
      if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = function(value) {
          this.value = value;
        };
      }
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, promise2) {
        if (hasStacks && promise2.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var p = promise2; !!p; p = p.source) {
            if (p.stack) {
              stacks.unshift(p.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          qFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function deprecate2(callback, name, alternative) {
        return function() {
          if (typeof console !== "undefined" && typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
          }
          return callback.apply(callback, arguments);
        };
      }
      function Q20(value) {
        if (value instanceof Promise2) {
          return value;
        }
        if (isPromiseAlike(value)) {
          return coerce(value);
        } else {
          return fulfill(value);
        }
      }
      Q20.resolve = Q20;
      Q20.nextTick = nextTick;
      Q20.longStackSupport = false;
      if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q20.longStackSupport = true;
      }
      Q20.defer = defer2;
      function defer2() {
        var messages = [], progressListeners = [], resolvedPromise;
        var deferred = object_create(defer2.prototype);
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, operands) {
          var args = array_slice(arguments);
          if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            Q20.nextTick(function() {
              resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
          }
        };
        promise2.valueOf = function() {
          if (messages) {
            return promise2;
          }
          var nearerValue = nearer(resolvedPromise);
          if (isPromise2(nearerValue)) {
            resolvedPromise = nearerValue;
          }
          return nearerValue;
        };
        promise2.inspect = function() {
          if (!resolvedPromise) {
            return { state: "pending" };
          }
          return resolvedPromise.inspect();
        };
        if (Q20.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e) {
            promise2.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          }
        }
        function become(newPromise) {
          resolvedPromise = newPromise;
          promise2.source = newPromise;
          array_reduce(messages, function(undefined2, message) {
            Q20.nextTick(function() {
              newPromise.promiseDispatch.apply(newPromise, message);
            });
          }, void 0);
          messages = void 0;
          progressListeners = void 0;
        }
        deferred.promise = promise2;
        deferred.resolve = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(Q20(value));
        };
        deferred.fulfill = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(fulfill(value));
        };
        deferred.reject = function(reason) {
          if (resolvedPromise) {
            return;
          }
          become(reject(reason));
        };
        deferred.notify = function(progress2) {
          if (resolvedPromise) {
            return;
          }
          array_reduce(progressListeners, function(undefined2, progressListener) {
            Q20.nextTick(function() {
              progressListener(progress2);
            });
          }, void 0);
        };
        return deferred;
      }
      defer2.prototype.makeNodeResolver = function() {
        var self2 = this;
        return function(error, value) {
          if (error) {
            self2.reject(error);
          } else if (arguments.length > 2) {
            self2.resolve(array_slice(arguments, 1));
          } else {
            self2.resolve(value);
          }
        };
      };
      Q20.Promise = promise;
      Q20.promise = promise;
      function promise(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function.");
        }
        var deferred = defer2();
        try {
          resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
          deferred.reject(reason);
        }
        return deferred.promise;
      }
      promise.race = race;
      promise.all = all;
      promise.reject = reject;
      promise.resolve = Q20;
      Q20.passByCopy = function(object) {
        return object;
      };
      Promise2.prototype.passByCopy = function() {
        return this;
      };
      Q20.join = function(x, y) {
        return Q20(x).join(y);
      };
      Promise2.prototype.join = function(that) {
        return Q20([this, that]).spread(function(x, y) {
          if (x === y) {
            return x;
          } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
          }
        });
      };
      Q20.race = race;
      function race(answerPs) {
        return promise(function(resolve, reject2) {
          for (var i = 0, len = answerPs.length; i < len; i++) {
            Q20(answerPs[i]).then(resolve, reject2);
          }
        });
      }
      Promise2.prototype.race = function() {
        return this.then(Q20.race);
      };
      Q20.makePromise = Promise2;
      function Promise2(descriptor, fallback, inspect) {
        if (fallback === void 0) {
          fallback = function(op) {
            return reject(new Error(
              "Promise does not support operation: " + op
            ));
          };
        }
        if (inspect === void 0) {
          inspect = function() {
            return { state: "unknown" };
          };
        }
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise2, args);
            } else {
              result = fallback.call(promise2, op, args);
            }
          } catch (exception2) {
            result = reject(exception2);
          }
          if (resolve) {
            resolve(result);
          }
        };
        promise2.inspect = inspect;
        if (inspect) {
          var inspected = inspect();
          if (inspected.state === "rejected") {
            promise2.exception = inspected.reason;
          }
          promise2.valueOf = function() {
            var inspected2 = inspect();
            if (inspected2.state === "pending" || inspected2.state === "rejected") {
              return promise2;
            }
            return inspected2.value;
          };
        }
        return promise2;
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.then = function(fulfilled, rejected, progressed) {
        var self2 = this;
        var deferred = defer2();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
          } catch (exception2) {
            return reject(exception2);
          }
        }
        function _rejected(exception2) {
          if (typeof rejected === "function") {
            makeStackTraceLong(exception2, self2);
            try {
              return rejected(exception2);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception2);
        }
        function _progressed(value) {
          return typeof progressed === "function" ? progressed(value) : value;
        }
        Q20.nextTick(function() {
          self2.promiseDispatch(function(value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, "when", [function(exception2) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_rejected(exception2));
          }]);
        });
        self2.promiseDispatch(void 0, "when", [void 0, function(value) {
          var newValue;
          var threw = false;
          try {
            newValue = _progressed(value);
          } catch (e) {
            threw = true;
            if (Q20.onerror) {
              Q20.onerror(e);
            } else {
              throw e;
            }
          }
          if (!threw) {
            deferred.notify(newValue);
          }
        }]);
        return deferred.promise;
      };
      Q20.tap = function(promise2, callback) {
        return Q20(promise2).tap(callback);
      };
      Promise2.prototype.tap = function(callback) {
        callback = Q20(callback);
        return this.then(function(value) {
          return callback.fcall(value).thenResolve(value);
        });
      };
      Q20.when = when;
      function when(value, fulfilled, rejected, progressed) {
        return Q20(value).then(fulfilled, rejected, progressed);
      }
      Promise2.prototype.thenResolve = function(value) {
        return this.then(function() {
          return value;
        });
      };
      Q20.thenResolve = function(promise2, value) {
        return Q20(promise2).thenResolve(value);
      };
      Promise2.prototype.thenReject = function(reason) {
        return this.then(function() {
          throw reason;
        });
      };
      Q20.thenReject = function(promise2, reason) {
        return Q20(promise2).thenReject(reason);
      };
      Q20.nearer = nearer;
      function nearer(value) {
        if (isPromise2(value)) {
          var inspected = value.inspect();
          if (inspected.state === "fulfilled") {
            return inspected.value;
          }
        }
        return value;
      }
      Q20.isPromise = isPromise2;
      function isPromise2(object) {
        return object instanceof Promise2;
      }
      Q20.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return isObject3(object) && typeof object.then === "function";
      }
      Q20.isPending = isPending;
      function isPending(object) {
        return isPromise2(object) && object.inspect().state === "pending";
      }
      Promise2.prototype.isPending = function() {
        return this.inspect().state === "pending";
      };
      Q20.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromise2(object) || object.inspect().state === "fulfilled";
      }
      Promise2.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
      };
      Q20.isRejected = isRejected;
      function isRejected(object) {
        return isPromise2(object) && object.inspect().state === "rejected";
      }
      Promise2.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
      };
      var unhandledReasons = [];
      var unhandledRejections = [];
      var reportedUnhandledRejections = [];
      var trackUnhandledRejections = true;
      function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        if (!trackUnhandledRejections) {
          trackUnhandledRejections = true;
        }
      }
      function trackRejection(promise2, reason) {
        if (!trackUnhandledRejections) {
          return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
          Q20.nextTick.runAfter(function() {
            if (array_indexOf(unhandledRejections, promise2) !== -1) {
              process.emit("unhandledRejection", reason, promise2);
              reportedUnhandledRejections.push(promise2);
            }
          });
        }
        unhandledRejections.push(promise2);
        if (reason && typeof reason.stack !== "undefined") {
          unhandledReasons.push(reason.stack);
        } else {
          unhandledReasons.push("(no stack) " + reason);
        }
      }
      function untrackRejection(promise2) {
        if (!trackUnhandledRejections) {
          return;
        }
        var at = array_indexOf(unhandledRejections, promise2);
        if (at !== -1) {
          if (typeof process === "object" && typeof process.emit === "function") {
            Q20.nextTick.runAfter(function() {
              var atReport = array_indexOf(reportedUnhandledRejections, promise2);
              if (atReport !== -1) {
                process.emit("rejectionHandled", unhandledReasons[at], promise2);
                reportedUnhandledRejections.splice(atReport, 1);
              }
            });
          }
          unhandledRejections.splice(at, 1);
          unhandledReasons.splice(at, 1);
        }
      }
      Q20.resetUnhandledRejections = resetUnhandledRejections;
      Q20.getUnhandledReasons = function() {
        return unhandledReasons.slice();
      };
      Q20.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
      };
      resetUnhandledRejections();
      Q20.reject = reject;
      function reject(reason) {
        var rejection = Promise2({
          "when": function(rejected) {
            if (rejected) {
              untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
          }
        }, function fallback() {
          return this;
        }, function inspect() {
          return { state: "rejected", reason };
        });
        trackRejection(rejection, reason);
        return rejection;
      }
      Q20.fulfill = fulfill;
      function fulfill(value) {
        return Promise2({
          "when": function() {
            return value;
          },
          "get": function(name) {
            return value[name];
          },
          "set": function(name, rhs) {
            value[name] = rhs;
          },
          "delete": function(name) {
            delete value[name];
          },
          "post": function(name, args) {
            if (name === null || name === void 0) {
              return value.apply(void 0, args);
            } else {
              return value[name].apply(value, args);
            }
          },
          "apply": function(thisp, args) {
            return value.apply(thisp, args);
          },
          "keys": function() {
            return object_keys(value);
          }
        }, void 0, function inspect() {
          return { state: "fulfilled", value };
        });
      }
      function coerce(promise2) {
        var deferred = defer2();
        Q20.nextTick(function() {
          try {
            promise2.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception2) {
            deferred.reject(exception2);
          }
        });
        return deferred.promise;
      }
      Q20.master = master;
      function master(object) {
        return Promise2({
          "isDef": function() {
          }
        }, function fallback(op, args) {
          return dispatch(object, op, args);
        }, function() {
          return Q20(object).inspect();
        });
      }
      Q20.spread = spread;
      function spread(value, fulfilled, rejected) {
        return Q20(value).spread(fulfilled, rejected);
      }
      Promise2.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
          return fulfilled.apply(void 0, array);
        }, rejected);
      };
      Q20.async = async;
      function async(makeGenerator) {
        return function() {
          function continuer(verb, arg) {
            var result;
            if (typeof StopIteration === "undefined") {
              try {
                result = generator[verb](arg);
              } catch (exception2) {
                return reject(exception2);
              }
              if (result.done) {
                return Q20(result.value);
              } else {
                return when(result.value, callback, errback);
              }
            } else {
              try {
                result = generator[verb](arg);
              } catch (exception2) {
                if (isStopIteration(exception2)) {
                  return Q20(exception2.value);
                } else {
                  return reject(exception2);
                }
              }
              return when(result, callback, errback);
            }
          }
          var generator = makeGenerator.apply(this, arguments);
          var callback = continuer.bind(continuer, "next");
          var errback = continuer.bind(continuer, "throw");
          return callback();
        };
      }
      Q20.spawn = spawn;
      function spawn(makeGenerator) {
        Q20.done(Q20.async(makeGenerator)());
      }
      Q20["return"] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      Q20.promised = promised;
      function promised(callback) {
        return function() {
          return spread([this, all(arguments)], function(self2, args) {
            return callback.apply(self2, args);
          });
        };
      }
      Q20.dispatch = dispatch;
      function dispatch(object, op, args) {
        return Q20(object).dispatch(op, args);
      }
      Promise2.prototype.dispatch = function(op, args) {
        var self2 = this;
        var deferred = defer2();
        Q20.nextTick(function() {
          self2.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      };
      Q20.get = function(object, key) {
        return Q20(object).dispatch("get", [key]);
      };
      Promise2.prototype.get = function(key) {
        return this.dispatch("get", [key]);
      };
      Q20.set = function(object, key, value) {
        return Q20(object).dispatch("set", [key, value]);
      };
      Promise2.prototype.set = function(key, value) {
        return this.dispatch("set", [key, value]);
      };
      Q20.del = // XXX legacy
      Q20["delete"] = function(object, key) {
        return Q20(object).dispatch("delete", [key]);
      };
      Promise2.prototype.del = // XXX legacy
      Promise2.prototype["delete"] = function(key) {
        return this.dispatch("delete", [key]);
      };
      Q20.mapply = // XXX As proposed by "Redsandro"
      Q20.post = function(object, name, args) {
        return Q20(object).dispatch("post", [name, args]);
      };
      Promise2.prototype.mapply = // XXX As proposed by "Redsandro"
      Promise2.prototype.post = function(name, args) {
        return this.dispatch("post", [name, args]);
      };
      Q20.send = // XXX Mark Miller's proposed parlance
      Q20.mcall = // XXX As proposed by "Redsandro"
      Q20.invoke = function(object, name) {
        return Q20(object).dispatch("post", [name, array_slice(arguments, 2)]);
      };
      Promise2.prototype.send = // XXX Mark Miller's proposed parlance
      Promise2.prototype.mcall = // XXX As proposed by "Redsandro"
      Promise2.prototype.invoke = function(name) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
      };
      Q20.fapply = function(object, args) {
        return Q20(object).dispatch("apply", [void 0, args]);
      };
      Promise2.prototype.fapply = function(args) {
        return this.dispatch("apply", [void 0, args]);
      };
      Q20["try"] = Q20.fcall = function(object) {
        return Q20(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
      };
      Promise2.prototype.fcall = function() {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
      };
      Q20.fbind = function(object) {
        var promise2 = Q20(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        };
      };
      Promise2.prototype.fbind = function() {
        var promise2 = this;
        var args = array_slice(arguments);
        return function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        };
      };
      Q20.keys = function(object) {
        return Q20(object).dispatch("keys", []);
      };
      Promise2.prototype.keys = function() {
        return this.dispatch("keys", []);
      };
      Q20.all = all;
      function all(promises) {
        return when(promises, function(promises2) {
          var pendingCount = 0;
          var deferred = defer2();
          array_reduce(promises2, function(undefined2, promise2, index) {
            var snapshot;
            if (isPromise2(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
              promises2[index] = snapshot.value;
            } else {
              ++pendingCount;
              when(
                promise2,
                function(value) {
                  promises2[index] = value;
                  if (--pendingCount === 0) {
                    deferred.resolve(promises2);
                  }
                },
                deferred.reject,
                function(progress2) {
                  deferred.notify({ index, value: progress2 });
                }
              );
            }
          }, void 0);
          if (pendingCount === 0) {
            deferred.resolve(promises2);
          }
          return deferred.promise;
        });
      }
      Promise2.prototype.all = function() {
        return all(this);
      };
      Q20.any = any;
      function any(promises) {
        if (promises.length === 0) {
          return Q20.resolve();
        }
        var deferred = Q20.defer();
        var pendingCount = 0;
        array_reduce(promises, function(prev, current, index) {
          var promise2 = promises[index];
          pendingCount++;
          when(promise2, onFulfilled, onRejected, onProgress);
          function onFulfilled(result) {
            deferred.resolve(result);
          }
          function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
              deferred.reject(new Error(
                "Can't get fulfillment value from any promise, all promises were rejected."
              ));
            }
          }
          function onProgress(progress2) {
            deferred.notify({
              index,
              value: progress2
            });
          }
        }, void 0);
        return deferred.promise;
      }
      Promise2.prototype.any = function() {
        return any(this);
      };
      Q20.allResolved = deprecate2(allResolved, "allResolved", "allSettled");
      function allResolved(promises) {
        return when(promises, function(promises2) {
          promises2 = array_map(promises2, Q20);
          return when(all(array_map(promises2, function(promise2) {
            return when(promise2, noop3, noop3);
          })), function() {
            return promises2;
          });
        });
      }
      Promise2.prototype.allResolved = function() {
        return allResolved(this);
      };
      Q20.allSettled = allSettled;
      function allSettled(promises) {
        return Q20(promises).allSettled();
      }
      Promise2.prototype.allSettled = function() {
        return this.then(function(promises) {
          return all(array_map(promises, function(promise2) {
            promise2 = Q20(promise2);
            function regardless() {
              return promise2.inspect();
            }
            return promise2.then(regardless, regardless);
          }));
        });
      };
      Q20.fail = // XXX legacy
      Q20["catch"] = function(object, rejected) {
        return Q20(object).then(void 0, rejected);
      };
      Promise2.prototype.fail = // XXX legacy
      Promise2.prototype["catch"] = function(rejected) {
        return this.then(void 0, rejected);
      };
      Q20.progress = progress;
      function progress(object, progressed) {
        return Q20(object).then(void 0, void 0, progressed);
      }
      Promise2.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
      };
      Q20.fin = // XXX legacy
      Q20["finally"] = function(object, callback) {
        return Q20(object)["finally"](callback);
      };
      Promise2.prototype.fin = // XXX legacy
      Promise2.prototype["finally"] = function(callback) {
        callback = Q20(callback);
        return this.then(function(value) {
          return callback.fcall().then(function() {
            return value;
          });
        }, function(reason) {
          return callback.fcall().then(function() {
            throw reason;
          });
        });
      };
      Q20.done = function(object, fulfilled, rejected, progress2) {
        return Q20(object).done(fulfilled, rejected, progress2);
      };
      Promise2.prototype.done = function(fulfilled, rejected, progress2) {
        var onUnhandledError = function(error) {
          Q20.nextTick(function() {
            makeStackTraceLong(error, promise2);
            if (Q20.onerror) {
              Q20.onerror(error);
            } else {
              throw error;
            }
          });
        };
        var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
        if (typeof process === "object" && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        promise2.then(void 0, onUnhandledError);
      };
      Q20.timeout = function(object, ms, error) {
        return Q20(object).timeout(ms, error);
      };
      Promise2.prototype.timeout = function(ms, error) {
        var deferred = defer2();
        var timeoutId = setTimeout(function() {
          if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
          }
          deferred.reject(error);
        }, ms);
        this.then(function(value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function(exception2) {
          clearTimeout(timeoutId);
          deferred.reject(exception2);
        }, deferred.notify);
        return deferred.promise;
      };
      Q20.delay = function(object, timeout) {
        if (timeout === void 0) {
          timeout = object;
          object = void 0;
        }
        return Q20(object).delay(timeout);
      };
      Promise2.prototype.delay = function(timeout) {
        return this.then(function(value) {
          var deferred = defer2();
          setTimeout(function() {
            deferred.resolve(value);
          }, timeout);
          return deferred.promise;
        });
      };
      Q20.nfapply = function(callback, args) {
        return Q20(callback).nfapply(args);
      };
      Promise2.prototype.nfapply = function(args) {
        var deferred = defer2();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q20.nfcall = function(callback) {
        var args = array_slice(arguments, 1);
        return Q20(callback).nfapply(args);
      };
      Promise2.prototype.nfcall = function() {
        var nodeArgs = array_slice(arguments);
        var deferred = defer2();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q20.nfbind = Q20.denodeify = function(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer2();
          nodeArgs.push(deferred.makeNodeResolver());
          Q20(callback).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q20.denodeify.apply(void 0, args);
      };
      Q20.nbind = function(callback, thisp) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer2();
          nodeArgs.push(deferred.makeNodeResolver());
          function bound() {
            return callback.apply(thisp, arguments);
          }
          Q20(bound).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nbind = function() {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q20.nbind.apply(void 0, args);
      };
      Q20.nmapply = // XXX As proposed by "Redsandro"
      Q20.npost = function(object, name, args) {
        return Q20(object).npost(name, args);
      };
      Promise2.prototype.nmapply = // XXX As proposed by "Redsandro"
      Promise2.prototype.npost = function(name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer2();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q20.nsend = // XXX Based on Mark Miller's proposed "send"
      Q20.nmcall = // XXX Based on "Redsandro's" proposal
      Q20.ninvoke = function(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer2();
        nodeArgs.push(deferred.makeNodeResolver());
        Q20(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Promise2.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
      Promise2.prototype.nmcall = // XXX Based on "Redsandro's" proposal
      Promise2.prototype.ninvoke = function(name) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer2();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q20.nodeify = nodeify;
      function nodeify(object, nodeback) {
        return Q20(object).nodeify(nodeback);
      }
      Promise2.prototype.nodeify = function(nodeback) {
        if (nodeback) {
          this.then(function(value) {
            Q20.nextTick(function() {
              nodeback(null, value);
            });
          }, function(error) {
            Q20.nextTick(function() {
              nodeback(error);
            });
          });
        } else {
          return this;
        }
      };
      Q20.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
      };
      var qEndingLine = captureLine();
      return Q20;
    });
  }
});

// node_modules/select/src/select.js
var require_select = __commonJS({
  "node_modules/select/src/select.js"(exports, module) {
    function select(element) {
      var selectedText;
      if (element.nodeName === "SELECT") {
        element.focus();
        selectedText = element.value;
      } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
        var isReadOnly = element.hasAttribute("readonly");
        if (!isReadOnly) {
          element.setAttribute("readonly", "");
        }
        element.select();
        element.setSelectionRange(0, element.value.length);
        if (!isReadOnly) {
          element.removeAttribute("readonly");
        }
        selectedText = element.value;
      } else {
        if (element.hasAttribute("contenteditable")) {
          element.focus();
        }
        var selection = window.getSelection();
        var range = document.createRange();
        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);
        selectedText = selection.toString();
      }
      return selectedText;
    }
    module.exports = select;
  }
});

// node_modules/clipboard/lib/clipboard-action.js
var require_clipboard_action = __commonJS({
  "node_modules/clipboard/lib/clipboard-action.js"(exports, module) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define(["module", "select"], factory);
      } else if (typeof exports !== "undefined") {
        factory(module, require_select());
      } else {
        var mod = {
          exports: {}
        };
        factory(mod, global2.select);
        global2.clipboardAction = mod.exports;
      }
    })(exports, function(module2, _select) {
      "use strict";
      var _select2 = _interopRequireDefault5(_select);
      function _interopRequireDefault5(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props6) {
          for (var i = 0; i < props6.length; i++) {
            var descriptor = props6[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var ClipboardAction = function() {
        function ClipboardAction2(options2) {
          _classCallCheck(this, ClipboardAction2);
          this.resolveOptions(options2);
          this.initSelection();
        }
        _createClass(ClipboardAction2, [{
          key: "resolveOptions",
          value: function resolveOptions() {
            var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.action = options2.action;
            this.container = options2.container;
            this.emitter = options2.emitter;
            this.target = options2.target;
            this.text = options2.text;
            this.trigger = options2.trigger;
            this.selectedText = "";
          }
        }, {
          key: "initSelection",
          value: function initSelection() {
            if (this.text) {
              this.selectFake();
            } else if (this.target) {
              this.selectTarget();
            }
          }
        }, {
          key: "selectFake",
          value: function selectFake() {
            var _this = this;
            var isRTL = document.documentElement.getAttribute("dir") == "rtl";
            this.removeFake();
            this.fakeHandlerCallback = function() {
              return _this.removeFake();
            };
            this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || true;
            this.fakeElem = document.createElement("textarea");
            this.fakeElem.style.fontSize = "12pt";
            this.fakeElem.style.border = "0";
            this.fakeElem.style.padding = "0";
            this.fakeElem.style.margin = "0";
            this.fakeElem.style.position = "absolute";
            this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
            this.fakeElem.style.top = yPosition + "px";
            this.fakeElem.setAttribute("readonly", "");
            this.fakeElem.value = this.text;
            this.container.appendChild(this.fakeElem);
            this.selectedText = (0, _select2.default)(this.fakeElem);
            this.copyText();
          }
        }, {
          key: "removeFake",
          value: function removeFake() {
            if (this.fakeHandler) {
              this.container.removeEventListener("click", this.fakeHandlerCallback);
              this.fakeHandler = null;
              this.fakeHandlerCallback = null;
            }
            if (this.fakeElem) {
              this.container.removeChild(this.fakeElem);
              this.fakeElem = null;
            }
          }
        }, {
          key: "selectTarget",
          value: function selectTarget() {
            this.selectedText = (0, _select2.default)(this.target);
            this.copyText();
          }
        }, {
          key: "copyText",
          value: function copyText() {
            var succeeded = void 0;
            try {
              succeeded = document.execCommand(this.action);
            } catch (err) {
              succeeded = false;
            }
            this.handleResult(succeeded);
          }
        }, {
          key: "handleResult",
          value: function handleResult(succeeded) {
            this.emitter.emit(succeeded ? "success" : "error", {
              action: this.action,
              text: this.selectedText,
              trigger: this.trigger,
              clearSelection: this.clearSelection.bind(this)
            });
          }
        }, {
          key: "clearSelection",
          value: function clearSelection() {
            if (this.trigger) {
              this.trigger.focus();
            }
            window.getSelection().removeAllRanges();
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.removeFake();
          }
        }, {
          key: "action",
          set: function set() {
            var action2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "copy";
            this._action = action2;
            if (this._action !== "copy" && this._action !== "cut") {
              throw new Error('Invalid "action" value, use either "copy" or "cut"');
            }
          },
          get: function get2() {
            return this._action;
          }
        }, {
          key: "target",
          set: function set(target) {
            if (target !== void 0) {
              if (target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object" && target.nodeType === 1) {
                if (this.action === "copy" && target.hasAttribute("disabled")) {
                  throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                }
                if (this.action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                  throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                }
                this._target = target;
              } else {
                throw new Error('Invalid "target" value, use a valid Element');
              }
            }
          },
          get: function get2() {
            return this._target;
          }
        }]);
        return ClipboardAction2;
      }();
      module2.exports = ClipboardAction;
    });
  }
});

// node_modules/clipboard/node_modules/tiny-emitter/index.js
var require_tiny_emitter2 = __commonJS({
  "node_modules/clipboard/node_modules/tiny-emitter/index.js"(exports, module) {
    function E() {
    }
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self2 = this;
        function listener() {
          self2.off(name, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    module.exports = E;
    module.exports.TinyEmitter = E;
  }
});

// node_modules/good-listener/src/is.js
var require_is = __commonJS({
  "node_modules/good-listener/src/is.js"(exports) {
    exports.node = function(value) {
      return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
    };
    exports.nodeList = function(value) {
      var type = Object.prototype.toString.call(value);
      return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports.node(value[0]));
    };
    exports.string = function(value) {
      return typeof value === "string" || value instanceof String;
    };
    exports.fn = function(value) {
      var type = Object.prototype.toString.call(value);
      return type === "[object Function]";
    };
  }
});

// node_modules/delegate/src/closest.js
var require_closest = __commonJS({
  "node_modules/delegate/src/closest.js"(exports, module) {
    var DOCUMENT_NODE_TYPE = 9;
    if (typeof Element !== "undefined" && !Element.prototype.matches) {
      proto5 = Element.prototype;
      proto5.matches = proto5.matchesSelector || proto5.mozMatchesSelector || proto5.msMatchesSelector || proto5.oMatchesSelector || proto5.webkitMatchesSelector;
    }
    var proto5;
    function closest(element, selector) {
      while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === "function" && element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
      }
    }
    module.exports = closest;
  }
});

// node_modules/delegate/src/delegate.js
var require_delegate = __commonJS({
  "node_modules/delegate/src/delegate.js"(exports, module) {
    var closest = require_closest();
    function _delegate(element, selector, type, callback, useCapture) {
      var listenerFn = listener.apply(this, arguments);
      element.addEventListener(type, listenerFn, useCapture);
      return {
        destroy: function() {
          element.removeEventListener(type, listenerFn, useCapture);
        }
      };
    }
    function delegate(elements, selector, type, callback, useCapture) {
      if (typeof elements.addEventListener === "function") {
        return _delegate.apply(null, arguments);
      }
      if (typeof type === "function") {
        return _delegate.bind(null, document).apply(null, arguments);
      }
      if (typeof elements === "string") {
        elements = document.querySelectorAll(elements);
      }
      return Array.prototype.map.call(elements, function(element) {
        return _delegate(element, selector, type, callback, useCapture);
      });
    }
    function listener(element, selector, type, callback) {
      return function(e) {
        e.delegateTarget = closest(e.target, selector);
        if (e.delegateTarget) {
          callback.call(element, e);
        }
      };
    }
    module.exports = delegate;
  }
});

// node_modules/good-listener/src/listen.js
var require_listen = __commonJS({
  "node_modules/good-listener/src/listen.js"(exports, module) {
    var is = require_is();
    var delegate = require_delegate();
    function listen(target, type, callback) {
      if (!target && !type && !callback) {
        throw new Error("Missing required arguments");
      }
      if (!is.string(type)) {
        throw new TypeError("Second argument must be a String");
      }
      if (!is.fn(callback)) {
        throw new TypeError("Third argument must be a Function");
      }
      if (is.node(target)) {
        return listenNode(target, type, callback);
      } else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
      } else if (is.string(target)) {
        return listenSelector(target, type, callback);
      } else {
        throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
      }
    }
    function listenNode(node, type, callback) {
      node.addEventListener(type, callback);
      return {
        destroy: function() {
          node.removeEventListener(type, callback);
        }
      };
    }
    function listenNodeList(nodeList, type, callback) {
      Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
      });
      return {
        destroy: function() {
          Array.prototype.forEach.call(nodeList, function(node) {
            node.removeEventListener(type, callback);
          });
        }
      };
    }
    function listenSelector(selector, type, callback) {
      return delegate(document.body, selector, type, callback);
    }
    module.exports = listen;
  }
});

// node_modules/clipboard/lib/clipboard.js
var require_clipboard = __commonJS({
  "node_modules/clipboard/lib/clipboard.js"(exports, module) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define(["module", "./clipboard-action", "tiny-emitter", "good-listener"], factory);
      } else if (typeof exports !== "undefined") {
        factory(module, require_clipboard_action(), require_tiny_emitter2(), require_listen());
      } else {
        var mod = {
          exports: {}
        };
        factory(mod, global2.clipboardAction, global2.tinyEmitter, global2.goodListener);
        global2.clipboard = mod.exports;
      }
    })(exports, function(module2, _clipboardAction, _tinyEmitter, _goodListener) {
      "use strict";
      var _clipboardAction2 = _interopRequireDefault5(_clipboardAction);
      var _tinyEmitter2 = _interopRequireDefault5(_tinyEmitter);
      var _goodListener2 = _interopRequireDefault5(_goodListener);
      function _interopRequireDefault5(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props6) {
          for (var i = 0; i < props6.length; i++) {
            var descriptor = props6[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _possibleConstructorReturn(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var Clipboard4 = function(_Emitter) {
        _inherits(Clipboard5, _Emitter);
        function Clipboard5(trigger, options2) {
          _classCallCheck(this, Clipboard5);
          var _this = _possibleConstructorReturn(this, (Clipboard5.__proto__ || Object.getPrototypeOf(Clipboard5)).call(this));
          _this.resolveOptions(options2);
          _this.listenClick(trigger);
          return _this;
        }
        _createClass(Clipboard5, [{
          key: "resolveOptions",
          value: function resolveOptions() {
            var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.action = typeof options2.action === "function" ? options2.action : this.defaultAction;
            this.target = typeof options2.target === "function" ? options2.target : this.defaultTarget;
            this.text = typeof options2.text === "function" ? options2.text : this.defaultText;
            this.container = _typeof(options2.container) === "object" ? options2.container : document.body;
          }
        }, {
          key: "listenClick",
          value: function listenClick(trigger) {
            var _this2 = this;
            this.listener = (0, _goodListener2.default)(trigger, "click", function(e) {
              return _this2.onClick(e);
            });
          }
        }, {
          key: "onClick",
          value: function onClick(e) {
            var trigger = e.delegateTarget || e.currentTarget;
            if (this.clipboardAction) {
              this.clipboardAction = null;
            }
            this.clipboardAction = new _clipboardAction2.default({
              action: this.action(trigger),
              target: this.target(trigger),
              text: this.text(trigger),
              container: this.container,
              trigger,
              emitter: this
            });
          }
        }, {
          key: "defaultAction",
          value: function defaultAction(trigger) {
            return getAttributeValue("action", trigger);
          }
        }, {
          key: "defaultTarget",
          value: function defaultTarget(trigger) {
            var selector = getAttributeValue("target", trigger);
            if (selector) {
              return document.querySelector(selector);
            }
          }
        }, {
          key: "defaultText",
          value: function defaultText(trigger) {
            return getAttributeValue("text", trigger);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.listener.destroy();
            if (this.clipboardAction) {
              this.clipboardAction.destroy();
              this.clipboardAction = null;
            }
          }
        }], [{
          key: "isSupported",
          value: function isSupported() {
            var action2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
            var actions = typeof action2 === "string" ? [action2] : action2;
            var support = !!document.queryCommandSupported;
            actions.forEach(function(action3) {
              support = support && !!document.queryCommandSupported(action3);
            });
            return support;
          }
        }]);
        return Clipboard5;
      }(_tinyEmitter2.default);
      function getAttributeValue(suffix, element) {
        var attribute = "data-clipboard-" + suffix;
        if (!element.hasAttribute(attribute)) {
          return;
        }
        return element.getAttribute(attribute);
      }
      module2.exports = Clipboard4;
    });
  }
});

// node_modules/@sindresorhus/to-milliseconds/index.js
var require_to_milliseconds = __commonJS({
  "node_modules/@sindresorhus/to-milliseconds/index.js"(exports, module) {
    "use strict";
    var converters = {
      days: (value) => value * 864e5,
      hours: (value) => value * 36e5,
      minutes: (value) => value * 6e4,
      seconds: (value) => value * 1e3,
      milliseconds: (value) => value,
      microseconds: (value) => value / 1e3,
      nanoseconds: (value) => value / 1e6
    };
    var toMilliseconds2 = (object) => Object.entries(object).reduce((milliseconds, [key, value]) => {
      if (typeof value !== "number") {
        throw new TypeError(`Expected a \`number\` for key \`${key}\`, got \`${value}\` (${typeof value})`);
      }
      if (!converters[key]) {
        throw new Error("Unsupported time key");
      }
      return milliseconds + converters[key](value);
    }, 0);
    module.exports = toMilliseconds2;
    module.exports.default = toMilliseconds2;
  }
});

// node_modules/parse-ms/index.js
var require_parse_ms = __commonJS({
  "node_modules/parse-ms/index.js"(exports, module) {
    "use strict";
    module.exports = (milliseconds) => {
      if (typeof milliseconds !== "number") {
        throw new TypeError("Expected a number");
      }
      const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
      return {
        days: roundTowardsZero(milliseconds / 864e5),
        hours: roundTowardsZero(milliseconds / 36e5) % 24,
        minutes: roundTowardsZero(milliseconds / 6e4) % 60,
        seconds: roundTowardsZero(milliseconds / 1e3) % 60,
        milliseconds: roundTowardsZero(milliseconds) % 1e3,
        microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
        nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
      };
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/_commonjsHelpers.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/handlebars.runtime.js
var handlebars_runtime = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/base.js
var base = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/utils.js
var utils = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/utils.js
utils.__esModule = true;
utils.extend = extend;
utils.indexOf = indexOf;
utils.escapeExpression = escapeExpression;
utils.isEmpty = isEmpty;
utils.createFrame = createFrame;
utils.blockParams = blockParams;
utils.appendContextPath = appendContextPath;
var escape2 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
var badChars = /[&<>"'`=]/g;
var possible = /[&<>"'`=]/;
function escapeChar(chr) {
  return escape2[chr];
}
function extend(obj) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }
  return obj;
}
var toString = Object.prototype.toString;
utils.toString = toString;
var isFunction = function isFunction2(value) {
  return typeof value === "function";
};
if (isFunction(/x/)) {
  utils.isFunction = isFunction = function(value) {
    return typeof value === "function" && toString.call(value) === "[object Function]";
  };
}
utils.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
};
utils.isArray = isArray;
function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}
function escapeExpression(string) {
  if (typeof string !== "string") {
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + "";
    }
    string = "" + string;
  }
  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}
function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}
function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}
function blockParams(params, ids) {
  params.path = ids;
  return params;
}
function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + "." : "") + id;
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/exception.js
var exception = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/exception.js
(function(module, exports) {
  exports.__esModule = true;
  var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function Exception(message, node) {
    var loc4 = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
    if (loc4) {
      line = loc4.start.line;
      endLineNumber = loc4.end.line;
      column = loc4.start.column;
      endColumn = loc4.end.column;
      message += " - " + line + ":" + column;
    }
    var tmp = Error.prototype.constructor.call(this, message);
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }
    try {
      if (loc4) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;
        if (Object.defineProperty) {
          Object.defineProperty(this, "column", {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, "endColumn", {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
    }
  }
  Exception.prototype = new Error();
  exports["default"] = Exception;
  module.exports = exports["default"];
})(exception, exception.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/helpers.js
var helpers = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/block-helper-missing.js
var blockHelperMissing = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
(function(module, exports) {
  exports.__esModule = true;
  var _utils4 = utils;
  exports["default"] = function(instance) {
    instance.registerHelper("blockHelperMissing", function(context, options2) {
      var inverse = options2.inverse, fn11 = options2.fn;
      if (context === true) {
        return fn11(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils4.isArray(context)) {
        if (context.length > 0) {
          if (options2.ids) {
            options2.ids = [options2.name];
          }
          return instance.helpers.each(context, options2);
        } else {
          return inverse(this);
        }
      } else {
        if (options2.data && options2.ids) {
          var data = _utils4.createFrame(options2.data);
          data.contextPath = _utils4.appendContextPath(options2.data.contextPath, options2.name);
          options2 = {
            data
          };
        }
        return fn11(context, options2);
      }
    });
  };
  module.exports = exports["default"];
})(blockHelperMissing, blockHelperMissing.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/each.js
var each = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/each.js
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault5(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  var _utils4 = utils;
  var _exception4 = exception.exports;
  var _exception23 = _interopRequireDefault5(_exception4);
  exports["default"] = function(instance) {
    instance.registerHelper("each", function(context, options2) {
      if (!options2) {
        throw new _exception23["default"]("Must pass iterator to #each");
      }
      var fn11 = options2.fn, inverse = options2.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
      if (options2.data && options2.ids) {
        contextPath = _utils4.appendContextPath(options2.data.contextPath, options2.ids[0]) + ".";
      }
      if (_utils4.isFunction(context)) {
        context = context.call(this);
      }
      if (options2.data) {
        data = _utils4.createFrame(options2.data);
      }
      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;
          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }
        ret = ret + fn11(context[field], {
          data,
          blockParams: _utils4.blockParams([context[field], field], [contextPath + field, null])
        });
      }
      if (context && typeof context === "object") {
        if (_utils4.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[commonjsGlobal.Symbol.iterator]();
          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function() {
            var priorKey = void 0;
            Object.keys(context).forEach(function(key) {
              if (priorKey !== void 0) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== void 0) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret;
    });
  };
  module.exports = exports["default"];
})(each, each.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/helper-missing.js
var helperMissing = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault5(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  var _exception4 = exception.exports;
  var _exception23 = _interopRequireDefault5(_exception4);
  exports["default"] = function(instance) {
    instance.registerHelper("helperMissing", function() {
      if (arguments.length === 1) {
        return void 0;
      } else {
        throw new _exception23["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };
  module.exports = exports["default"];
})(helperMissing, helperMissing.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/if.js
var _if = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/if.js
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault5(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  var _utils4 = utils;
  var _exception4 = exception.exports;
  var _exception23 = _interopRequireDefault5(_exception4);
  exports["default"] = function(instance) {
    instance.registerHelper("if", function(conditional, options2) {
      if (arguments.length != 2) {
        throw new _exception23["default"]("#if requires exactly one argument");
      }
      if (_utils4.isFunction(conditional)) {
        conditional = conditional.call(this);
      }
      if (!options2.hash.includeZero && !conditional || _utils4.isEmpty(conditional)) {
        return options2.inverse(this);
      } else {
        return options2.fn(this);
      }
    });
    instance.registerHelper("unless", function(conditional, options2) {
      if (arguments.length != 2) {
        throw new _exception23["default"]("#unless requires exactly one argument");
      }
      return instance.helpers["if"].call(this, conditional, {
        fn: options2.inverse,
        inverse: options2.fn,
        hash: options2.hash
      });
    });
  };
  module.exports = exports["default"];
})(_if, _if.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/log.js
var log = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/log.js
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(instance) {
    instance.registerHelper("log", function() {
      var args = [void 0], options2 = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }
      var level = 1;
      if (options2.hash.level != null) {
        level = options2.hash.level;
      } else if (options2.data && options2.data.level != null) {
        level = options2.data.level;
      }
      args[0] = level;
      instance.log.apply(instance, args);
    });
  };
  module.exports = exports["default"];
})(log, log.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/lookup.js
var lookup = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/lookup.js
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(instance) {
    instance.registerHelper("lookup", function(obj, field, options2) {
      if (!obj) {
        return obj;
      }
      return options2.lookupProperty(obj, field);
    });
  };
  module.exports = exports["default"];
})(lookup, lookup.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/with.js
var _with = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers/with.js
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault5(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  var _utils4 = utils;
  var _exception4 = exception.exports;
  var _exception23 = _interopRequireDefault5(_exception4);
  exports["default"] = function(instance) {
    instance.registerHelper("with", function(context, options2) {
      if (arguments.length != 2) {
        throw new _exception23["default"]("#with requires exactly one argument");
      }
      if (_utils4.isFunction(context)) {
        context = context.call(this);
      }
      var fn11 = options2.fn;
      if (!_utils4.isEmpty(context)) {
        var data = options2.data;
        if (options2.data && options2.ids) {
          data = _utils4.createFrame(options2.data);
          data.contextPath = _utils4.appendContextPath(options2.data.contextPath, options2.ids[0]);
        }
        return fn11(context, {
          data,
          blockParams: _utils4.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options2.inverse(this);
      }
    });
  };
  module.exports = exports["default"];
})(_with, _with.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/helpers.js
helpers.__esModule = true;
helpers.registerDefaultHelpers = registerDefaultHelpers;
helpers.moveHelperToHooks = moveHelperToHooks;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var _helpersBlockHelperMissing = blockHelperMissing.exports;
var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
var _helpersEach = each.exports;
var _helpersEach2 = _interopRequireDefault(_helpersEach);
var _helpersHelperMissing = helperMissing.exports;
var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
var _helpersIf = _if.exports;
var _helpersIf2 = _interopRequireDefault(_helpersIf);
var _helpersLog = log.exports;
var _helpersLog2 = _interopRequireDefault(_helpersLog);
var _helpersLookup = lookup.exports;
var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
var _helpersWith = _with.exports;
var _helpersWith2 = _interopRequireDefault(_helpersWith);
function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2["default"](instance);
  _helpersEach2["default"](instance);
  _helpersHelperMissing2["default"](instance);
  _helpersIf2["default"](instance);
  _helpersLog2["default"](instance);
  _helpersLookup2["default"](instance);
  _helpersWith2["default"](instance);
}
function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];
    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/decorators.js
var decorators = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/inline.js
var inline = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/decorators/inline.js
(function(module, exports) {
  exports.__esModule = true;
  var _utils4 = utils;
  exports["default"] = function(instance) {
    instance.registerDecorator("inline", function(fn11, props6, container, options2) {
      var ret = fn11;
      if (!props6.partials) {
        props6.partials = {};
        ret = function(context, options3) {
          var original = container.partials;
          container.partials = _utils4.extend({}, original, props6.partials);
          var ret2 = fn11(context, options3);
          container.partials = original;
          return ret2;
        };
      }
      props6.partials[options2.args[0]] = options2.fn;
      return ret;
    });
  };
  module.exports = exports["default"];
})(inline, inline.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/decorators.js
decorators.__esModule = true;
decorators.registerDefaultDecorators = registerDefaultDecorators;
function _interopRequireDefault2(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var _decoratorsInline = inline.exports;
var _decoratorsInline2 = _interopRequireDefault2(_decoratorsInline);
function registerDefaultDecorators(instance) {
  _decoratorsInline2["default"](instance);
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/logger.js
var logger = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/logger.js
(function(module, exports) {
  exports.__esModule = true;
  var _utils4 = utils;
  var logger3 = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function lookupLevel(level) {
      if (typeof level === "string") {
        var levelMap = _utils4.indexOf(logger3.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }
      return level;
    },
    // Can be overridden in the host environment
    log: function log5(level) {
      level = logger3.lookupLevel(level);
      if (typeof console !== "undefined" && logger3.lookupLevel(logger3.level) <= level) {
        var method = logger3.methodMap[level];
        if (!console[method]) {
          method = "log";
        }
        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }
        console[method].apply(console, message);
      }
    }
  };
  exports["default"] = logger3;
  module.exports = exports["default"];
})(logger, logger.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/proto-access.js
var protoAccess = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/create-new-lookup-object.js
var createNewLookupObject = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
createNewLookupObject.__esModule = true;
createNewLookupObject.createNewLookupObject = createNewLookupObject2;
var _utils = utils;
function createNewLookupObject2() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/internal/proto-access.js
protoAccess.__esModule = true;
protoAccess.createProtoAccessControl = createProtoAccessControl;
protoAccess.resultIsAllowed = resultIsAllowed;
protoAccess.resetLoggedProperties = resetLoggedProperties;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    return newObj;
  }
}
var _createNewLookupObject = createNewLookupObject;
var _logger = logger.exports;
var logger2 = _interopRequireWildcard(_logger);
var loggedProperties = /* @__PURE__ */ Object.create(null);
function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
  defaultMethodWhiteList["constructor"] = false;
  defaultMethodWhiteList["__defineGetter__"] = false;
  defaultMethodWhiteList["__defineSetter__"] = false;
  defaultMethodWhiteList["__lookupGetter__"] = false;
  var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
  defaultPropertyWhiteList["__proto__"] = false;
  return {
    properties: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}
function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === "function") {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}
function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }
  if (protoAccessControlForType.defaultValue !== void 0) {
    return protoAccessControlForType.defaultValue;
  }
  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}
function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger2.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}
function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function(propertyName) {
    delete loggedProperties[propertyName];
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/base.js
base.__esModule = true;
base.HandlebarsEnvironment = HandlebarsEnvironment;
function _interopRequireDefault3(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var _utils2 = utils;
var _exception = exception.exports;
var _exception2 = _interopRequireDefault3(_exception);
var _helpers = helpers;
var _decorators = decorators;
var _logger2 = logger.exports;
var _logger22 = _interopRequireDefault3(_logger2);
var _internalProtoAccess = protoAccess;
var VERSION = "4.7.7";
base.VERSION = VERSION;
var COMPILER_REVISION = 8;
base.COMPILER_REVISION = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;
base.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: "<= 1.0.rc.2",
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: "== 1.0.0-rc.3",
  3: "== 1.0.0-rc.4",
  4: "== 1.x.x",
  5: "== 2.0.0-alpha.x",
  6: ">= 2.0.0-beta.1",
  7: ">= 4.0.0 <4.3.0",
  8: ">= 4.3.0"
};
base.REVISION_CHANGES = REVISION_CHANGES;
var objectType = "[object Object]";
function HandlebarsEnvironment(helpers2, partials, decorators2) {
  this.helpers = helpers2 || {};
  this.partials = partials || {};
  this.decorators = decorators2 || {};
  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,
  logger: _logger22["default"],
  log: _logger22["default"].log,
  registerHelper: function registerHelper(name, fn11) {
    if (_utils2.toString.call(name) === objectType) {
      if (fn11) {
        throw new _exception2["default"]("Arg not supported with multiple helpers");
      }
      _utils2.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn11;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },
  registerPartial: function registerPartial(name, partial) {
    if (_utils2.toString.call(name) === objectType) {
      _utils2.extend(this.partials, name);
    } else {
      if (typeof partial === "undefined") {
        throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },
  registerDecorator: function registerDecorator(name, fn11) {
    if (_utils2.toString.call(name) === objectType) {
      if (fn11) {
        throw new _exception2["default"]("Arg not supported with multiple decorators");
      }
      _utils2.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn11;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    _internalProtoAccess.resetLoggedProperties();
  }
};
var log2 = _logger22["default"].log;
base.log = log2;
base.createFrame = _utils2.createFrame;
base.logger = _logger22["default"];

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/safe-string.js
var safeString = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/safe-string.js
(function(module, exports) {
  exports.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }
  SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    return "" + this.string;
  };
  exports["default"] = SafeString;
  module.exports = exports["default"];
})(safeString, safeString.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/runtime.js
var runtime = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/wrapHelper.js
var wrapHelper = {};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
wrapHelper.__esModule = true;
wrapHelper.wrapHelper = wrapHelper2;
function wrapHelper2(helper, transformOptionsFn) {
  if (typeof helper !== "function") {
    return helper;
  }
  var wrapper = function wrapper2() {
    var options2 = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options2);
    return helper.apply(this, arguments);
  };
  return wrapper;
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/runtime.js
runtime.__esModule = true;
runtime.checkRevision = checkRevision;
runtime.template = template;
runtime.wrapProgram = wrapProgram;
runtime.resolvePartial = resolvePartial;
runtime.invokePartial = invokePartial;
runtime.noop = noop;
function _interopRequireDefault4(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _interopRequireWildcard2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj["default"] = obj;
    return newObj;
  }
}
var _utils3 = utils;
var Utils = _interopRequireWildcard2(_utils3);
var _exception3 = exception.exports;
var _exception22 = _interopRequireDefault4(_exception3);
var _base = base;
var _helpers2 = helpers;
var _internalWrapHelper = wrapHelper;
var _internalProtoAccess2 = protoAccess;
function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    return;
  }
  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    throw new _exception22["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
  } else {
    throw new _exception22["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
  }
}
function template(templateSpec, env) {
  if (!env) {
    throw new _exception22["default"]("No environment passed to template");
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception22["default"]("Unknown template object: " + typeof templateSpec);
  }
  templateSpec.main.decorator = templateSpec.main_d;
  env.VM.checkRevision(templateSpec.compiler);
  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
  function invokePartialWrapper(partial, context, options2) {
    if (options2.hash) {
      context = Utils.extend({}, context, options2.hash);
      if (options2.ids) {
        options2.ids[0] = true;
      }
    }
    partial = env.VM.resolvePartial.call(this, partial, context, options2);
    var extendedOptions = Utils.extend({}, options2, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });
    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
    if (result == null && env.compile) {
      options2.partials[options2.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options2.partials[options2.name](context, extendedOptions);
    }
    if (result != null) {
      if (options2.indent) {
        var lines = result.split("\n");
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }
          lines[i] = options2.indent + lines[i];
        }
        result = lines.join("\n");
      }
      return result;
    } else {
      throw new _exception22["default"]("The partial " + options2.name + " could not be compiled when running in runtime-only mode");
    }
  }
  var container = {
    strict: function strict(obj, name, loc4) {
      if (!obj || !(name in obj)) {
        throw new _exception22["default"]('"' + name + '" not defined in ' + obj, {
          loc: loc4
        });
      }
      return container.lookupProperty(obj, name);
    },
    lookupProperty: function lookupProperty(parent, propertyName) {
      var result = parent[propertyName];
      if (result == null) {
        return result;
      }
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return result;
      }
      if (_internalProtoAccess2.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }
      return void 0;
    },
    lookup: function lookup2(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name);
        if (result != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === "function" ? current.call(context) : current;
    },
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    fn: function fn11(i) {
      var ret2 = templateSpec[i];
      ret2.decorator = templateSpec[i + "_d"];
      return ret2;
    },
    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams2, depths) {
      var programWrapper = this.programs[i], fn11 = this.fn(i);
      if (data || depths || blockParams2 || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn11, data, declaredBlockParams, blockParams2, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn11);
      }
      return programWrapper;
    },
    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;
      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }
      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };
  function ret(context) {
    var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
    var data = options2.data;
    ret._setup(options2);
    if (!options2.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = void 0, blockParams2 = templateSpec.useBlockParams ? [] : void 0;
    if (templateSpec.useDepths) {
      if (options2.depths) {
        depths = context != options2.depths[0] ? [context].concat(options2.depths) : options2.depths;
      } else {
        depths = [context];
      }
    }
    function main(context2) {
      return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams2, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options2.depths || [], data, blockParams2);
    return main(context, options2);
  }
  ret.isTop = true;
  ret._setup = function(options2) {
    if (!options2.partial) {
      var mergedHelpers = Utils.extend({}, env.helpers, options2.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;
      if (templateSpec.usePartial) {
        container.partials = container.mergeIfNeeded(options2.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils.extend({}, env.decorators, options2.decorators);
      }
      container.hooks = {};
      container.protoAccessControl = _internalProtoAccess2.createProtoAccessControl(options2);
      var keepHelperInHelpers = options2.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
      _helpers2.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
      _helpers2.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
    } else {
      container.protoAccessControl = options2.protoAccessControl;
      container.helpers = options2.helpers;
      container.partials = options2.partials;
      container.decorators = options2.decorators;
      container.hooks = options2.hooks;
    }
  };
  ret._child = function(i, data, blockParams2, depths) {
    if (templateSpec.useBlockParams && !blockParams2) {
      throw new _exception22["default"]("must pass block params");
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception22["default"]("must pass parent depths");
    }
    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams2, depths);
  };
  return ret;
}
function wrapProgram(container, i, fn11, data, declaredBlockParams, blockParams2, depths) {
  function prog(context) {
    var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }
    return fn11(container, context, container.helpers, container.partials, options2.data || data, blockParams2 && [options2.blockParams].concat(blockParams2), currentDepths);
  }
  prog = executeDecorators(fn11, prog, container, depths, data, blockParams2);
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}
function resolvePartial(partial, context, options2) {
  if (!partial) {
    if (options2.name === "@partial-block") {
      partial = options2.data["partial-block"];
    } else {
      partial = options2.partials[options2.name];
    }
  } else if (!partial.call && !options2.name) {
    options2.name = partial;
    partial = options2.partials[partial];
  }
  return partial;
}
function invokePartial(partial, context, options2) {
  var currentPartialBlock = options2.data && options2.data["partial-block"];
  options2.partial = true;
  if (options2.ids) {
    options2.data.contextPath = options2.ids[0] || options2.data.contextPath;
  }
  var partialBlock = void 0;
  if (options2.fn && options2.fn !== noop) {
    (function() {
      options2.data = _base.createFrame(options2.data);
      var fn11 = options2.fn;
      partialBlock = options2.data["partial-block"] = function partialBlockWrapper(context2) {
        var options3 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        options3.data = _base.createFrame(options3.data);
        options3.data["partial-block"] = currentPartialBlock;
        return fn11(context2, options3);
      };
      if (fn11.partials) {
        options2.partials = Utils.extend({}, options2.partials, fn11.partials);
      }
    })();
  }
  if (partial === void 0 && partialBlock) {
    partial = partialBlock;
  }
  if (partial === void 0) {
    throw new _exception22["default"]("The partial " + options2.name + " could not be found");
  } else if (partial instanceof Function) {
    return partial(context, options2);
  }
}
function noop() {
  return "";
}
function initData(context, data) {
  if (!data || !("root" in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}
function executeDecorators(fn11, prog, container, depths, data, blockParams2) {
  if (fn11.decorator) {
    var props6 = {};
    prog = fn11.decorator(prog, props6, container, depths && depths[0], data, blockParams2, depths);
    Utils.extend(prog, props6);
  }
  return prog;
}
function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function(helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}
function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return _internalWrapHelper.wrapHelper(helper, function(options2) {
    return Utils.extend({
      lookupProperty
    }, options2);
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/no-conflict.js
var noConflict = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars/no-conflict.js
(function(module, exports) {
  exports.__esModule = true;
  exports["default"] = function(Handlebars) {
    var root = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : window, $Handlebars = root.Handlebars;
    Handlebars.noConflict = function() {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };
  module.exports = exports["default"];
})(noConflict, noConflict.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/handlebars/dist/cjs/handlebars.runtime.js
(function(module, exports) {
  exports.__esModule = true;
  function _interopRequireDefault5(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  function _interopRequireWildcard3(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  var _handlebarsBase = base;
  var base$1 = _interopRequireWildcard3(_handlebarsBase);
  var _handlebarsSafeString = safeString.exports;
  var _handlebarsSafeString2 = _interopRequireDefault5(_handlebarsSafeString);
  var _handlebarsException = exception.exports;
  var _handlebarsException2 = _interopRequireDefault5(_handlebarsException);
  var _handlebarsUtils = utils;
  var Utils2 = _interopRequireWildcard3(_handlebarsUtils);
  var _handlebarsRuntime = runtime;
  var runtime$1 = _interopRequireWildcard3(_handlebarsRuntime);
  var _handlebarsNoConflict = noConflict.exports;
  var _handlebarsNoConflict2 = _interopRequireDefault5(_handlebarsNoConflict);
  function create4() {
    var hb = new base$1.HandlebarsEnvironment();
    Utils2.extend(hb, base$1);
    hb.SafeString = _handlebarsSafeString2["default"];
    hb.Exception = _handlebarsException2["default"];
    hb.Utils = Utils2;
    hb.escapeExpression = Utils2.escapeExpression;
    hb.VM = runtime$1;
    hb.template = function(spec) {
      return runtime$1.template(spec, hb);
    };
    return hb;
  }
  var inst = create4();
  inst.create = create4;
  _handlebarsNoConflict2["default"](inst);
  inst["default"] = inst;
  exports["default"] = inst;
  module.exports = exports["default"];
})(handlebars_runtime, handlebars_runtime.exports);
var _Handlebars2 = getDefaultExportFromCjs(handlebars_runtime.exports);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/underscore-min.js
var underscoreMin = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/lib/underscore/underscore-min.js
(function(module, exports) {
  !function(n, r) {
    module.exports = r();
  }(commonjsGlobal, function() {
    var n = "1.13.1", r = "object" == typeof self && self.self === self && self || "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || Function("return this")() || {}, t = Array.prototype, e = Object.prototype, u = "undefined" != typeof Symbol ? Symbol.prototype : null, o = t.push, i = t.slice, a2 = e.toString, f = e.hasOwnProperty, c2 = "undefined" != typeof ArrayBuffer, l = "undefined" != typeof DataView, s = Array.isArray, p = Object.keys, v = Object.create, h = c2 && ArrayBuffer.isView, y = isNaN, d = isFinite, g = !{
      toString: null
    }.propertyIsEnumerable("toString"), b2 = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"], m = Math.pow(2, 53) - 1;
    function j(n2, r2) {
      return r2 = null == r2 ? n2.length - 1 : +r2, function() {
        for (var t2 = Math.max(arguments.length - r2, 0), e2 = Array(t2), u2 = 0; u2 < t2; u2++)
          e2[u2] = arguments[u2 + r2];
        switch (r2) {
          case 0:
            return n2.call(this, e2);
          case 1:
            return n2.call(this, arguments[0], e2);
          case 2:
            return n2.call(this, arguments[0], arguments[1], e2);
        }
        var o2 = Array(r2 + 1);
        for (u2 = 0; u2 < r2; u2++)
          o2[u2] = arguments[u2];
        return o2[r2] = e2, n2.apply(this, o2);
      };
    }
    function _2(n2) {
      var r2 = typeof n2;
      return "function" === r2 || "object" === r2 && !!n2;
    }
    function w(n2) {
      return void 0 === n2;
    }
    function A(n2) {
      return true === n2 || false === n2 || "[object Boolean]" === a2.call(n2);
    }
    function x(n2) {
      var r2 = "[object " + n2 + "]";
      return function(n3) {
        return a2.call(n3) === r2;
      };
    }
    var S = x("String"), O = x("Number"), M = x("Date"), E = x("RegExp"), B = x("Error"), N = x("Symbol"), I = x("ArrayBuffer"), T = x("Function"), k = r.document && r.document.childNodes;
    "function" != typeof /./ && "object" != typeof Int8Array && "function" != typeof k && (T = function(n2) {
      return "function" == typeof n2 || false;
    });
    var D = T, R = x("Object"), F = l && R(new DataView(new ArrayBuffer(8))), V = "undefined" != typeof Map && R(/* @__PURE__ */ new Map()), P = x("DataView");
    var q = F ? function(n2) {
      return null != n2 && D(n2.getInt8) && I(n2.buffer);
    } : P, U = s || x("Array");
    function W(n2, r2) {
      return null != n2 && f.call(n2, r2);
    }
    var z = x("Arguments");
    !function() {
      z(arguments) || (z = function(n2) {
        return W(n2, "callee");
      });
    }();
    var L = z;
    function $(n2) {
      return O(n2) && y(n2);
    }
    function C(n2) {
      return function() {
        return n2;
      };
    }
    function K(n2) {
      return function(r2) {
        var t2 = n2(r2);
        return "number" == typeof t2 && t2 >= 0 && t2 <= m;
      };
    }
    function J(n2) {
      return function(r2) {
        return null == r2 ? void 0 : r2[n2];
      };
    }
    var G = J("byteLength"), H = K(G), Q20 = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    var X = c2 ? function(n2) {
      return h ? h(n2) && !q(n2) : H(n2) && Q20.test(a2.call(n2));
    } : C(false), Y = J("length");
    function Z(n2, r2) {
      r2 = function(n3) {
        for (var r3 = {}, t3 = n3.length, e2 = 0; e2 < t3; ++e2)
          r3[n3[e2]] = true;
        return {
          contains: function(n4) {
            return r3[n4];
          },
          push: function(t4) {
            return r3[t4] = true, n3.push(t4);
          }
        };
      }(r2);
      var t2 = b2.length, u2 = n2.constructor, o2 = D(u2) && u2.prototype || e, i2 = "constructor";
      for (W(n2, i2) && !r2.contains(i2) && r2.push(i2); t2--; )
        (i2 = b2[t2]) in n2 && n2[i2] !== o2[i2] && !r2.contains(i2) && r2.push(i2);
    }
    function nn(n2) {
      if (!_2(n2))
        return [];
      if (p)
        return p(n2);
      var r2 = [];
      for (var t2 in n2)
        W(n2, t2) && r2.push(t2);
      return g && Z(n2, r2), r2;
    }
    function rn(n2, r2) {
      var t2 = nn(r2), e2 = t2.length;
      if (null == n2)
        return !e2;
      for (var u2 = Object(n2), o2 = 0; o2 < e2; o2++) {
        var i2 = t2[o2];
        if (r2[i2] !== u2[i2] || !(i2 in u2))
          return false;
      }
      return true;
    }
    function tn(n2) {
      return n2 instanceof tn ? n2 : this instanceof tn ? void (this._wrapped = n2) : new tn(n2);
    }
    function en(n2) {
      return new Uint8Array(n2.buffer || n2, n2.byteOffset || 0, G(n2));
    }
    tn.VERSION = n, tn.prototype.value = function() {
      return this._wrapped;
    }, tn.prototype.valueOf = tn.prototype.toJSON = tn.prototype.value, tn.prototype.toString = function() {
      return String(this._wrapped);
    };
    var un = "[object DataView]";
    function on(n2, r2, t2, e2) {
      if (n2 === r2)
        return 0 !== n2 || 1 / n2 == 1 / r2;
      if (null == n2 || null == r2)
        return false;
      if (n2 != n2)
        return r2 != r2;
      var o2 = typeof n2;
      return ("function" === o2 || "object" === o2 || "object" == typeof r2) && function n3(r3, t3, e3, o3) {
        r3 instanceof tn && (r3 = r3._wrapped);
        t3 instanceof tn && (t3 = t3._wrapped);
        var i2 = a2.call(r3);
        if (i2 !== a2.call(t3))
          return false;
        if (F && "[object Object]" == i2 && q(r3)) {
          if (!q(t3))
            return false;
          i2 = un;
        }
        switch (i2) {
          case "[object RegExp]":
          case "[object String]":
            return "" + r3 == "" + t3;
          case "[object Number]":
            return +r3 != +r3 ? +t3 != +t3 : 0 == +r3 ? 1 / +r3 == 1 / t3 : +r3 == +t3;
          case "[object Date]":
          case "[object Boolean]":
            return +r3 == +t3;
          case "[object Symbol]":
            return u.valueOf.call(r3) === u.valueOf.call(t3);
          case "[object ArrayBuffer]":
          case un:
            return n3(en(r3), en(t3), e3, o3);
        }
        var f2 = "[object Array]" === i2;
        if (!f2 && X(r3)) {
          if (G(r3) !== G(t3))
            return false;
          if (r3.buffer === t3.buffer && r3.byteOffset === t3.byteOffset)
            return true;
          f2 = true;
        }
        if (!f2) {
          if ("object" != typeof r3 || "object" != typeof t3)
            return false;
          var c3 = r3.constructor, l2 = t3.constructor;
          if (c3 !== l2 && !(D(c3) && c3 instanceof c3 && D(l2) && l2 instanceof l2) && "constructor" in r3 && "constructor" in t3)
            return false;
        }
        o3 = o3 || [];
        var s2 = (e3 = e3 || []).length;
        for (; s2--; )
          if (e3[s2] === r3)
            return o3[s2] === t3;
        if (e3.push(r3), o3.push(t3), f2) {
          if ((s2 = r3.length) !== t3.length)
            return false;
          for (; s2--; )
            if (!on(r3[s2], t3[s2], e3, o3))
              return false;
        } else {
          var p2, v2 = nn(r3);
          if (s2 = v2.length, nn(t3).length !== s2)
            return false;
          for (; s2--; )
            if (p2 = v2[s2], !W(t3, p2) || !on(r3[p2], t3[p2], e3, o3))
              return false;
        }
        return e3.pop(), o3.pop(), true;
      }(n2, r2, t2, e2);
    }
    function an(n2) {
      if (!_2(n2))
        return [];
      var r2 = [];
      for (var t2 in n2)
        r2.push(t2);
      return g && Z(n2, r2), r2;
    }
    function fn11(n2) {
      var r2 = Y(n2);
      return function(t2) {
        if (null == t2)
          return false;
        var e2 = an(t2);
        if (Y(e2))
          return false;
        for (var u2 = 0; u2 < r2; u2++)
          if (!D(t2[n2[u2]]))
            return false;
        return n2 !== hn || !D(t2[cn]);
      };
    }
    var cn = "forEach", ln = "has", sn = ["clear", "delete"], pn = ["get", ln, "set"], vn = sn.concat(cn, pn), hn = sn.concat(pn), yn = ["add"].concat(sn, cn, ln), dn = V ? fn11(vn) : x("Map"), gn = V ? fn11(hn) : x("WeakMap"), bn = V ? fn11(yn) : x("Set"), mn = x("WeakSet");
    function jn(n2) {
      for (var r2 = nn(n2), t2 = r2.length, e2 = Array(t2), u2 = 0; u2 < t2; u2++)
        e2[u2] = n2[r2[u2]];
      return e2;
    }
    function _n(n2) {
      for (var r2 = {}, t2 = nn(n2), e2 = 0, u2 = t2.length; e2 < u2; e2++)
        r2[n2[t2[e2]]] = t2[e2];
      return r2;
    }
    function wn(n2) {
      var r2 = [];
      for (var t2 in n2)
        D(n2[t2]) && r2.push(t2);
      return r2.sort();
    }
    function An(n2, r2) {
      return function(t2) {
        var e2 = arguments.length;
        if (r2 && (t2 = Object(t2)), e2 < 2 || null == t2)
          return t2;
        for (var u2 = 1; u2 < e2; u2++)
          for (var o2 = arguments[u2], i2 = n2(o2), a3 = i2.length, f2 = 0; f2 < a3; f2++) {
            var c3 = i2[f2];
            r2 && void 0 !== t2[c3] || (t2[c3] = o2[c3]);
          }
        return t2;
      };
    }
    var xn = An(an), Sn = An(nn), On = An(an, true);
    function Mn(n2) {
      if (!_2(n2))
        return {};
      if (v)
        return v(n2);
      var r2 = function() {
      };
      r2.prototype = n2;
      var t2 = new r2();
      return r2.prototype = null, t2;
    }
    function En(n2) {
      return _2(n2) ? U(n2) ? n2.slice() : xn({}, n2) : n2;
    }
    function Bn(n2) {
      return U(n2) ? n2 : [n2];
    }
    function Nn(n2) {
      return tn.toPath(n2);
    }
    function In(n2, r2) {
      for (var t2 = r2.length, e2 = 0; e2 < t2; e2++) {
        if (null == n2)
          return;
        n2 = n2[r2[e2]];
      }
      return t2 ? n2 : void 0;
    }
    function Tn(n2, r2, t2) {
      var e2 = In(n2, Nn(r2));
      return w(e2) ? t2 : e2;
    }
    function kn(n2) {
      return n2;
    }
    function Dn(n2) {
      return n2 = Sn({}, n2), function(r2) {
        return rn(r2, n2);
      };
    }
    function Rn(n2) {
      return n2 = Nn(n2), function(r2) {
        return In(r2, n2);
      };
    }
    function Fn(n2, r2, t2) {
      if (void 0 === r2)
        return n2;
      switch (null == t2 ? 3 : t2) {
        case 1:
          return function(t3) {
            return n2.call(r2, t3);
          };
        case 3:
          return function(t3, e2, u2) {
            return n2.call(r2, t3, e2, u2);
          };
        case 4:
          return function(t3, e2, u2, o2) {
            return n2.call(r2, t3, e2, u2, o2);
          };
      }
      return function() {
        return n2.apply(r2, arguments);
      };
    }
    function Vn(n2, r2, t2) {
      return null == n2 ? kn : D(n2) ? Fn(n2, r2, t2) : _2(n2) && !U(n2) ? Dn(n2) : Rn(n2);
    }
    function Pn(n2, r2) {
      return Vn(n2, r2, 1 / 0);
    }
    function qn(n2, r2, t2) {
      return tn.iteratee !== Pn ? tn.iteratee(n2, r2) : Vn(n2, r2, t2);
    }
    function Un() {
    }
    function Wn(n2, r2) {
      return null == r2 && (r2 = n2, n2 = 0), n2 + Math.floor(Math.random() * (r2 - n2 + 1));
    }
    tn.toPath = Bn, tn.iteratee = Pn;
    var zn = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    function Ln(n2) {
      var r2 = function(r3) {
        return n2[r3];
      }, t2 = "(?:" + nn(n2).join("|") + ")", e2 = RegExp(t2), u2 = RegExp(t2, "g");
      return function(n3) {
        return n3 = null == n3 ? "" : "" + n3, e2.test(n3) ? n3.replace(u2, r2) : n3;
      };
    }
    var $n = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    }, Cn = Ln($n), Kn = Ln(_n($n)), Jn = tn.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    }, Gn = /(.)^/, Hn = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Qn = /\\|'|\r|\n|\u2028|\u2029/g;
    function Xn(n2) {
      return "\\" + Hn[n2];
    }
    var Yn = /^\s*(\w|\$)+\s*$/;
    var Zn = 0;
    function nr(n2, r2, t2, e2, u2) {
      if (!(e2 instanceof r2))
        return n2.apply(t2, u2);
      var o2 = Mn(n2.prototype), i2 = n2.apply(o2, u2);
      return _2(i2) ? i2 : o2;
    }
    var rr = j(function(n2, r2) {
      var t2 = rr.placeholder, e2 = function() {
        for (var u2 = 0, o2 = r2.length, i2 = Array(o2), a3 = 0; a3 < o2; a3++)
          i2[a3] = r2[a3] === t2 ? arguments[u2++] : r2[a3];
        for (; u2 < arguments.length; )
          i2.push(arguments[u2++]);
        return nr(n2, e2, this, this, i2);
      };
      return e2;
    });
    rr.placeholder = tn;
    var tr = j(function(n2, r2, t2) {
      if (!D(n2))
        throw new TypeError("Bind must be called on a function");
      var e2 = j(function(u2) {
        return nr(n2, e2, r2, this, t2.concat(u2));
      });
      return e2;
    }), er = K(Y);
    function ur(n2, r2, t2, e2) {
      if (e2 = e2 || [], r2 || 0 === r2) {
        if (r2 <= 0)
          return e2.concat(n2);
      } else
        r2 = 1 / 0;
      for (var u2 = e2.length, o2 = 0, i2 = Y(n2); o2 < i2; o2++) {
        var a3 = n2[o2];
        if (er(a3) && (U(a3) || L(a3))) {
          if (r2 > 1)
            ur(a3, r2 - 1, t2, e2), u2 = e2.length;
          else
            for (var f2 = 0, c3 = a3.length; f2 < c3; )
              e2[u2++] = a3[f2++];
        } else
          t2 || (e2[u2++] = a3);
      }
      return e2;
    }
    var or = j(function(n2, r2) {
      var t2 = (r2 = ur(r2, false, false)).length;
      if (t2 < 1)
        throw new Error("bindAll must be passed function names");
      for (; t2--; ) {
        var e2 = r2[t2];
        n2[e2] = tr(n2[e2], n2);
      }
      return n2;
    });
    var ir = j(function(n2, r2, t2) {
      return setTimeout(function() {
        return n2.apply(null, t2);
      }, r2);
    }), ar = rr(ir, tn, 1);
    function fr(n2) {
      return function() {
        return !n2.apply(this, arguments);
      };
    }
    function cr(n2, r2) {
      var t2;
      return function() {
        return --n2 > 0 && (t2 = r2.apply(this, arguments)), n2 <= 1 && (r2 = null), t2;
      };
    }
    var lr = rr(cr, 2);
    function sr(n2, r2, t2) {
      r2 = qn(r2, t2);
      for (var e2, u2 = nn(n2), o2 = 0, i2 = u2.length; o2 < i2; o2++)
        if (r2(n2[e2 = u2[o2]], e2, n2))
          return e2;
    }
    function pr(n2) {
      return function(r2, t2, e2) {
        t2 = qn(t2, e2);
        for (var u2 = Y(r2), o2 = n2 > 0 ? 0 : u2 - 1; o2 >= 0 && o2 < u2; o2 += n2)
          if (t2(r2[o2], o2, r2))
            return o2;
        return -1;
      };
    }
    var vr = pr(1), hr = pr(-1);
    function yr(n2, r2, t2, e2) {
      for (var u2 = (t2 = qn(t2, e2, 1))(r2), o2 = 0, i2 = Y(n2); o2 < i2; ) {
        var a3 = Math.floor((o2 + i2) / 2);
        t2(n2[a3]) < u2 ? o2 = a3 + 1 : i2 = a3;
      }
      return o2;
    }
    function dr(n2, r2, t2) {
      return function(e2, u2, o2) {
        var a3 = 0, f2 = Y(e2);
        if ("number" == typeof o2)
          n2 > 0 ? a3 = o2 >= 0 ? o2 : Math.max(o2 + f2, a3) : f2 = o2 >= 0 ? Math.min(o2 + 1, f2) : o2 + f2 + 1;
        else if (t2 && o2 && f2)
          return e2[o2 = t2(e2, u2)] === u2 ? o2 : -1;
        if (u2 != u2)
          return (o2 = r2(i.call(e2, a3, f2), $)) >= 0 ? o2 + a3 : -1;
        for (o2 = n2 > 0 ? a3 : f2 - 1; o2 >= 0 && o2 < f2; o2 += n2)
          if (e2[o2] === u2)
            return o2;
        return -1;
      };
    }
    var gr = dr(1, vr, yr), br = dr(-1, hr);
    function mr(n2, r2, t2) {
      var e2 = (er(n2) ? vr : sr)(n2, r2, t2);
      if (void 0 !== e2 && -1 !== e2)
        return n2[e2];
    }
    function jr(n2, r2, t2) {
      var e2, u2;
      if (r2 = Fn(r2, t2), er(n2))
        for (e2 = 0, u2 = n2.length; e2 < u2; e2++)
          r2(n2[e2], e2, n2);
      else {
        var o2 = nn(n2);
        for (e2 = 0, u2 = o2.length; e2 < u2; e2++)
          r2(n2[o2[e2]], o2[e2], n2);
      }
      return n2;
    }
    function _r(n2, r2, t2) {
      r2 = qn(r2, t2);
      for (var e2 = !er(n2) && nn(n2), u2 = (e2 || n2).length, o2 = Array(u2), i2 = 0; i2 < u2; i2++) {
        var a3 = e2 ? e2[i2] : i2;
        o2[i2] = r2(n2[a3], a3, n2);
      }
      return o2;
    }
    function wr(n2) {
      var r2 = function(r3, t2, e2, u2) {
        var o2 = !er(r3) && nn(r3), i2 = (o2 || r3).length, a3 = n2 > 0 ? 0 : i2 - 1;
        for (u2 || (e2 = r3[o2 ? o2[a3] : a3], a3 += n2); a3 >= 0 && a3 < i2; a3 += n2) {
          var f2 = o2 ? o2[a3] : a3;
          e2 = t2(e2, r3[f2], f2, r3);
        }
        return e2;
      };
      return function(n3, t2, e2, u2) {
        var o2 = arguments.length >= 3;
        return r2(n3, Fn(t2, u2, 4), e2, o2);
      };
    }
    var Ar = wr(1), xr = wr(-1);
    function Sr(n2, r2, t2) {
      var e2 = [];
      return r2 = qn(r2, t2), jr(n2, function(n3, t3, u2) {
        r2(n3, t3, u2) && e2.push(n3);
      }), e2;
    }
    function Or(n2, r2, t2) {
      r2 = qn(r2, t2);
      for (var e2 = !er(n2) && nn(n2), u2 = (e2 || n2).length, o2 = 0; o2 < u2; o2++) {
        var i2 = e2 ? e2[o2] : o2;
        if (!r2(n2[i2], i2, n2))
          return false;
      }
      return true;
    }
    function Mr(n2, r2, t2) {
      r2 = qn(r2, t2);
      for (var e2 = !er(n2) && nn(n2), u2 = (e2 || n2).length, o2 = 0; o2 < u2; o2++) {
        var i2 = e2 ? e2[o2] : o2;
        if (r2(n2[i2], i2, n2))
          return true;
      }
      return false;
    }
    function Er(n2, r2, t2, e2) {
      return er(n2) || (n2 = jn(n2)), ("number" != typeof t2 || e2) && (t2 = 0), gr(n2, r2, t2) >= 0;
    }
    var Br = j(function(n2, r2, t2) {
      var e2, u2;
      return D(r2) ? u2 = r2 : (r2 = Nn(r2), e2 = r2.slice(0, -1), r2 = r2[r2.length - 1]), _r(n2, function(n3) {
        var o2 = u2;
        if (!o2) {
          if (e2 && e2.length && (n3 = In(n3, e2)), null == n3)
            return;
          o2 = n3[r2];
        }
        return null == o2 ? o2 : o2.apply(n3, t2);
      });
    });
    function Nr(n2, r2) {
      return _r(n2, Rn(r2));
    }
    function Ir(n2, r2, t2) {
      var e2, u2, o2 = -1 / 0, i2 = -1 / 0;
      if (null == r2 || "number" == typeof r2 && "object" != typeof n2[0] && null != n2)
        for (var a3 = 0, f2 = (n2 = er(n2) ? n2 : jn(n2)).length; a3 < f2; a3++)
          null != (e2 = n2[a3]) && e2 > o2 && (o2 = e2);
      else
        r2 = qn(r2, t2), jr(n2, function(n3, t3, e3) {
          ((u2 = r2(n3, t3, e3)) > i2 || u2 === -1 / 0 && o2 === -1 / 0) && (o2 = n3, i2 = u2);
        });
      return o2;
    }
    function Tr(n2, r2, t2) {
      if (null == r2 || t2)
        return er(n2) || (n2 = jn(n2)), n2[Wn(n2.length - 1)];
      var e2 = er(n2) ? En(n2) : jn(n2), u2 = Y(e2);
      r2 = Math.max(Math.min(r2, u2), 0);
      for (var o2 = u2 - 1, i2 = 0; i2 < r2; i2++) {
        var a3 = Wn(i2, o2), f2 = e2[i2];
        e2[i2] = e2[a3], e2[a3] = f2;
      }
      return e2.slice(0, r2);
    }
    function kr(n2, r2) {
      return function(t2, e2, u2) {
        var o2 = r2 ? [[], []] : {};
        return e2 = qn(e2, u2), jr(t2, function(r3, u3) {
          var i2 = e2(r3, u3, t2);
          n2(o2, r3, i2);
        }), o2;
      };
    }
    var Dr = kr(function(n2, r2, t2) {
      W(n2, t2) ? n2[t2].push(r2) : n2[t2] = [r2];
    }), Rr = kr(function(n2, r2, t2) {
      n2[t2] = r2;
    }), Fr = kr(function(n2, r2, t2) {
      W(n2, t2) ? n2[t2]++ : n2[t2] = 1;
    }), Vr = kr(function(n2, r2, t2) {
      n2[t2 ? 0 : 1].push(r2);
    }, true), Pr = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function qr(n2, r2, t2) {
      return r2 in t2;
    }
    var Ur = j(function(n2, r2) {
      var t2 = {}, e2 = r2[0];
      if (null == n2)
        return t2;
      D(e2) ? (r2.length > 1 && (e2 = Fn(e2, r2[1])), r2 = an(n2)) : (e2 = qr, r2 = ur(r2, false, false), n2 = Object(n2));
      for (var u2 = 0, o2 = r2.length; u2 < o2; u2++) {
        var i2 = r2[u2], a3 = n2[i2];
        e2(a3, i2, n2) && (t2[i2] = a3);
      }
      return t2;
    }), Wr = j(function(n2, r2) {
      var t2, e2 = r2[0];
      return D(e2) ? (e2 = fr(e2), r2.length > 1 && (t2 = r2[1])) : (r2 = _r(ur(r2, false, false), String), e2 = function(n3, t3) {
        return !Er(r2, t3);
      }), Ur(n2, e2, t2);
    });
    function zr(n2, r2, t2) {
      return i.call(n2, 0, Math.max(0, n2.length - (null == r2 || t2 ? 1 : r2)));
    }
    function Lr(n2, r2, t2) {
      return null == n2 || n2.length < 1 ? null == r2 || t2 ? void 0 : [] : null == r2 || t2 ? n2[0] : zr(n2, n2.length - r2);
    }
    function $r(n2, r2, t2) {
      return i.call(n2, null == r2 || t2 ? 1 : r2);
    }
    var Cr = j(function(n2, r2) {
      return r2 = ur(r2, true, true), Sr(n2, function(n3) {
        return !Er(r2, n3);
      });
    }), Kr = j(function(n2, r2) {
      return Cr(n2, r2);
    });
    function Jr(n2, r2, t2, e2) {
      A(r2) || (e2 = t2, t2 = r2, r2 = false), null != t2 && (t2 = qn(t2, e2));
      for (var u2 = [], o2 = [], i2 = 0, a3 = Y(n2); i2 < a3; i2++) {
        var f2 = n2[i2], c3 = t2 ? t2(f2, i2, n2) : f2;
        r2 && !t2 ? (i2 && o2 === c3 || u2.push(f2), o2 = c3) : t2 ? Er(o2, c3) || (o2.push(c3), u2.push(f2)) : Er(u2, f2) || u2.push(f2);
      }
      return u2;
    }
    var Gr = j(function(n2) {
      return Jr(ur(n2, true, true));
    });
    function Hr(n2) {
      for (var r2 = n2 && Ir(n2, Y).length || 0, t2 = Array(r2), e2 = 0; e2 < r2; e2++)
        t2[e2] = Nr(n2, e2);
      return t2;
    }
    var Qr = j(Hr);
    function Xr(n2, r2) {
      return n2._chain ? tn(r2).chain() : r2;
    }
    function Yr(n2) {
      return jr(wn(n2), function(r2) {
        var t2 = tn[r2] = n2[r2];
        tn.prototype[r2] = function() {
          var n3 = [this._wrapped];
          return o.apply(n3, arguments), Xr(this, t2.apply(tn, n3));
        };
      }), tn;
    }
    jr(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(n2) {
      var r2 = t[n2];
      tn.prototype[n2] = function() {
        var t2 = this._wrapped;
        return null != t2 && (r2.apply(t2, arguments), "shift" !== n2 && "splice" !== n2 || 0 !== t2.length || delete t2[0]), Xr(this, t2);
      };
    }), jr(["concat", "join", "slice"], function(n2) {
      var r2 = t[n2];
      tn.prototype[n2] = function() {
        var n3 = this._wrapped;
        return null != n3 && (n3 = r2.apply(n3, arguments)), Xr(this, n3);
      };
    });
    var Zr = Yr({
      __proto__: null,
      VERSION: n,
      restArguments: j,
      isObject: _2,
      isNull: function(n2) {
        return null === n2;
      },
      isUndefined: w,
      isBoolean: A,
      isElement: function(n2) {
        return !(!n2 || 1 !== n2.nodeType);
      },
      isString: S,
      isNumber: O,
      isDate: M,
      isRegExp: E,
      isError: B,
      isSymbol: N,
      isArrayBuffer: I,
      isDataView: q,
      isArray: U,
      isFunction: D,
      isArguments: L,
      isFinite: function(n2) {
        return !N(n2) && d(n2) && !isNaN(parseFloat(n2));
      },
      isNaN: $,
      isTypedArray: X,
      isEmpty: function(n2) {
        if (null == n2)
          return true;
        var r2 = Y(n2);
        return "number" == typeof r2 && (U(n2) || S(n2) || L(n2)) ? 0 === r2 : 0 === Y(nn(n2));
      },
      isMatch: rn,
      isEqual: function(n2, r2) {
        return on(n2, r2);
      },
      isMap: dn,
      isWeakMap: gn,
      isSet: bn,
      isWeakSet: mn,
      keys: nn,
      allKeys: an,
      values: jn,
      pairs: function(n2) {
        for (var r2 = nn(n2), t2 = r2.length, e2 = Array(t2), u2 = 0; u2 < t2; u2++)
          e2[u2] = [r2[u2], n2[r2[u2]]];
        return e2;
      },
      invert: _n,
      functions: wn,
      methods: wn,
      extend: xn,
      extendOwn: Sn,
      assign: Sn,
      defaults: On,
      create: function(n2, r2) {
        var t2 = Mn(n2);
        return r2 && Sn(t2, r2), t2;
      },
      clone: En,
      tap: function(n2, r2) {
        return r2(n2), n2;
      },
      get: Tn,
      has: function(n2, r2) {
        for (var t2 = (r2 = Nn(r2)).length, e2 = 0; e2 < t2; e2++) {
          var u2 = r2[e2];
          if (!W(n2, u2))
            return false;
          n2 = n2[u2];
        }
        return !!t2;
      },
      mapObject: function(n2, r2, t2) {
        r2 = qn(r2, t2);
        for (var e2 = nn(n2), u2 = e2.length, o2 = {}, i2 = 0; i2 < u2; i2++) {
          var a3 = e2[i2];
          o2[a3] = r2(n2[a3], a3, n2);
        }
        return o2;
      },
      identity: kn,
      constant: C,
      noop: Un,
      toPath: Bn,
      property: Rn,
      propertyOf: function(n2) {
        return null == n2 ? Un : function(r2) {
          return Tn(n2, r2);
        };
      },
      matcher: Dn,
      matches: Dn,
      times: function(n2, r2, t2) {
        var e2 = Array(Math.max(0, n2));
        r2 = Fn(r2, t2, 1);
        for (var u2 = 0; u2 < n2; u2++)
          e2[u2] = r2(u2);
        return e2;
      },
      random: Wn,
      now: zn,
      escape: Cn,
      unescape: Kn,
      templateSettings: Jn,
      template: function(n2, r2, t2) {
        !r2 && t2 && (r2 = t2), r2 = On({}, r2, tn.templateSettings);
        var e2 = RegExp([(r2.escape || Gn).source, (r2.interpolate || Gn).source, (r2.evaluate || Gn).source].join("|") + "|$", "g"), u2 = 0, o2 = "__p+='";
        n2.replace(e2, function(r3, t3, e3, i3, a4) {
          return o2 += n2.slice(u2, a4).replace(Qn, Xn), u2 = a4 + r3.length, t3 ? o2 += "'+\n((__t=(" + t3 + "))==null?'':_.escape(__t))+\n'" : e3 ? o2 += "'+\n((__t=(" + e3 + "))==null?'':__t)+\n'" : i3 && (o2 += "';\n" + i3 + "\n__p+='"), r3;
        }), o2 += "';\n";
        var i2, a3 = r2.variable;
        if (a3) {
          if (!Yn.test(a3))
            throw new Error("variable is not a bare identifier: " + a3);
        } else
          o2 = "with(obj||{}){\n" + o2 + "}\n", a3 = "obj";
        o2 = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o2 + "return __p;\n";
        try {
          i2 = new Function(a3, "_", o2);
        } catch (n3) {
          throw n3.source = o2, n3;
        }
        var f2 = function(n3) {
          return i2.call(this, n3, tn);
        };
        return f2.source = "function(" + a3 + "){\n" + o2 + "}", f2;
      },
      result: function(n2, r2, t2) {
        var e2 = (r2 = Nn(r2)).length;
        if (!e2)
          return D(t2) ? t2.call(n2) : t2;
        for (var u2 = 0; u2 < e2; u2++) {
          var o2 = null == n2 ? void 0 : n2[r2[u2]];
          void 0 === o2 && (o2 = t2, u2 = e2), n2 = D(o2) ? o2.call(n2) : o2;
        }
        return n2;
      },
      uniqueId: function(n2) {
        var r2 = ++Zn + "";
        return n2 ? n2 + r2 : r2;
      },
      chain: function(n2) {
        var r2 = tn(n2);
        return r2._chain = true, r2;
      },
      iteratee: Pn,
      partial: rr,
      bind: tr,
      bindAll: or,
      memoize: function(n2, r2) {
        var t2 = function(e2) {
          var u2 = t2.cache, o2 = "" + (r2 ? r2.apply(this, arguments) : e2);
          return W(u2, o2) || (u2[o2] = n2.apply(this, arguments)), u2[o2];
        };
        return t2.cache = {}, t2;
      },
      delay: ir,
      defer: ar,
      throttle: function(n2, r2, t2) {
        var e2, u2, o2, i2, a3 = 0;
        t2 || (t2 = {});
        var f2 = function() {
          a3 = false === t2.leading ? 0 : zn(), e2 = null, i2 = n2.apply(u2, o2), e2 || (u2 = o2 = null);
        }, c3 = function() {
          var c4 = zn();
          a3 || false !== t2.leading || (a3 = c4);
          var l2 = r2 - (c4 - a3);
          return u2 = this, o2 = arguments, l2 <= 0 || l2 > r2 ? (e2 && (clearTimeout(e2), e2 = null), a3 = c4, i2 = n2.apply(u2, o2), e2 || (u2 = o2 = null)) : e2 || false === t2.trailing || (e2 = setTimeout(f2, l2)), i2;
        };
        return c3.cancel = function() {
          clearTimeout(e2), a3 = 0, e2 = u2 = o2 = null;
        }, c3;
      },
      debounce: function(n2, r2, t2) {
        var e2, u2, o2, i2, a3, f2 = function() {
          var c4 = zn() - u2;
          r2 > c4 ? e2 = setTimeout(f2, r2 - c4) : (e2 = null, t2 || (i2 = n2.apply(a3, o2)), e2 || (o2 = a3 = null));
        }, c3 = j(function(c4) {
          return a3 = this, o2 = c4, u2 = zn(), e2 || (e2 = setTimeout(f2, r2), t2 && (i2 = n2.apply(a3, o2))), i2;
        });
        return c3.cancel = function() {
          clearTimeout(e2), e2 = o2 = a3 = null;
        }, c3;
      },
      wrap: function(n2, r2) {
        return rr(r2, n2);
      },
      negate: fr,
      compose: function() {
        var n2 = arguments, r2 = n2.length - 1;
        return function() {
          for (var t2 = r2, e2 = n2[r2].apply(this, arguments); t2--; )
            e2 = n2[t2].call(this, e2);
          return e2;
        };
      },
      after: function(n2, r2) {
        return function() {
          if (--n2 < 1)
            return r2.apply(this, arguments);
        };
      },
      before: cr,
      once: lr,
      findKey: sr,
      findIndex: vr,
      findLastIndex: hr,
      sortedIndex: yr,
      indexOf: gr,
      lastIndexOf: br,
      find: mr,
      detect: mr,
      findWhere: function(n2, r2) {
        return mr(n2, Dn(r2));
      },
      each: jr,
      forEach: jr,
      map: _r,
      collect: _r,
      reduce: Ar,
      foldl: Ar,
      inject: Ar,
      reduceRight: xr,
      foldr: xr,
      filter: Sr,
      select: Sr,
      reject: function(n2, r2, t2) {
        return Sr(n2, fr(qn(r2)), t2);
      },
      every: Or,
      all: Or,
      some: Mr,
      any: Mr,
      contains: Er,
      includes: Er,
      include: Er,
      invoke: Br,
      pluck: Nr,
      where: function(n2, r2) {
        return Sr(n2, Dn(r2));
      },
      max: Ir,
      min: function(n2, r2, t2) {
        var e2, u2, o2 = 1 / 0, i2 = 1 / 0;
        if (null == r2 || "number" == typeof r2 && "object" != typeof n2[0] && null != n2)
          for (var a3 = 0, f2 = (n2 = er(n2) ? n2 : jn(n2)).length; a3 < f2; a3++)
            null != (e2 = n2[a3]) && e2 < o2 && (o2 = e2);
        else
          r2 = qn(r2, t2), jr(n2, function(n3, t3, e3) {
            ((u2 = r2(n3, t3, e3)) < i2 || u2 === 1 / 0 && o2 === 1 / 0) && (o2 = n3, i2 = u2);
          });
        return o2;
      },
      shuffle: function(n2) {
        return Tr(n2, 1 / 0);
      },
      sample: Tr,
      sortBy: function(n2, r2, t2) {
        var e2 = 0;
        return r2 = qn(r2, t2), Nr(_r(n2, function(n3, t3, u2) {
          return {
            value: n3,
            index: e2++,
            criteria: r2(n3, t3, u2)
          };
        }).sort(function(n3, r3) {
          var t3 = n3.criteria, e3 = r3.criteria;
          if (t3 !== e3) {
            if (t3 > e3 || void 0 === t3)
              return 1;
            if (t3 < e3 || void 0 === e3)
              return -1;
          }
          return n3.index - r3.index;
        }), "value");
      },
      groupBy: Dr,
      indexBy: Rr,
      countBy: Fr,
      partition: Vr,
      toArray: function(n2) {
        return n2 ? U(n2) ? i.call(n2) : S(n2) ? n2.match(Pr) : er(n2) ? _r(n2, kn) : jn(n2) : [];
      },
      size: function(n2) {
        return null == n2 ? 0 : er(n2) ? n2.length : nn(n2).length;
      },
      pick: Ur,
      omit: Wr,
      first: Lr,
      head: Lr,
      take: Lr,
      initial: zr,
      last: function(n2, r2, t2) {
        return null == n2 || n2.length < 1 ? null == r2 || t2 ? void 0 : [] : null == r2 || t2 ? n2[n2.length - 1] : $r(n2, Math.max(0, n2.length - r2));
      },
      rest: $r,
      tail: $r,
      drop: $r,
      compact: function(n2) {
        return Sr(n2, Boolean);
      },
      flatten: function(n2, r2) {
        return ur(n2, r2, false);
      },
      without: Kr,
      uniq: Jr,
      unique: Jr,
      union: Gr,
      intersection: function(n2) {
        for (var r2 = [], t2 = arguments.length, e2 = 0, u2 = Y(n2); e2 < u2; e2++) {
          var o2 = n2[e2];
          if (!Er(r2, o2)) {
            var i2;
            for (i2 = 1; i2 < t2 && Er(arguments[i2], o2); i2++)
              ;
            i2 === t2 && r2.push(o2);
          }
        }
        return r2;
      },
      difference: Cr,
      unzip: Hr,
      transpose: Hr,
      zip: Qr,
      object: function(n2, r2) {
        for (var t2 = {}, e2 = 0, u2 = Y(n2); e2 < u2; e2++)
          r2 ? t2[n2[e2]] = r2[e2] : t2[n2[e2][0]] = n2[e2][1];
        return t2;
      },
      range: function(n2, r2, t2) {
        null == r2 && (r2 = n2 || 0, n2 = 0), t2 || (t2 = r2 < n2 ? -1 : 1);
        for (var e2 = Math.max(Math.ceil((r2 - n2) / t2), 0), u2 = Array(e2), o2 = 0; o2 < e2; o2++, n2 += t2)
          u2[o2] = n2;
        return u2;
      },
      chunk: function(n2, r2) {
        if (null == r2 || r2 < 1)
          return [];
        for (var t2 = [], e2 = 0, u2 = n2.length; e2 < u2; )
          t2.push(i.call(n2, e2, e2 += r2));
        return t2;
      },
      mixin: Yr,
      default: tn
    });
    return Zr._ = Zr, Zr;
  });
})(underscoreMin);
var _ = underscoreMin.exports;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/underscore-wrapper.js
_.mixin({
  resultCtx: function(object, property, context, defaultValue) {
    let value = _.isObject(object) ? object[property] : void 0;
    if (_.isFunction(value)) {
      value = value.call(context || object);
    }
    if (value) {
      return value;
    } else {
      return !_.isUndefined(defaultValue) ? defaultValue : value;
    }
  },
  isInteger: function(x) {
    return _.isNumber(x) && x % 1 === 0;
  },
  // TODO: This will be deprecated at some point. Views should use precompiled templates
  // eslint-disable-next-line @okta/okta-ui/no-bare-templates
  template: function(source, data) {
    const template8 = _Handlebars2.compile(source);
    if (data) {
      return template8(data);
    }
    const fn11 = function(data2) {
      return template8(data2);
    };
    fn11.source = "";
    return fn11;
  }
});
var oktaUnderscore = _;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/backbone.js
var backbone = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/jquery-1.12.4.js
var jquery1_12_4 = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/lib/jquery-1.12.4.js
(function(module) {
  (function(global2, factory) {
    {
      module.exports = global2.document ? factory(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var deletedIds = [];
    var document2 = window2.document;
    var slice = deletedIds.slice;
    var concat = deletedIds.concat;
    var push = deletedIds.push;
    var indexOf2 = deletedIds.indexOf;
    var class2type = {};
    var toString2 = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var version2 = "1.12.4", jQuery2 = function(selector, context) {
      return new jQuery2.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
      return letter.toUpperCase();
    };
    jQuery2.fn = jQuery2.prototype = {
      // The current version of jQuery being used
      jquery: version2,
      constructor: jQuery2,
      // Start with an empty selector
      selector: "",
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        return num != null ? (
          // Return just the one element from the set
          num < 0 ? this[num + this.length] : this[num]
        ) : (
          // Return all the elements in a clean array
          slice.call(this)
        );
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery2.merge(this.constructor(), elems);
        ret.prevObject = this;
        ret.context = this.context;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery2.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery2.map(this, function(elem, i2) {
          return callback.call(elem, i2, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      eq: function(i2) {
        var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push,
      sort: deletedIds.sort,
      splice: deletedIds.splice
    };
    jQuery2.extend = jQuery2.fn.extend = function() {
      var src, copyIsArray, copy, name, options2, clone2, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i2] || {};
        i2++;
      }
      if (typeof target !== "object" && !jQuery2.isFunction(target)) {
        target = {};
      }
      if (i2 === length) {
        target = this;
        i2--;
      }
      for (; i2 < length; i2++) {
        if ((options2 = arguments[i2]) != null) {
          for (name in options2) {
            src = target[name];
            copy = options2[name];
            if (name === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = jQuery2.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone2 = src && jQuery2.isArray(src) ? src : [];
              } else {
                clone2 = src && jQuery2.isPlainObject(src) ? src : {};
              }
              target[name] = jQuery2.extend(deep, clone2, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery2.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      // See test/unit/core.js for details concerning isFunction.
      // Since version 1.3, DOM methods and functions like alert
      // aren't supported. They return false on IE (#2968).
      isFunction: function(obj) {
        return jQuery2.type(obj) === "function";
      },
      isArray: Array.isArray || function(obj) {
        return jQuery2.type(obj) === "array";
      },
      isWindow: function(obj) {
        return obj != null && obj == obj.window;
      },
      isNumeric: function(obj) {
        var realStringObj = obj && obj.toString();
        return !jQuery2.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      isPlainObject: function(obj) {
        var key;
        if (!obj || jQuery2.type(obj) !== "object" || obj.nodeType || jQuery2.isWindow(obj)) {
          return false;
        }
        try {
          if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
        } catch (e) {
          return false;
        }
        if (!support.ownFirst) {
          for (key in obj) {
            return hasOwn.call(obj, key);
          }
        }
        for (key in obj) {
        }
        return key === void 0 || hasOwn.call(obj, key);
      },
      type: function(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
      },
      // Workarounds based on findings by Jim Driscoll
      // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
      globalEval: function(data) {
        if (data && jQuery2.trim(data)) {
          (window2.execScript || function(data2) {
            window2["eval"].call(window2, data2);
          })(data);
        }
      },
      // Convert dashed to camelCase; used by the css and data modules
      // Microsoft forgot to hump their vendor prefix (#9572)
      camelCase: function(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      },
      nodeName: function(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      },
      each: function(obj, callback) {
        var length, i2 = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i2 < length; i2++) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        } else {
          for (i2 in obj) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // Support: Android<4.1, IE<9
      trim: function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "");
      },
      // results is for internal usage only
      makeArray: function(arr, results) {
        var ret = results || [];
        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery2.merge(ret, typeof arr === "string" ? [arr] : arr);
          } else {
            push.call(ret, arr);
          }
        }
        return ret;
      },
      inArray: function(elem, arr, i2) {
        var len;
        if (arr) {
          if (indexOf2) {
            return indexOf2.call(arr, elem, i2);
          }
          len = arr.length;
          i2 = i2 ? i2 < 0 ? Math.max(0, len + i2) : i2 : 0;
          for (; i2 < len; i2++) {
            if (i2 in arr && arr[i2] === elem) {
              return i2;
            }
          }
        }
        return -1;
      },
      merge: function(first, second) {
        var len = +second.length, j = 0, i2 = first.length;
        while (j < len) {
          first[i2++] = second[j++];
        }
        if (len !== len) {
          while (second[j] !== void 0) {
            first[i2++] = second[j++];
          }
        }
        first.length = i2;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
        for (; i2 < length; i2++) {
          callbackInverse = !callback(elems[i2], i2);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i2]);
          }
        }
        return matches;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i2 = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i2 < length; i2++) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i2 in elems) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return concat.apply([], ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // Bind a function to a context, optionally partially applying any
      // arguments.
      proxy: function(fn11, context) {
        var args, proxy, tmp;
        if (typeof context === "string") {
          tmp = fn11[context];
          context = fn11;
          fn11 = tmp;
        }
        if (!jQuery2.isFunction(fn11)) {
          return void 0;
        }
        args = slice.call(arguments, 2);
        proxy = function() {
          return fn11.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn11.guid = fn11.guid || jQuery2.guid++;
        return proxy;
      },
      now: function() {
        return +/* @__PURE__ */ new Date();
      },
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery2.fn[Symbol.iterator] = deletedIds[Symbol.iterator];
    }
    jQuery2.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i2, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
      var length = !!obj && "length" in obj && obj.length, type = jQuery2.type(obj);
      if (type === "function" || jQuery2.isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = (
      /*!
       * Sizzle CSS Selector Engine v2.2.1
       * http://sizzlejs.com/
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license
       * http://jquery.org/license
       *
       * Date: 2015-10-17
       */
      function(window3) {
        var i2, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a2, b2) {
          if (a2 === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn2 = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push2 = arr.push, slice2 = arr.slice, indexOf3 = function(list, elem) {
          var i3 = 0, len = list.length;
          for (; i3 < len; i3++) {
            if (list[i3] === elem) {
              return i3;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes2 = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes2 + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes2),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_2, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 65536;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? (
            // BMP codepoint
            String.fromCharCode(high + 65536)
          ) : (
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
          );
        }, unloadHandler = function() {
          setDocument();
        };
        try {
          push2.apply(arr = slice2.call(preferredDoc.childNodes), preferredDoc.childNodes);
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: arr.length ? (
              // Leverage slice if possible
              function(target, els) {
                push_native.apply(target, slice2.call(els));
              }
            ) : (
              // Support: IE<9
              // Otherwise append directly
              function(target, els) {
                var j = target.length, i3 = 0;
                while (target[j++] = els[i3++]) {
                }
                target.length = j - 1;
              }
            )
          };
        }
        function Sizzle2(selector, context, results, seed) {
          var m, i3, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            if ((context ? context.ownerDocument || context : preferredDoc) !== document3) {
              setDocument(context);
            }
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                if (nodeType !== 1) {
                  newContext = context;
                  newSelector = selector;
                } else if (context.nodeName.toLowerCase() !== "object") {
                  if (nid = context.getAttribute("id")) {
                    nid = nid.replace(rescape, "\\$&");
                  } else {
                    context.setAttribute("id", nid = expando);
                  }
                  groups = tokenize(selector);
                  i3 = groups.length;
                  nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                  while (i3--) {
                    groups[i3] = nidselect + " " + toSelector(groups[i3]);
                  }
                  newSelector = groups.join(",");
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                }
                if (newSelector) {
                  try {
                    push2.apply(results, newContext.querySelectorAll(newSelector));
                    return results;
                  } catch (qsaError) {
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim2, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn11) {
          fn11[expando] = true;
          return fn11;
        }
        function assert(fn11) {
          var div = document3.createElement("div");
          try {
            return !!fn11(div);
          } catch (e) {
            return false;
          } finally {
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
            div = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr2 = attrs.split("|"), i3 = arr2.length;
          while (i3--) {
            Expr.attrHandle[arr2[i3]] = handler;
          }
        }
        function siblingCheck(a2, b2) {
          var cur = b2 && a2, diff = cur && a2.nodeType === 1 && b2.nodeType === 1 && (~b2.sourceIndex || MAX_NEGATIVE) - (~a2.sourceIndex || MAX_NEGATIVE);
          if (diff) {
            return diff;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b2) {
                return -1;
              }
            }
          }
          return a2 ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createPositionalPseudo(fn11) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn11([], seed.length, argument), i3 = matchIndexes.length;
              while (i3--) {
                if (seed[j = matchIndexes[i3]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support2 = Sizzle2.support = {};
        isXML = Sizzle2.isXML = function(elem) {
          var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
          return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle2.setDocument = function(node) {
          var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc === document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          docElem = document3.documentElement;
          documentIsHTML = !isXML(document3);
          if ((parent = document3.defaultView) && parent.top !== parent) {
            if (parent.addEventListener) {
              parent.addEventListener("unload", unloadHandler, false);
            } else if (parent.attachEvent) {
              parent.attachEvent("onunload", unloadHandler);
            }
          }
          support2.attributes = assert(function(div) {
            div.className = "i";
            return !div.getAttribute("className");
          });
          support2.getElementsByTagName = assert(function(div) {
            div.appendChild(document3.createComment(""));
            return !div.getElementsByTagName("*").length;
          });
          support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
          support2.getById = assert(function(div) {
            docElem.appendChild(div).id = expando;
            return !document3.getElementsByName || !document3.getElementsByName(expando).length;
          });
          if (support2.getById) {
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var m = context.getElementById(id);
                return m ? [m] : [];
              }
            };
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
          } else {
            delete Expr.find["ID"];
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
          }
          Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support2.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem, tmp = [], i3 = 0, results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i3++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support2.getElementsByClassName && function(className2, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className2);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if (support2.qsa = rnative.test(document3.querySelectorAll)) {
            assert(function(div) {
              docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
              if (div.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
              }
              if (!div.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!div.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!div.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
            });
            assert(function(div) {
              var input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              div.appendChild(input).setAttribute("name", "D");
              if (div.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
              }
              if (!div.querySelectorAll(":enabled").length) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              div.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function(div) {
              support2.disconnectedMatch = matches.call(div, "div");
              matches.call(div, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a2, b2) {
            var adown = a2.nodeType === 9 ? a2.documentElement : a2, bup = b2 && b2.parentNode;
            return a2 === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
          } : function(a2, b2) {
            if (b2) {
              while (b2 = b2.parentNode) {
                if (b2 === a2) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a2.ownerDocument || a2) === (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support2.sortDetached && b2.compareDocumentPosition(a2) === compare) {
              if (a2 === document3 || a2.ownerDocument === preferredDoc && contains(preferredDoc, a2)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument === preferredDoc && contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i3 = 0, aup = a2.parentNode, bup = b2.parentNode, ap = [a2], bp = [b2];
            if (!aup || !bup) {
              return a2 === document3 ? -1 : b2 === document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
            } else if (aup === bup) {
              return siblingCheck(a2, b2);
            }
            cur = a2;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b2;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i3] === bp[i3]) {
              i3++;
            }
            return i3 ? (
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck(ap[i3], bp[i3])
            ) : (
              // Otherwise nodes in our document sort first
              ap[i3] === preferredDoc ? -1 : bp[i3] === preferredDoc ? 1 : 0
            );
          };
          return document3;
        };
        Sizzle2.matches = function(expr, elements) {
          return Sizzle2(expr, null, null, elements);
        };
        Sizzle2.matchesSelector = function(elem, expr) {
          if ((elem.ownerDocument || elem) !== document3) {
            setDocument(elem);
          }
          expr = expr.replace(rattributeQuotes, "='$1']");
          if (support2.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
            }
          }
          return Sizzle2(expr, document3, null, [elem]).length > 0;
        };
        Sizzle2.contains = function(context, elem) {
          if ((context.ownerDocument || context) !== document3) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle2.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) !== document3) {
            setDocument(elem);
          }
          var fn11 = Expr.attrHandle[name.toLowerCase()], val = fn11 && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn11(elem, name, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i3 = 0;
          hasDuplicate = !support2.detectDuplicates;
          sortInput = !support2.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i3++]) {
              if (elem === results[i3]) {
                j = duplicates.push(i3);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle2.getText = function(elem) {
          var node, ret = "", i3 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i3++]) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle2.selectors = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": {
              dir: "parentNode"
            },
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": {
              dir: "previousSibling"
            }
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                Sizzle2.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            "CLASS": function(className2) {
              var pattern = classCache[className2 + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className2 + "(" + whitespace + "|$)")) && classCache(className2, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle2.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, context, xml) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args, fn11 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
              if (fn11[expando]) {
                return fn11(argument);
              }
              if (fn11.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn11(seed, argument), i3 = matched.length;
                  while (i3--) {
                    idx = indexOf3(seed, matched[i3]);
                    seed[idx] = !(matches2[idx] = matched[i3]);
                  }
                }) : function(elem) {
                  return fn11(elem, 0, args);
                };
              }
              return fn11;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                while (i3--) {
                  if (elem = unmatched[i3]) {
                    seed[i3] = !(matches2[i3] = elem);
                  }
                }
              }) : function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle2(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            "target": function(elem) {
              var hash = window3.location && window3.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            "enabled": function(elem) {
              return elem.disabled === false;
            },
            "disabled": function(elem) {
              return elem.disabled === true;
            },
            "checked": function(elem) {
              var nodeName = elem.nodeName.toLowerCase();
              return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            // Element/input types
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 0;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 1;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3 = argument < 0 ? argument + length : argument;
              for (; --i3 >= 0; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3 = argument < 0 ? argument + length : argument;
              for (; ++i3 < length; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i2 in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i2] = createInputPseudo(i2);
        }
        for (i2 in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i2] = createButtonPseudo(i2);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rcombinators.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrim2, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        };
        function toSelector(tokens) {
          var i3 = 0, len = tokens.length, selector = "";
          for (; i3 < len; i3++) {
            selector += tokens[i3].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base2) {
          var dir2 = combinator.dir, checkNonElements = base2 && dir2 === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if ((oldCache = uniqueCache[dir2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[dir2] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i3 = matchers.length;
            while (i3--) {
              if (!matchers[i3](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i3 = 0, len = contexts.length;
          for (; i3 < len; i3++) {
            Sizzle2(selector, contexts[i3], results);
          }
          return results;
        }
        function condense(unmatched, map, filter, context, xml) {
          var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
          for (; i3 < len; i3++) {
            if (elem = unmatched[i3]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map.push(i3);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
              postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              )
            ) : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i3 = temp.length;
              while (i3--) {
                if (elem = temp[i3]) {
                  matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i3 = matcherOut.length;
                  while (i3--) {
                    if (elem = matcherOut[i3]) {
                      temp.push(matcherIn[i3] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i3 = matcherOut.length;
                while (i3--) {
                  if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf3(seed, elem) : preMap[i3]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf3(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i3 < len; i3++) {
            if (matcher = Expr.relative[tokens[i3].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
              if (matcher[expando]) {
                j = ++i3;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i3 > 1 && elementMatcher(matchers), i3 > 1 && toSelector(
                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  tokens.slice(0, i3 - 1).concat({
                    value: tokens[i3 - 2].type === " " ? "*" : ""
                  })
                ).replace(rtrim2, "$1"), matcher, i3 < j && matcherFromTokens(tokens.slice(i3, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context === document3 || context || outermost;
            }
            for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i3;
            if (bySet && i3 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i3--) {
                    if (!(unmatched[i3] || setMatched[i3])) {
                      setMatched[i3] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle2.compile = function(selector, match) {
          var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i3 = match.length;
            while (i3--) {
              cached = matcherFromTokens(match[i3]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle2.select = function(selector, context, results, seed) {
          var i3, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support2.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i3--) {
              token = tokens[i3];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find2 = Expr.find[type]) {
                if (seed = find2(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                  tokens.splice(i3, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        };
        support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support2.detectDuplicates = !!hasDuplicate;
        setDocument();
        support2.sortDetached = assert(function(div1) {
          return div1.compareDocumentPosition(document3.createElement("div")) & 1;
        });
        if (!assert(function(div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML2) {
            if (!isXML2) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support2.attributes || !assert(function(div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, name, isXML2) {
            if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML2) {
            var val;
            if (!isXML2) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle2;
      }(window2)
    );
    jQuery2.find = Sizzle;
    jQuery2.expr = Sizzle.selectors;
    jQuery2.expr[":"] = jQuery2.expr.pseudos;
    jQuery2.uniqueSort = jQuery2.unique = Sizzle.uniqueSort;
    jQuery2.text = Sizzle.getText;
    jQuery2.isXMLDoc = Sizzle.isXML;
    jQuery2.contains = Sizzle.contains;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery2(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery2.expr.match.needsContext;
    var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
      if (jQuery2.isFunction(qualifier)) {
        return jQuery2.grep(elements, function(elem, i2) {
          return !!qualifier.call(elem, i2, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery2.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier === "string") {
        if (risSimple.test(qualifier)) {
          return jQuery2.filter(qualifier, elements, not);
        }
        qualifier = jQuery2.filter(qualifier, elements);
      }
      return jQuery2.grep(elements, function(elem) {
        return jQuery2.inArray(elem, qualifier) > -1 !== not;
      });
    }
    jQuery2.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery2.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery2.fn.extend({
      find: function(selector) {
        var i2, ret = [], self2 = this, len = self2.length;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery2(selector).filter(function() {
            for (i2 = 0; i2 < len; i2++) {
              if (jQuery2.contains(self2[i2], this)) {
                return true;
              }
            }
          }));
        }
        for (i2 = 0; i2 < len; i2++) {
          jQuery2.find(selector, self2[i2], ret);
        }
        ret = this.pushStack(len > 1 ? jQuery2.unique(ret) : ret);
        ret.selector = this.selector ? this.selector + " " + selector : selector;
        return ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery2.fn.init = function(selector, context, root) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root = root || rootjQuery;
      if (typeof selector === "string") {
        if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery2 ? context[0] : context;
            jQuery2.merge(this, jQuery2.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document2, true));
            if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
              for (match in context) {
                if (jQuery2.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match[2]);
            if (elem && elem.parentNode) {
              if (elem.id !== match[2]) {
                return rootjQuery.find(selector);
              }
              this.length = 1;
              this[0] = elem;
            }
            this.context = document2;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery2.isFunction(selector)) {
        return typeof root.ready !== "undefined" ? root.ready(selector) : (
          // Execute immediately if ready is not present
          selector(jQuery2)
        );
      }
      if (selector.selector !== void 0) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery2.makeArray(selector, this);
    };
    init.prototype = jQuery2.fn;
    rootjQuery = jQuery2(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery2.fn.extend({
      has: function(target) {
        var i2, targets = jQuery2(target, this), len = targets.length;
        return this.filter(function() {
          for (i2 = 0; i2 < len; i2++) {
            if (jQuery2.contains(this, targets[i2])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i2 = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery2(selectors, context || this.context) : 0;
        for (; i2 < l; i2++) {
          for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : (
              // Don't pass non-elements to Sizzle
              cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
            ))) {
              matched.push(cur);
              break;
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within
      // the matched set of elements
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return jQuery2.inArray(this[0], jQuery2(elem));
        }
        return jQuery2.inArray(
          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem,
          this
        );
      },
      add: function(selector, context) {
        return this.pushStack(jQuery2.uniqueSort(jQuery2.merge(this.get(), jQuery2(selector, context))));
      },
      addBack: function(selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      }
    });
    function sibling(cur, dir2) {
      do {
        cur = cur[dir2];
      } while (cur && cur.nodeType !== 1);
      return cur;
    }
    jQuery2.each({
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, i2, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, i2, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, i2, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        return jQuery2.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery2.merge([], elem.childNodes);
      }
    }, function(name, fn11) {
      jQuery2.fn[name] = function(until, selector) {
        var ret = jQuery2.map(this, fn11, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          ret = jQuery2.filter(selector, ret);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            ret = jQuery2.uniqueSort(ret);
          }
          if (rparentsprev.test(name)) {
            ret = ret.reverse();
          }
        }
        return this.pushStack(ret);
      };
    });
    var rnotwhite = /\S+/g;
    function createOptions(options2) {
      var object = {};
      jQuery2.each(options2.match(rnotwhite) || [], function(_2, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery2.Callbacks = function(options2) {
      options2 = typeof options2 === "string" ? createOptions(options2) : jQuery2.extend({}, options2);
      var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
        locked = options2.once;
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options2.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options2.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              jQuery2.each(args, function(_2, arg) {
                if (jQuery2.isFunction(arg)) {
                  if (!options2.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && jQuery2.type(arg) !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          jQuery2.each(arguments, function(_2, arg) {
            var index;
            while ((index = jQuery2.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn11) {
          return fn11 ? jQuery2.inArray(fn11, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = true;
          if (!memory) {
            self2.disable();
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    jQuery2.extend({
      Deferred: function(func) {
        var tuples = [
          // action, add listener, listener list, final state
          ["resolve", "done", jQuery2.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery2.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery2.Callbacks("memory")]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function() {
            var fns = arguments;
            return jQuery2.Deferred(function(newDefer) {
              jQuery2.each(tuples, function(i2, tuple) {
                var fn11 = jQuery2.isFunction(fns[i2]) && fns[i2];
                deferred[tuple[1]](function() {
                  var returned = fn11 && fn11.apply(this, arguments);
                  if (returned && jQuery2.isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn11 ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery2.extend(obj, promise) : promise;
          }
        }, deferred = {};
        promise.pipe = promise.then;
        jQuery2.each(tuples, function(i2, tuple) {
          var list = tuple[2], stateString = tuple[3];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(function() {
              state = stateString;
            }, tuples[i2 ^ 1][2].disable, tuples[2][2].lock);
          }
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      // Deferred helper
      when: function(subordinate) {
        var i2 = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery2.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery2.Deferred(), updateFunc = function(i3, contexts, values) {
          return function(value) {
            contexts[i3] = this;
            values[i3] = arguments.length > 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
        if (length > 1) {
          progressValues = new Array(length);
          progressContexts = new Array(length);
          resolveContexts = new Array(length);
          for (; i2 < length; i2++) {
            if (resolveValues[i2] && jQuery2.isFunction(resolveValues[i2].promise)) {
              resolveValues[i2].promise().progress(updateFunc(i2, progressContexts, progressValues)).done(updateFunc(i2, resolveContexts, resolveValues)).fail(deferred.reject);
            } else {
              --remaining;
            }
          }
        }
        if (!remaining) {
          deferred.resolveWith(resolveContexts, resolveValues);
        }
        return deferred.promise();
      }
    });
    var readyList;
    jQuery2.fn.ready = function(fn11) {
      jQuery2.ready.promise().done(fn11);
      return this;
    };
    jQuery2.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See #6781
      readyWait: 1,
      // Hold (or release) the ready event
      holdReady: function(hold) {
        if (hold) {
          jQuery2.readyWait++;
        } else {
          jQuery2.ready(true);
        }
      },
      // Handle when the DOM is ready
      ready: function(wait) {
        if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
          return;
        }
        jQuery2.isReady = true;
        if (wait !== true && --jQuery2.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery2]);
        if (jQuery2.fn.triggerHandler) {
          jQuery2(document2).triggerHandler("ready");
          jQuery2(document2).off("ready");
        }
      }
    });
    function detach() {
      if (document2.addEventListener) {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
      } else {
        document2.detachEvent("onreadystatechange", completed);
        window2.detachEvent("onload", completed);
      }
    }
    function completed() {
      if (document2.addEventListener || window2.event.type === "load" || document2.readyState === "complete") {
        detach();
        jQuery2.ready();
      }
    }
    jQuery2.ready.promise = function(obj) {
      if (!readyList) {
        readyList = jQuery2.Deferred();
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery2.ready);
        } else if (document2.addEventListener) {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        } else {
          document2.attachEvent("onreadystatechange", completed);
          window2.attachEvent("onload", completed);
          var top = false;
          try {
            top = window2.frameElement == null && document2.documentElement;
          } catch (e) {
          }
          if (top && top.doScroll) {
            (function doScrollCheck() {
              if (!jQuery2.isReady) {
                try {
                  top.doScroll("left");
                } catch (e) {
                  return window2.setTimeout(doScrollCheck, 50);
                }
                detach();
                jQuery2.ready();
              }
            })();
          }
        }
      }
      return readyList.promise(obj);
    };
    jQuery2.ready.promise();
    var i;
    for (i in jQuery2(support)) {
      break;
    }
    support.ownFirst = i === "0";
    support.inlineBlockNeedsLayout = false;
    jQuery2(function() {
      var val, div, body, container;
      body = document2.getElementsByTagName("body")[0];
      if (!body || !body.style) {
        return;
      }
      div = document2.createElement("div");
      container = document2.createElement("div");
      container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
      body.appendChild(container).appendChild(div);
      if (typeof div.style.zoom !== "undefined") {
        div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
        support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
        if (val) {
          body.style.zoom = 1;
        }
      }
      body.removeChild(container);
    });
    (function() {
      var div = document2.createElement("div");
      support.deleteExpando = true;
      try {
        delete div.test;
      } catch (e) {
        support.deleteExpando = false;
      }
      div = null;
    })();
    var acceptData = function(elem) {
      var noData = jQuery2.noData[(elem.nodeName + " ").toLowerCase()], nodeType = +elem.nodeType || 1;
      return nodeType !== 1 && nodeType !== 9 ? false : (
        // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || noData !== true && elem.getAttribute("classid") === noData
      );
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
      if (data === void 0 && elem.nodeType === 1) {
        var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
        data = elem.getAttribute(name);
        if (typeof data === "string") {
          try {
            data = data === "true" ? true : data === "false" ? false : data === "null" ? null : (
              // Only convert to a number if it doesn't change the string
              +data + "" === data ? +data : rbrace.test(data) ? jQuery2.parseJSON(data) : data
            );
          } catch (e) {
          }
          jQuery2.data(elem, key, data);
        } else {
          data = void 0;
        }
      }
      return data;
    }
    function isEmptyDataObject(obj) {
      var name;
      for (name in obj) {
        if (name === "data" && jQuery2.isEmptyObject(obj[name])) {
          continue;
        }
        if (name !== "toJSON") {
          return false;
        }
      }
      return true;
    }
    function internalData(elem, name, data, pvt) {
      if (!acceptData(elem)) {
        return;
      }
      var ret, thisCache, internalKey = jQuery2.expando, isNode = elem.nodeType, cache = isNode ? jQuery2.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
      if ((!id || !cache[id] || !pvt && !cache[id].data) && data === void 0 && typeof name === "string") {
        return;
      }
      if (!id) {
        if (isNode) {
          id = elem[internalKey] = deletedIds.pop() || jQuery2.guid++;
        } else {
          id = internalKey;
        }
      }
      if (!cache[id]) {
        cache[id] = isNode ? {} : {
          toJSON: jQuery2.noop
        };
      }
      if (typeof name === "object" || typeof name === "function") {
        if (pvt) {
          cache[id] = jQuery2.extend(cache[id], name);
        } else {
          cache[id].data = jQuery2.extend(cache[id].data, name);
        }
      }
      thisCache = cache[id];
      if (!pvt) {
        if (!thisCache.data) {
          thisCache.data = {};
        }
        thisCache = thisCache.data;
      }
      if (data !== void 0) {
        thisCache[jQuery2.camelCase(name)] = data;
      }
      if (typeof name === "string") {
        ret = thisCache[name];
        if (ret == null) {
          ret = thisCache[jQuery2.camelCase(name)];
        }
      } else {
        ret = thisCache;
      }
      return ret;
    }
    function internalRemoveData(elem, name, pvt) {
      if (!acceptData(elem)) {
        return;
      }
      var thisCache, i2, isNode = elem.nodeType, cache = isNode ? jQuery2.cache : elem, id = isNode ? elem[jQuery2.expando] : jQuery2.expando;
      if (!cache[id]) {
        return;
      }
      if (name) {
        thisCache = pvt ? cache[id] : cache[id].data;
        if (thisCache) {
          if (!jQuery2.isArray(name)) {
            if (name in thisCache) {
              name = [name];
            } else {
              name = jQuery2.camelCase(name);
              if (name in thisCache) {
                name = [name];
              } else {
                name = name.split(" ");
              }
            }
          } else {
            name = name.concat(jQuery2.map(name, jQuery2.camelCase));
          }
          i2 = name.length;
          while (i2--) {
            delete thisCache[name[i2]];
          }
          if (pvt ? !isEmptyDataObject(thisCache) : !jQuery2.isEmptyObject(thisCache)) {
            return;
          }
        }
      }
      if (!pvt) {
        delete cache[id].data;
        if (!isEmptyDataObject(cache[id])) {
          return;
        }
      }
      if (isNode) {
        jQuery2.cleanData([elem], true);
      } else if (support.deleteExpando || cache != cache.window) {
        delete cache[id];
      } else {
        cache[id] = void 0;
      }
    }
    jQuery2.extend({
      cache: {},
      // The following elements (space-suffixed to avoid Object.prototype collisions)
      // throw uncatchable exceptions if you attempt to set expando properties
      noData: {
        "applet ": true,
        "embed ": true,
        // ...but Flash objects (which have this classid) *can* handle expandos
        "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
      },
      hasData: function(elem) {
        elem = elem.nodeType ? jQuery2.cache[elem[jQuery2.expando]] : elem[jQuery2.expando];
        return !!elem && !isEmptyDataObject(elem);
      },
      data: function(elem, name, data) {
        return internalData(elem, name, data);
      },
      removeData: function(elem, name) {
        return internalRemoveData(elem, name);
      },
      // For internal use only.
      _data: function(elem, name, data) {
        return internalData(elem, name, data, true);
      },
      _removeData: function(elem, name) {
        return internalRemoveData(elem, name, true);
      }
    });
    jQuery2.fn.extend({
      data: function(key, value) {
        var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data = jQuery2.data(elem);
            if (elem.nodeType === 1 && !jQuery2._data(elem, "parsedAttrs")) {
              i2 = attrs.length;
              while (i2--) {
                if (attrs[i2]) {
                  name = attrs[i2].name;
                  if (name.indexOf("data-") === 0) {
                    name = jQuery2.camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              jQuery2._data(elem, "parsedAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            jQuery2.data(this, key);
          });
        }
        return arguments.length > 1 ? (
          // Sets one value
          this.each(function() {
            jQuery2.data(this, key, value);
          })
        ) : (
          // Gets one value
          // Try to fetch any internally stored data first
          elem ? dataAttr(elem, key, jQuery2.data(elem, key)) : void 0
        );
      },
      removeData: function(key) {
        return this.each(function() {
          jQuery2.removeData(this, key);
        });
      }
    });
    jQuery2.extend({
      queue: function(elem, type, data) {
        var queue;
        if (elem) {
          type = (type || "fx") + "queue";
          queue = jQuery2._data(elem, type);
          if (data) {
            if (!queue || jQuery2.isArray(data)) {
              queue = jQuery2._data(elem, type, jQuery2.makeArray(data));
            } else {
              queue.push(data);
            }
          }
          return queue || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue = jQuery2.queue(elem, type), startLength = queue.length, fn11 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
          jQuery2.dequeue(elem, type);
        };
        if (fn11 === "inprogress") {
          fn11 = queue.shift();
          startLength--;
        }
        if (fn11) {
          if (type === "fx") {
            queue.unshift("inprogress");
          }
          delete hooks.stop;
          fn11.call(elem, next, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // not intended for public consumption - generates a queueHooks object,
      // or returns the current one
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return jQuery2._data(elem, key) || jQuery2._data(elem, key, {
          empty: jQuery2.Callbacks("once memory").add(function() {
            jQuery2._removeData(elem, type + "queue");
            jQuery2._removeData(elem, key);
          })
        });
      }
    });
    jQuery2.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery2.queue(this[0], type);
        }
        return data === void 0 ? this : this.each(function() {
          var queue = jQuery2.queue(this, type, data);
          jQuery2._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery2.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery2.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(type, obj) {
        var tmp, count = 1, defer2 = jQuery2.Deferred(), elements = this, i2 = this.length, resolve = function() {
          if (!--count) {
            defer2.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i2--) {
          tmp = jQuery2._data(elements[i2], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer2.promise(obj);
      }
    });
    (function() {
      var shrinkWrapBlocksVal;
      support.shrinkWrapBlocks = function() {
        if (shrinkWrapBlocksVal != null) {
          return shrinkWrapBlocksVal;
        }
        shrinkWrapBlocksVal = false;
        var div, body, container;
        body = document2.getElementsByTagName("body")[0];
        if (!body || !body.style) {
          return;
        }
        div = document2.createElement("div");
        container = document2.createElement("div");
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild(container).appendChild(div);
        if (typeof div.style.zoom !== "undefined") {
          div.style.cssText = // Support: Firefox<29, Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1";
          div.appendChild(document2.createElement("div")).style.width = "5px";
          shrinkWrapBlocksVal = div.offsetWidth !== 3;
        }
        body.removeChild(container);
        return shrinkWrapBlocksVal;
      };
    })();
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var isHidden = function(elem, el) {
      elem = el || elem;
      return jQuery2.css(elem, "display") === "none" || !jQuery2.contains(elem.ownerDocument, elem);
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery2.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        unit = unit || initialInUnit[3];
        valueParts = valueParts || [];
        initialInUnit = +initial || 1;
        do {
          scale = scale || ".5";
          initialInUnit = initialInUnit / scale;
          jQuery2.style(elem, prop, initialInUnit + unit);
        } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var access = function(elems, fn11, key, value, chainable, emptyGet, raw) {
      var i2 = 0, length = elems.length, bulk = key == null;
      if (jQuery2.type(key) === "object") {
        chainable = true;
        for (i2 in key) {
          access(elems, fn11, i2, key[i2], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!jQuery2.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn11.call(elems, value);
            fn11 = null;
          } else {
            bulk = fn11;
            fn11 = function(elem, key2, value2) {
              return bulk.call(jQuery2(elem), value2);
            };
          }
        }
        if (fn11) {
          for (; i2 < length; i2++) {
            fn11(elems[i2], key, raw ? value : value.call(elems[i2], i2, fn11(elems[i2], key)));
          }
        }
      }
      return chainable ? elems : (
        // Gets
        bulk ? fn11.call(elems) : length ? fn11(elems[0], key) : emptyGet
      );
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([\w:-]+)/;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var rleadingWhitespace = /^\s+/;
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video";
    function createSafeFragment(document3) {
      var list = nodeNames.split("|"), safeFrag = document3.createDocumentFragment();
      if (safeFrag.createElement) {
        while (list.length) {
          safeFrag.createElement(list.pop());
        }
      }
      return safeFrag;
    }
    (function() {
      var div = document2.createElement("div"), fragment = document2.createDocumentFragment(), input = document2.createElement("input");
      div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
      support.leadingWhitespace = div.firstChild.nodeType === 3;
      support.tbody = !div.getElementsByTagName("tbody").length;
      support.htmlSerialize = !!div.getElementsByTagName("link").length;
      support.html5Clone = document2.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>";
      input.type = "checkbox";
      input.checked = true;
      fragment.appendChild(input);
      support.appendChecked = input.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
      fragment.appendChild(div);
      input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      support.noCloneEvent = !!div.addEventListener;
      div[jQuery2.expando] = 1;
      support.attributes = !div.getAttribute(jQuery2.expando);
    })();
    var wrapMap = {
      legend: [1, "<fieldset>", "</fieldset>"],
      area: [1, "<map>", "</map>"],
      // Support: IE8
      param: [1, "<object>", "</object>"],
      thead: [1, "<table>", "</table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
      // unless wrapped in a div with non-breaking characters in front of it.
      _default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var elems, elem, i2 = 0, found = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : void 0;
      if (!found) {
        for (found = [], elems = context.childNodes || context; (elem = elems[i2]) != null; i2++) {
          if (!tag || jQuery2.nodeName(elem, tag)) {
            found.push(elem);
          } else {
            jQuery2.merge(found, getAll(elem, tag));
          }
        }
      }
      return tag === void 0 || tag && jQuery2.nodeName(context, tag) ? jQuery2.merge([context], found) : found;
    }
    function setGlobalEval(elems, refElements) {
      var elem, i2 = 0;
      for (; (elem = elems[i2]) != null; i2++) {
        jQuery2._data(elem, "globalEval", !refElements || jQuery2._data(refElements[i2], "globalEval"));
      }
    }
    var rhtml = /<|&#?\w+;/, rtbody = /<tbody/i;
    function fixDefaultChecked(elem) {
      if (rcheckableType.test(elem.type)) {
        elem.defaultChecked = elem.checked;
      }
    }
    function buildFragment(elems, context, scripts, selection, ignored) {
      var j, elem, contains, tmp, tag, tbody, wrap2, l = elems.length, safe = createSafeFragment(context), nodes = [], i2 = 0;
      for (; i2 < l; i2++) {
        elem = elems[i2];
        if (elem || elem === 0) {
          if (jQuery2.type(elem) === "object") {
            jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || safe.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap2 = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap2[1] + jQuery2.htmlPrefilter(elem) + wrap2[2];
            j = wrap2[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
            }
            if (!support.tbody) {
              elem = tag === "table" && !rtbody.test(elem) ? tmp.firstChild : (
                // String was a bare <thead> or <tfoot>
                wrap2[1] === "<table>" && !rtbody.test(elem) ? tmp : 0
              );
              j = elem && elem.childNodes.length;
              while (j--) {
                if (jQuery2.nodeName(tbody = elem.childNodes[j], "tbody") && !tbody.childNodes.length) {
                  elem.removeChild(tbody);
                }
              }
            }
            jQuery2.merge(nodes, tmp.childNodes);
            tmp.textContent = "";
            while (tmp.firstChild) {
              tmp.removeChild(tmp.firstChild);
            }
            tmp = safe.lastChild;
          }
        }
      }
      if (tmp) {
        safe.removeChild(tmp);
      }
      if (!support.appendChecked) {
        jQuery2.grep(getAll(nodes, "input"), fixDefaultChecked);
      }
      i2 = 0;
      while (elem = nodes[i2++]) {
        if (selection && jQuery2.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        contains = jQuery2.contains(elem.ownerDocument, elem);
        tmp = getAll(safe.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      tmp = null;
      return safe;
    }
    (function() {
      var i2, eventName;
      for (i2 in {
        submit: true,
        change: true,
        focusin: true
      }) {
        eventName = "on" + i2;
        support[i2] = eventName in window2;
      }
    })();
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on(elem, types, selector, data, fn11, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = void 0;
        }
        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }
        return elem;
      }
      if (data == null && fn11 == null) {
        fn11 = selector;
        data = selector = void 0;
      } else if (fn11 == null) {
        if (typeof selector === "string") {
          fn11 = data;
          data = void 0;
        } else {
          fn11 = data;
          data = selector;
          selector = void 0;
        }
      }
      if (fn11 === false) {
        fn11 = returnFalse;
      } else if (!fn11) {
        return elem;
      }
      if (one === 1) {
        origFn = fn11;
        fn11 = function(event) {
          jQuery2().off(event);
          return origFn.apply(this, arguments);
        };
        fn11.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
      }
      return elem.each(function() {
        jQuery2.event.add(this, types, fn11, data, selector);
      });
    }
    jQuery2.event = {
      global: {},
      add: function(elem, types, handler, data, selector) {
        var tmp, events4, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery2._data(elem);
        if (!elemData) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (!handler.guid) {
          handler.guid = jQuery2.guid++;
        }
        if (!(events4 = elemData.events)) {
          events4 = elemData.events = {};
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery2 !== "undefined" && (!e || jQuery2.event.triggered !== e.type) ? jQuery2.event.dispatch.apply(eventHandle.elem, arguments) : void 0;
          };
          eventHandle.elem = elem;
        }
        types = (types || "").match(rnotwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery2.event.special[type] || {};
          handleObj = jQuery2.extend({
            type,
            origType,
            data,
            handler,
            guid: handler.guid,
            selector,
            needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events4[type])) {
            handlers = events4[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle, false);
              } else if (elem.attachEvent) {
                elem.attachEvent("on" + type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery2.event.global[type] = true;
        }
        elem = null;
      },
      // Detach an event or set of events from an element
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, handleObj, tmp, origCount, t, events4, special, handlers, type, namespaces, origType, elemData = jQuery2.hasData(elem) && jQuery2._data(elem);
        if (!elemData || !(events4 = elemData.events)) {
          return;
        }
        types = (types || "").match(rnotwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events4) {
              jQuery2.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events4[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery2.removeEvent(elem, type, elemData.handle);
            }
            delete events4[type];
          }
        }
        if (jQuery2.isEmptyObject(events4)) {
          delete elemData.handle;
          jQuery2._removeData(elem, "events");
        }
      },
      trigger: function(event, data, elem, onlyHandlers) {
        var handle, ontype, cur, bubbleType, special, tmp, i2, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery2.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [event] : jQuery2.makeArray(data, [event]);
        special = jQuery2.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !jQuery2.isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i2 = 0;
        while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
          event.type = i2 > 1 ? bubbleType : special.bindType || type;
          handle = (jQuery2._data(cur, "events") || {})[event.type] && jQuery2._data(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && elem[type] && !jQuery2.isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery2.event.triggered = type;
              try {
                elem[type]();
              } catch (e) {
              }
              jQuery2.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      dispatch: function(event) {
        event = jQuery2.event.fix(event);
        var i2, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery2._data(this, "events") || {})[event.type] || [], special = jQuery2.event.special[event.type] || {};
        args[0] = event;
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
        i2 = 0;
        while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i2, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
          for (; cur != this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
              matches = [];
              for (i2 = 0; i2 < delegateCount; i2++) {
                handleObj = handlers[i2];
                sel = handleObj.selector + " ";
                if (matches[sel] === void 0) {
                  matches[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                }
                if (matches[sel]) {
                  matches.push(handleObj);
                }
              }
              if (matches.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matches
                });
              }
            }
          }
        }
        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: this,
            handlers: handlers.slice(delegateCount)
          });
        }
        return handlerQueue;
      },
      fix: function(event) {
        if (event[jQuery2.expando]) {
          return event;
        }
        var i2, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
        if (!fixHook) {
          this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
        }
        copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
        event = new jQuery2.Event(originalEvent);
        i2 = copy.length;
        while (i2--) {
          prop = copy[i2];
          event[prop] = originalEvent[prop];
        }
        if (!event.target) {
          event.target = originalEvent.srcElement || document2;
        }
        if (event.target.nodeType === 3) {
          event.target = event.target.parentNode;
        }
        event.metaKey = !!event.metaKey;
        return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
      },
      // Includes some event props shared by KeyEvent and MouseEvent
      props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
      fixHooks: {},
      keyHooks: {
        props: "char charCode key keyCode".split(" "),
        filter: function(event, original) {
          if (event.which == null) {
            event.which = original.charCode != null ? original.charCode : original.keyCode;
          }
          return event;
        }
      },
      mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
        filter: function(event, original) {
          var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
          if (event.pageX == null && original.clientX != null) {
            eventDoc = event.target.ownerDocument || document2;
            doc = eventDoc.documentElement;
            body = eventDoc.body;
            event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
          }
          if (!event.relatedTarget && fromElement) {
            event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
          }
          if (!event.which && button !== void 0) {
            event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
          }
          return event;
        }
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        focus: {
          // Fire native event if possible so blur/focus sequence is correct
          trigger: function() {
            if (this !== safeActiveElement() && this.focus) {
              try {
                this.focus();
                return false;
              } catch (e) {
              }
            }
          },
          delegateType: "focusin"
        },
        blur: {
          trigger: function() {
            if (this === safeActiveElement() && this.blur) {
              this.blur();
              return false;
            }
          },
          delegateType: "focusout"
        },
        click: {
          // For checkbox, fire native event so checked state will be right
          trigger: function() {
            if (jQuery2.nodeName(this, "input") && this.type === "checkbox" && this.click) {
              this.click();
              return false;
            }
          },
          // For cross-browser consistency, don't fire native .click() on links
          _default: function(event) {
            return jQuery2.nodeName(event.target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      },
      // Piggyback on a donor event to simulate a different one
      simulate: function(type, elem, event) {
        var e = jQuery2.extend(new jQuery2.Event(), event, {
          type,
          isSimulated: true
          // Previously, `originalEvent: {}` was set here, so stopPropagation call
          // would not be triggered on donor event, since in our own
          // jQuery.event.stopPropagation function we had a check for existence of
          // originalEvent.stopPropagation method, so, consequently it would be a noop.
          //
          // Guard for simulated events was moved to jQuery.event.stopPropagation function
          // since `originalEvent` should point to the original event for the
          // constancy with other events and for more focused logic
        });
        jQuery2.event.trigger(e, null, elem);
        if (e.isDefaultPrevented()) {
          event.preventDefault();
        }
      }
    };
    jQuery2.removeEvent = document2.removeEventListener ? function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    } : function(elem, type, handle) {
      var name = "on" + type;
      if (elem.detachEvent) {
        if (typeof elem[name] === "undefined") {
          elem[name] = null;
        }
        elem.detachEvent(name, handle);
      }
    };
    jQuery2.Event = function(src, props6) {
      if (!(this instanceof jQuery2.Event)) {
        return new jQuery2.Event(src, props6);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: IE < 9, Android < 4.0
        src.returnValue === false ? returnTrue : returnFalse;
      } else {
        this.type = src;
      }
      if (props6) {
        jQuery2.extend(this, props6);
      }
      this.timeStamp = src && src.timeStamp || jQuery2.now();
      this[jQuery2.expando] = true;
    };
    jQuery2.Event.prototype = {
      constructor: jQuery2.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (!e) {
          return;
        }
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (!e || this.isSimulated) {
          return;
        }
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        e.cancelBubble = true;
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && e.stopImmediatePropagation) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery2.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery2.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery2.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    if (!support.submit) {
      jQuery2.event.special.submit = {
        setup: function() {
          if (jQuery2.nodeName(this, "form")) {
            return false;
          }
          jQuery2.event.add(this, "click._submit keypress._submit", function(e) {
            var elem = e.target, form2 = jQuery2.nodeName(elem, "input") || jQuery2.nodeName(elem, "button") ? (
              // Support: IE <=8
              // We use jQuery.prop instead of elem.form
              // to allow fixing the IE8 delegated submit issue (gh-2332)
              // by 3rd party polyfills/workarounds.
              jQuery2.prop(elem, "form")
            ) : void 0;
            if (form2 && !jQuery2._data(form2, "submit")) {
              jQuery2.event.add(form2, "submit._submit", function(event) {
                event._submitBubble = true;
              });
              jQuery2._data(form2, "submit", true);
            }
          });
        },
        postDispatch: function(event) {
          if (event._submitBubble) {
            delete event._submitBubble;
            if (this.parentNode && !event.isTrigger) {
              jQuery2.event.simulate("submit", this.parentNode, event);
            }
          }
        },
        teardown: function() {
          if (jQuery2.nodeName(this, "form")) {
            return false;
          }
          jQuery2.event.remove(this, "._submit");
        }
      };
    }
    if (!support.change) {
      jQuery2.event.special.change = {
        setup: function() {
          if (rformElems.test(this.nodeName)) {
            if (this.type === "checkbox" || this.type === "radio") {
              jQuery2.event.add(this, "propertychange._change", function(event) {
                if (event.originalEvent.propertyName === "checked") {
                  this._justChanged = true;
                }
              });
              jQuery2.event.add(this, "click._change", function(event) {
                if (this._justChanged && !event.isTrigger) {
                  this._justChanged = false;
                }
                jQuery2.event.simulate("change", this, event);
              });
            }
            return false;
          }
          jQuery2.event.add(this, "beforeactivate._change", function(e) {
            var elem = e.target;
            if (rformElems.test(elem.nodeName) && !jQuery2._data(elem, "change")) {
              jQuery2.event.add(elem, "change._change", function(event) {
                if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                  jQuery2.event.simulate("change", this.parentNode, event);
                }
              });
              jQuery2._data(elem, "change", true);
            }
          });
        },
        handle: function(event) {
          var elem = event.target;
          if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== "radio" && elem.type !== "checkbox") {
            return event.handleObj.handler.apply(this, arguments);
          }
        },
        teardown: function() {
          jQuery2.event.remove(this, "._change");
          return !rformElems.test(this.nodeName);
        }
      };
    }
    if (!support.focusin) {
      jQuery2.each({
        focus: "focusin",
        blur: "focusout"
      }, function(orig, fix) {
        var handler = function(event) {
          jQuery2.event.simulate(fix, event.target, jQuery2.event.fix(event));
        };
        jQuery2.event.special[fix] = {
          setup: function() {
            var doc = this.ownerDocument || this, attaches = jQuery2._data(doc, fix);
            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }
            jQuery2._data(doc, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this, attaches = jQuery2._data(doc, fix) - 1;
            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              jQuery2._removeData(doc, fix);
            } else {
              jQuery2._data(doc, fix, attaches);
            }
          }
        };
      });
    }
    jQuery2.fn.extend({
      on: function(types, selector, data, fn11) {
        return on(this, types, selector, data, fn11);
      },
      one: function(types, selector, data, fn11) {
        return on(this, types, selector, data, fn11, 1);
      },
      off: function(types, selector, fn11) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery2(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn11 = selector;
          selector = void 0;
        }
        if (fn11 === false) {
          fn11 = returnFalse;
        }
        return this.each(function() {
          jQuery2.event.remove(this, types, fn11, selector);
        });
      },
      trigger: function(type, data) {
        return this.each(function() {
          jQuery2.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery2.event.trigger(type, data, elem, true);
        }
      }
    });
    var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"), rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, safeFragment = createSafeFragment(document2), fragmentDiv = safeFragment.appendChild(document2.createElement("div"));
    function manipulationTarget(elem, content) {
      return jQuery2.nodeName(elem, "table") && jQuery2.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
      elem.type = (jQuery2.find.attr(elem, "type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      var match = rscriptTypeMasked.exec(elem.type);
      if (match) {
        elem.type = match[1];
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      if (dest.nodeType !== 1 || !jQuery2.hasData(src)) {
        return;
      }
      var type, i2, l, oldData = jQuery2._data(src), curData = jQuery2._data(dest, oldData), events4 = oldData.events;
      if (events4) {
        delete curData.handle;
        curData.events = {};
        for (type in events4) {
          for (i2 = 0, l = events4[type].length; i2 < l; i2++) {
            jQuery2.event.add(dest, type, events4[type][i2]);
          }
        }
      }
      if (curData.data) {
        curData.data = jQuery2.extend({}, curData.data);
      }
    }
    function fixCloneNodeIssues(src, dest) {
      var nodeName, e, data;
      if (dest.nodeType !== 1) {
        return;
      }
      nodeName = dest.nodeName.toLowerCase();
      if (!support.noCloneEvent && dest[jQuery2.expando]) {
        data = jQuery2._data(dest);
        for (e in data.events) {
          jQuery2.removeEvent(dest, e, data.handle);
        }
        dest.removeAttribute(jQuery2.expando);
      }
      if (nodeName === "script" && dest.text !== src.text) {
        disableScript(dest).text = src.text;
        restoreScript(dest);
      } else if (nodeName === "object") {
        if (dest.parentNode) {
          dest.outerHTML = src.outerHTML;
        }
        if (support.html5Clone && src.innerHTML && !jQuery2.trim(dest.innerHTML)) {
          dest.innerHTML = src.innerHTML;
        }
      } else if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.defaultChecked = dest.checked = src.checked;
        if (dest.value !== src.value) {
          dest.value = src.value;
        }
      } else if (nodeName === "option") {
        dest.defaultSelected = dest.selected = src.defaultSelected;
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = concat.apply([], args);
      var first, node, hasScripts, scripts, doc, fragment, i2 = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction4 = jQuery2.isFunction(value);
      if (isFunction4 || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self2 = collection.eq(index);
          if (isFunction4) {
            args[0] = value.call(this, index, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i2 < l; i2++) {
            node = fragment;
            if (i2 !== iNoClone) {
              node = jQuery2.clone(node, true, true);
              if (hasScripts) {
                jQuery2.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i2], node, i2);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery2.map(scripts, restoreScript);
            for (i2 = 0; i2 < hasScripts; i2++) {
              node = scripts[i2];
              if (rscriptType.test(node.type || "") && !jQuery2._data(node, "globalEval") && jQuery2.contains(doc, node)) {
                if (node.src) {
                  if (jQuery2._evalUrl) {
                    jQuery2._evalUrl(node.src);
                  }
                } else {
                  jQuery2.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, ""));
                }
              }
            }
          }
          fragment = first = null;
        }
      }
      return collection;
    }
    function remove(elem, selector, keepData) {
      var node, elems = selector ? jQuery2.filter(selector, elem) : elem, i2 = 0;
      for (; (node = elems[i2]) != null; i2++) {
        if (!keepData && node.nodeType === 1) {
          jQuery2.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && jQuery2.contains(node.ownerDocument, node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery2.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var destElements, node, clone2, i2, srcElements, inPage = jQuery2.contains(elem.ownerDocument, elem);
        if (support.html5Clone || jQuery2.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
          clone2 = elem.cloneNode(true);
        } else {
          fragmentDiv.innerHTML = elem.outerHTML;
          fragmentDiv.removeChild(clone2 = fragmentDiv.firstChild);
        }
        if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
          destElements = getAll(clone2);
          srcElements = getAll(elem);
          for (i2 = 0; (node = srcElements[i2]) != null; ++i2) {
            if (destElements[i2]) {
              fixCloneNodeIssues(node, destElements[i2]);
            }
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone2);
            for (i2 = 0; (node = srcElements[i2]) != null; i2++) {
              cloneCopyEvent(node, destElements[i2]);
            }
          } else {
            cloneCopyEvent(elem, clone2);
          }
        }
        destElements = getAll(clone2, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        destElements = srcElements = node = null;
        return clone2;
      },
      cleanData: function(elems, forceAcceptData) {
        var elem, type, id, data, i2 = 0, internalKey = jQuery2.expando, cache = jQuery2.cache, attributes2 = support.attributes, special = jQuery2.event.special;
        for (; (elem = elems[i2]) != null; i2++) {
          if (forceAcceptData || acceptData(elem)) {
            id = elem[internalKey];
            data = id && cache[id];
            if (data) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery2.event.remove(elem, type);
                  } else {
                    jQuery2.removeEvent(elem, type, data.handle);
                  }
                }
              }
              if (cache[id]) {
                delete cache[id];
                if (!attributes2 && typeof elem.removeAttribute !== "undefined") {
                  elem.removeAttribute(internalKey);
                } else {
                  elem[internalKey] = void 0;
                }
                deletedIds.push(id);
              }
            }
          }
        }
      }
    });
    jQuery2.fn.extend({
      // Keep domManip exposed until 3.0 (gh-2225)
      domManip,
      detach: function(selector) {
        return remove(this, selector, true);
      },
      remove: function(selector) {
        return remove(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery2.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document2).createTextNode(value2));
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i2 = 0;
        for (; (elem = this[i2]) != null; i2++) {
          if (elem.nodeType === 1) {
            jQuery2.cleanData(getAll(elem, false));
          }
          while (elem.firstChild) {
            elem.removeChild(elem.firstChild);
          }
          if (elem.options && jQuery2.nodeName(elem, "select")) {
            elem.options.length = 0;
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i2 = 0, l = this.length;
          if (value2 === void 0) {
            return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : void 0;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && (support.htmlSerialize || !rnoshimcache.test(value2)) && (support.leadingWhitespace || !rleadingWhitespace.test(value2)) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery2.htmlPrefilter(value2);
            try {
              for (; i2 < l; i2++) {
                elem = this[i2] || {};
                if (elem.nodeType === 1) {
                  jQuery2.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent = this.parentNode;
          if (jQuery2.inArray(this, ignored) < 0) {
            jQuery2.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery2.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name, original) {
      jQuery2.fn[name] = function(selector) {
        var elems, i2 = 0, ret = [], insert = jQuery2(selector), last = insert.length - 1;
        for (; i2 <= last; i2++) {
          elems = i2 === last ? this : this.clone(true);
          jQuery2(insert[i2])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var iframe, elemdisplay = {
      // Support: Firefox
      // We have to pre-define these values for FF (#10227)
      HTML: "block",
      BODY: "block"
    };
    function actualDisplay(name, doc) {
      var elem = jQuery2(doc.createElement(name)).appendTo(doc.body), display = jQuery2.css(elem[0], "display");
      elem.detach();
      return display;
    }
    function defaultDisplay(nodeName) {
      var doc = document2, display = elemdisplay[nodeName];
      if (!display) {
        display = actualDisplay(nodeName, doc);
        if (display === "none" || !display) {
          iframe = (iframe || jQuery2("<iframe frameborder='0' width='0' height='0'></iframe>")).appendTo(doc.documentElement);
          doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
          doc.write();
          doc.close();
          display = actualDisplay(nodeName, doc);
          iframe.detach();
        }
        elemdisplay[nodeName] = display;
      }
      return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var swap = function(elem, options2, callback, args) {
      var ret, name, old = {};
      for (name in options2) {
        old[name] = elem.style[name];
        elem.style[name] = options2[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options2) {
        elem.style[name] = old[name];
      }
      return ret;
    };
    var documentElement = document2.documentElement;
    (function() {
      var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.cssText = "float:left;opacity:.5";
      support.opacity = div.style.opacity === "0.5";
      support.cssFloat = !!div.style.cssFloat;
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      container = document2.createElement("div");
      container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute";
      div.innerHTML = "";
      container.appendChild(div);
      support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" || div.style.WebkitBoxSizing === "";
      jQuery2.extend(support, {
        reliableHiddenOffsets: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return reliableHiddenOffsetsVal;
        },
        boxSizingReliable: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return boxSizingReliableVal;
        },
        pixelMarginRight: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return pixelMarginRightVal;
        },
        pixelPosition: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return pixelPositionVal;
        },
        reliableMarginRight: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return reliableMarginRightVal;
        },
        reliableMarginLeft: function() {
          if (pixelPositionVal == null) {
            computeStyleTests();
          }
          return reliableMarginLeftVal;
        }
      });
      function computeStyleTests() {
        var contents, divStyle, documentElement2 = document2.documentElement;
        documentElement2.appendChild(container);
        div.style.cssText = // Support: Android 2.3
        // Vendor-prefix box-sizing
        "-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%";
        pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
        pixelMarginRightVal = reliableMarginRightVal = true;
        if (window2.getComputedStyle) {
          divStyle = window2.getComputedStyle(div);
          pixelPositionVal = (divStyle || {}).top !== "1%";
          reliableMarginLeftVal = (divStyle || {}).marginLeft === "2px";
          boxSizingReliableVal = (divStyle || {
            width: "4px"
          }).width === "4px";
          div.style.marginRight = "50%";
          pixelMarginRightVal = (divStyle || {
            marginRight: "4px"
          }).marginRight === "4px";
          contents = div.appendChild(document2.createElement("div"));
          contents.style.cssText = div.style.cssText = // Support: Android 2.3
          // Vendor-prefix box-sizing
          "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          contents.style.marginRight = contents.style.width = "0";
          div.style.width = "1px";
          reliableMarginRightVal = !parseFloat((window2.getComputedStyle(contents) || {}).marginRight);
          div.removeChild(contents);
        }
        div.style.display = "none";
        reliableHiddenOffsetsVal = div.getClientRects().length === 0;
        if (reliableHiddenOffsetsVal) {
          div.style.display = "";
          div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
          div.childNodes[0].style.borderCollapse = "separate";
          contents = div.getElementsByTagName("td");
          contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
          reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
          if (reliableHiddenOffsetsVal) {
            contents[0].style.display = "";
            contents[1].style.display = "none";
            reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
          }
        }
        documentElement2.removeChild(container);
      }
    })();
    var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
    if (window2.getComputedStyle) {
      getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      curCSS = function(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : void 0;
        if ((ret === "" || ret === void 0) && !jQuery2.contains(elem.ownerDocument, elem)) {
          ret = jQuery2.style(elem, name);
        }
        if (computed) {
          if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret === void 0 ? ret : ret + "";
      };
    } else if (documentElement.currentStyle) {
      getStyles = function(elem) {
        return elem.currentStyle;
      };
      curCSS = function(elem, name, computed) {
        var left, rs, rsLeft, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed[name] : void 0;
        if (ret == null && style && style[name]) {
          ret = style[name];
        }
        if (rnumnonpx.test(ret) && !rposition.test(name)) {
          left = style.left;
          rs = elem.runtimeStyle;
          rsLeft = rs && rs.left;
          if (rsLeft) {
            rs.left = elem.currentStyle.left;
          }
          style.left = name === "fontSize" ? "1em" : ret;
          ret = style.pixelLeft + "px";
          style.left = left;
          if (rsLeft) {
            rs.left = rsLeft;
          }
        }
        return ret === void 0 ? ret : ret + "" || "auto";
      };
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/i, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    }, cssPrefixes = ["Webkit", "O", "Moz", "ms"], emptyStyle = document2.createElement("div").style;
    function vendorPropName(name) {
      if (name in emptyStyle) {
        return name;
      }
      var capName = name.charAt(0).toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
      while (i2--) {
        name = cssPrefixes[i2] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }
    function showHide(elements, show) {
      var display, elem, hidden, values = [], index = 0, length = elements.length;
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        values[index] = jQuery2._data(elem, "olddisplay");
        display = elem.style.display;
        if (show) {
          if (!values[index] && display === "none") {
            elem.style.display = "";
          }
          if (elem.style.display === "" && isHidden(elem)) {
            values[index] = jQuery2._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
          }
        } else {
          hidden = isHidden(elem);
          if (display && display !== "none" || !hidden) {
            jQuery2._data(elem, "olddisplay", hidden ? display : jQuery2.css(elem, "display"));
          }
        }
      }
      for (index = 0; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        if (!show || elem.style.display === "none" || elem.style.display === "") {
          elem.style.display = show ? values[index] || "" : "none";
        }
      }
      return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
      var matches = rnumsplit.exec(value);
      return matches ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px")
      ) : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
      var i2 = extra === (isBorderBox ? "border" : "content") ? (
        // If we already have the right measurement, avoid augmentation
        4
      ) : (
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0
      ), val = 0;
      for (; i2 < 4; i2 += 2) {
        if (extra === "margin") {
          val += jQuery2.css(elem, extra + cssExpand[i2], true, styles);
        }
        if (isBorderBox) {
          if (extra === "content") {
            val -= jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
          }
          if (extra !== "margin") {
            val -= jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
          }
        } else {
          val += jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
          if (extra !== "padding") {
            val += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
          }
        }
      }
      return val;
    }
    function getWidthOrHeight(elem, name, extra) {
      var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing && jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
      if (val <= 0 || val == null) {
        val = curCSS(elem, name, styles);
        if (val < 0 || val == null) {
          val = elem.style[name];
        }
        if (rnumnonpx.test(val)) {
          return val;
        }
        valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
        val = parseFloat(val) || 0;
      }
      return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    jQuery2.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {
        // normalize float css property
        "float": support.cssFloat ? "cssFloat" : "styleFloat"
      },
      // Get and set the style property on a DOM Node
      style: function(elem, name, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks, origName = jQuery2.camelCase(name), style = elem.style;
        name = jQuery2.cssProps[origName] || (jQuery2.cssProps[origName] = vendorPropName(origName) || origName);
        hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number") {
            value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
            try {
              style[name] = value;
            } catch (e) {
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name];
        }
      },
      css: function(elem, name, extra, styles) {
        var num, val, hooks, origName = jQuery2.camelCase(name);
        name = jQuery2.cssProps[origName] || (jQuery2.cssProps[origName] = vendorPropName(origName) || origName);
        hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name, styles);
        }
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery2.each(["height", "width"], function(i2, name) {
      jQuery2.cssHooks[name] = {
        get: function(elem, computed, extra) {
          if (computed) {
            return rdisplayswap.test(jQuery2.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, name, extra);
            }) : getWidthOrHeight(elem, name, extra);
          }
        },
        set: function(elem, value, extra) {
          var styles = extra && getStyles(elem);
          return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
        }
      };
    });
    if (!support.opacity) {
      jQuery2.cssHooks.opacity = {
        get: function(elem, computed) {
          return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? 0.01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
        },
        set: function(elem, value) {
          var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery2.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "", filter = currentStyle && currentStyle.filter || style.filter || "";
          style.zoom = 1;
          if ((value >= 1 || value === "") && jQuery2.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {
            style.removeAttribute("filter");
            if (value === "" || currentStyle && !currentStyle.filter) {
              return;
            }
          }
          style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
        }
      };
    }
    jQuery2.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
      if (computed) {
        return swap(elem, {
          "display": "inline-block"
        }, curCSS, [elem, "marginRight"]);
      }
    });
    jQuery2.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || // Support: IE<=11+
        // Running getBoundingClientRect on a disconnected node in IE throws an error
        // Support: IE8 only
        // getClientRects() errors on disconnected elems
        (jQuery2.contains(elem.ownerDocument, elem) ? elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function() {
          return elem.getBoundingClientRect().left;
        }) : 0)) + "px";
      }
    });
    jQuery2.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery2.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i2 < 4; i2++) {
            expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (!rmargin.test(prefix)) {
        jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery2.fn.extend({
      css: function(name, value) {
        return access(this, function(elem, name2, value2) {
          var styles, len, map = {}, i2 = 0;
          if (jQuery2.isArray(name2)) {
            styles = getStyles(elem);
            len = name2.length;
            for (; i2 < len; i2++) {
              map[name2[i2]] = jQuery2.css(elem, name2[i2], false, styles);
            }
            return map;
          }
          return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
        }, name, value, arguments.length > 1);
      },
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHidden(this)) {
            jQuery2(this).show();
          } else {
            jQuery2(this).hide();
          }
        });
      }
    });
    function Tween(elem, options2, prop, end, easing) {
      return new Tween.prototype.init(elem, options2, prop, end, easing);
    }
    jQuery2.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options2, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery2.easing._default;
        this.options = options2;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery2.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery2.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery2.fx.step[tween.prop]) {
            jQuery2.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery2.cssProps[tween.prop]] != null || jQuery2.cssHooks[tween.prop])) {
            jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery2.easing = {
      linear: function(p) {
        return p;
      },
      swing: function(p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery2.fx = Tween.prototype.init;
    jQuery2.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = jQuery2.now();
    }
    function genFx(type, includeWidth) {
      var which, attrs = {
        height: type
      }, i2 = 0;
      includeWidth = includeWidth ? 1 : 0;
      for (; i2 < 4; i2 += 2 - includeWidth) {
        which = cssExpand[i2];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props6, opts) {
      var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery2._data(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery2._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery2.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      if (elem.nodeType === 1 && ("height" in props6 || "width" in props6)) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        display = jQuery2.css(elem, "display");
        checkDisplay = display === "none" ? jQuery2._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
        if (checkDisplay === "inline" && jQuery2.css(elem, "float") === "none") {
          if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === "inline") {
            style.display = "inline-block";
          } else {
            style.zoom = 1;
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        if (!support.shrinkWrapBlocks()) {
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
      }
      for (prop in props6) {
        value = props6[prop];
        if (rfxtypes.exec(value)) {
          delete props6[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
        } else {
          display = void 0;
        }
      }
      if (!jQuery2.isEmptyObject(orig)) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = jQuery2._data(elem, "fxshow", {});
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          jQuery2(elem).show();
        } else {
          anim.done(function() {
            jQuery2(elem).hide();
          });
        }
        anim.done(function() {
          var prop2;
          jQuery2._removeData(elem, "fxshow");
          for (prop2 in orig) {
            jQuery2.style(elem, prop2, orig[prop2]);
          }
        });
        for (prop in orig) {
          tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = tween.start;
            if (hidden) {
              tween.end = tween.start;
              tween.start = prop === "width" || prop === "height" ? 1 : 0;
            }
          }
        }
      } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
        style.display = display;
      }
    }
    function propFilter(props6, specialEasing) {
      var index, name, easing, value, hooks;
      for (index in props6) {
        name = jQuery2.camelCase(index);
        easing = specialEasing[name];
        value = props6[index];
        if (jQuery2.isArray(value)) {
          easing = value[1];
          value = props6[index] = value[0];
        }
        if (index !== name) {
          props6[name] = value;
          delete props6[index];
        }
        hooks = jQuery2.cssHooks[name];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props6[name];
          for (index in value) {
            if (!(index in props6)) {
              props6[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }
    function Animation(elem, properties, options2) {
      var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
        for (; index2 < length2; index2++) {
          animation.tweens[index2].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem,
        props: jQuery2.extend({}, properties),
        opts: jQuery2.extend(true, {
          specialEasing: {},
          easing: jQuery2.easing._default
        }, options2),
        originalProperties: properties,
        originalOptions: options2,
        startTime: fxNow || createFxNow(),
        duration: options2.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery2.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props6 = animation.props;
      propFilter(props6, animation.opts.specialEasing);
      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props6, animation.opts);
        if (result) {
          if (jQuery2.isFunction(result.stop)) {
            jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = jQuery2.proxy(result.stop, result);
          }
          return result;
        }
      }
      jQuery2.map(props6, createTween, animation);
      if (jQuery2.isFunction(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      jQuery2.fx.timer(jQuery2.extend(tick, {
        elem,
        anim: animation,
        queue: animation.opts.queue
      }));
      return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery2.Animation = jQuery2.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props6, callback) {
        if (jQuery2.isFunction(props6)) {
          callback = props6;
          props6 = ["*"];
        } else {
          props6 = props6.match(rnotwhite);
        }
        var prop, index = 0, length = props6.length;
        for (; index < length; index++) {
          prop = props6[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery2.speed = function(speed, easing, fn11) {
      var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
        complete: fn11 || !fn11 && easing || jQuery2.isFunction(speed) && speed,
        duration: speed,
        easing: fn11 && easing || easing && !jQuery2.isFunction(easing) && easing
      };
      opt.duration = jQuery2.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery2.fx.speeds ? jQuery2.fx.speeds[opt.duration] : jQuery2.fx.speeds._default;
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (jQuery2.isFunction(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery2.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery2.fn.extend({
      fadeTo: function(speed, to2, easing, callback) {
        return this.filter(isHidden).css("opacity", 0).show().end().animate({
          opacity: to2
        }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery2.extend({}, prop), optall);
          if (empty || jQuery2._data(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue && type !== false) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = jQuery2._data(this);
          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery2.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data = jQuery2._data(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
          data.finish = true;
          jQuery2.queue(this, type, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery2.each(["toggle", "show", "hide"], function(i2, name) {
      var cssFn = jQuery2.fn[name];
      jQuery2.fn[name] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    });
    jQuery2.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(name, props6) {
      jQuery2.fn[name] = function(speed, easing, callback) {
        return this.animate(props6, speed, easing, callback);
      };
    });
    jQuery2.timers = [];
    jQuery2.fx.tick = function() {
      var timer, timers = jQuery2.timers, i2 = 0;
      fxNow = jQuery2.now();
      for (; i2 < timers.length; i2++) {
        timer = timers[i2];
        if (!timer() && timers[i2] === timer) {
          timers.splice(i2--, 1);
        }
      }
      if (!timers.length) {
        jQuery2.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery2.fx.timer = function(timer) {
      jQuery2.timers.push(timer);
      if (timer()) {
        jQuery2.fx.start();
      } else {
        jQuery2.timers.pop();
      }
    };
    jQuery2.fx.interval = 13;
    jQuery2.fx.start = function() {
      if (!timerId) {
        timerId = window2.setInterval(jQuery2.fx.tick, jQuery2.fx.interval);
      }
    };
    jQuery2.fx.stop = function() {
      window2.clearInterval(timerId);
      timerId = null;
    };
    jQuery2.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    };
    jQuery2.fn.delay = function(time, type) {
      time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks) {
        var timeout = window2.setTimeout(next, time);
        hooks.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var a2, input = document2.createElement("input"), div = document2.createElement("div"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      div = document2.createElement("div");
      div.setAttribute("className", "t");
      div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
      a2 = div.getElementsByTagName("a")[0];
      input.setAttribute("type", "checkbox");
      div.appendChild(input);
      a2 = div.getElementsByTagName("a")[0];
      a2.style.cssText = "top:1px";
      support.getSetAttribute = div.className !== "t";
      support.style = /top/.test(a2.getAttribute("style"));
      support.hrefNormalized = a2.getAttribute("href") === "/a";
      support.checkOn = !!input.value;
      support.optSelected = opt.selected;
      support.enctype = !!document2.createElement("form").enctype;
      select.disabled = true;
      support.optDisabled = !opt.disabled;
      input = document2.createElement("input");
      input.setAttribute("value", "");
      support.input = input.getAttribute("value") === "";
      input.value = "t";
      input.setAttribute("type", "radio");
      support.radioValue = input.value === "t";
    })();
    var rreturn = /\r/g, rspaces = /[\x20\t\r\n\f]+/g;
    jQuery2.fn.extend({
      val: function(value) {
        var hooks, ret, isFunction4, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            return typeof ret === "string" ? (
              // handle most common string cases
              ret.replace(rreturn, "")
            ) : (
              // handle cases where value is null/undef or number
              ret == null ? "" : ret
            );
          }
          return;
        }
        isFunction4 = jQuery2.isFunction(value);
        return this.each(function(i2) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (isFunction4) {
            val = value.call(this, i2, jQuery2(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (jQuery2.isArray(val)) {
            val = jQuery2.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery2.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery2.find.attr(elem, "value");
            return val != null ? val : (
              // Support: IE10-11+
              // option.text throws exceptions (#14686, #14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              jQuery2.trim(jQuery2.text(elem)).replace(rspaces, " ")
            );
          }
        },
        select: {
          get: function(elem) {
            var value, option2, options2 = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options2.length, i2 = index < 0 ? max : one ? index : 0;
            for (; i2 < max; i2++) {
              option2 = options2[i2];
              if ((option2.selected || i2 === index) && // Don't return options that are disabled or in a disabled optgroup
              (support.optDisabled ? !option2.disabled : option2.getAttribute("disabled") === null) && (!option2.parentNode.disabled || !jQuery2.nodeName(option2.parentNode, "optgroup"))) {
                value = jQuery2(option2).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option2, options2 = elem.options, values = jQuery2.makeArray(value), i2 = options2.length;
            while (i2--) {
              option2 = options2[i2];
              if (jQuery2.inArray(jQuery2.valHooks.option.get(option2), values) > -1) {
                try {
                  option2.selected = optionSet = true;
                } catch (_2) {
                  option2.scrollHeight;
                }
              } else {
                option2.selected = false;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return options2;
          }
        }
      }
    });
    jQuery2.each(["radio", "checkbox"], function() {
      jQuery2.valHooks[this] = {
        set: function(elem, value) {
          if (jQuery2.isArray(value)) {
            return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery2.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    var nodeHook, boolHook, attrHandle = jQuery2.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery2.fn.extend({
      attr: function(name, value) {
        return access(this, jQuery2.attr, name, value, arguments.length > 1);
      },
      removeAttr: function(name) {
        return this.each(function() {
          jQuery2.removeAttr(this, name);
        });
      }
    });
    jQuery2.extend({
      attr: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery2.prop(elem, name, value);
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          name = name.toLowerCase();
          hooks = jQuery2.attrHooks[name] || (jQuery2.expr.match.bool.test(name) ? boolHook : nodeHook);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery2.removeAttr(elem, name);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          if (name === "style") {
            elem.removeAttribute(name);
            var styles = value.split(";");
            jQuery2.each(styles, function(i2, style) {
              if (style) {
                var styleKeyVal = style.split(":"), styleKey = jQuery2.camelCase(jQuery2.trim(styleKeyVal.shift())), styleVal = jQuery2.trim(styleKeyVal);
                var styleName = jQuery2.cssProps[styleKey] || (jQuery2.cssProps[styleKey] = vendorPropName(styleKey) || styleKey);
                try {
                  elem.style[styleName] = styleVal;
                } catch (e) {
                }
              }
            });
            return;
          }
          elem.setAttribute(name, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        ret = jQuery2.find.attr(elem, name);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && jQuery2.nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name, propName, i2 = 0, attrNames = value && value.match(rnotwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i2++]) {
            propName = jQuery2.propFix[name] || name;
            if (jQuery2.expr.match.bool.test(name)) {
              if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                elem[propName] = false;
              } else {
                elem[jQuery2.camelCase("default-" + name)] = elem[propName] = false;
              }
            } else {
              jQuery2.attr(elem, name, "");
            }
            elem.removeAttribute(getSetAttribute ? name : propName);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name) {
        if (value === false) {
          jQuery2.removeAttr(elem, name);
        } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
          elem.setAttribute(!getSetAttribute && jQuery2.propFix[name] || name, name);
        } else {
          elem[jQuery2.camelCase("default-" + name)] = elem[name] = true;
        }
        return name;
      }
    };
    jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(i2, name) {
      var getter = attrHandle[name] || jQuery2.find.attr;
      if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle;
          if (!isXML) {
            handle = attrHandle[name2];
            attrHandle[name2] = ret;
            ret = getter(elem, name2, isXML) != null ? name2.toLowerCase() : null;
            attrHandle[name2] = handle;
          }
          return ret;
        };
      } else {
        attrHandle[name] = function(elem, name2, isXML) {
          if (!isXML) {
            return elem[jQuery2.camelCase("default-" + name2)] ? name2.toLowerCase() : null;
          }
        };
      }
    });
    if (!getSetInput || !getSetAttribute) {
      jQuery2.attrHooks.value = {
        set: function(elem, value, name) {
          if (jQuery2.nodeName(elem, "input")) {
            elem.defaultValue = value;
          } else {
            return nodeHook && nodeHook.set(elem, value, name);
          }
        }
      };
    }
    if (!getSetAttribute) {
      nodeHook = {
        set: function(elem, value, name) {
          var ret = elem.getAttributeNode(name);
          if (!ret) {
            elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
          }
          ret.value = value += "";
          if (name === "value" || value === elem.getAttribute(name)) {
            return value;
          }
        }
      };
      attrHandle.id = attrHandle.name = attrHandle.coords = function(elem, name, isXML) {
        var ret;
        if (!isXML) {
          return (ret = elem.getAttributeNode(name)) && ret.value !== "" ? ret.value : null;
        }
      };
      jQuery2.valHooks.button = {
        get: function(elem, name) {
          var ret = elem.getAttributeNode(name);
          if (ret && ret.specified) {
            return ret.value;
          }
        },
        set: nodeHook.set
      };
      jQuery2.attrHooks.contenteditable = {
        set: function(elem, value, name) {
          nodeHook.set(elem, value === "" ? false : value, name);
        }
      };
      jQuery2.each(["width", "height"], function(i2, name) {
        jQuery2.attrHooks[name] = {
          set: function(elem, value) {
            if (value === "") {
              elem.setAttribute(name, "auto");
              return value;
            }
          }
        };
      });
    }
    if (!support.style) {
      jQuery2.attrHooks.style = {
        get: function(elem) {
          return elem.style.cssText || void 0;
        },
        set: function(elem, value) {
          return elem.style.cssText = value + "";
        }
      };
    }
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery2.fn.extend({
      prop: function(name, value) {
        return access(this, jQuery2.prop, name, value, arguments.length > 1);
      },
      removeProp: function(name) {
        name = jQuery2.propFix[name] || name;
        return this.each(function() {
          try {
            this[name] = void 0;
            delete this[name];
          } catch (e) {
          }
        });
      }
    });
    jQuery2.extend({
      prop: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          name = jQuery2.propFix[name] || name;
          hooks = jQuery2.propHooks[name];
        }
        if (value !== void 0) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          return elem[name] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery2.find.attr(elem, "tabindex");
            return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.hrefNormalized) {
      jQuery2.each(["href", "src"], function(i2, name) {
        jQuery2.propHooks[name] = {
          get: function(elem) {
            return elem.getAttribute(name, 4);
          }
        };
      });
    }
    if (!support.optSelected) {
      jQuery2.propHooks.selected = {
        get: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
          return null;
        },
        set: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery2.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
      jQuery2.propFix[this.toLowerCase()] = this;
    });
    if (!support.enctype) {
      jQuery2.propFix.enctype = "encoding";
    }
    var rclass = /[\t\r\n\f]/g;
    function getClass(elem) {
      return jQuery2.attr(elem, "class") || "";
    }
    jQuery2.fn.extend({
      addClass: function(value) {
        var classes, elem, cur, curValue, clazz, j, finalValue, i2 = 0;
        if (jQuery2.isFunction(value)) {
          return this.each(function(j2) {
            jQuery2(this).addClass(value.call(this, j2, getClass(this)));
          });
        }
        if (typeof value === "string" && value) {
          classes = value.match(rnotwhite) || [];
          while (elem = this[i2++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
            if (cur) {
              j = 0;
              while (clazz = classes[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              }
              finalValue = jQuery2.trim(cur);
              if (curValue !== finalValue) {
                jQuery2.attr(elem, "class", finalValue);
              }
            }
          }
        }
        return this;
      },
      removeClass: function(value) {
        var classes, elem, cur, curValue, clazz, j, finalValue, i2 = 0;
        if (jQuery2.isFunction(value)) {
          return this.each(function(j2) {
            jQuery2(this).removeClass(value.call(this, j2, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        if (typeof value === "string" && value) {
          classes = value.match(rnotwhite) || [];
          while (elem = this[i2++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
            if (cur) {
              j = 0;
              while (clazz = classes[j++]) {
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              }
              finalValue = jQuery2.trim(cur);
              if (curValue !== finalValue) {
                jQuery2.attr(elem, "class", finalValue);
              }
            }
          }
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var type = typeof value;
        if (typeof stateVal === "boolean" && type === "string") {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (jQuery2.isFunction(value)) {
          return this.each(function(i2) {
            jQuery2(this).toggleClass(value.call(this, i2, getClass(this), stateVal), stateVal);
          });
        }
        return this.each(function() {
          var className2, i2, self2, classNames;
          if (type === "string") {
            i2 = 0;
            self2 = jQuery2(this);
            classNames = value.match(rnotwhite) || [];
            while (className2 = classNames[i2++]) {
              if (self2.hasClass(className2)) {
                self2.removeClass(className2);
              } else {
                self2.addClass(className2);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className2 = getClass(this);
            if (className2) {
              jQuery2._data(this, "__className__", className2);
            }
            jQuery2.attr(this, "class", className2 || value === false ? "" : jQuery2._data(this, "__className__") || "");
          }
        });
      },
      hasClass: function(selector) {
        var className2, elem, i2 = 0;
        className2 = " " + selector + " ";
        while (elem = this[i2++]) {
          if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className2) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    jQuery2.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i2, name) {
      jQuery2.fn[name] = function(data, fn11) {
        return arguments.length > 0 ? this.on(name, null, data, fn11) : this.trigger(name);
      };
    });
    jQuery2.fn.extend({
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    var location2 = window2.location;
    var nonce = jQuery2.now();
    var rquery = /\?/;
    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery2.parseJSON = function(data) {
      if (window2.JSON && window2.JSON.parse) {
        return window2.JSON.parse(data + "");
      }
      var requireNonComma, depth = null, str = jQuery2.trim(data + "");
      return str && !jQuery2.trim(str.replace(rvalidtokens, function(token, comma, open, close) {
        if (requireNonComma && comma) {
          depth = 0;
        }
        if (depth === 0) {
          return token;
        }
        requireNonComma = open || comma;
        depth += !close - !open;
        return "";
      })) ? Function("return " + str)() : jQuery2.error("Invalid JSON: " + data);
    };
    jQuery2.parseXML = function(data) {
      var xml, tmp;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        if (window2.DOMParser) {
          tmp = new window2.DOMParser();
          xml = tmp.parseFromString(data, "text/xml");
        } else {
          xml = new window2.ActiveXObject("Microsoft.XMLDOM");
          xml.async = "false";
          xml.loadXML(data);
        }
      } catch (e) {
        xml = void 0;
      }
      if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
        jQuery2.error("Invalid XML: " + data);
      }
      return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = location2.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
        if (jQuery2.isFunction(func)) {
          while (dataType = dataTypes[i2++]) {
            if (dataType.charAt(0) === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options2, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options2, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options2.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options2.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var deep, key, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery2.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s["throws"]) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return {
        state: "success",
        data: response
      };
    }
    jQuery2.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: ajaxLocation,
        type: "GET",
        isLocal: rlocalProtocol.test(ajaxLocParts[1]),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": jQuery2.parseJSON,
          // Parse text as xml
          "text xml": jQuery2.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(target, settings) {
        return settings ? (
          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
        ) : (
          // Extending ajaxSettings
          ajaxExtend(jQuery2.ajaxSettings, target)
        );
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function(url, options2) {
        if (typeof url === "object") {
          options2 = url;
          url = void 0;
        }
        options2 = options2 || {};
        var parts, i2, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery2.ajaxSetup({}, options2), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          // Raw string
          getAllResponseHeaders: function() {
            return state === 2 ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function(name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function(map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR).complete = completeDeferred.add;
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;
        s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
        s.type = options2.method || options2.type || s.method || s.type;
        s.dataTypes = jQuery2.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
        if (s.crossDomain == null) {
          parts = rurl.exec(s.url.toLowerCase());
          s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery2.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options2, jqXHR);
        if (state === 2) {
          return jqXHR;
        }
        fireGlobals = jQuery2.event && s.global;
        if (fireGlobals && jQuery2.active++ === 0) {
          jQuery2.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url;
        if (!s.hasContent) {
          if (s.data) {
            cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            s.url = rts.test(cacheURL) ? (
              // If there is already a '_' parameter, set its value
              cacheURL.replace(rts, "$1_=" + nonce++)
            ) : (
              // Otherwise add one to the end
              cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++
            );
          }
        }
        if (s.ifModified) {
          if (jQuery2.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
          }
          if (jQuery2.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options2.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
        for (i2 in s.headers) {
          jqXHR.setRequestHeader(i2, s.headers[i2]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        for (i2 in {
          success: 1,
          error: 1,
          complete: 1
        }) {
          jqXHR[i2](s[i2]);
        }
        transport = inspectPrefiltersOrTransports(transports, s, options2, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (state === 2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            state = 1;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (state < 2) {
              done(-1, e);
            } else {
              throw e;
            }
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified, statusText = nativeStatusText;
          if (state === 2) {
            return;
          }
          state = 2;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery2.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery2.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery2.active) {
              jQuery2.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data, callback) {
        return jQuery2.get(url, data, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery2.get(url, void 0, callback, "script");
      }
    });
    jQuery2.each(["get", "post"], function(i2, method) {
      jQuery2[method] = function(url, data, callback, type) {
        if (jQuery2.isFunction(data)) {
          type = type || callback;
          callback = data;
          data = void 0;
        }
        return jQuery2.ajax(jQuery2.extend({
          url,
          type: method,
          dataType: type,
          data,
          success: callback
        }, jQuery2.isPlainObject(url) && url));
      };
    });
    jQuery2._evalUrl = function(url) {
      return jQuery2.ajax({
        url,
        // Make this explicit, since user can override this through ajaxSetup (#11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        "throws": true
      });
    };
    jQuery2.fn.extend({
      wrapAll: function(html) {
        if (jQuery2.isFunction(html)) {
          return this.each(function(i2) {
            jQuery2(this).wrapAll(html.call(this, i2));
          });
        }
        if (this[0]) {
          var wrap2 = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap2.insertBefore(this[0]);
          }
          wrap2.map(function() {
            var elem = this;
            while (elem.firstChild && elem.firstChild.nodeType === 1) {
              elem = elem.firstChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (jQuery2.isFunction(html)) {
          return this.each(function(i2) {
            jQuery2(this).wrapInner(html.call(this, i2));
          });
        }
        return this.each(function() {
          var self2 = jQuery2(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var isFunction4 = jQuery2.isFunction(html);
        return this.each(function(i2) {
          jQuery2(this).wrapAll(isFunction4 ? html.call(this, i2) : html);
        });
      },
      unwrap: function() {
        return this.parent().each(function() {
          if (!jQuery2.nodeName(this, "body")) {
            jQuery2(this).replaceWith(this.childNodes);
          }
        }).end();
      }
    });
    function getDisplay(elem) {
      return elem.style && elem.style.display || jQuery2.css(elem, "display");
    }
    function filterHidden(elem) {
      if (!jQuery2.contains(elem.ownerDocument || document2, elem)) {
        return true;
      }
      while (elem && elem.nodeType === 1) {
        if (getDisplay(elem) === "none" || elem.type === "hidden") {
          return true;
        }
        elem = elem.parentNode;
      }
      return false;
    }
    jQuery2.expr.filters.hidden = function(elem) {
      return support.reliableHiddenOffsets() ? elem.offsetWidth <= 0 && elem.offsetHeight <= 0 && !elem.getClientRects().length : filterHidden(elem);
    };
    jQuery2.expr.filters.visible = function(elem) {
      return !jQuery2.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
      var name;
      if (jQuery2.isArray(obj)) {
        jQuery2.each(obj, function(i2, v) {
          if (traditional || rbracket.test(prefix)) {
            add(prefix, v);
          } else {
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i2 : "") + "]", v, traditional, add);
          }
        });
      } else if (!traditional && jQuery2.type(obj) === "object") {
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        add(prefix, obj);
      }
    }
    jQuery2.param = function(a2, traditional) {
      var prefix, s = [], add = function(key, value) {
        value = jQuery2.isFunction(value) ? value() : value == null ? "" : value;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };
      if (traditional === void 0) {
        traditional = jQuery2.ajaxSettings && jQuery2.ajaxSettings.traditional;
      }
      if (jQuery2.isArray(a2) || a2.jquery && !jQuery2.isPlainObject(a2)) {
        jQuery2.each(a2, function() {
          add(this.name, this.value);
        });
      } else {
        for (prefix in a2) {
          buildParams(prefix, a2[prefix], traditional, add);
        }
      }
      return s.join("&").replace(r20, "+");
    };
    jQuery2.fn.extend({
      serialize: function() {
        return jQuery2.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery2.prop(this, "elements");
          return elements ? jQuery2.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(i2, elem) {
          var val = jQuery2(this).val();
          return val == null ? null : jQuery2.isArray(val) ? jQuery2.map(val, function(val2) {
            return {
              name: elem.name,
              value: val2.replace(rCRLF, "\r\n")
            };
          }) : {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }).get();
      }
    });
    jQuery2.ajaxSettings.xhr = window2.ActiveXObject !== void 0 ? (
      // Support: IE6-IE8
      function() {
        if (this.isLocal) {
          return createActiveXHR();
        }
        if (document2.documentMode > 8) {
          return createStandardXHR();
        }
        return /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
      }
    ) : (
      // For all other browsers, use the standard XMLHttpRequest object
      createStandardXHR
    );
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery2.ajaxSettings.xhr();
    if (window2.attachEvent) {
      window2.attachEvent("onunload", function() {
        for (var key in xhrCallbacks) {
          xhrCallbacks[key](void 0, true);
        }
      });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;
    if (xhrSupported) {
      jQuery2.ajaxTransport(function(options2) {
        if (!options2.crossDomain || support.cors) {
          var callback;
          return {
            send: function(headers, complete) {
              var i2, xhr = options2.xhr(), id = ++xhrId;
              xhr.open(options2.type, options2.url, options2.async, options2.username, options2.password);
              if (options2.xhrFields) {
                for (i2 in options2.xhrFields) {
                  xhr[i2] = options2.xhrFields[i2];
                }
              }
              if (options2.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options2.mimeType);
              }
              if (!options2.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i2 in headers) {
                if (headers[i2] !== void 0) {
                  xhr.setRequestHeader(i2, headers[i2] + "");
                }
              }
              xhr.send(options2.hasContent && options2.data || null);
              callback = function(_2, isAbort) {
                var status, statusText, responses;
                if (callback && (isAbort || xhr.readyState === 4)) {
                  delete xhrCallbacks[id];
                  callback = void 0;
                  xhr.onreadystatechange = jQuery2.noop;
                  if (isAbort) {
                    if (xhr.readyState !== 4) {
                      xhr.abort();
                    }
                  } else {
                    responses = {};
                    status = xhr.status;
                    if (typeof xhr.responseText === "string") {
                      responses.text = xhr.responseText;
                    }
                    try {
                      statusText = xhr.statusText;
                    } catch (e) {
                      statusText = "";
                    }
                    if (!status && options2.isLocal && !options2.crossDomain) {
                      status = responses.text ? 200 : 404;
                    } else if (status === 1223) {
                      status = 204;
                    }
                  }
                }
                if (responses) {
                  complete(status, statusText, responses, xhr.getAllResponseHeaders());
                }
              };
              if (!options2.async) {
                callback();
              } else if (xhr.readyState === 4) {
                window2.setTimeout(callback);
              } else {
                xhr.onreadystatechange = xhrCallbacks[id] = callback;
              }
            },
            abort: function() {
              if (callback) {
                callback(void 0, true);
              }
            }
          };
        }
      });
    }
    function createStandardXHR() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    }
    function createActiveXHR() {
      try {
        return new window2.ActiveXObject("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
    jQuery2.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery2.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery2.globalEval(text);
          return text;
        }
      }
    });
    jQuery2.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
        s.global = false;
      }
    });
    jQuery2.ajaxTransport("script", function(s) {
      if (s.crossDomain) {
        var script, head = document2.head || jQuery2("head")[0] || document2.documentElement;
        return {
          send: function(_2, callback) {
            script = document2.createElement("script");
            script.async = true;
            if (s.scriptCharset) {
              script.charset = s.scriptCharset;
            }
            script.src = s.url;
            script.onload = script.onreadystatechange = function(_3, isAbort) {
              if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                script.onload = script.onreadystatechange = null;
                if (script.parentNode) {
                  script.parentNode.removeChild(script);
                }
                script = null;
                if (!isAbort) {
                  callback(200, "success");
                }
              }
            };
            head.insertBefore(script, head.firstChild);
          },
          abort: function() {
            if (script) {
              script.onload(void 0, true);
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery2.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery2.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = jQuery2.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery2.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery2(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && jQuery2.isFunction(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    jQuery2.parseHTML = function(data, context, keepScripts) {
      if (!data || typeof data !== "string") {
        return null;
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      context = context || document2;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data], context, scripts);
      if (scripts && scripts.length) {
        jQuery2(scripts).remove();
      }
      return jQuery2.merge([], parsed.childNodes);
    };
    var _load = jQuery2.fn.load;
    jQuery2.fn.load = function(url, params, callback) {
      if (typeof url !== "string" && _load) {
        return _load.apply(this, arguments);
      }
      var selector, type, response, self2 = this, off = url.indexOf(" ");
      if (off > -1) {
        selector = jQuery2.trim(url.slice(off, url.length));
        url = url.slice(0, off);
      }
      if (jQuery2.isFunction(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery2.ajax({
          url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? (
            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
          ) : (
            // Otherwise use the full result
            responseText
          ));
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery2.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i2, type) {
      jQuery2.fn[type] = function(fn11) {
        return this.on(type, fn11);
      };
    });
    jQuery2.expr.filters.animated = function(elem) {
      return jQuery2.grep(jQuery2.timers, function(fn11) {
        return elem === fn11.elem;
      }).length;
    };
    function getWindow(elem) {
      return jQuery2.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery2.offset = {
      setOffset: function(elem, options2, i2) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props6 = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery2.css(elem, "top");
        curCSSLeft = jQuery2.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && jQuery2.inArray("auto", [curCSSTop, curCSSLeft]) > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (jQuery2.isFunction(options2)) {
          options2 = options2.call(elem, i2, jQuery2.extend({}, curOffset));
        }
        if (options2.top != null) {
          props6.top = options2.top - curOffset.top + curTop;
        }
        if (options2.left != null) {
          props6.left = options2.left - curOffset.left + curLeft;
        }
        if ("using" in options2) {
          options2.using.call(elem, props6);
        } else {
          curElem.css(props6);
        }
      }
    };
    jQuery2.fn.extend({
      offset: function(options2) {
        if (arguments.length) {
          return options2 === void 0 ? this : this.each(function(i2) {
            jQuery2.offset.setOffset(this, options2, i2);
          });
        }
        var docElem, win, box = {
          top: 0,
          left: 0
        }, elem = this[0], doc = elem && elem.ownerDocument;
        if (!doc) {
          return;
        }
        docElem = doc.documentElement;
        if (!jQuery2.contains(docElem, elem)) {
          return box;
        }
        if (typeof elem.getBoundingClientRect !== "undefined") {
          box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        return {
          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
        };
      },
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset, parentOffset = {
          top: 0,
          left: 0
        }, elem = this[0];
        if (jQuery2.css(elem, "position") === "fixed") {
          offset = elem.getBoundingClientRect();
        } else {
          offsetParent = this.offsetParent();
          offset = this.offset();
          if (!jQuery2.nodeName(offsetParent[0], "html")) {
            parentOffset = offsetParent.offset();
          }
          parentOffset.top += jQuery2.css(offsetParent[0], "borderTopWidth", true);
          parentOffset.left += jQuery2.css(offsetParent[0], "borderLeftWidth", true);
        }
        return {
          top: offset.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
        };
      },
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && !jQuery2.nodeName(offsetParent, "html") && jQuery2.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery2.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
    }, function(method, prop) {
      var top = /Y/.test(prop);
      jQuery2.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win = getWindow(elem);
          if (val2 === void 0) {
            return win ? prop in win ? win[prop] : win.document.documentElement[method2] : elem[method2];
          }
          if (win) {
            win.scrollTo(!top ? val2 : jQuery2(win).scrollLeft(), top ? val2 : jQuery2(win).scrollTop());
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length, null);
      };
    });
    jQuery2.each(["top", "left"], function(i2, prop) {
      jQuery2.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
        }
      });
    });
    jQuery2.each({
      Height: "height",
      Width: "width"
    }, function(name, type) {
      jQuery2.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function(defaultExtra, funcName) {
        jQuery2.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc;
            if (jQuery2.isWindow(elem)) {
              return elem.document.documentElement["client" + name];
            }
            if (elem.nodeType === 9) {
              doc = elem.documentElement;
              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
            }
            return value2 === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery2.css(elem, type2, extra)
            ) : (
              // Set width or height on the element
              jQuery2.style(elem, type2, value2, extra)
            );
          }, type, chainable ? margin : void 0, chainable, null);
        };
      });
    });
    jQuery2.fn.extend({
      bind: function(types, data, fn11) {
        return this.on(types, null, data, fn11);
      },
      unbind: function(types, fn11) {
        return this.off(types, null, fn11);
      },
      delegate: function(selector, types, data, fn11) {
        return this.on(types, selector, data, fn11);
      },
      undelegate: function(selector, types, fn11) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn11);
      }
    });
    jQuery2.fn.size = function() {
      return this.length;
    };
    jQuery2.fn.andSelf = jQuery2.fn.addBack;
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery2.noConflict = function(deep) {
      if (window2.$ === jQuery2) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery2) {
        window2.jQuery = _jQuery;
      }
      return jQuery2;
    };
    if (!noGlobal || window2.__OKTA_EXPORT_JQUERY__) {
      window2.jQuery = window2.$ = jQuery2;
    }
    return jQuery2;
  });
})(jquery1_12_4);
var jQuery = jquery1_12_4.exports;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/lib/backbone.js
(function(module, exports) {
  const jQuery2 = jquery1_12_4.exports;
  (function(factory) {
    var root = typeof self == "object" && self.self === self && self || typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal && commonjsGlobal;
    {
      var _2 = underscoreMin.exports, $;
      try {
        $ = jQuery2;
      } catch (e) {
      }
      factory(root, exports, _2, $);
    }
  })(function(root, Backbone2, _2, $) {
    var previousBackbone = root.Backbone;
    var slice = Array.prototype.slice;
    Backbone2.VERSION = "1.4.0";
    Backbone2.$ = $;
    Backbone2.noConflict = function() {
      root.Backbone = previousBackbone;
      return this;
    };
    Backbone2.emulateHTTP = false;
    Backbone2.emulateJSON = false;
    var Events = Backbone2.Events = {};
    var eventSplitter = /\s+/;
    var _listening;
    var eventsApi = function(iteratee, events4, name, callback, opts) {
      var i = 0, names;
      if (name && typeof name === "object") {
        if (callback !== void 0 && "context" in opts && opts.context === void 0)
          opts.context = callback;
        for (names = _2.keys(name); i < names.length; i++) {
          events4 = eventsApi(iteratee, events4, names[i], name[names[i]], opts);
        }
      } else if (name && eventSplitter.test(name)) {
        for (names = name.split(eventSplitter); i < names.length; i++) {
          events4 = iteratee(events4, names[i], callback, opts);
        }
      } else {
        events4 = iteratee(events4, name, callback, opts);
      }
      return events4;
    };
    Events.on = function(name, callback, context) {
      this._events = eventsApi(onApi, this._events || {}, name, callback, {
        context,
        ctx: this,
        listening: _listening
      });
      if (_listening) {
        var listeners = this._listeners || (this._listeners = {});
        listeners[_listening.id] = _listening;
        _listening.interop = false;
      }
      return this;
    };
    Events.listenTo = function(obj, name, callback) {
      if (!obj)
        return this;
      var id = obj._listenId || (obj._listenId = _2.uniqueId("l"));
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var listening = _listening = listeningTo[id];
      if (!listening) {
        this._listenId || (this._listenId = _2.uniqueId("l"));
        listening = _listening = listeningTo[id] = new Listening(this, obj);
      }
      var error = tryCatchOn(obj, name, callback, this);
      _listening = void 0;
      if (error)
        throw error;
      if (listening.interop)
        listening.on(name, callback);
      return this;
    };
    var onApi = function(events4, name, callback, options2) {
      if (callback) {
        var handlers = events4[name] || (events4[name] = []);
        var context = options2.context, ctx = options2.ctx, listening = options2.listening;
        if (listening)
          listening.count++;
        handlers.push({
          callback,
          context,
          ctx: context || ctx,
          listening
        });
      }
      return events4;
    };
    var tryCatchOn = function(obj, name, callback, context) {
      try {
        obj.on(name, callback, context);
      } catch (e) {
        return e;
      }
    };
    Events.off = function(name, callback, context) {
      if (!this._events)
        return this;
      this._events = eventsApi(offApi, this._events, name, callback, {
        context,
        listeners: this._listeners
      });
      return this;
    };
    Events.stopListening = function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo)
        return this;
      var ids = obj ? [obj._listenId] : _2.keys(listeningTo);
      for (var i = 0; i < ids.length; i++) {
        var listening = listeningTo[ids[i]];
        if (!listening)
          break;
        listening.obj.off(name, callback, this);
        if (listening.interop)
          listening.off(name, callback);
      }
      if (_2.isEmpty(listeningTo))
        this._listeningTo = void 0;
      return this;
    };
    var offApi = function(events4, name, callback, options2) {
      if (!events4)
        return;
      var context = options2.context, listeners = options2.listeners;
      var i = 0, names;
      if (!name && !context && !callback) {
        for (names = _2.keys(listeners); i < names.length; i++) {
          listeners[names[i]].cleanup();
        }
        return;
      }
      names = name ? [name] : _2.keys(events4);
      for (; i < names.length; i++) {
        name = names[i];
        var handlers = events4[name];
        if (!handlers)
          break;
        var remaining = [];
        for (var j = 0; j < handlers.length; j++) {
          var handler = handlers[j];
          if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
            remaining.push(handler);
          } else {
            var listening = handler.listening;
            if (listening)
              listening.off(name, callback);
          }
        }
        if (remaining.length) {
          events4[name] = remaining;
        } else {
          delete events4[name];
        }
      }
      return events4;
    };
    Events.once = function(name, callback, context) {
      var events4 = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
      if (typeof name === "string" && context == null)
        callback = void 0;
      return this.on(events4, callback, context);
    };
    Events.listenToOnce = function(obj, name, callback) {
      var events4 = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
      return this.listenTo(obj, events4);
    };
    var onceMap = function(map, name, callback, offer) {
      if (callback) {
        var once = map[name] = _2.once(function() {
          offer(name, once);
          callback.apply(this, arguments);
        });
        once._callback = callback;
      }
      return map;
    };
    Events.trigger = function(name) {
      if (!this._events)
        return this;
      var length = Math.max(0, arguments.length - 1);
      var args = Array(length);
      for (var i = 0; i < length; i++)
        args[i] = arguments[i + 1];
      eventsApi(triggerApi, this._events, name, void 0, args);
      return this;
    };
    var triggerApi = function(objEvents, name, callback, args) {
      if (objEvents) {
        var events4 = objEvents[name];
        var allEvents = objEvents.all;
        if (events4 && allEvents)
          allEvents = allEvents.slice();
        if (events4)
          triggerEvents(events4, args);
        if (allEvents)
          triggerEvents(allEvents, [name].concat(args));
      }
      return objEvents;
    };
    var triggerEvents = function(events4, args) {
      var ev, i = -1, l = events4.length, a1 = args[0], a2 = args[1], a3 = args[2];
      switch (args.length) {
        case 0:
          while (++i < l)
            (ev = events4[i]).callback.call(ev.ctx);
          return;
        case 1:
          while (++i < l)
            (ev = events4[i]).callback.call(ev.ctx, a1);
          return;
        case 2:
          while (++i < l)
            (ev = events4[i]).callback.call(ev.ctx, a1, a2);
          return;
        case 3:
          while (++i < l)
            (ev = events4[i]).callback.call(ev.ctx, a1, a2, a3);
          return;
        default:
          while (++i < l)
            (ev = events4[i]).callback.apply(ev.ctx, args);
          return;
      }
    };
    var Listening = function(listener, obj) {
      this.id = listener._listenId;
      this.listener = listener;
      this.obj = obj;
      this.interop = true;
      this.count = 0;
      this._events = void 0;
    };
    Listening.prototype.on = Events.on;
    Listening.prototype.off = function(name, callback) {
      var cleanup;
      if (this.interop) {
        this._events = eventsApi(offApi, this._events, name, callback, {
          context: void 0,
          listeners: void 0
        });
        cleanup = !this._events;
      } else {
        this.count--;
        cleanup = this.count === 0;
      }
      if (cleanup)
        this.cleanup();
    };
    Listening.prototype.cleanup = function() {
      delete this.listener._listeningTo[this.obj._listenId];
      if (!this.interop)
        delete this.obj._listeners[this.id];
    };
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _2.extend(Backbone2, Events);
    var Model5 = Backbone2.Model = function(attributes2, options2) {
      var attrs = attributes2 || {};
      options2 || (options2 = {});
      this.preinitialize.apply(this, arguments);
      this.cid = _2.uniqueId(this.cidPrefix);
      this.attributes = {};
      if (options2.collection)
        this.collection = options2.collection;
      if (options2.parse)
        attrs = this.parse(attrs, options2) || {};
      var defaults2 = _2.result(this, "defaults");
      attrs = _2.defaults(_2.extend({}, defaults2, attrs), defaults2);
      this.set(attrs, options2);
      this.changed = {};
      this.initialize.apply(this, arguments);
    };
    _2.extend(Model5.prototype, Events, {
      // A hash of attributes whose current and previous value differ.
      changed: null,
      // The value returned during the last failed validation.
      validationError: null,
      // The default name for the JSON `id` attribute is `"id"`. MongoDB and
      // CouchDB users may want to set this to `"_id"`.
      idAttribute: "id",
      // The prefix is used to create the client id which is used to identify models locally.
      // You may want to override this if you're experiencing name clashes with model ids.
      cidPrefix: "c",
      // preinitialize is an empty function by default. You can override it with a function
      // or object.  preinitialize will run before any instantiation logic is run in the Model.
      preinitialize: function() {
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function() {
      },
      // Return a copy of the model's `attributes` object.
      toJSON: function(options2) {
        return _2.clone(this.attributes);
      },
      // Proxy `Backbone.sync` by default -- but override this if you need
      // custom syncing semantics for *this* particular model.
      sync: function() {
        return Backbone2.sync.apply(this, arguments);
      },
      // Get the value of an attribute.
      get: function(attr) {
        return this.attributes[attr];
      },
      // Get the HTML-escaped value of an attribute.
      escape: function(attr) {
        return _2.escape(this.get(attr));
      },
      // Returns `true` if the attribute contains a value that is not null
      // or undefined.
      has: function(attr) {
        return this.get(attr) != null;
      },
      // Special-cased proxy to underscore's `_.matches` method.
      matches: function(attrs) {
        return !!_2.iteratee(attrs, this)(this.attributes);
      },
      // Set a hash of model attributes on the object, firing `"change"`. This is
      // the core primitive operation of a model, updating the data and notifying
      // anyone who needs to know about the change in state. The heart of the beast.
      set: function(key, val, options2) {
        if (key == null)
          return this;
        var attrs;
        if (typeof key === "object") {
          attrs = key;
          options2 = val;
        } else {
          (attrs = {})[key] = val;
        }
        options2 || (options2 = {});
        if (!this._validate(attrs, options2))
          return false;
        var unset = options2.unset;
        var silent = options2.silent;
        var changes = [];
        var changing = this._changing;
        this._changing = true;
        if (!changing) {
          this._previousAttributes = _2.clone(this.attributes);
          this.changed = {};
        }
        var current = this.attributes;
        var changed = this.changed;
        var prev = this._previousAttributes;
        for (var attr in attrs) {
          val = attrs[attr];
          if (!_2.isEqual(current[attr], val))
            changes.push(attr);
          if (!_2.isEqual(prev[attr], val)) {
            changed[attr] = val;
          } else {
            delete changed[attr];
          }
          unset ? delete current[attr] : current[attr] = val;
        }
        if (this.idAttribute in attrs)
          this.id = this.get(this.idAttribute);
        if (!silent) {
          if (changes.length)
            this._pending = options2;
          for (var i = 0; i < changes.length; i++) {
            this.trigger("change:" + changes[i], this, current[changes[i]], options2);
          }
        }
        if (changing)
          return this;
        if (!silent) {
          while (this._pending) {
            options2 = this._pending;
            this._pending = false;
            this.trigger("change", this, options2);
          }
        }
        this._pending = false;
        this._changing = false;
        return this;
      },
      // Remove an attribute from the model, firing `"change"`. `unset` is a noop
      // if the attribute doesn't exist.
      unset: function(attr, options2) {
        return this.set(attr, void 0, _2.extend({}, options2, {
          unset: true
        }));
      },
      // Clear all attributes on the model, firing `"change"`.
      clear: function(options2) {
        var attrs = {};
        for (var key in this.attributes)
          attrs[key] = void 0;
        return this.set(attrs, _2.extend({}, options2, {
          unset: true
        }));
      },
      // Determine if the model has changed since the last `"change"` event.
      // If you specify an attribute name, determine if that attribute has changed.
      hasChanged: function(attr) {
        if (attr == null)
          return !_2.isEmpty(this.changed);
        return _2.has(this.changed, attr);
      },
      // Return an object containing all the attributes that have changed, or
      // false if there are no changed attributes. Useful for determining what
      // parts of a view need to be updated and/or what attributes need to be
      // persisted to the server. Unset attributes will be set to undefined.
      // You can also pass an attributes object to diff against the model,
      // determining if there *would be* a change.
      changedAttributes: function(diff) {
        if (!diff)
          return this.hasChanged() ? _2.clone(this.changed) : false;
        var old = this._changing ? this._previousAttributes : this.attributes;
        var changed = {};
        var hasChanged;
        for (var attr in diff) {
          var val = diff[attr];
          if (_2.isEqual(old[attr], val))
            continue;
          changed[attr] = val;
          hasChanged = true;
        }
        return hasChanged ? changed : false;
      },
      // Get the previous value of an attribute, recorded at the time the last
      // `"change"` event was fired.
      previous: function(attr) {
        if (attr == null || !this._previousAttributes)
          return null;
        return this._previousAttributes[attr];
      },
      // Get all of the attributes of the model at the time of the previous
      // `"change"` event.
      previousAttributes: function() {
        return _2.clone(this._previousAttributes);
      },
      // Fetch the model from the server, merging the response with the model's
      // local attributes. Any changed attributes will trigger a "change" event.
      fetch: function(options2) {
        options2 = _2.extend({
          parse: true
        }, options2);
        var model = this;
        var success = options2.success;
        options2.success = function(resp) {
          var serverAttrs = options2.parse ? model.parse(resp, options2) : resp;
          if (!model.set(serverAttrs, options2))
            return false;
          if (success)
            success.call(options2.context, model, resp, options2);
          model.trigger("sync", model, resp, options2);
        };
        wrapError(this, options2);
        return this.sync("read", this, options2);
      },
      // Set a hash of model attributes, and sync the model to the server.
      // If the server returns an attributes hash that differs, the model's
      // state will be `set` again.
      save: function(key, val, options2) {
        var attrs;
        if (key == null || typeof key === "object") {
          attrs = key;
          options2 = val;
        } else {
          (attrs = {})[key] = val;
        }
        options2 = _2.extend({
          validate: true,
          parse: true
        }, options2);
        var wait = options2.wait;
        if (attrs && !wait) {
          if (!this.set(attrs, options2))
            return false;
        } else if (!this._validate(attrs, options2)) {
          return false;
        }
        var model = this;
        var success = options2.success;
        var attributes2 = this.attributes;
        options2.success = function(resp) {
          model.attributes = attributes2;
          var serverAttrs = options2.parse ? model.parse(resp, options2) : resp;
          if (wait)
            serverAttrs = _2.extend({}, attrs, serverAttrs);
          if (serverAttrs && !model.set(serverAttrs, options2))
            return false;
          if (success)
            success.call(options2.context, model, resp, options2);
          model.trigger("sync", model, resp, options2);
        };
        wrapError(this, options2);
        if (attrs && wait)
          this.attributes = _2.extend({}, attributes2, attrs);
        var method = this.isNew() ? "create" : options2.patch ? "patch" : "update";
        if (method === "patch" && !options2.attrs)
          options2.attrs = attrs;
        var xhr = this.sync(method, this, options2);
        this.attributes = attributes2;
        return xhr;
      },
      // Destroy this model on the server if it was already persisted.
      // Optimistically removes the model from its collection, if it has one.
      // If `wait: true` is passed, waits for the server to respond before removal.
      destroy: function(options2) {
        options2 = options2 ? _2.clone(options2) : {};
        var model = this;
        var success = options2.success;
        var wait = options2.wait;
        var destroy = function() {
          model.stopListening();
          model.trigger("destroy", model, model.collection, options2);
        };
        options2.success = function(resp) {
          if (wait)
            destroy();
          if (success)
            success.call(options2.context, model, resp, options2);
          if (!model.isNew())
            model.trigger("sync", model, resp, options2);
        };
        var xhr = false;
        if (this.isNew()) {
          _2.defer(options2.success);
        } else {
          wrapError(this, options2);
          xhr = this.sync("delete", this, options2);
        }
        if (!wait)
          destroy();
        return xhr;
      },
      // Default URL for the model's representation on the server -- if you're
      // using Backbone's restful methods, override this to change the endpoint
      // that will be called.
      url: function() {
        var base2 = _2.result(this, "urlRoot") || _2.result(this.collection, "url") || urlError();
        if (this.isNew())
          return base2;
        var id = this.get(this.idAttribute);
        return base2.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
      },
      // **parse** converts a response into the hash of attributes to be `set` on
      // the model. The default implementation is just to pass the response along.
      parse: function(resp, options2) {
        return resp;
      },
      // Create a new model with identical attributes to this one.
      clone: function() {
        return new this.constructor(this.attributes);
      },
      // A model is new if it has never been saved to the server, and lacks an id.
      isNew: function() {
        return !this.has(this.idAttribute);
      },
      // Check if the model is currently in a valid state.
      isValid: function(options2) {
        return this._validate({}, _2.extend({}, options2, {
          validate: true
        }));
      },
      // Run validation against the next complete set of model attributes,
      // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
      _validate: function(attrs, options2) {
        if (!options2.validate || !this.validate)
          return true;
        attrs = _2.extend({}, this.attributes, attrs);
        var error = this.validationError = this.validate(attrs, options2) || null;
        if (!error)
          return true;
        this.trigger("invalid", this, error, _2.extend(options2, {
          validationError: error
        }));
        return false;
      }
    });
    var Collection3 = Backbone2.Collection = function(models, options2) {
      options2 || (options2 = {});
      this.preinitialize.apply(this, arguments);
      if (options2.model)
        this.model = options2.model;
      if (options2.comparator !== void 0)
        this.comparator = options2.comparator;
      this._reset();
      this.initialize.apply(this, arguments);
      if (models)
        this.reset(models, _2.extend({
          silent: true
        }, options2));
    };
    var setOptions = {
      add: true,
      remove: true,
      merge: true
    };
    var addOptions = {
      add: true,
      remove: false
    };
    var splice = function(array, insert, at) {
      at = Math.min(Math.max(at, 0), array.length);
      var tail = Array(array.length - at);
      var length = insert.length;
      var i;
      for (i = 0; i < tail.length; i++)
        tail[i] = array[i + at];
      for (i = 0; i < length; i++)
        array[i + at] = insert[i];
      for (i = 0; i < tail.length; i++)
        array[i + length + at] = tail[i];
    };
    _2.extend(Collection3.prototype, Events, {
      // The default model for a collection is just a **Backbone.Model**.
      // This should be overridden in most cases.
      model: Model5,
      // preinitialize is an empty function by default. You can override it with a function
      // or object.  preinitialize will run before any instantiation logic is run in the Collection.
      preinitialize: function() {
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function() {
      },
      // The JSON representation of a Collection is an array of the
      // models' attributes.
      toJSON: function(options2) {
        return this.map(function(model) {
          return model.toJSON(options2);
        });
      },
      // Proxy `Backbone.sync` by default.
      sync: function() {
        return Backbone2.sync.apply(this, arguments);
      },
      // Add a model, or list of models to the set. `models` may be Backbone
      // Models or raw JavaScript objects to be converted to Models, or any
      // combination of the two.
      add: function(models, options2) {
        return this.set(models, _2.extend({
          merge: false
        }, options2, addOptions));
      },
      // Remove a model, or a list of models from the set.
      remove: function(models, options2) {
        options2 = _2.extend({}, options2);
        var singular = !_2.isArray(models);
        models = singular ? [models] : models.slice();
        var removed = this._removeModels(models, options2);
        if (!options2.silent && removed.length) {
          options2.changes = {
            added: [],
            merged: [],
            removed
          };
          this.trigger("update", this, options2);
        }
        return singular ? removed[0] : removed;
      },
      // Update a collection by `set`-ing a new list of models, adding new ones,
      // removing models that are no longer present, and merging models that
      // already exist in the collection, as necessary. Similar to **Model#set**,
      // the core operation for updating the data contained by the collection.
      set: function(models, options2) {
        if (models == null)
          return;
        options2 = _2.extend({}, setOptions, options2);
        if (options2.parse && !this._isModel(models)) {
          models = this.parse(models, options2) || [];
        }
        var singular = !_2.isArray(models);
        models = singular ? [models] : models.slice();
        var at = options2.at;
        if (at != null)
          at = +at;
        if (at > this.length)
          at = this.length;
        if (at < 0)
          at += this.length + 1;
        var set = [];
        var toAdd = [];
        var toMerge = [];
        var toRemove = [];
        var modelMap = {};
        var add = options2.add;
        var merge = options2.merge;
        var remove = options2.remove;
        var sort = false;
        var sortable = this.comparator && at == null && options2.sort !== false;
        var sortAttr = _2.isString(this.comparator) ? this.comparator : null;
        var model, i;
        for (i = 0; i < models.length; i++) {
          model = models[i];
          var existing = this.get(model);
          if (existing) {
            if (merge && model !== existing) {
              var attrs = this._isModel(model) ? model.attributes : model;
              if (options2.parse)
                attrs = existing.parse(attrs, options2);
              existing.set(attrs, options2);
              toMerge.push(existing);
              if (sortable && !sort)
                sort = existing.hasChanged(sortAttr);
            }
            if (!modelMap[existing.cid]) {
              modelMap[existing.cid] = true;
              set.push(existing);
            }
            models[i] = existing;
          } else if (add) {
            model = models[i] = this._prepareModel(model, options2);
            if (model) {
              toAdd.push(model);
              this._addReference(model, options2);
              modelMap[model.cid] = true;
              set.push(model);
            }
          }
        }
        if (remove) {
          for (i = 0; i < this.length; i++) {
            model = this.models[i];
            if (!modelMap[model.cid])
              toRemove.push(model);
          }
          if (toRemove.length)
            this._removeModels(toRemove, options2);
        }
        var orderChanged = false;
        var replace = !sortable && add && remove;
        if (set.length && replace) {
          orderChanged = this.length !== set.length || _2.some(this.models, function(m, index) {
            return m !== set[index];
          });
          this.models.length = 0;
          splice(this.models, set, 0);
          this.length = this.models.length;
        } else if (toAdd.length) {
          if (sortable)
            sort = true;
          splice(this.models, toAdd, at == null ? this.length : at);
          this.length = this.models.length;
        }
        if (sort)
          this.sort({
            silent: true
          });
        if (!options2.silent) {
          for (i = 0; i < toAdd.length; i++) {
            if (at != null)
              options2.index = at + i;
            model = toAdd[i];
            model.trigger("add", model, this, options2);
          }
          if (sort || orderChanged)
            this.trigger("sort", this, options2);
          if (toAdd.length || toRemove.length || toMerge.length) {
            options2.changes = {
              added: toAdd,
              removed: toRemove,
              merged: toMerge
            };
            this.trigger("update", this, options2);
          }
        }
        return singular ? models[0] : models;
      },
      // When you have more items than you want to add or remove individually,
      // you can reset the entire set with a new list of models, without firing
      // any granular `add` or `remove` events. Fires `reset` when finished.
      // Useful for bulk operations and optimizations.
      reset: function(models, options2) {
        options2 = options2 ? _2.clone(options2) : {};
        for (var i = 0; i < this.models.length; i++) {
          this._removeReference(this.models[i], options2);
        }
        options2.previousModels = this.models;
        this._reset();
        models = this.add(models, _2.extend({
          silent: true
        }, options2));
        if (!options2.silent)
          this.trigger("reset", this, options2);
        return models;
      },
      // Add a model to the end of the collection.
      push: function(model, options2) {
        return this.add(model, _2.extend({
          at: this.length
        }, options2));
      },
      // Remove a model from the end of the collection.
      pop: function(options2) {
        var model = this.at(this.length - 1);
        return this.remove(model, options2);
      },
      // Add a model to the beginning of the collection.
      unshift: function(model, options2) {
        return this.add(model, _2.extend({
          at: 0
        }, options2));
      },
      // Remove a model from the beginning of the collection.
      shift: function(options2) {
        var model = this.at(0);
        return this.remove(model, options2);
      },
      // Slice out a sub-array of models from the collection.
      slice: function() {
        return slice.apply(this.models, arguments);
      },
      // Get a model from the set by id, cid, model object with id or cid
      // properties, or an attributes object that is transformed through modelId.
      get: function(obj) {
        if (obj == null)
          return void 0;
        return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid && this._byId[obj.cid];
      },
      // Returns `true` if the model is in the collection.
      has: function(obj) {
        return this.get(obj) != null;
      },
      // Get the model at the given index.
      at: function(index) {
        if (index < 0)
          index += this.length;
        return this.models[index];
      },
      // Return models with matching attributes. Useful for simple cases of
      // `filter`.
      where: function(attrs, first) {
        return this[first ? "find" : "filter"](attrs);
      },
      // Return the first model with matching attributes. Useful for simple cases
      // of `find`.
      findWhere: function(attrs) {
        return this.where(attrs, true);
      },
      // Force the collection to re-sort itself. You don't need to call this under
      // normal circumstances, as the set will maintain sort order as each item
      // is added.
      sort: function(options2) {
        var comparator = this.comparator;
        if (!comparator)
          throw new Error("Cannot sort a set without a comparator");
        options2 || (options2 = {});
        var length = comparator.length;
        if (_2.isFunction(comparator))
          comparator = comparator.bind(this);
        if (length === 1 || _2.isString(comparator)) {
          this.models = this.sortBy(comparator);
        } else {
          this.models.sort(comparator);
        }
        if (!options2.silent)
          this.trigger("sort", this, options2);
        return this;
      },
      // Pluck an attribute from each model in the collection.
      pluck: function(attr) {
        return this.map(attr + "");
      },
      // Fetch the default set of models for this collection, resetting the
      // collection when they arrive. If `reset: true` is passed, the response
      // data will be passed through the `reset` method instead of `set`.
      fetch: function(options2) {
        options2 = _2.extend({
          parse: true
        }, options2);
        var success = options2.success;
        var collection = this;
        options2.success = function(resp) {
          var method = options2.reset ? "reset" : "set";
          collection[method](resp, options2);
          if (success)
            success.call(options2.context, collection, resp, options2);
          collection.trigger("sync", collection, resp, options2);
        };
        wrapError(this, options2);
        return this.sync("read", this, options2);
      },
      // Create a new instance of a model in this collection. Add the model to the
      // collection immediately, unless `wait: true` is passed, in which case we
      // wait for the server to agree.
      create: function(model, options2) {
        options2 = options2 ? _2.clone(options2) : {};
        var wait = options2.wait;
        model = this._prepareModel(model, options2);
        if (!model)
          return false;
        if (!wait)
          this.add(model, options2);
        var collection = this;
        var success = options2.success;
        options2.success = function(m, resp, callbackOpts) {
          if (wait)
            collection.add(m, callbackOpts);
          if (success)
            success.call(callbackOpts.context, m, resp, callbackOpts);
        };
        model.save(null, options2);
        return model;
      },
      // **parse** converts a response into a list of models to be added to the
      // collection. The default implementation is just to pass it through.
      parse: function(resp, options2) {
        return resp;
      },
      // Create a new collection with an identical list of models as this one.
      clone: function() {
        return new this.constructor(this.models, {
          model: this.model,
          comparator: this.comparator
        });
      },
      // Define how to uniquely identify models in the collection.
      modelId: function(attrs) {
        return attrs[this.model.prototype.idAttribute || "id"];
      },
      // Get an iterator of all models in this collection.
      values: function() {
        return new CollectionIterator(this, ITERATOR_VALUES);
      },
      // Get an iterator of all model IDs in this collection.
      keys: function() {
        return new CollectionIterator(this, ITERATOR_KEYS);
      },
      // Get an iterator of all [ID, model] tuples in this collection.
      entries: function() {
        return new CollectionIterator(this, ITERATOR_KEYSVALUES);
      },
      // Private method to reset all internal state. Called when the collection
      // is first initialized or reset.
      _reset: function() {
        this.length = 0;
        this.models = [];
        this._byId = {};
      },
      // Prepare a hash of attributes (or other model) to be added to this
      // collection.
      _prepareModel: function(attrs, options2) {
        if (this._isModel(attrs)) {
          if (!attrs.collection)
            attrs.collection = this;
          return attrs;
        }
        options2 = options2 ? _2.clone(options2) : {};
        options2.collection = this;
        var model = new this.model(attrs, options2);
        if (!model.validationError)
          return model;
        this.trigger("invalid", this, model.validationError, options2);
        return false;
      },
      // Internal method called by both remove and set.
      _removeModels: function(models, options2) {
        var removed = [];
        for (var i = 0; i < models.length; i++) {
          var model = this.get(models[i]);
          if (!model)
            continue;
          var index = this.indexOf(model);
          this.models.splice(index, 1);
          this.length--;
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (!options2.silent) {
            options2.index = index;
            model.trigger("remove", model, this, options2);
          }
          removed.push(model);
          this._removeReference(model, options2);
        }
        return removed;
      },
      // Method for checking whether an object should be considered a model for
      // the purposes of adding to the collection.
      _isModel: function(model) {
        return model instanceof Model5;
      },
      // Internal method to create a model's ties to a collection.
      _addReference: function(model, options2) {
        this._byId[model.cid] = model;
        var id = this.modelId(model.attributes);
        if (id != null)
          this._byId[id] = model;
        model.on("all", this._onModelEvent, this);
      },
      // Internal method to sever a model's ties to a collection.
      _removeReference: function(model, options2) {
        delete this._byId[model.cid];
        var id = this.modelId(model.attributes);
        if (id != null)
          delete this._byId[id];
        if (this === model.collection)
          delete model.collection;
        model.off("all", this._onModelEvent, this);
      },
      // Internal method called every time a model in the set fires an event.
      // Sets need to update their indexes when models change ids. All other
      // events simply proxy through. "add" and "remove" events that originate
      // in other collections are ignored.
      _onModelEvent: function(event, model, collection, options2) {
        if (model) {
          if ((event === "add" || event === "remove") && collection !== this)
            return;
          if (event === "destroy")
            this.remove(model, options2);
          if (event === "change") {
            var prevId = this.modelId(model.previousAttributes());
            var id = this.modelId(model.attributes);
            if (prevId !== id) {
              if (prevId != null)
                delete this._byId[prevId];
              if (id != null)
                this._byId[id] = model;
            }
          }
        }
        this.trigger.apply(this, arguments);
      }
    });
    var $$iterator = typeof Symbol === "function" && Symbol.iterator;
    if ($$iterator) {
      Collection3.prototype[$$iterator] = Collection3.prototype.values;
    }
    var CollectionIterator = function(collection, kind) {
      this._collection = collection;
      this._kind = kind;
      this._index = 0;
    };
    var ITERATOR_VALUES = 1;
    var ITERATOR_KEYS = 2;
    var ITERATOR_KEYSVALUES = 3;
    if ($$iterator) {
      CollectionIterator.prototype[$$iterator] = function() {
        return this;
      };
    }
    CollectionIterator.prototype.next = function() {
      if (this._collection) {
        if (this._index < this._collection.length) {
          var model = this._collection.at(this._index);
          this._index++;
          var value;
          if (this._kind === ITERATOR_VALUES) {
            value = model;
          } else {
            var id = this._collection.modelId(model.attributes);
            if (this._kind === ITERATOR_KEYS) {
              value = id;
            } else {
              value = [id, model];
            }
          }
          return {
            value,
            done: false
          };
        }
        this._collection = void 0;
      }
      return {
        value: void 0,
        done: true
      };
    };
    var View3 = Backbone2.View = function(options2) {
      this.cid = _2.uniqueId("view");
      this.preinitialize.apply(this, arguments);
      _2.extend(this, _2.pick(options2, viewOptions));
      this._ensureElement();
      this.initialize.apply(this, arguments);
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
    _2.extend(View3.prototype, Events, {
      // The default `tagName` of a View's element is `"div"`.
      tagName: "div",
      // jQuery delegate for element lookup, scoped to DOM elements within the
      // current view. This should be preferred to global lookups where possible.
      $: function(selector) {
        return this.$el.find(selector);
      },
      // preinitialize is an empty function by default. You can override it with a function
      // or object.  preinitialize will run before any instantiation logic is run in the View
      preinitialize: function() {
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function() {
      },
      // **render** is the core function that your view should override, in order
      // to populate its element (`this.el`), with the appropriate HTML. The
      // convention is for **render** to always return `this`.
      render: function() {
        return this;
      },
      // Remove this view by taking the element out of the DOM, and removing any
      // applicable Backbone.Events listeners.
      remove: function() {
        this._removeElement();
        this.stopListening();
        return this;
      },
      // Remove this view's element from the document and all event listeners
      // attached to it. Exposed for subclasses using an alternative DOM
      // manipulation API.
      _removeElement: function() {
        this.$el.remove();
      },
      // Change the view's element (`this.el` property) and re-delegate the
      // view's events on the new element.
      setElement: function(element) {
        this.undelegateEvents();
        this._setElement(element);
        this.delegateEvents();
        return this;
      },
      // Creates the `this.el` and `this.$el` references for this view using the
      // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
      // context or an element. Subclasses can override this to utilize an
      // alternative DOM manipulation API and are only required to set the
      // `this.el` property.
      _setElement: function(el) {
        this.$el = el instanceof Backbone2.$ ? el : Backbone2.$(el);
        this.el = this.$el[0];
      },
      // Set callbacks, where `this.events` is a hash of
      //
      // *{"event selector": "callback"}*
      //
      //     {
      //       'mousedown .title':  'edit',
      //       'click .button':     'save',
      //       'click .open':       function(e) { ... }
      //     }
      //
      // pairs. Callbacks will be bound to the view, with `this` set properly.
      // Uses event delegation for efficiency.
      // Omitting the selector binds the event to `this.el`.
      delegateEvents: function(events4) {
        events4 || (events4 = _2.result(this, "events"));
        if (!events4)
          return this;
        this.undelegateEvents();
        for (var key in events4) {
          var method = events4[key];
          if (!_2.isFunction(method))
            method = this[method];
          if (!method)
            continue;
          var match = key.match(delegateEventSplitter);
          this.delegate(match[1], match[2], method.bind(this));
        }
        return this;
      },
      // Add a single event listener to the view's element (or a child element
      // using `selector`). This only works for delegate-able events: not `focus`,
      // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
      delegate: function(eventName, selector, listener) {
        this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
        return this;
      },
      // Clears all callbacks previously bound to the view by `delegateEvents`.
      // You usually don't need to use this, but may wish to if you have multiple
      // Backbone views attached to the same DOM element.
      undelegateEvents: function() {
        if (this.$el)
          this.$el.off(".delegateEvents" + this.cid);
        return this;
      },
      // A finer-grained `undelegateEvents` for removing a single delegated event.
      // `selector` and `listener` are both optional.
      undelegate: function(eventName, selector, listener) {
        this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
        return this;
      },
      // Produces a DOM element to be assigned to your view. Exposed for
      // subclasses using an alternative DOM manipulation API.
      _createElement: function(tagName) {
        return document.createElement(tagName);
      },
      // Ensure that the View has a DOM element to render into.
      // If `this.el` is a string, pass it through `$()`, take the first
      // matching element, and re-assign it to `el`. Otherwise, create
      // an element from the `id`, `className` and `tagName` properties.
      _ensureElement: function() {
        if (!this.el) {
          var attrs = _2.extend({}, _2.result(this, "attributes"));
          if (this.id)
            attrs.id = _2.result(this, "id");
          if (this.className)
            attrs["class"] = _2.result(this, "className");
          this.setElement(this._createElement(_2.result(this, "tagName")));
          this._setAttributes(attrs);
        } else {
          this.setElement(_2.result(this, "el"));
        }
      },
      // Set attributes from a hash on this view's element.  Exposed for
      // subclasses using an alternative DOM manipulation API.
      _setAttributes: function(attributes2) {
        this.$el.attr(attributes2);
      }
    });
    var addMethod = function(base2, length, method, attribute) {
      switch (length) {
        case 1:
          return function() {
            return base2[method](this[attribute]);
          };
        case 2:
          return function(value) {
            return base2[method](this[attribute], value);
          };
        case 3:
          return function(iteratee, context) {
            return base2[method](this[attribute], cb(iteratee, this), context);
          };
        case 4:
          return function(iteratee, defaultVal, context) {
            return base2[method](this[attribute], cb(iteratee, this), defaultVal, context);
          };
        default:
          return function() {
            var args = slice.call(arguments);
            args.unshift(this[attribute]);
            return base2[method].apply(base2, args);
          };
      }
    };
    var addUnderscoreMethods = function(Class2, base2, methods2, attribute) {
      _2.each(methods2, function(length, method) {
        if (base2[method])
          Class2.prototype[method] = addMethod(base2, length, method, attribute);
      });
    };
    var cb = function(iteratee, instance) {
      if (_2.isFunction(iteratee))
        return iteratee;
      if (_2.isObject(iteratee) && !instance._isModel(iteratee))
        return modelMatcher(iteratee);
      if (_2.isString(iteratee))
        return function(model) {
          return model.get(iteratee);
        };
      return iteratee;
    };
    var modelMatcher = function(attrs) {
      var matcher = _2.matches(attrs);
      return function(model) {
        return matcher(model.attributes);
      };
    };
    var collectionMethods = {
      forEach: 3,
      each: 3,
      map: 3,
      collect: 3,
      reduce: 0,
      foldl: 0,
      inject: 0,
      reduceRight: 0,
      foldr: 0,
      find: 3,
      detect: 3,
      filter: 3,
      select: 3,
      reject: 3,
      every: 3,
      all: 3,
      some: 3,
      any: 3,
      include: 3,
      includes: 3,
      contains: 3,
      invoke: 0,
      max: 3,
      min: 3,
      toArray: 1,
      size: 1,
      first: 3,
      head: 3,
      take: 3,
      initial: 3,
      rest: 3,
      tail: 3,
      drop: 3,
      last: 3,
      without: 0,
      difference: 0,
      indexOf: 3,
      shuffle: 1,
      lastIndexOf: 3,
      isEmpty: 1,
      chain: 1,
      sample: 3,
      partition: 3,
      groupBy: 3,
      countBy: 3,
      sortBy: 3,
      indexBy: 3,
      findIndex: 3,
      findLastIndex: 3
    };
    var modelMethods = {
      keys: 1,
      values: 1,
      pairs: 1,
      invert: 1,
      pick: 0,
      omit: 0,
      chain: 1,
      isEmpty: 1
    };
    _2.each([[Collection3, collectionMethods, "models"], [Model5, modelMethods, "attributes"]], function(config2) {
      var Base = config2[0], methods2 = config2[1], attribute = config2[2];
      Base.mixin = function(obj) {
        var mappings = _2.reduce(_2.functions(obj), function(memo, name) {
          memo[name] = 0;
          return memo;
        }, {});
        addUnderscoreMethods(Base, obj, mappings, attribute);
      };
      addUnderscoreMethods(Base, _2, methods2, attribute);
    });
    Backbone2.sync = function(method, model, options2) {
      var type = methodMap[method];
      _2.defaults(options2 || (options2 = {}), {
        emulateHTTP: Backbone2.emulateHTTP,
        emulateJSON: Backbone2.emulateJSON
      });
      var params = {
        type,
        dataType: "json"
      };
      if (!options2.url) {
        params.url = _2.result(model, "url") || urlError();
      }
      if (options2.data == null && model && (method === "create" || method === "update" || method === "patch")) {
        params.contentType = "application/json";
        params.data = JSON.stringify(options2.attrs || model.toJSON(options2));
      }
      if (options2.emulateJSON) {
        params.contentType = "application/x-www-form-urlencoded";
        params.data = params.data ? {
          model: params.data
        } : {};
      }
      if (options2.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
        params.type = "POST";
        if (options2.emulateJSON)
          params.data._method = type;
        var beforeSend = options2.beforeSend;
        options2.beforeSend = function(xhr2) {
          xhr2.setRequestHeader("X-HTTP-Method-Override", type);
          if (beforeSend)
            return beforeSend.apply(this, arguments);
        };
      }
      if (params.type !== "GET" && !options2.emulateJSON) {
        params.processData = false;
      }
      var error = options2.error;
      options2.error = function(xhr2, textStatus, errorThrown) {
        options2.textStatus = textStatus;
        options2.errorThrown = errorThrown;
        if (error)
          error.call(options2.context, xhr2, textStatus, errorThrown);
      };
      var xhr = options2.xhr = Backbone2.ajax(_2.extend(params, options2));
      model.trigger("request", model, xhr, options2);
      return xhr;
    };
    var methodMap = {
      create: "POST",
      update: "PUT",
      patch: "PATCH",
      delete: "DELETE",
      read: "GET"
    };
    Backbone2.ajax = function() {
      return Backbone2.$.ajax.apply(Backbone2.$, arguments);
    };
    var Router2 = Backbone2.Router = function(options2) {
      options2 || (options2 = {});
      this.preinitialize.apply(this, arguments);
      if (options2.routes)
        this.routes = options2.routes;
      this._bindRoutes();
      this.initialize.apply(this, arguments);
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _2.extend(Router2.prototype, Events, {
      // preinitialize is an empty function by default. You can override it with a function
      // or object.  preinitialize will run before any instantiation logic is run in the Router.
      preinitialize: function() {
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function() {
      },
      // Manually bind a single named route to a callback. For example:
      //
      //     this.route('search/:query/p:num', 'search', function(query, num) {
      //       ...
      //     });
      //
      route: function(route, name, callback) {
        if (!_2.isRegExp(route))
          route = this._routeToRegExp(route);
        if (_2.isFunction(name)) {
          callback = name;
          name = "";
        }
        if (!callback)
          callback = this[name];
        var router = this;
        Backbone2.history.route(route, function(fragment) {
          var args = router._extractParameters(route, fragment);
          if (router.execute(callback, args, name) !== false) {
            router.trigger.apply(router, ["route:" + name].concat(args));
            router.trigger("route", name, args);
            Backbone2.history.trigger("route", router, name, args);
          }
        });
        return this;
      },
      // Execute a route handler with the provided parameters.  This is an
      // excellent place to do pre-route setup or post-route cleanup.
      execute: function(callback, args, name) {
        if (callback)
          callback.apply(this, args);
      },
      // Simple proxy to `Backbone.history` to save a fragment into the history.
      navigate: function(fragment, options2) {
        Backbone2.history.navigate(fragment, options2);
        return this;
      },
      // Bind all defined routes to `Backbone.history`. We have to reverse the
      // order of the routes here to support behavior where the most general
      // routes can be defined at the bottom of the route map.
      _bindRoutes: function() {
        if (!this.routes)
          return;
        this.routes = _2.result(this, "routes");
        var route, routes2 = _2.keys(this.routes);
        while ((route = routes2.pop()) != null) {
          this.route(route, this.routes[route]);
        }
      },
      // Convert a route string into a regular expression, suitable for matching
      // against the current location hash.
      _routeToRegExp: function(route) {
        route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
          return optional ? match : "([^/?]+)";
        }).replace(splatParam, "([^?]*?)");
        return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
      },
      // Given a route, and a URL fragment that it matches, return the array of
      // extracted decoded parameters. Empty or unmatched parameters will be
      // treated as `null` to normalize cross-browser behavior.
      _extractParameters: function(route, fragment) {
        var params = route.exec(fragment).slice(1);
        return _2.map(params, function(param, i) {
          if (i === params.length - 1)
            return param || null;
          return param ? decodeURIComponent(param) : null;
        });
      }
    });
    var History = Backbone2.History = function() {
      this.handlers = [];
      this.checkUrl = this.checkUrl.bind(this);
      if (typeof window !== "undefined") {
        this.location = window.location;
        this.history = window.history;
      }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var pathStripper = /#.*$/;
    History.started = false;
    _2.extend(History.prototype, Events, {
      // The default interval to poll for hash changes, if necessary, is
      // twenty times a second.
      interval: 50,
      // Are we at the app root?
      atRoot: function() {
        var path = this.location.pathname.replace(/[^\/]$/, "$&/");
        return path === this.root && !this.getSearch();
      },
      // Does the pathname match the root?
      matchRoot: function() {
        var path = this.decodeFragment(this.location.pathname);
        var rootPath = path.slice(0, this.root.length - 1) + "/";
        return rootPath === this.root;
      },
      // Unicode characters in `location.pathname` are percent encoded so they're
      // decoded for comparison. `%25` should not be decoded since it may be part
      // of an encoded parameter.
      decodeFragment: function(fragment) {
        return decodeURI(fragment.replace(/%25/g, "%2525"));
      },
      // In IE6, the hash fragment and search params are incorrect if the
      // fragment contains `?`.
      getSearch: function() {
        var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
        return match ? match[0] : "";
      },
      // Gets the true hash value. Cannot use location.hash directly due to bug
      // in Firefox where location.hash will always be decoded.
      getHash: function(window2) {
        var match = (window2 || this).location.href.match(/#(.*)$/);
        return match ? match[1] : "";
      },
      // Get the pathname and search params, without the root.
      getPath: function() {
        var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
        return path.charAt(0) === "/" ? path.slice(1) : path;
      },
      // Get the cross-browser normalized URL fragment from the path or hash.
      getFragment: function(fragment) {
        if (fragment == null) {
          if (this._usePushState || !this._wantsHashChange) {
            fragment = this.getPath();
          } else {
            fragment = this.getHash();
          }
        }
        return fragment.replace(routeStripper, "");
      },
      // Start the hash change handling, returning `true` if the current URL matches
      // an existing route, and `false` otherwise.
      start: function(options2) {
        if (History.started)
          throw new Error("Backbone.history has already been started");
        History.started = true;
        this.options = _2.extend({
          root: "/"
        }, this.options, options2);
        this.root = this.options.root;
        this._wantsHashChange = this.options.hashChange !== false;
        this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
        this._useHashChange = this._wantsHashChange && this._hasHashChange;
        this._wantsPushState = !!this.options.pushState;
        this._hasPushState = !!(this.history && this.history.pushState);
        this._usePushState = this._wantsPushState && this._hasPushState;
        this.fragment = this.getFragment();
        this.root = ("/" + this.root + "/").replace(rootStripper, "/");
        if (this._wantsHashChange && this._wantsPushState) {
          if (!this._hasPushState && !this.atRoot()) {
            var rootPath = this.root.slice(0, -1) || "/";
            this.location.replace(rootPath + "#" + this.getPath());
            return true;
          } else if (this._hasPushState && this.atRoot()) {
            this.navigate(this.getHash(), {
              replace: true
            });
          }
        }
        if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
          this.iframe = document.createElement("iframe");
          this.iframe.src = "javascript:0";
          this.iframe.style.display = "none";
          this.iframe.tabIndex = -1;
          var body = document.body;
          var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
          iWindow.document.open();
          iWindow.document.close();
          iWindow.location.hash = "#" + this.fragment;
        }
        var addEventListener = window.addEventListener || function(eventName, listener) {
          return attachEvent("on" + eventName, listener);
        };
        if (this._usePushState) {
          addEventListener("popstate", this.checkUrl, false);
        } else if (this._useHashChange && !this.iframe) {
          addEventListener("hashchange", this.checkUrl, false);
        } else if (this._wantsHashChange) {
          this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
        }
        if (!this.options.silent)
          return this.loadUrl();
      },
      // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
      // but possibly useful for unit testing Routers.
      stop: function() {
        var removeEventListener = window.removeEventListener || function(eventName, listener) {
          return detachEvent("on" + eventName, listener);
        };
        if (this._usePushState) {
          removeEventListener("popstate", this.checkUrl, false);
        } else if (this._useHashChange && !this.iframe) {
          removeEventListener("hashchange", this.checkUrl, false);
        }
        if (this.iframe) {
          document.body.removeChild(this.iframe);
          this.iframe = null;
        }
        if (this._checkUrlInterval)
          clearInterval(this._checkUrlInterval);
        History.started = false;
      },
      // Add a route to be tested when the fragment changes. Routes added later
      // may override previous routes.
      route: function(route, callback) {
        this.handlers.unshift({
          route,
          callback
        });
      },
      // Checks the current URL to see if it has changed, and if it has,
      // calls `loadUrl`, normalizing across the hidden iframe.
      checkUrl: function(e) {
        var current = this.getFragment();
        if (current === this.fragment && this.iframe) {
          current = this.getHash(this.iframe.contentWindow);
        }
        if (current === this.fragment)
          return false;
        if (this.iframe)
          this.navigate(current);
        this.loadUrl();
      },
      // Attempt to load the current URL fragment. If a route succeeds with a
      // match, returns `true`. If no defined routes matches the fragment,
      // returns `false`.
      loadUrl: function(fragment) {
        if (!this.matchRoot())
          return false;
        fragment = this.fragment = this.getFragment(fragment);
        return _2.some(this.handlers, function(handler) {
          if (handler.route.test(fragment)) {
            handler.callback(fragment);
            return true;
          }
        });
      },
      // Save a fragment into the hash history, or replace the URL state if the
      // 'replace' option is passed. You are responsible for properly URL-encoding
      // the fragment in advance.
      //
      // The options object can contain `trigger: true` if you wish to have the
      // route callback be fired (not usually desirable), or `replace: true`, if
      // you wish to modify the current URL without adding an entry to the history.
      navigate: function(fragment, options2) {
        if (!History.started)
          return false;
        if (!options2 || options2 === true)
          options2 = {
            trigger: !!options2
          };
        fragment = this.getFragment(fragment || "");
        var rootPath = this.root;
        if (fragment === "" || fragment.charAt(0) === "?") {
          rootPath = rootPath.slice(0, -1) || "/";
        }
        var url = rootPath + fragment;
        fragment = fragment.replace(pathStripper, "");
        var decodedFragment = this.decodeFragment(fragment);
        if (this.fragment === decodedFragment)
          return;
        this.fragment = decodedFragment;
        if (this._usePushState) {
          this.history[options2.replace ? "replaceState" : "pushState"]({}, document.title, url);
        } else if (this._wantsHashChange) {
          this._updateHash(this.location, fragment, options2.replace);
          if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
            var iWindow = this.iframe.contentWindow;
            if (!options2.replace) {
              iWindow.document.open();
              iWindow.document.close();
            }
            this._updateHash(iWindow.location, fragment, options2.replace);
          }
        } else {
          return this.location.assign(url);
        }
        if (options2.trigger)
          return this.loadUrl(fragment);
      },
      // Update the hash location, either replacing the current entry, or adding
      // a new one to the browser history.
      _updateHash: function(location2, fragment, replace) {
        if (replace) {
          var href = location2.href.replace(/(javascript:|#).*$/, "");
          location2.replace(href + "#" + fragment);
        } else {
          location2.hash = "#" + fragment;
        }
      }
    });
    Backbone2.history = new History();
    var extend3 = function(protoProps, staticProps) {
      var parent = this;
      var child;
      if (protoProps && _2.has(protoProps, "constructor")) {
        child = protoProps.constructor;
      } else {
        child = function() {
          return parent.apply(this, arguments);
        };
      }
      _2.extend(child, parent, staticProps);
      child.prototype = _2.create(parent.prototype, protoProps);
      child.prototype.constructor = child;
      child.__super__ = parent.prototype;
      return child;
    };
    Model5.extend = Collection3.extend = Router2.extend = View3.extend = History.extend = extend3;
    var urlError = function() {
      throw new Error('A "url" property or function must be specified');
    };
    var wrapError = function(model, options2) {
      var error = options2.error;
      options2.error = function(resp) {
        if (error)
          error.call(options2.context, model, resp, options2);
        model.trigger("error", model, resp, options2);
      };
    };
    return Backbone2;
  });
})(backbone, backbone.exports);
var Backbone = backbone.exports;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/framework/Collection.js
var STATE = "__STATE__";
var FETCH_DATA = "FETCH_DATA";
var PAGINATION_DATA = "PAGINATION_DATA";
var DEFAULT_PARAMS = "DEFAULT_PARAMS";
var LINK_BY_HEADER = "LINK_BY_HEADER";
var XHR = "XHR";
function unquote(value) {
  if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
    return value.substring(1, value.length - 1);
  }
  return value;
}
function parseLinkHeader(header) {
  var linkexp = /<[^>]*>\s*(\s*;\s*[^()<>@,;:"/[\]?={} \t]+=(([^()<>@,;:"/[\]?={} \t]+)|("[^"]*")))*(,|$)/g;
  var paramexp = /[^()<>@,;:"/[\]?={} \t]+=(([^()<>@,;:"/[\]?={} \t]+)|("[^"]*"))/g;
  var matches = header.match(linkexp);
  var rels = {};
  for (var i = 0; i < matches.length; i++) {
    var split = matches[i].split(">");
    var href = split[0].substring(1);
    var link = {
      href: void 0,
      rel: void 0
    };
    link.href = href;
    var s = split[1].match(paramexp);
    for (var j = 0; j < s.length; j++) {
      var paramsplit = s[j].split("=");
      var name = paramsplit[0];
      link[name] = unquote(paramsplit[1]);
    }
    if (link.rel !== void 0) {
      rels[link.rel] = link;
    }
  }
  return rels;
}
function setLinkHeadersPagination(collection, xhr) {
  try {
    var links = parseLinkHeader(xhr.getResponseHeader("link"));
    collection[STATE].set(LINK_BY_HEADER, true);
    collection.setPagination(links["next"].href);
  } catch (e) {
    if (collection[STATE].get(LINK_BY_HEADER)) {
      collection.setPagination(null);
    }
  }
}
function parseQuery(url) {
  var params = {};
  var rawQueryStr = url && url.split("?")[1];
  var queryString = rawQueryStr && decodeURIComponent(rawQueryStr.split("#")[0]).replace(/\+/g, " ");
  var props6 = queryString ? queryString.split("&") : [];
  for (var i = 0; i < props6.length; i++) {
    var parts = props6[i].split("=");
    params[parts.shift()] = parts.join("=");
  }
  return params;
}
var collectionProps = (
  /** @lends src/framework/Collection.prototype */
  {
    /**
     * Default fetch parameters
     * @type {Object|Function}
     */
    params: {},
    preinitialize: function(models, options2) {
      const state = new Backbone.Model();
      const defaultParams = oktaUnderscore.defaults(options2 && options2.params || {}, oktaUnderscore.result(this, "params") || {});
      state.set(DEFAULT_PARAMS, defaultParams);
      this[STATE] = state;
      if (oktaUnderscore.isFunction(this.model) && this.model.length === 0 && this.model.isCourageModel !== true) {
        this.model = oktaUnderscore.result(this, "model");
      }
      Backbone.Collection.prototype.preinitialize.apply(this, arguments);
    },
    /**
     * See [Backbone Collection.sync](http://backbonejs.org/#Collection-sync).
     */
    sync: function(method, collection, options2) {
      var self2 = this;
      var success = options2.success;
      options2.success = function(resp, status, xhr) {
        setLinkHeadersPagination(self2, xhr);
        success.apply(null, arguments);
      };
      return Backbone.Collection.prototype.sync.call(this, method, collection, options2);
    },
    /**
     * See [Backbone Collection.fetch](http://backbonejs.org/#Collection-fetch).
     */
    fetch: function(options2) {
      options2 || (options2 = {});
      var state = this[STATE];
      var xhr = state.get(XHR);
      options2.data = oktaUnderscore.extend({}, state.get(DEFAULT_PARAMS), options2.data || {});
      options2.fromFetch = true;
      state.set(FETCH_DATA, options2.data);
      if (xhr && xhr.abort && options2.abort !== false) {
        xhr.abort();
      }
      xhr = Backbone.Collection.prototype.fetch.call(this, options2);
      state.set(XHR, xhr);
      return xhr;
    },
    /**
     * Set pagination data to get to the next page
     * @param {Mixed} params
     * @param {Object} [options]
     * @param {Boolean} [options.fromFetch] should we include data from the previous fetch call in this object
     * @example
     * collection.setPagination({q: 'foo', page: '2'}); //=> {q: 'foo', page: '2'}
     *
     * collection.setPagination('/path/to/resource?q=baz&page=4'); //=> {q: 'baz', page: '4'}
     *
     * collection.setPagination('/path/to/resource'); //=> {}
     *
     * collection.fetch({data: {q: 'foo'}});
     * collection.setPagination({page: 2}, {fromFetch: true}); //=> {q: 'foo', page: 2}
     *
     * any "falsy" value resets pagination
     * collection.setPagination(); //=> {}
     * collection.setPagination(null); //=> {}
     * collection.setPagination(false); //=> {}
     * collection.setPagination(''); //=> {}
     * collection.setPagination(0); //=> {}
     * @protected
     */
    setPagination: function(params, options2) {
      if (oktaUnderscore.isString(params) && params) {
        params = parseQuery(params);
      }
      if (!oktaUnderscore.isObject(params) || oktaUnderscore.isArray(params) || !oktaUnderscore.size(params)) {
        params = null;
      } else if (options2 && options2.fromFetch) {
        params = oktaUnderscore.extend({}, this.getFetchData(), params);
      }
      this[STATE].set(PAGINATION_DATA, params);
    },
    /**
     * Returns the `data` parameters applied in th most recent `fetch` call
     * It will include parameters set by {@link #params} and optios.params passed to the constructor
     * @return {Object}
     * @protected
     */
    getFetchData: function() {
      return this[STATE].get(FETCH_DATA) || {};
    },
    /**
     * Data object for constructing a request to fetch the next page
     * @return {Object}
     * @protected
     */
    getPaginationData: function() {
      return this[STATE].get(PAGINATION_DATA) || {};
    },
    /**
     * Does this collection have more data on the server (e.g is there a next "page")
     * @return {Boolean}
     */
    hasMore: function() {
      return oktaUnderscore.size(this.getPaginationData()) > 0;
    },
    /**
     * Get the next page from the server
     * @return {Object} xhr returned by {@link #fetch}
     */
    fetchMore: function() {
      if (!this.hasMore()) {
        throw new Error("Invalid Request");
      }
      return this.fetch({
        data: this.getPaginationData(),
        add: true,
        remove: false,
        update: true
      });
    },
    /**
     * See [Backbone Collection.reset](http://backbonejs.org/#Collection-reset).
     */
    reset: function(models, options2) {
      options2 || (options2 = {});
      if (!options2.fromFetch) {
        this.setPagination(null);
      }
      return Backbone.Collection.prototype.reset.apply(this, arguments);
    },
    // we want "where" to be able to search through derived properties as well
    where: function(attrs, first) {
      if (oktaUnderscore.isEmpty(attrs)) {
        return first ? void 0 : [];
      }
      return this[first ? "find" : "filter"](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) {
            return false;
          }
        }
        return true;
      });
    },
    /**
     * See [Backbone Collection.create](http://backbonejs.org/#Collection-create).
     */
    create: function(model, options2) {
      options2 || (options2 = {});
      if (!oktaUnderscore.result(model, "urlRoot")) {
        options2.url = oktaUnderscore.result(this, "url");
      }
      return Backbone.Collection.prototype.create.call(this, model, options2);
    },
    // Use Object.create instead of {} on _byId to avoid __proto__ functions to return
    // This can be removed once the issue has addressed in backbone framework
    // https://github.com/jashkenas/backbone/pull/4225
    _reset: function() {
      Backbone.Collection.prototype["_reset"].call(this);
      this._byId = /* @__PURE__ */ Object.create(null);
    }
  }
);
var Collection = Backbone.Collection.extend(collectionProps);
Collection.isCourageCollection = true;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/models/BaseCollection.js
var baseCollectionProps = (
  /** @lends module:Okta.Collection.prototype */
  {
    /**
     * Is the end point using the legacy "secureJSON" format
     * @type {Function|Boolean}
     */
    secureJSON: false,
    // TODO: may not be simplily moved to initialize as
    // child class override initialize but didn't invoke parent.initialize.
    // need to refactor child classes first.
    constructor: function() {
      Collection.apply(this, arguments);
      if (oktaUnderscore.result(this, "secureJSON")) {
        this.sync = oktaUnderscore.wrap(this.sync, function(sync, method, collection, options2) {
          return sync.call(this, method, collection, oktaUnderscore.extend({
            dataType: "secureJSON"
          }, options2));
        });
      }
    }
  }
);
var BaseCollection = Collection.extend(baseCollectionProps);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/framework/Model.js
function isModelPropertySchema(obj) {
  return obj && obj.type || obj.deps;
}
var Model;
var statics = {
  ERROR_BLANK: "model.validation.field.blank",
  ERROR_WRONG_TYPE: "model.validation.field.wrong.type",
  ERROR_NOT_ALLOWED: "model.validation.field.value.not.allowed",
  ERROR_INVALID: "model.validation.field.invalid",
  ERROR_IARRAY_UNIQUE: "model.validation.field.array.unique",
  ERROR_INVALID_FORMAT_EMAIL: "model.validation.field.invalid.format.email",
  ERROR_INVALID_FORMAT_URI: "model.validation.field.invalid.format.uri",
  ERROR_INVALID_FORMAT_IPV4: "model.validation.field.invalid.format.ipv4",
  ERROR_INVALID_FORMAT_HOSTNAME: "model.validation.field.invalid.format.hostname",
  ERROR_STRING_STRING_MIN_LENGTH: "model.validation.field.string.minLength",
  ERROR_STRING_STRING_MAX_LENGTH: "model.validation.field.string.maxLength"
};
function flatten(value, objectTypeFields, key, target) {
  var filter = oktaUnderscore.contains(objectTypeFields, key);
  target || (target = {});
  if (!filter && oktaUnderscore.isObject(value) && !oktaUnderscore.isArray(value) && !oktaUnderscore.isFunction(value)) {
    oktaUnderscore.each(value, function(val, i) {
      flatten(val, objectTypeFields, key ? key + "." + i : i, target);
    });
  } else if (key !== void 0) {
    target[key] = value;
  }
  return target;
}
function unflatten(data) {
  oktaUnderscore.each(data, function(value, key, data2) {
    if (key.indexOf(".") === -1) {
      return;
    }
    var part;
    var ref = data2;
    var parts = key.split(".");
    while ((part = parts.shift()) !== void 0) {
      if (!ref[part]) {
        ref[part] = parts.length ? {} : value;
      }
      ref = ref[part];
    }
    delete data2[key];
  });
  return data;
}
function createMessage(field, msg) {
  var obj = {};
  obj[field.name] = msg;
  return obj;
}
function normalizeSchemaDef(field, name) {
  var target;
  if (oktaUnderscore.isString(field)) {
    target = {
      type: field
    };
  } else if (oktaUnderscore.isArray(field)) {
    target = {
      type: field[0],
      required: field[1],
      value: field[2]
    };
  } else {
    target = oktaUnderscore.clone(field);
  }
  oktaUnderscore.defaults(target, {
    required: false,
    name
  });
  return target;
}
function capitalize(string) {
  return string.toLowerCase().replace(/\b[a-z]/g, function(letter) {
    return letter.toUpperCase();
  });
}
function _validateRegex(value, pattern, error) {
  if (!pattern.test(value)) {
    return error;
  }
}
var StringFormatValidators = {
  /*eslint max-len: 0 */
  email: function(value) {
    var pattern = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_EMAIL);
  },
  uri: function(value) {
    var pattern = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i;
    return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_URI);
  },
  ipv4: function(value) {
    var pattern = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_IPV4);
  },
  hostname: function(value) {
    var pattern = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$/;
    return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_HOSTNAME);
  }
};
function validateStringFormat(field, value) {
  var validator = StringFormatValidators[field.format];
  if (field.format && !validator) {
    throw new TypeError(field.format + " is not a supported string format");
  }
  return validator && validator(value);
}
function validateString(field, value) {
  var createMessageWith = oktaUnderscore.partial(createMessage, field);
  var invalidFormat = validateStringFormat(field, value);
  if (invalidFormat) {
    return createMessageWith(invalidFormat);
  }
  if (value && field.minLength && value.length < field.minLength) {
    return createMessageWith(Model.ERROR_STRING_STRING_MIN_LENGTH);
  }
  if (value && field.maxLength && value.length > field.maxLength) {
    return createMessageWith(Model.ERROR_STRING_STRING_MAX_LENGTH);
  }
}
function validateField(field, value) {
  var createMessageWith = oktaUnderscore.partial(createMessage, field);
  var isDefined = !oktaUnderscore.isUndefined(value) && !oktaUnderscore.isNull(value);
  var checkType;
  var errorMessage;
  if (Array.isArray(field.validate)) {
    const output = [];
    let foundError = false;
    let result2;
    field.validate.forEach((item) => {
      if (!value) {
        result2 = false;
      } else {
        switch (item.type.toLowerCase()) {
          case "regex":
            result2 = new RegExp(item.value.pattern, item.value.flags || "").test(value);
            break;
          default:
            result2 = false;
        }
      }
      foundError = foundError || !result2;
      output.push({
        // eslint-disable-next-line no-prototype-builtins
        message: item.hasOwnProperty("message") ? item.message : "",
        passed: result2
      });
    });
    if (foundError) {
      return createMessageWith(output);
    }
    return;
  }
  if (field.required && (!isDefined || oktaUnderscore.isNull(value) || value === "")) {
    return createMessageWith(Model.ERROR_BLANK);
  }
  checkType = oktaUnderscore["is" + capitalize(field.type)];
  if (isDefined && field.type !== "any" && (!oktaUnderscore.isFunction(checkType) || !checkType(value))) {
    return createMessageWith(Model.ERROR_WRONG_TYPE);
  }
  if (value && field.type === "string") {
    var error = validateString(field, value);
    if (error) {
      return error;
    }
  }
  if (isDefined && field.values && !oktaUnderscore.contains(field.values, value)) {
    return createMessageWith(Model.ERROR_NOT_ALLOWED);
  }
  if (oktaUnderscore.isFunction(field.validate)) {
    var result = field.validate(value);
    if (oktaUnderscore.isString(result) && result) {
      return createMessageWith(result);
    } else if (result === false) {
      return createMessageWith(Model.ERROR_INVALID);
    }
  }
  if (isDefined && field.type === "array" && (errorMessage = validateArrayField(field, value))) {
    return createMessageWith(errorMessage);
  }
}
function validateArrayField(field, arr) {
  if (field.minItems && arr.length < field.minItems) {
    return "model.validation.field.array.minItems";
  } else if (field.maxItems && arr.length > field.maxItems) {
    return "model.validation.field.array.maxItems";
  } else if (field.uniqueItems && arr.length > oktaUnderscore.uniq(arr).length) {
    return Model.ERROR_IARRAY_UNIQUE;
  } else if (field.items) {
    var arrayField = normalizeSchemaDef(field.items, "placeholder");
    for (var i = 0; i < arr.length; i++) {
      var value = arr[i];
      var error = validateField(arrayField, value);
      if (error) {
        return error["placeholder"];
      }
    }
  }
}
var props = (
  /** @lends src/framework/Model.prototype */
  {
    /**
       * Pass props as an object to extend, describing the observable properties of your model. The props
       * properties should not be set on an instance, as this won't define new properties, they should only be passed to
       * extend.
       * Properties can be defined in three different ways:
       *
       * - As a string with the expected dataType. One of string, number, boolean, array, object, date, or any.
       * Eg: `name: 'string'`.
       * - An array of `[dataType, required, default]`
       * - An object `{type: 'string', format: '', required: true, value: '', values: [], validate: function() {}`
       *   - `value` will be the value that the property will be set to if it is undefined, either by not being set during
       *   initialization, or by being explicitly set to undefined.
       *   - `format` is a json-schame derived string format. Supported formats are: `email`, `uri`, `hostname` and `ipv4`.
       *   - If `required` is true, one of two things will happen. If a default is set for the property, the property will
       *   start with that value. If a default is not set for the property, validation will fail
       *   - If `values` array is passed, then you'll be able to change a property to one of those values only.
       *   - If `validate` is defined, it should return false or a custom message string when the validation fails.
       *   - If the type is defined as `array`, the array elements could be defined by `minItems` (Number),
       *   `uniqueItems` (Boolean) and `items` (a field definition such as this one that will validate each array member)
       *   To the `validate` method
       *   - Trying to set a property to an invalid type will raise an exception.
       *
       * @type {Mixed|Function}
       * @example
       * var Person = Model.extend({
       *   props: {
       *     name: 'string',
       *     age: 'number',
       *     paying: ['boolean', true, false], //required attribute, defaulted to false
       *     type: {
       *       type: 'string',
       *       values: ['regular-hero', 'super-hero', 'mega-hero']
       *     },
       *     likes: {
       *       type: 'string',
       *       validate: function (value) {
       *         return /^[\w]+ing$/.test(value)
       *       }
       *     }
       *   }
       * });
       */
    props: {},
    /**
       * Derived properties (also known as computed properties) are properties of the model that depend on the
       * other (props, local or even derived properties to determine their value. Best demonstrated with an example:
       *
       * Each derived property, is defined as an object with the current properties:
       *
       * - `deps` {Array} - An array of property names which the derived property depends on.
       * - `fn` {Function} - A function which returns the value of the computed property. It is called in the context of
       * the current object, so that this is set correctly.
       * - `cache` {Boolean} -  - Whether to cache the property. Uncached properties are computed every time they are
       * accessed. Useful if it depends on the current time for example. Defaults to `true`.
       *
       * Derived properties are retrieved and fire change events just like any other property. They cannot be set
       * directly.
       * @type {Object|Function}
       * @example
       * var Person = Model.extend({
       *   props: {
       *     firstName: 'string',
       *     lastName: 'string'
       *   },
       *   derived: {
       *     fullName: {
       *       deps: ['firstName', 'lastName'],
       *       fn: function (firstName, lastName) {
       *         return firstName + ' ' + lastName;
       *       }
       *     }
       *   }
       * });
       *
       * var person = new Person({ firstName: 'Phil', lastName: 'Roberts' })
       * console.log(person.get('fullName')) //=> "Phil Roberts"
       *
       * person.set('firstName', 'Bob');
       * console.log(person.get('fullName')) //=> "Bob Roberts"
       */
    derived: {},
    /**
       * local properties are defined and work in exactly the same way as {@link src/framework/Model#props|props}, but generally only exist for
       * the lifetime of the page.
       * They would not typically be persisted to the server, and are not returned by calls to {@link src/framework/Model#toJSON|toJSON}.
       *
       * @type {Object|Function}
       * @example
       * var Person = Model.extend({
       *   props: {
       *     name: 'string',
       *   },
       *   local: {
       *     isLoggedIn: 'boolean'
       *   }
       * );
       */
    local: {},
    /**
       * Flatten the payload into dot notation string keys:
       *
       * @type {Boolean|Function}
       * @example
       * var Person = Model.extend({
       *   props: {
       *     'profile.fname': 'string',
       *     'profile.lname': 'string',
       *     'profile.languages': 'object'
       *   },
       *   flat: true
       * });
       * var person = new Person({'profile': {
       *                            'fname': 'John',
       *                            'lname': 'Doe',
       *                            'languages': {name: "English", value: "EN"}
       *                         }}, {parse: true});
       * person.get('profile'); //=> undefined
       * person.get('profile.fname'); //=> 'John'
       * person.get('profile.lname'); //=> 'Doe'
       * person.get('profile.languages'); //=> {name: "English", value: "EN"}
       * person.get('profile.languages.name'); //=> undefined
       * person.toJSON(); //=> {'profile': {'fname': 'John'} }
       */
    flat: true,
    /**
       * @deprecated
       * @alias Backbone.Model#defaults
       */
    defaults: {},
    // FIXME: preinitialize takes parameter `attributes` and `options`, which inherit from constructor.
    preinitialize: function(options2, ...rest) {
      this.options = options2 || {};
      var schema = this["__schema__"] = {};
      var objectTypeFields = [];
      schema.computedProperties = {};
      schema.props = oktaUnderscore.clone(oktaUnderscore.result(this, "props") || {});
      schema.derived = oktaUnderscore.clone(oktaUnderscore.result(this, "derived") || {});
      schema.local = oktaUnderscore.clone(oktaUnderscore.result(this, "local") || {});
      var defaults2 = {};
      oktaUnderscore.each(oktaUnderscore.extend({}, schema.props, schema.local), function(options3, name) {
        var schemaDef = normalizeSchemaDef(options3, name);
        if (!oktaUnderscore.isUndefined(schemaDef.value)) {
          defaults2[name] = schemaDef.value;
        }
        if (schemaDef.type === "object") {
          objectTypeFields.push(name);
        }
      }, this);
      if (oktaUnderscore.size(defaults2)) {
        var localDefaults = oktaUnderscore.result(this, "defaults");
        this.defaults = function() {
          return oktaUnderscore.defaults({}, defaults2, localDefaults);
        };
      }
      this.validate = oktaUnderscore.wrap(this.validate, function(validate) {
        var args = oktaUnderscore.rest(arguments);
        var res = oktaUnderscore.extend(this._validateSchema.apply(this, args), validate.apply(this, args));
        return oktaUnderscore.size(res) && res || void 0;
      });
      this.parse = oktaUnderscore.wrap(this.parse, function(parse) {
        var target = parse.apply(this, oktaUnderscore.rest(arguments));
        if (oktaUnderscore.result(this, "flat")) {
          target = flatten(target, objectTypeFields);
        }
        return target;
      });
      Backbone.Model.prototype.preinitialize.call(this, options2, ...rest);
    },
    // FIXME:
    // constructor takes parameter `attributes` and `options`.
    constructor: function() {
      Backbone.Model.apply(this, arguments);
      var schema = this["__schema__"];
      oktaUnderscore.each(schema.derived, function(options2, name) {
        schema.computedProperties[name] = this.__getDerivedValue(name);
        var deps = isModelPropertySchema(options2) ? options2.deps || [] : [];
        if (deps.length) {
          this.on("cache:clear change:" + deps.join(" change:"), function() {
            var value = this.__getDerivedValue(name);
            if (value !== schema.computedProperties[name]) {
              schema.computedProperties[name] = value;
              this.trigger("change:" + name, this, value);
            }
          }, this);
        }
      }, this);
      this.on("sync", function() {
        this.__syncedData = this.toJSON();
      }, this);
    },
    validate: function() {
    },
    /**
       * Check if the schema settings allow this field to exist in the model
       * @param  {String} key
       * @return {Boolean}
       */
    allows: function(key) {
      var schema = this["__schema__"];
      var all = oktaUnderscore.extend({}, schema.props, schema.local);
      if (!oktaUnderscore.has(all, key))
        ;
      return true;
    },
    /**
       * Returns the schema for the specific property
       *
       * @param propName - The name of the property
       * @returns {*} | null
       */
    getPropertySchema: function(propName) {
      var schema = this["__schema__"];
      return oktaUnderscore.reduce([schema.props, schema.local], function(result, options2) {
        return result || normalizeSchemaDef(options2[propName], propName);
      }, null);
    },
    set: function(key, val) {
      var attrs;
      if (typeof key === "object") {
        attrs = key;
      } else {
        (attrs = {})[key] = val;
      }
      oktaUnderscore.each(attrs, function(value, key2) {
        if (oktaUnderscore.has(this["__schema__"].derived, key2)) {
          throw new Error(`overriding derived properties is not supported: ${key2}`);
        }
      }, this);
      var errorFields = [];
      oktaUnderscore.each(attrs, function(value, key2) {
        this.allows(key2) || errorFields.push(key2);
      }, this);
      if (errorFields.length) {
        throw new Error(`field not allowed: ${errorFields.join(", ")}`);
      }
      return Backbone.Model.prototype.set.apply(this, arguments);
    },
    get: function(attr) {
      var schema = this["__schema__"];
      if (oktaUnderscore.has(schema.derived, attr)) {
        if (schema.derived[attr].cache !== false) {
          return schema.computedProperties[attr];
        } else {
          return this.__getDerivedValue(attr);
        }
      }
      return Backbone.Model.prototype.get.apply(this, arguments);
    },
    /**
       * Return a shallow copy of the model's attributes for JSON stringification.
       * This can be used for persistence, serialization, or for augmentation before being sent to the server.
       * The name of this method is a bit confusing, as it doesn't actually return a JSON string —
       * but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.
       *
       * See [Backbone.Model.toJSON](http://backbonejs.org/#Model-toJSON)
       *
       * @param  {Object} options
       * @return {Object}
       * @example
       * var artist = new Model({
       *   firstName: 'Wassily',
       *   lastName: 'Kandinsky'
       * });
       *
       * artist.set({birthday: 'December 16, 1866'});
       * JSON.stringify(artist); //=> {'firstName':'Wassily','lastName':'Kandinsky','birthday':'December 16, 1866'}
       */
    toJSON: function(options2) {
      options2 || (options2 = {});
      var res = oktaUnderscore.clone(Backbone.Model.prototype.toJSON.apply(this, arguments));
      var schema = this["__schema__"];
      if (!options2.verbose) {
        res = oktaUnderscore.omit(res, oktaUnderscore.keys(schema.local));
      } else {
        oktaUnderscore.each(schema.derived, function(options3, name) {
          res[name] = this.get(name);
        }, this);
      }
      if (this.flat) {
        res = unflatten(res);
      }
      return res;
    },
    /**
       * Removes all attributes from the model, including the id attribute.
       * Fires a `"change"` event unless `silent` is passed as an option.
       * Sets the default values to the model
       * @param {Object} [options]
       */
    reset: function(options2) {
      this.clear(options2);
      this.set(oktaUnderscore.result(this, "defaults"), options2);
    },
    /**
       * Is the data on the model has local modifications since the last sync event?
       * @return {Boolean} is the model in sync with the server
       */
    isSynced: function() {
      return oktaUnderscore.isEqual(this.__syncedData, this.toJSON());
    },
    /**
       * validate a specific field in the model.
       * @param  {String} key
       * @return {Object} returns `{fieldName: errorMessage}` if invalid, otherwise undefined.
       * @readonly
       */
    validateField: function(key) {
      var schema = key && this.getPropertySchema(key);
      return schema && validateField(schema, this.get(key));
    },
    /**
       * Runs local schema validation. Invoked internally by {@link src/framework/Model#validate|validate}.
       * @return {Object}
       * @protected
       */
    _validateSchema: function() {
      var schema = this["__schema__"];
      return oktaUnderscore.reduce(oktaUnderscore.extend({}, schema.props, schema.local), function(memo, options2, name) {
        return oktaUnderscore.extend(memo, this.validateField(name) || {});
      }, {}, this);
    },
    __getDerivedValue: function(name) {
      var options2 = this["__schema__"].derived[name];
      if (oktaUnderscore.isString(options2)) {
        var key = options2;
        options2 = {
          deps: [key],
          fn: function() {
            return this.get(key);
          }
        };
      }
      var deps = options2.deps || [];
      return options2.fn.apply(this, oktaUnderscore.map(deps, this.get, this));
    }
  }
);
Model = Backbone.Model.extend(props, statics);
Model.isCourageModel = true;
var FrameworkModel = Model;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/models/Model.js
var Model2 = FrameworkModel.extend(
  /** @lends module:Okta.Model.prototype */
  {
    /**
     * Is the end point using the legacy "secureJSON" format
     * @type {Function|Boolean}
     */
    secureJSON: false,
    _builtInLocalProps: {
      __edit__: "boolean",
      __pending__: "boolean"
    },
    preinitialize: function() {
      this.local = oktaUnderscore.defaults({}, oktaUnderscore.result(this, "local"), this._builtInLocalProps);
      FrameworkModel.prototype.preinitialize.apply(this, arguments);
    },
    constructor: function() {
      FrameworkModel.apply(this, arguments);
      if (oktaUnderscore.result(this, "secureJSON")) {
        this.sync = oktaUnderscore.wrap(this.sync, function(sync, method, model, options2) {
          return sync.call(this, method, model, oktaUnderscore.extend({
            dataType: "secureJSON"
          }, options2));
        });
      }
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/models/BaseModel.js
var hasProps = function(model) {
  const local3 = oktaUnderscore.omit(model.local, oktaUnderscore.keys(model._builtInLocalProps));
  return oktaUnderscore.size(model.props) + oktaUnderscore.size(local3) > 0;
};
var props2 = (
  /** @lends module:Okta.BaseModel.prototype */
  {
    /**
     * @type {Boolean}
     */
    flat: false,
    constructor: function() {
      Model2.apply(this, arguments);
      this.on("sync", this._setSynced);
    },
    allows: function() {
      if (hasProps(this)) {
        return Model2.prototype.allows.apply(this, arguments);
      } else {
        return true;
      }
    },
    // bw compatibility support for old computed properties
    set: function(key, val) {
      let attrs;
      if (typeof key === "object") {
        attrs = key;
      } else {
        (attrs = {})[key] = val;
      }
      oktaUnderscore(attrs).each(function(fn11, attr) {
        if (!fn11 || !oktaUnderscore.isArray(fn11.__attributes)) {
          return;
        }
        this.on("change:" + fn11.__attributes.join(" change:"), function() {
          const val2 = this.get(attr);
          if (val2 !== this["__schema__"].computedProperties[attr]) {
            this["__schema__"].computedProperties[attr] = val2;
            this.trigger("change:" + attr, val2);
          }
        }, this);
      }, this);
      return Model2.prototype.set.apply(this, arguments);
    },
    /**
     * Get the current value of an attribute from the model. For example: `note.get("title")`
     *
     * See [Model.get](http://backbonejs.org/#Model-get)
     * @param {String} attribute
     * @return {Mixed} The value of the model attribute
     */
    get: function() {
      const value = Model2.prototype.get.apply(this, arguments);
      if (oktaUnderscore.isFunction(value)) {
        return value.apply(this, oktaUnderscore.map(value.__attributes || [], this.get, this));
      }
      return value;
    },
    /**
     * Return a shallow copy of the model's attributes for JSON stringification.
     * This can be used for persistence, serialization, or for augmentation before being sent to the server.
     * The name of this method is a bit confusing, as it doesn't actually return a JSON string —
     *  but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.
     *
     * ```javascript
     * var artist = new Model({
     *   firstName: "Wassily",
     *   lastName: "Kandinsky"
     * });
     *
     * artist.set({birthday: "December 16, 1866"});
     * alert(JSON.stringify(artist)); // {"firstName":"Wassily","lastName":"Kandinsky","birthday":"December 16, 1866"}
     * ```
     * See [Model.toJSON](http://backbonejs.org/#Model-toJSON)
     * @param  {Object} options
     * @return {Object}
     */
    toJSON: function(options2) {
      options2 || (options2 = {});
      const res = Model2.prototype.toJSON.apply(this, arguments);
      oktaUnderscore(res).each(function(value, key) {
        if (typeof value === "function") {
          if (options2.verbose) {
            res[key] = this.get(key);
          } else {
            delete res[key];
          }
        }
      }, this);
      if (!options2.verbose) {
        oktaUnderscore(res).each(function(value, key) {
          if (/^__\w+__$/.test(key)) {
            delete res[key];
          }
        });
      }
      return res;
    },
    sanitizeAttributes: function(attributes2) {
      const attrs = {};
      oktaUnderscore.each(attributes2, function(value, key) {
        if (!oktaUnderscore.isFunction(value)) {
          attrs[key] = value;
        }
      });
      return attrs;
    },
    reset: function(options2) {
      this.clear(options2);
      this.set(this.sanitizeAttributes(this.defaults), options2);
    },
    clear: function(options2) {
      const attrs = {};
      oktaUnderscore.each(this.sanitizeAttributes(this.attributes), function(value, key) {
        attrs[key] = void 0;
      });
      return this.set(attrs, oktaUnderscore.extend({}, options2, {
        unset: true
      }));
    },
    /**
     * @private
     */
    _setSynced: function(newModel) {
      this._syncedData = newModel && oktaUnderscore.isFunction(newModel.toJSON) ? newModel.toJSON() : {};
    },
    /**
     * @private
     */
    _getSynced: function() {
      return this._syncedData;
    },
    isSynced: function() {
      return oktaUnderscore.isEqual(this._getSynced(), this.toJSON());
    }
  }
);
var statics2 = (
  /** @lends module:Okta.BaseModel.prototype */
  {
    /**
     * @static
     *
     * Example:
     *
     * ```javascript
     * var Model = BaseModel.extend({
     *   defaults: {
     *     name: BaseModel.ComputedProperty(['fname', 'lname'], function (fname, lname) {
     *       return fname + ' ' + lname;
     *     })
     *   }
     * });
     * var model = new Model({fname: 'Joe', lname: 'Doe'});
     * model.get('name'); // Joe Doe
     * model.toJSON(); // {fname: 'Joe', lname: 'Doe'}
     * ```
     *
     * @param {Array} attributes (optional) - an array of the attribute names this method depends on
     * @param {Function} callback the function that computes the value of the property
     *
     * @deprecated Use {@link #derived} instead
     */
    ComputedProperty: function(attributes2, fn11) {
      if (!fn11 && typeof attributes2 === "function") {
        fn11 = attributes2;
      } else {
        fn11.__attributes = attributes2;
      }
      return fn11;
    }
  }
);
var BaseModel = Model2.extend(props2, statics2);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/jquery-wrapper.js
jQuery.ajaxSetup({
  beforeSend: function(xhr) {
    xhr.setRequestHeader("X-Okta-XsrfToken", jQuery("#_xsrfToken").text());
  },
  converters: {
    "text secureJSON": function(str) {
      if (str.substring(0, 11) === "while(1){};") {
        str = str.substring(11);
      }
      return JSON.parse(str);
    }
  }
});
var oktaJQueryStatic = jQuery;
window.jQueryCourage = oktaJQueryStatic;

// node_modules/@okta/okta-signin-widget/dist/esm/src/config/config.json.js
var defaultLanguage = "en";
var version = "6.9.0";
var supportedLanguages = [
  "en",
  "cs",
  "da",
  "de",
  "el",
  "es",
  "fi",
  "fr",
  "hu",
  "id",
  "in",
  "it",
  "ja",
  "ko",
  "ms",
  "nb",
  "nl-NL",
  "ok-PL",
  "pl",
  "pt-BR",
  "ro",
  "ru",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-TW"
];
var config = {
  defaultLanguage,
  version,
  supportedLanguages
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Bundles.js
var import_cross_fetch = __toESM(require_browser_ponyfill());

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/i18n/src/json/country.json.js
var AF = "Afghanistan";
var AX = "Åland Islands";
var AL = "Albania";
var DZ = "Algeria";
var AS = "American Samoa";
var AD = "Andorra";
var AO = "Angola";
var AI = "Anguilla";
var AQ = "Antarctica";
var AG = "Antigua and Barbuda";
var AR = "Argentina";
var AM = "Armenia";
var AW = "Aruba";
var AU = "Australia";
var AT = "Austria";
var AZ = "Azerbaijan";
var BS = "Bahamas";
var BH = "Bahrain";
var BD = "Bangladesh";
var BB = "Barbados";
var BY = "Belarus";
var BE = "Belgium";
var BZ = "Belize";
var BJ = "Benin";
var BM = "Bermuda";
var BT = "Bhutan";
var BO = "Bolivia, Plurinational State of";
var BA = "Bosnia and Herzegovina";
var BW = "Botswana";
var BV = "Bouvet Island";
var BR = "Brazil";
var IO = "British Indian Ocean Territory";
var VG = "Virgin Islands, British";
var BN = "Brunei Darussalam";
var BG = "Bulgaria";
var BF = "Burkina Faso";
var BI = "Burundi";
var KH = "Cambodia";
var CM = "Cameroon";
var CA = "Canada";
var CV = "Cape Verde";
var KY = "Cayman Islands";
var CF = "Central African Republic";
var TD = "Chad";
var CL = "Chile";
var CN = "China";
var CX = "Christmas Island";
var CO = "Colombia";
var KM = "Comoros";
var CG = "Congo";
var CK = "Cook Islands";
var CR = "Costa Rica";
var CI = "Côte d'Ivoire";
var HR = "Croatia";
var CU = "Cuba";
var CY = "Cyprus";
var CZ = "Czech Republic";
var CD = "Congo, the Democratic Republic of the";
var DK = "Denmark";
var DJ = "Djibouti";
var DM = "Dominica";
var DO = "Dominican Republic";
var TL = "Timor-Leste";
var EC = "Ecuador";
var EG = "Egypt";
var SV = "El Salvador";
var GQ = "Equatorial Guinea";
var ER = "Eritrea";
var EE = "Estonia";
var ET = "Ethiopia";
var FK = "Falkland Islands (Malvinas)";
var FO = "Faroe Islands";
var FJ = "Fiji";
var FI = "Finland";
var FR = "France";
var GF = "French Guiana";
var PF = "French Polynesia";
var TF = "French Southern Territories";
var GA = "Gabon";
var GM = "Gambia";
var GE = "Georgia";
var DE = "Germany";
var GH = "Ghana";
var GI = "Gibraltar";
var GR = "Greece";
var GL = "Greenland";
var GD = "Grenada";
var GP = "Guadeloupe";
var GU = "Guam";
var GT = "Guatemala";
var GG = "Guernsey";
var GN = "Guinea";
var GW = "Guinea-Bissau";
var GY = "Guyana";
var HT = "Haiti";
var HM = "Heard Island and McDonald Islands";
var HN = "Honduras";
var HK = "Hong Kong";
var HU = "Hungary";
var IS = "Iceland";
var IN = "India";
var ID = "Indonesia";
var IR = "Iran, Islamic Republic of";
var IQ = "Iraq";
var IE = "Ireland";
var IL = "Israel";
var IT = "Italy";
var JM = "Jamaica";
var JP = "Japan";
var JE = "Jersey";
var JO = "Jordan";
var KZ = "Kazakhstan";
var KE = "Kenya";
var KI = "Kiribati";
var KR = "Korea, Republic of";
var XK = "Kosovo, Republic of";
var KW = "Kuwait";
var KG = "Kyrgyzstan";
var LA = "Lao People's Democratic Republic";
var LV = "Latvia";
var LB = "Lebanon";
var LS = "Lesotho";
var LR = "Liberia";
var LY = "Libya";
var LI = "Liechtenstein";
var LT = "Lithuania";
var LU = "Luxembourg";
var MO = "Macao";
var MK = "Macedonia, the former Yugoslav Republic of";
var MG = "Madagascar";
var MW = "Malawi";
var MY = "Malaysia";
var MV = "Maldives";
var ML = "Mali";
var MT = "Malta";
var MH = "Marshall Islands";
var MQ = "Martinique";
var MR = "Mauritania";
var MU = "Mauritius";
var YT = "Mayotte";
var MX = "Mexico";
var FM = "Micronesia, Federated States of";
var MD = "Moldova, Republic of";
var MC = "Monaco";
var MN = "Mongolia";
var ME = "Montenegro";
var MS = "Montserrat";
var MA = "Morocco";
var MZ = "Mozambique";
var MM = "Myanmar";
var NA = "Namibia";
var NR = "Nauru";
var NP = "Nepal";
var NL = "Netherlands";
var AN = "Netherlands Antilles";
var NC = "New Caledonia";
var NZ = "New Zealand";
var NI = "Nicaragua";
var NE = "Niger";
var NG = "Nigeria";
var NU = "Niue";
var NF = "Norfolk Island";
var KP = "Korea, Democratic People's Republic of";
var MP = "Northern Mariana Islands";
var NO = "Norway";
var OM = "Oman";
var PK = "Pakistan";
var PW = "Palau";
var PS = "Palestine, State of";
var PA = "Panama";
var PG = "Papua New Guinea";
var PY = "Paraguay";
var PE = "Peru";
var PH = "Philippines";
var PN = "Pitcairn";
var PL = "Poland";
var PT = "Portugal";
var PR = "Puerto Rico";
var QA = "Qatar";
var RE = "Réunion";
var RO = "Romania";
var RU = "Russian Federation";
var RW = "Rwanda";
var SH = "Saint Helena, Ascension and Tristan da Cunha";
var KN = "Saint Kitts and Nevis";
var LC = "Saint Lucia";
var PM = "Saint Pierre and Miquelon";
var VC = "Saint Vincent and the Grenadines";
var WS = "Samoa";
var SM = "San Marino";
var ST = "São Tomé and Príncipe";
var SA = "Saudi Arabia";
var SN = "Senegal";
var RS = "Serbia";
var SC = "Seychelles";
var SL = "Sierra Leone";
var SG = "Singapore";
var SK = "Slovakia";
var SI = "Slovenia";
var SB = "Solomon Islands";
var SO = "Somalia";
var ZA = "South Africa";
var GS = "South Georgia and the South Sandwich Islands";
var SS = "South Sudan";
var ES = "Spain";
var LK = "Sri Lanka";
var SD = "Sudan";
var SR = "Suriname";
var SJ = "Svalbard and Jan Mayen";
var SZ = "Swaziland";
var SE = "Sweden";
var CH = "Switzerland";
var SY = "Syrian Arab Republic";
var TW = "Taiwan";
var TJ = "Tajikistan";
var TZ = "Tanzania, United Republic of";
var TH = "Thailand";
var TG = "Togo";
var TK = "Tokelau";
var TO = "Tonga";
var TT = "Trinidad and Tobago";
var TN = "Tunisia";
var TR = "Turkey";
var TM = "Turkmenistan";
var TC = "Turks and Caicos Islands";
var TV = "Tuvalu";
var VI = "Virgin Islands, U.S.";
var UG = "Uganda";
var UA = "Ukraine";
var AE = "United Arab Emirates";
var GB = "United Kingdom";
var US = "United States";
var UM = "United States Minor Outlying Islands";
var UY = "Uruguay";
var UZ = "Uzbekistan";
var VU = "Vanuatu";
var VA = "Holy See (Vatican City State)";
var VE = "Venezuela, Bolivarian Republic of";
var VN = "Viet Nam";
var WF = "Wallis and Futuna";
var EH = "Western Sahara";
var YE = "Yemen";
var ZM = "Zambia";
var ZW = "Zimbabwe";
var country = {
  AF,
  AX,
  AL,
  DZ,
  AS,
  AD,
  AO,
  AI,
  AQ,
  AG,
  AR,
  AM,
  AW,
  AU,
  AT,
  AZ,
  BS,
  BH,
  BD,
  BB,
  BY,
  BE,
  BZ,
  BJ,
  BM,
  BT,
  BO,
  BA,
  BW,
  BV,
  BR,
  IO,
  VG,
  BN,
  BG,
  BF,
  BI,
  KH,
  CM,
  CA,
  CV,
  KY,
  CF,
  TD,
  CL,
  CN,
  CX,
  CO,
  KM,
  CG,
  CK,
  CR,
  CI,
  HR,
  CU,
  CY,
  CZ,
  CD,
  DK,
  DJ,
  DM,
  DO,
  TL,
  EC,
  EG,
  SV,
  GQ,
  ER,
  EE,
  ET,
  FK,
  FO,
  FJ,
  FI,
  FR,
  GF,
  PF,
  TF,
  GA,
  GM,
  GE,
  DE,
  GH,
  GI,
  GR,
  GL,
  GD,
  GP,
  GU,
  GT,
  GG,
  GN,
  GW,
  GY,
  HT,
  HM,
  HN,
  HK,
  HU,
  IS,
  IN,
  ID,
  IR,
  IQ,
  IE,
  IL,
  IT,
  JM,
  JP,
  JE,
  JO,
  KZ,
  KE,
  KI,
  KR,
  XK,
  KW,
  KG,
  LA,
  LV,
  LB,
  LS,
  LR,
  LY,
  LI,
  LT,
  LU,
  MO,
  MK,
  MG,
  MW,
  MY,
  MV,
  ML,
  MT,
  MH,
  MQ,
  MR,
  MU,
  YT,
  MX,
  FM,
  MD,
  MC,
  MN,
  ME,
  MS,
  MA,
  MZ,
  MM,
  NA,
  NR,
  NP,
  NL,
  AN,
  NC,
  NZ,
  NI,
  NE,
  NG,
  NU,
  NF,
  KP,
  MP,
  NO,
  OM,
  PK,
  PW,
  PS,
  PA,
  PG,
  PY,
  PE,
  PH,
  PN,
  PL,
  PT,
  PR,
  QA,
  RE,
  RO,
  RU,
  RW,
  SH,
  KN,
  LC,
  PM,
  VC,
  WS,
  SM,
  ST,
  SA,
  SN,
  RS,
  SC,
  SL,
  SG,
  SK,
  SI,
  SB,
  SO,
  ZA,
  GS,
  SS,
  ES,
  LK,
  SD,
  SR,
  SJ,
  SZ,
  SE,
  CH,
  SY,
  TW,
  TJ,
  TZ,
  TH,
  TG,
  TK,
  TO,
  TT,
  TN,
  TR,
  TM,
  TC,
  TV,
  VI,
  UG,
  UA,
  AE,
  GB,
  US,
  UM,
  UY,
  UZ,
  VU,
  VA,
  VE,
  VN,
  WF,
  EH,
  YE,
  ZM,
  ZW
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/i18n/src/json/login.json.js
var signout = "Sign Out";
var signin = "Sign In";
var signup = "Sign Up";
var remember = "Remember me";
var rememberDevice = "Trust this device";
var autoPush = "Send push automatically";
var unlockaccount = "Unlock account?";
var haveaccount = "Already have an account?";
var needhelp = "Need help signing in?";
var forgotpassword = "Forgot password?";
var help = "Help";
var retry = "Retry";
var iphone = "iPhone";
var android = "Android";
var goback = "Back to sign in";
var closeWindow = "You can close this window";
var minutes = "{0} minutes";
var hours = "{0} hours";
var days = "{0} days";
var tagsNotAllowed = "The field must not contain HTML tags";
var E0000010 = "Server is unable to respond at the moment.";
var login = {
  signout,
  signin,
  signup,
  remember,
  rememberDevice,
  "rememberDevice.timebased": "Do not challenge me on this device for the next {0}",
  "rememberDevice.devicebased": "Do not challenge me on this device again",
  autoPush,
  unlockaccount,
  haveaccount,
  needhelp,
  forgotpassword,
  help,
  retry,
  iphone,
  android,
  goback,
  closeWindow,
  "country.label": "Country",
  "country.option.label": "{0} ({1})",
  "phone.extention.label": "Extension",
  "select.default_value": "Select an option",
  "select.filter.no_match": 'No results found for "{0}"',
  "sensitive.input.show": "Show",
  "sensitive.input.hide": "Hide",
  "processing.alt.text": "Processing...",
  "skip.to.main.content": "Skip to main content",
  "minutes.oneMinute": "minute",
  minutes,
  hours,
  days,
  "error.config": "There was a configuration error",
  "error.required.authParams": 'Missing parameters for the configured authentication scheme - "OAUTH2"',
  "error.required.baseUrl": '"baseUrl" is a required widget parameter',
  "error.required.success": "A success handler is required",
  "error.required.el": '"el" is a required widget parameter',
  "error.invalid.colors.brand": '"colors.brand" must be in six-digit hex format',
  "error.unsupported.browser": "Unsupported browser",
  "error.unsupported.cors": "Unsupported browser - missing CORS support",
  "error.unsupported.localStorage": "Unsupported browser - missing localStorage support",
  "error.enabled.cors": "There was an error sending the request - have you enabled CORS?",
  "error.expired.session": "Your session has expired. Please try to sign in again.",
  "error.mfa.only.expired.session": "Unable to authenticate at this time.",
  "error.auth.lockedOut": "Your account is locked. Please contact your administrator.",
  "error.oauth.idToken": "There was a problem generating the id_token for the user. Please try again.",
  "error.network.connection": "Unable to connect to the server. Please check your network connection.",
  "error.username.required": "Please enter a username",
  "error.password.required": "Please enter a password",
  "error.mfa.required": "The current sign on policy requires this client to redirect for re-authentication or MFA. Please contact your administrator.",
  "error.unsupported.response": "There was an unsupported response from server.",
  "error.jit_failure": "Unable to sign in, please try another sign in method.",
  "error.unsynced.clock": "Unable to sign in. Please check that your device's clock is accurate and try again.",
  "errors.E0000004": "Unable to sign in",
  "errors.E0000069": "Your account is locked because of too many authentication attempts.",
  "errors.E0000047": "You exceeded the maximum number of requests. Try again in a while.",
  "errors.E0000079": "The operation is not allowed. Please refresh the page to proceed.",
  "errors.E0000001": "Api validation failed: {0}",
  "errors.E0000002": "The request was not valid: {0}",
  "errors.E0000003": "The request body was not well-formed.",
  "errors.E0000005": "Invalid session",
  "errors.E0000006": "You do not have permission to perform the requested action",
  "errors.E0000007": "Not found: {0}",
  "errors.E0000008": "The requested path was not found",
  "errors.E0000009": "Internal Server Error",
  "errors.E0000010": "Service is in read only mode",
  "errors.E0000011": "Invalid token provided",
  "errors.E0000012": "Unsupported media type",
  "errors.E0000013": "Invalid client app id",
  "errors.E0000015": "You do not have permission to access the feature you are requesting",
  "errors.E0000016": "Activation failed because the user is already active",
  "errors.E0000017": "Password reset failed",
  "errors.E0000018": "Bad request.  Accept and/or Content-Type headers are likely not set.",
  "errors.E0000019": "Bad request.  Accept and/or Content-Type headers likely do not match supported values.",
  "errors.E0000020": "Bad request.",
  "errors.E0000021": "Bad request.  Accept and/or Content-Type headers likely do not match supported values.",
  "errors.E0000022": "The endpoint does not support the provided HTTP method",
  "errors.E0000023": "Operation failed because user profile is mastered under another system",
  "errors.E0000024": "Bad request.  This operation on app metadata is not yet supported.",
  "errors.E0000025": "App version assignment failed.",
  "errors.E0000026": "This endpoint has been deprecated.",
  "errors.E0000027": "Group push bad request : {0}",
  "errors.E0000028": "The request is missing a required parameter.",
  "errors.E0000029": "Invalid paging request.",
  "errors.E0000030": "Bad request. Invalid date. Dates must be of the form yyyy-MM-dd''T''HH:mm:ss.SSSZZ, e.g. 2013-01-01T12:00:00.000-07:00.",
  "errors.E0000031": "Invalid search criteria.",
  "errors.E0000032": "Unlock is not allowed for this user.",
  "errors.E0000033": "Bad request. Can't specify a search query and filter in the same request.",
  "errors.E0000034": "Forgot password not allowed on specified user.",
  "errors.E0000035": "Change password not allowed on specified user.",
  "errors.E0000036": "Change recovery question not allowed on specified user.",
  "errors.E0000037": "Type mismatch exception.",
  "errors.E0000038": "This operation is not allowed in the user''s current status.",
  "errors.E0000039": "Operation on application settings failed.",
  "errors.E0000040": "Application label must not be the same as an existing application label.",
  "errors.E0000041": "Credentials should not be set on this resource based on the scheme.",
  "errors.E0000042": "Setting the error page redirect URL failed.",
  "errors.E0000043": "Self service application assignment is not enabled.",
  "errors.E0000044": "Self service application assignment is not supported.",
  "errors.E0000045": "Field mapping bad request.",
  "errors.E0000046": "Deactivate application for user forbidden.",
  "errors.E0000048": "Entity not found exception.",
  "errors.E0000049": "Invalid SCIM data from SCIM implementation.",
  "errors.E0000050": "Invalid SCIM data from client.",
  "errors.E0000051": "No response from SCIM implementation.",
  "errors.E0000052": "Endpoint not implemented.",
  "errors.E0000053": "Invalid SCIM filter.",
  "errors.E0000054": "Invalid pagination properties.",
  "errors.E0000055": "Duplicate group.",
  "errors.E0000056": "Delete application forbidden.",
  "errors.E0000057": "Access to this application is denied due to a policy.",
  "errors.E0000058": "Access to this application requires MFA: {0}",
  "errors.E0000059": "The connector configuration could not be tested. Make sure that the URL, Authentication Parameters are correct and that there is an implementation available at the URL provided.",
  "errors.E0000060": "Unsupported operation.",
  "errors.E0000061": "Tab error: {0}",
  "errors.E0000062": "The specified user is already assigned to the application.",
  "errors.E0000063": "Invalid combination of parameters specified.",
  "errors.E0000064": "Password is expired and must be changed.",
  "errors.E0000065": "Internal error processing app metadata.",
  "errors.E0000066": "APNS is not configured, contact your admin",
  "errors.E0000067": "Factors Service Error.",
  "errors.E0000070": "Waiting for ACK",
  "errors.E0000071": "Unsupported OS Version: {0}",
  "errors.E0000072": "MIM policy settings have disallowed enrollment for this user",
  "errors.E0000073": "User rejected authentication",
  "errors.E0000074": "Factor Service Error",
  "errors.E0000075": "Cannot modify the {0} attribute because it has a field mapping and profile push is enabled.",
  "errors.E0000076": "Cannot modify the app user because it is mastered by an external app.",
  "errors.E0000077": "Cannot modify the {0} attribute because it is read-only.",
  "errors.E0000078": "Cannot modify the {0} attribute because it is immutable.",
  "errors.E0000081": "Cannot modify the {0} attribute because it is a reserved attribute for this application.",
  "errors.E0000082": "Each code can only be used once. Please wait for a new code and try again.",
  "errors.E0000083": "PassCode is valid but exceeded time window.",
  "errors.E0000084": "App evaluation error.",
  "errors.E0000085": "You do not have permission to access your account at this time.",
  "errors.E0000086": "This policy cannot be activated at this time.",
  "errors.E0000087": "The recovery question answer did not match our records.",
  "errors.E0000090": "The role specified is already assigned to the user.",
  "errors.E0000091": "The provided role type was not the same as required role type.",
  "errors.E0000092": "Access to this application requires re-authentication: {0}",
  "errors.E0000093": "Target count limit exceeded",
  "errors.E0000094": "The provided filter is unsupported.",
  "errors.E0000095": "Recovery not allowed for unknown user.",
  "errors.E0000096": "This certificate has already been uploaded with kid={0}.",
  "errors.E0000097": "There is no verified phone number on file.",
  "errors.E0000098": "This phone number is invalid.",
  "errors.E0000099": "Only numbers located in US and Canada are allowed.  Contact your administrator if this is a problem.",
  "errors.E0000100": "Unable to perform search query.",
  "errors.E0000101": "Upload failed because of a problem with your ipa file, {0}",
  "errors.E0000102": "YubiKey cannot be deleted while assigned to an user. Please deactivate YubiKey using reset MFA and try again",
  "errors.E0000103": "Action on device already in queue or in progress",
  "errors.E0000104": "Device is already locked and cannot be locked again",
  "errors.E0000105": "You have accessed an account recovery link that has expired or been previously used.",
  "errors.E0000106": "Wait for token to change, then enter the new tokencode.",
  "errors.E0000107": "The entity is not in the expected state for the requested transition.",
  "errors.E0000109": "An SMS message was recently sent. Please wait 30 seconds before trying again.",
  "errors.E0000110": "You have accessed a link that has expired or has been previously used.",
  "errors.E0000111": "Cannot modify the {0} object because it is read-only.",
  "errors.E0000112": "Cannot update this user because they are still being activated. Please try again in a few minutes.",
  "errors.E0000113": "{0}.",
  "errors.E0000114": "A user with this login already exists in the current organization.",
  "errors.E0000115": "Upload failed, {0}",
  "errors.E0000116": "{0}",
  "errors.E0000119": "Your account is locked. Please contact your administrator.",
  "errors.E0000124": "Could not create user. To create a user and expire their password immediately, a password must be specified",
  "errors.E0000125": 'Could not create user. To create a user and expire their password immediately, "activate" must be true',
  "errors.E0000133": "A phone call was recently made. Please wait 30 seconds before trying again.",
  "errors.E0000207": "The username and/or the password you entered is incorrect. Please try again.",
  "oform.next": "Next",
  "oform.verify": "Verify",
  "oform.send": "Send",
  "oform.back": "Back",
  "oform.title.authenticate": "Authenticate",
  "oform.save": "Save",
  "oform.cancel": "Cancel",
  "oform.edit": "Edit",
  "oform.previous": "Previous",
  "oform.error.icon.ariaLabel": "Error",
  "oform.errorbanner.title": "We found some errors. Please review the form and make corrections.",
  "oform.errormsg.title": "Please review the form to correct the following errors:",
  "oform.error.unexpected": "There was an unexpected internal error. Please try again.",
  "oform.selectInput.country": "{0} selected",
  "model.validation.field.blank": "This field cannot be left blank",
  "model.validation.field.wrong.type": "This field is of the wrong type",
  "model.validation.field.invalid": "This field has an invalid value",
  "model.validation.field.value.not.allowed": "This field value is not allowed",
  "model.validation.field.array.minItems": "This array does not have enough items",
  "model.validation.field.array.maxItems": "This array contains too many items",
  "model.validation.field.array.unique": "This array can only have unique values",
  "model.validation.field.string.minLength": "This field cannot be less than the minimum required characters",
  "model.validation.field.string.maxLength": "This field cannot exceed the maximum allowed characters",
  "model.validation.field.invalid.format.email": "This value is not a valid email address",
  "model.validation.field.invalid.format.uri": "This value is not a valid URI",
  "model.validation.field.invalid.format.ipv4": "This value is not a valid IPv4 address",
  "model.validation.field.invalid.format.hostname": "This value is not a valid hostname",
  "model.validation.field.username": "Please check your username",
  "schema.validation.field.value.must.string": "Value must be a string",
  "schema.validation.field.value.must.number": "Value must be a number",
  "schema.validation.field.value.must.integer": "Value must be an integer",
  "schema.validation.field.value.must.object": "Value must be an object",
  "universal-directory.profiles.attribute.source.oktamastered": "Inherit from Okta",
  "universal-directory.profiles.attribute.source.override": "Override profile source",
  "universal-directory.profiles.attribute.form.union.disable.display": "Combine values across groups",
  "universal-directory.profiles.attribute.source.inherit": "Inherit from profile source",
  "universal-directory.profiles.attribute.enduser.permission.readonly": "Read Only",
  "universal-directory.profiles.attribute.enduser.permission.hide": "Hide",
  "universal-directory.profiles.attribute.enduser.permission.readwrite": "Read-Write",
  "universal-directory.profiles.attribute.form.union.enable.display": "Use Group Priority",
  "factor.totpSoft.oktaVerify": "Okta Verify",
  "factor.totpSoft.googleAuthenticator": "Google Authenticator",
  "factor.totpSoft.description": "Enter single-use code from the mobile app.",
  "factor.totpHard.rsaSecurId": "RSA SecurID",
  "factor.totpHard.symantecVip": "Symantec VIP",
  "factor.totpHard.description": "Enter a single-use code from a hardware token.",
  "factor.totpHard.yubikey": "YubiKey",
  "factor.totpHard.yubikey.description": "Insert your YubiKey and tap it to get a verification code.",
  "factor.totpHard.yubikey.placeholder": "Click here, then tap your YubiKey",
  "factor.oktaVerifyPush": "Okta Verify",
  "factor.push.description": "Use a push notification sent to the mobile app.",
  "factor.duo": "Duo Security",
  "factor.duo.description": "Use Push Notification, SMS, or Voice call to authenticate.",
  "factor.sms": "SMS Authentication",
  "factor.sms.description": "Enter a single-use code sent to your mobile phone.",
  "factor.sms.time.warning": `Haven't received an SMS? To try again, click <span style="font-weight:bold">Re-send code</span>.`,
  "factor.call": "Voice Call Authentication",
  "factor.call.description": "Use a phone to authenticate by following voice instructions.",
  "factor.call.time.warning": `Haven't received a voice call? To try again, click <span style="font-weight:bold">Redial</span>.`,
  "factor.securityQuestion": "Security Question",
  "factor.securityQuestion.description": "Use the answer to a security question to authenticate.",
  "factor.windowsHello": "Windows Hello",
  "factor.windowsHello.signin.description": "Sign in to Okta using Windows Hello.",
  "factor.windowsHello.signin.description.generic": "Sign in using Windows Hello.",
  "factor.windowsHello.signin.description.specific": "Sign in to {0} using Windows Hello.",
  "factor.u2f": "Security Key (U2F)",
  "factor.u2f.description": "Use a Universal 2nd Factor (U2F) security key to sign on to Okta.",
  "factor.u2f.description.generic": "Use a Universal 2nd Factor (U2F) security key to sign in.",
  "factor.u2f.description.specific": "Use a Universal 2nd Factor (U2F) security key to sign in to {0}.",
  "factor.email": "Email Authentication",
  "factor.email.description": "Enter a verification code sent to your email.",
  "factor.password": "Password",
  "factor.customFactor.description": "Redirect to a third party MFA provider to sign in to Okta.",
  "factor.customFactor.description.generic": "Redirect to a third party MFA provider to sign in.",
  "factor.customFactor.description.specific": "Redirect to a third party MFA provider to sign in to {0}.",
  "factor.webauthn.biometric": "Security Key or Biometric Authenticator",
  "factor.webauthn.biometric.description": "Use a security key (USB or bluetooth) or a biometric authenticator (Windows Hello, Touch ID, etc.)",
  "factor.hotp.description": "Enter a single-use code from an authenticator.",
  "mfa.challenge.verify": "Verify",
  "mfa.challenge.answer.placeholder": "Answer",
  "mfa.challenge.answer.tooltip": "Answer",
  "mfa.challenge.answer.showAnswer": "Show",
  "mfa.challenge.answer.hideAnswer": "Hide",
  "mfa.challenge.enterCode.placeholder": "Enter Code",
  "mfa.challenge.enterCode.tooltip": "Enter Code",
  "mfa.challenge.password.placeholder": "Password",
  "mfa.backToFactors": "Back to factor list",
  "mfa.enroll": "Enroll",
  "mfa.setupOptions": "Setup Options",
  "mfa.country": "Country/region",
  "mfa.phoneNumber.placeholder": "Phone number",
  "mfa.phoneNumber.ext.placeholder": "Extension",
  "mfa.sendCode": "Send code",
  "mfa.sent": "Sent",
  "mfa.resendCode": "Re-send code",
  "mfa.call": "Call",
  "mfa.calling": "Calling",
  "mfa.redial": "Redial",
  "mfa.sendEmail": "Send email",
  "mfa.resendEmail": "Re-send email",
  "mfa.scanBarcode": "Scan QR Code",
  "mfa.altQrCode": "QR code",
  "mfa.noAccessToEmail": "Can't access email",
  "password.reset": "Reset Password",
  "password.oldPassword.placeholder": "Old password",
  "password.oldPassword.tooltip": "Old password",
  "password.newPassword.placeholder": "New password",
  "password.newPassword.tooltip": "New password",
  "password.confirmPassword.placeholder": "Repeat password",
  "password.confirmPassword.tooltip": "Repeat password",
  "password.error.match": "New passwords must match",
  "password.enroll.error.match": "Passwords must match",
  "recovery.sms.hint": "SMS can only be used if a mobile phone number has been configured.",
  "recovery.mobile.hint": "{0} can only be used if a mobile phone number has been configured.",
  "recovery.sms": "SMS",
  "recovery.call": "Voice Call",
  "recovery.smsOrCall": "SMS or Voice Call",
  "verify.choices.description": "Verify with one of the following factors.",
  "email.button.send": "Send me the code",
  "email.button.resend": "Send again",
  "email.code.label": "Verification code",
  "email.code.not.received": "Haven't received an email?",
  "email.enroll.title": "Set up Email Authentication",
  "email.enroll.description": "Send a verification code to your registered email.",
  "email.enroll.enterCode": "Enter code",
  "email.link.terminal.msg": "To finish signing in, return to the screen where you requested the email link.",
  "email.mfa.title": "Verify with Email Authentication",
  "email.mfa.description": "Send a verification code to {0}.",
  "email.mfa.email.sent.description": "A verification code was sent to {0}. Check your email and enter the code below.",
  "email.mfa.email.sent.description.sentText": "A verification code was sent to",
  "email.mfa.email.sent.description.emailCodeText": "Check your email and enter the code below.",
  "enroll.choices.title": "Set up multifactor authentication",
  "enroll.choices.description": "Your company requires multifactor authentication to add an additional layer of security when signing in to your Okta account",
  "enroll.choices.description.generic": "Your company requires multifactor authentication to add an additional layer of security when signing in to your account",
  "enroll.choices.description.specific": "Your company requires multifactor authentication to add an additional layer of security when signing in to your {0} account",
  "enroll.choices.description.gracePeriod.bold": "Your company recommends setting up additional factors for authentication. Set up will be required in: <b>{0} day(s)</b>.",
  "enroll.choices.description.gracePeriod.oneDay.bold": "Your company recommends setting up additional factors for authentication. Set up will be required in: <b>less than 1 day</b>.",
  "enroll.choices.optional": "You can configure any additional optional factor or click finish",
  "enroll.choices.list.setup": "Setup required",
  "enroll.choices.list.enrolled": "Enrolled factors",
  "enroll.choices.list.optional": "Additional optional factors",
  "enroll.choices.setup": "Setup",
  "enroll.choices.setup.another": "Set up another",
  "enroll.choices.submit.finish": "Finish",
  "enroll.choices.submit.configure": "Configure factor",
  "enroll.choices.submit.next": "Configure next factor",
  "enroll.choices.cardinality.setup": "({0} set up)",
  "enroll.choices.cardinality.setup.remaining": "({0} of {1} set up)",
  "enroll.choices.setup.skip": "Skip set up",
  "enroll.securityQuestion.setup": "Setup secret question authentication",
  "security.disliked_food": "What is the food you least liked as a child?",
  "security.name_of_first_plush_toy": "What is the name of your first stuffed animal?",
  "security.first_award": "What did you earn your first medal or award for?",
  "security.favorite_security_question": "What is your favorite security question?",
  "security.favorite_toy": "What is the toy/stuffed animal you liked the most as a kid?",
  "security.first_computer_game": "What was the first computer game you played?",
  "security.favorite_movie_quote": "What is your favorite movie quote?",
  "security.first_sports_team_mascot": "What was the mascot of the first sports team you played on?",
  "security.first_music_purchase": "What music album or song did you first purchase?",
  "security.favorite_art_piece": "What is your favorite piece of art?",
  "security.grandmother_favorite_desert": "What was your grandmother's favorite dessert?",
  "security.first_thing_cooked": "What was the first thing you learned to cook?",
  "security.childhood_dream_job": "What was your dream job as a child?",
  "security.first_kiss_location": "Where did you have your first kiss?",
  "security.place_where_significant_other_was_met": "Where did you meet your spouse/significant other?",
  "security.favorite_vacation_location": "Where did you go for your favorite vacation?",
  "security.new_years_two_thousand": "Where were you on New Year's Eve in the year 2000?",
  "security.favorite_speaker_actor": "Who is your favorite speaker/orator?",
  "security.favorite_book_movie_character": "Who is your favorite book/movie character?",
  "security.favorite_sports_player": "Who is your favorite sports player?",
  "enroll.password.setup": "Select a password",
  "save.password": "Save password",
  "enroll.sms.setup": "Receive a code via SMS to authenticate",
  "enroll.sms.try_again": "The number you entered seems invalid. If the number is correct, please try again.",
  "enroll.call.setup": "Follow phone call instructions to authenticate",
  "enroll.onprem.username.placeholder": "Enter {0} username",
  "enroll.onprem.username.tooltip": "Enter {0} username",
  "enroll.onprem.passcode.placeholder": "Enter {0} passcode",
  "enroll.onprem.passcode.tooltip": "Enter {0} passcode",
  "enroll.symantecVip.subtitle": "Enter Credential ID and two consecutive generated codes",
  "enroll.symantecVip.credentialId.placeholder": "Enter credential ID",
  "enroll.symantecVip.credentialId.tooltip": "Enter credential ID",
  "enroll.symantecVip.passcode1.placeholder": "Security code 1",
  "enroll.symantecVip.passcode1.tooltip": "Security code 1",
  "enroll.symantecVip.passcode2.placeholder": "Security code 2",
  "enroll.symantecVip.passcode2.tooltip": "Security code 2",
  "enroll.yubikey.title": "Setup YubiKey",
  "enroll.yubikey.subtitle": "Insert your YubiKey into a USB port and tap it to generate a verification code",
  "enroll.totp.title": "Setup {0}",
  "enroll.totp.selectDevice": "Select your device type",
  "enroll.totp.downloadApp": 'Download <a href="{0}" class="inline-link">{1} from the {2}</a> onto your mobile device.',
  "enroll.hotp.restricted": "Contact your administrator to continue enrollment.",
  "enroll.duo.title": "Setup Duo Security",
  "enroll.windowsHello.title": "Enroll Windows Hello",
  "enroll.windowsHello.subtitle": "Click below to enroll Windows Hello as a second form of authentication",
  "enroll.windowsHello.subtitle.loading": "Please wait while Windows Hello is loading...",
  "enroll.windowsHello.save": "Enroll Windows Hello",
  "enroll.windowsHello.error.notWindows": "Windows Hello can only be used on Windows Edge with Windows 10. Contact your admin for assistance.",
  "enroll.windowsHello.error.notConfiguredHtml": "Windows Hello is not configured. Select the <b>Start</b> button, then select <b>Settings</b> - <b>Accounts</b> - <b>Sign-in</b> to configure Windows Hello.",
  "verify.windowsHello.subtitle": "Verify your identity with Windows Hello",
  "verify.windowsHello.subtitle.loading": "Please wait while Windows Hello is loading...",
  "verify.windowsHello.subtitle.signingIn": "Signing in to Okta...",
  "verify.windowsHello.subtitle.signingIn.generic": "Signing in...",
  "verify.windowsHello.subtitle.signingIn.specific": "Signing in to {0}...",
  "verify.windowsHello.save": "Verify with Windows Hello",
  "verify.windowsHello.error.notFound": "Your Windows Hello enrollment does not match our records. Contact your administrator for assistance.",
  "verify.windowsHello.error.notFound.selectAnother": "Your Windows Hello enrollment does not match our records. Select another factor or contact your administrator for assistance.",
  "enroll.u2f.title": "Setup Security Key (U2F)",
  "enroll.u2f.save": "Register Security Key",
  "enroll.u2f.general2": "Make sure you have a Security Key. If already inserted, remove it now.<br>If you have a Bluetooth Security Key, turn on your computer's Bluetooth.",
  "enroll.u2f.general3": "Click the button below to register",
  "enroll.u2f.instructions": "Insert your Security Key into a USB port on this computer. If it has a button or gold disk, tap it.",
  "enroll.u2f.instructionsBluetooth": "If you are using a Bluetooth Security Key, press the button.",
  "u2f.error.factorNotSupported": "Security Key (U2F) is not supported on this browser. Select another factor or contact your admin for assistance.",
  "u2f.error.factorNotSupported.oneFactor": "Security Key (U2F) is not supported on this browser. Contact your admin for assistance.",
  "u2f.error.other": "An unknown error has occured. Try again or select another factor.",
  "u2f.error.other.oneFactor": "An unknown error has occured. Try again or contact your admin for assistance.",
  "u2f.error.badRequest": "There was an error with the U2F request. Try again or select another factor.",
  "u2f.error.badRequest.oneFactor": "There was an error with the U2F request. Try again or contact your admin for assistance.",
  "u2f.error.unsupported": "The security key is unsupported. Select another factor.",
  "u2f.error.unsupported.oneFactor": "The security key is unsupported. Contact your admin for assistance.",
  "u2f.error.timeout": "You have timed out of the authentication period. Please try again.",
  "verify.u2f.instructions": "Insert your Security Key. If it has a button or gold disk, tap it.",
  "verify.u2f.instructionsBluetooth": "If you are using a Bluetooth Security Key, turn on your computer's Bluetooth and press the button.",
  "verify.u2f.retry": "Retry",
  "enroll.customFactor.subtitle": "Clicking below will redirect to MFA enrollment with {0}",
  "enroll.customFactor.save": "Enroll",
  "verify.customFactor.subtitle": "Clicking below will redirect to verification with {0}",
  "verify.customFactor.subtitle.redirect": "Redirecting to {0}...",
  "enroll.webauthn.biometric.title": "Set up security key or biometric authenticator",
  "enroll.webauthn.save": "Enroll",
  "enroll.webauthn.biometric.instructions": "Your browser will prompt to register a security key or biometric authenticator (Windows Hello, Touch ID, etc.). Follow the instructions to complete enrollment.",
  "enroll.webauthn.biometric.instructions.edge": "Note: If you are enrolling a security key and Windows Hello or PIN is enabled, you will need to select '<b>Cancel</b>' in the prompt before continuing.",
  "verify.webauthn.biometric.instructions": "Your browser or device will prompt you to verify with a security key or biometric authenticator. Follow the instructions to complete authentication.",
  "webauthn.biometric.error.factorNotSupported": "Security key or biometric authenticator is not supported on this browser. Select another factor or contact your admin for assistance.",
  "webauthn.biometric.error.factorNotSupported.oneFactor": "Security key or biometric authenticator is not supported on this browser. Contact your admin for assistance.",
  "enroll.webauthn.instructions.noSupportForBiometric": "Note: Some browsers may not support biometric authenticators.",
  "authfactor.webauthn.error": "You are currently unable to use a Security key or biometric authenticator. Try again.",
  "enroll.totp.enterCode": "Enter code displayed from the application",
  "enroll.totp.setupApp": "Launch {0} on your mobile device and select “Add an account”. Scan the QR code to continue.",
  "enroll.totp.setupGoogleAuthApp": 'Launch {0}, tap the "+" icon, then select "Scan barcode".',
  "enroll.totp.cannotScan": "Can't scan?",
  "enroll.totp.aria.cannotScan": "Setup without scanning a QR code.",
  "enroll.totp.refreshBarcode": "Refresh code",
  "enroll.totp.cannotScanBarcode": "Can't scan QR Code?",
  "enroll.totp.manualSetupInstructions": "To set up manually enter your Okta Account username and then input the following in the Secret Key Field",
  "enroll.totp.manualSetupInstructions.generic": "To set up manually enter your Account username and then input the following in the Secret Key Field",
  "enroll.totp.manualSetupInstructions.specific": "To set up manually enter your {0} Account username and then input the following in the Secret Key Field",
  "enroll.totp.sharedSecretInstructions": "Enter your Okta Account username and enter the following in the Secret Key Field",
  "enroll.totp.sharedSecretInstructions.generic": "Enter your Account username and enter the following in the Secret Key Field",
  "enroll.totp.sharedSecretInstructions.specific": "Enter your {0} Account username and enter the following in the Secret Key Field",
  "enroll.totp.sendSms": "Send activation link via SMS",
  "enroll.totp.sendEmail": "Send activation link via email",
  "enroll.totp.setupManually": "Setup manually without push notification",
  "enroll.totp.sharedSecretInstructions.aria.secretKey": "setup key {0}",
  "enroll.totp.enrollViaEmail.title": "Activation email sent!",
  "enroll.totp.enrollViaEmail.msg": "Open the email from your mobile device.",
  "enroll.totp.enrollViaSms.title": "SMS sent!",
  "enroll.totp.enrollViaSms.msg": "View the SMS on your mobile device.",
  "recoveryChallenge.sms.title": "Enter verification code sent via SMS",
  "recoveryChallenge.call.title": "Enter verification code received via Voice Call",
  "mfa.factors.dropdown.title": "Select an authentication factor",
  "mfa.factors.dropdown.sr.text": "Select Authentication Factor - {0} Factor Selected",
  "mfa.duoSecurity.push": "Push — {0}",
  "mfa.duoSecurity.sms": "SMS — {0}",
  "mfa.duoSecurity.call": "Call — {0}",
  "mfa.switch": "Switch Factor",
  "mfa.challenge.title": "Enter your {0} passcode",
  "mfa.challenge.orEnterCode": "Or enter code",
  "mfa.challenge.totp.subtitle.multiple": "Enter code from any registered {0} device.",
  "mfa.emailVerification.checkEmail": "To finish signing in, click the link in your email.",
  "mfa.emailVerification.title": "Sign in using a link sent to your email.",
  "mfa.emailVerification.subtitle": "Emails will be sent to {0}",
  "mfa.emailVerification.otc.finish": "To finish signing in, enter the code which was emailed to you.",
  "oktaverify.send": "Send Push",
  "oktaverify.resend": "Re-send Push",
  "oktaverify.sent": "Push sent!",
  "oktaverify.rejected": "You have chosen to reject this login.",
  "oktaverify.rejected.upgradeRequired.ios": "Verification failed because your Okta Verify version is no longer supported. To sign in, please update Okta Verify on the App Store, then try again.",
  "oktaverify.rejected.upgradeRequired.android": "Verification failed because your Okta Verify version is no longer supported. To sign in, please update Okta Verify on Google Play, then try again.",
  "oktaverify.timeout": "Your push notification has expired.",
  "oktaverify.warning": "Haven't received a push notification yet? Try opening the Okta Verify App on your phone.",
  "oktaverify.numberchallenge.instruction": 'On your phone, tap <span class="challenge-number">{0}</span> on Okta Verify prompt to continue.',
  "oktaverify.numberchallenge.explain": "This extra step helps us make sure it's really you signing in.",
  "primaryauth.title": "Sign In",
  "primaryauth.username.placeholder": "Username",
  "primaryauth.username.tooltip": "Username",
  "primaryauth.password.placeholder": "Password",
  "primaryauth.password.tooltip": "Password",
  "primaryauth.submit": "Sign In",
  "primaryauth.newUser.tooltip": "This is the first time you are connecting to {0} from this browser",
  "primaryauth.newUser.tooltip.close": "Close",
  "oktaVerify.description": "To access this resource, your organization requires you to sign in with Okta FastPass.",
  "oktaVerify.appDescription": "To access {0}, your organization requires you to sign in with Okta FastPass.",
  "oktaVerify.button": "Sign in with Okta FastPass",
  "signinWithWebAuthn.button": "Sign in with security key or biometrics",
  "idpDiscovery.email.placeholder": "Email",
  "password.forgot.email.or.username.placeholder": "Email or Username",
  "password.forgot.email.or.username.tooltip": "Email or Username",
  "password.forgot.sendText": "Reset via SMS",
  "password.forgot.sendEmail": "Reset via Email",
  "password.forgot.call": "Reset via Voice Call",
  "password.forgot.emailSent.title": "Email sent!",
  "password.forgot.emailSent.desc": "Email has been sent to {0} with instructions on resetting your password.",
  "password.forgot.question.title": "Answer Forgotten Password Challenge",
  "password.forgot.question.submit": "Reset Password",
  "password.forgot.code.notReceived": "Didn't receive a code? Reset via email",
  "password.forgot.noFactorsEnabled": "No password reset options available. Please contact your administrator.",
  "password.reset.title": "Reset your Okta password",
  "password.reset.title.generic": "Reset your password",
  "password.reset.title.specific": "Reset your {0} password",
  "password.complexity.requirements": "Password requirements: {0}.",
  "password.complexity.history": "Your password cannot be any of your last {0} passwords.",
  "password.complexity.minAgeMinutes": "At least {0} minute(s) must have elapsed since you last changed your password.",
  "password.complexity.minAgeHours": "At least {0} hour(s) must have elapsed since you last changed your password.",
  "password.complexity.minAgeDays": "At least {0} day(s) must have elapsed since you last changed your password.",
  "password.reset.verification": "Verify with one of the following factors to reset your password.",
  "password.complexity.length": "at least {0} characters",
  "password.complexity.list.element": ", {0}",
  "password.complexity.lowercase": "a lowercase letter",
  "password.complexity.uppercase": "an uppercase letter",
  "password.complexity.number": "a number",
  "password.complexity.symbol": "a symbol",
  "password.complexity.no_username": "no parts of your username",
  "password.complexity.no_first_name": "does not include your first name",
  "password.complexity.no_last_name": "does not include your last name",
  "password.complexity.requirements.header": "Password requirements:",
  "password.complexity.length.description": "At least {0} characters",
  "password.complexity.lowercase.description": "A lowercase letter",
  "password.complexity.uppercase.description": "An uppercase letter",
  "password.complexity.number.description": "A number",
  "password.complexity.symbol.description": "A symbol",
  "password.complexity.no_username.description": "No parts of your username",
  "password.complexity.no_first_name.description": "Does not include your first name",
  "password.complexity.no_last_name.description": "Does not include your last name",
  "password.complexity.history.description": "Your password cannot be any of your last {0} passwords",
  "password.complexity.minAgeMinutes.description": "At least {0} minute(s) must have elapsed since you last changed your password",
  "password.complexity.minAgeHours.description": "At least {0} hour(s) must have elapsed since you last changed your password",
  "password.complexity.minAgeDays.description": "At least {0} day(s) must have elapsed since you last changed your password",
  "password.expired.submit": "Change Password",
  "password.expired.title": "Your Okta password has expired",
  "password.expired.title.generic": "Your password has expired",
  "password.expired.title.specific": "Your {0} password has expired",
  "password.expiring.later": "Remind me later",
  "password.expiring.title": "Your password will expire in {0} days",
  "password.expiring.today": "Your password will expire later today",
  "password.expiring.soon": "Your password is expiring soon",
  "password.expiring.subtitle": "When password expires you may be locked out of Okta Mobile, mobile email, and other services.",
  "password.expiring.subtitle.generic": "When password expires you will be locked out of your account.",
  "password.expiring.subtitle.specific": "When password expires you will be locked out of your {0} account.",
  "password.expired.custom.submit": "Go to {0}",
  "password.expired.custom.subtitle": "This password is set on another website. Click the button below to go there and set a new password.",
  "hcaptcha.footer.label": "This site is protected by hCaptcha and its <$1>Privacy Policy</$1> and <$2>Terms of Service</$2> apply.",
  "account.unlock.title": "Unlock account",
  "account.unlock.email.or.username.placeholder": "Email or username",
  "account.unlock.email.or.username.tooltip": "Email or username",
  "account.unlock.sendText": "Send SMS",
  "account.unlock.voiceCall": "Voice Call",
  "account.unlock.sendEmail": "Send Email",
  "account.unlock.emailSent.title": "Email sent!",
  "account.unlock.emailSent.desc": "Email has been sent to {0} with instructions on unlocking your account.",
  "account.unlock.question.title": "Answer Unlock Account Challenge",
  "account.unlock.question.submit": "Unlock Account",
  "account.unlock.unlocked.title": "Account successfully unlocked!",
  "account.unlock.unlocked.desc": "You can log in using your existing username and password.",
  "account.unlock.code.notReceived": "Didn't receive a code? Unlock via email",
  "account.unlock.noFactorsEnabled": "No unlock options available. Please contact your administrator.",
  "contact.support": "If you didn't provide a secondary email address or don't have access to email, please contact your administrator at {0}",
  "customauth.sign.in.with.label": "Sign in with {0}",
  "socialauth.divider.text": "OR",
  "socialauth.facebook.label": "Sign in with Facebook",
  "socialauth.google.label": "Sign in with Google",
  "socialauth.linkedin.label": "Sign in with LinkedIn",
  "socialauth.microsoft.label": "Sign in with Microsoft",
  "socialauth.apple.label": "Sign in with Apple",
  "socialauth.github.label": "Sign in with GitHub",
  "socialauth.gitlab.label": "Sign in with GitLab",
  "socialauth.yahoo.label": "Sign in with Yahoo",
  "socialauth.line.label": "Sign in with LINE",
  "socialauth.paypal.label": "Sign in with PayPal",
  "socialauth.paypal_sandbox.label": "Sign in with PayPal Sandbox",
  "socialauth.salesforce.label": "Sign in with Salesforce",
  "socialauth.amazon.label": "Sign in with Amazon",
  "socialauth.yahoojp.label": "Sign in with Yahoo Japan",
  "socialauth.discord.label": "Sign in with Discord",
  "socialauth.adobe.label": "Sign in with Adobe",
  "socialauth.orcid.label": "Sign in with ORCiD",
  "socialauth.spotify.label": "Sign in with Spotify",
  "socialauth.xero.label": "Sign in with Xero",
  "socialauth.quickbooks.label": "Sign in with Quickbooks",
  "socialauth.popup.title": "External Identity Provider User Authentication",
  "authbutton.divider.text": "or",
  "registration.signup.label": "Don't have an account?",
  "registration.signup.text": "Sign up",
  "registration.complete.title": "Verification email sent",
  "registration.complete.confirm.text": "To finish signing in, check your email.",
  "registration.form.title": "Create Account",
  "registration.form.submit": "Register",
  "registration.passwordComplexity.minLength": "At least {0} character(s)",
  "registration.passwordComplexity.minLower": "At least {0} lowercase letter(s)",
  "registration.passwordComplexity.minUpper": "At least {0} uppercase letter(s)",
  "registration.passwordComplexity.minNumber": "At least {0} number(s)",
  "registration.passwordComplexity.minSymbol": "At least {0} symbol(s)",
  "registration.passwordComplexity.excludeUsername": "Does not contain part of username",
  "registration.passwordComplexity.excludeAttribute": "Does not contain '{0}'",
  "registration.required.fields.label": "* indicates required field",
  "registration.default.callbackhook.error": "We could not process your registration at this time. Please try again later.",
  "registration.error.userName.invalidEmail": "Invalid email address",
  "registration.error.password.passwordRequirementsNotMet": "Password requirements were not met",
  "registration.error.userName.notUniqueWithinOrg": "An account with that {0} already exists",
  "registration.error.notUniqueWithinOrg.Email": "A user with this Email already exists",
  "registration.error.notUniqueWithinOrg.custom": "A user with this {0} already exists",
  "registration.error.invalidLoginEmail.Email": "'Email' must be in the form of an email address",
  "registration.error.invalidLoginEmail.custom": "'{0}' must be in the form of an email address",
  "registration.error.doesNotMatchPattern.Email": "Provided value for property 'Email' does not match required pattern",
  "registration.error.doesNotMatchPattern.custom": "Provided value for property '{0}' does not match required pattern",
  "registration.error.generic": "There was an error creating your account. Please try registering again.",
  "registration.error.request.not.completed": "Your request could not be completed. Try again later.",
  "registration.model.validation.field.string.too.short": "Please enter something at least {0} characters long",
  "registration.model.validation.field.string.too.long": "Please enter something shorter than {0} characters",
  "piv.card": "PIV Card",
  "piv.card.insert": "Please insert your PIV card and select the user certificate.",
  "piv.card.error": "Certificate authentication failed. Contact your admin.",
  "piv.card.error.empty": "No certificate selected. Choose a certificate and try again.",
  "piv.card.error.invalid": "Certificate validation failed. Choose another certificate and try again.",
  "piv.cac.card": "Sign in with PIV / CAC card",
  "piv.cac.title": "PIV / CAC card",
  "piv.cac.card.insert": "Please insert your PIV / CAC card and select the user certificate.",
  "piv.cac.error": "There was an error signing in. Click the button below to try again.",
  "unsupported.oneDrive.title": "Your OneDrive version is not supported",
  "unsupported.oneDrive.desc": "Upgrade now by installing the OneDrive for Business Next Generation Sync Client to login to Okta",
  "unsupported.oneDrive.action": "Learn how to upgrade",
  "unsupported.cookies.title": "Cookies are required",
  "unsupported.cookies.desc": "Cookies are disabled on your browser. Please enable Cookies and refresh this page.",
  "unsupported.cookies.action": "Refresh",
  "deviceTrust.sso.text": "Sign in to access company resources",
  "deviceTrust.sso.subtitle.2": "Your company uses Okta Mobile to get you approved to access this app.",
  "deviceTrust.sso.button": "Sign in with Okta Mobile",
  "deviceTrust.sso.expire.title": "Oops let's get you back on track",
  "deviceTrust.sso.redirectText": "Verifying your identity",
  "deviceTrust.sso.expire.subtitle": "Unfortunately the steps required to sign in took longer than expected and your attempt timed out.",
  "deviceTrust.sso.expire.button": "Sign in using Okta Mobile",
  "deviceTrust.universalLink.fallback.getOktaMobile.title": "Get Okta Mobile",
  "deviceTrust.universalLink.fallback.getOktaMobile.subtitle": "Go to the {0}AppStore{1}, {0}search{1} for {0}Okta Mobile{1} and tap on {0}GET{1} Okta Mobile. Once installed, sign in to Okta Mobile and follow the instructions to secure your device.",
  "core.auth.factor.signedNonce.error.invalidDevice": "Your device or account was invalidated. If this is unexpected, contact your administrator for help.",
  "core.auth.factor.signedNonce.error": "Your device or account was invalidated. Re-enroll your account on Okta Verify and try again.",
  "user.fail.verifyIdentity": "Couldn’t verify your identity",
  "loopback.polling.cancel.link": "Cancel and take me to sign in",
  "loopback.polling.cancel.link.with.form.error": "Take me to sign in",
  "customUri.subtitle": "Launching Okta Verify...",
  "customUri.content": '<div class="skinny-content"> If nothing prompts from the browser, <a href="#" id="launch-ov" class="link">click here</a> to launch Okta Verify, or make sure Okta Verify is installed.</div>',
  "customUri.title": 'Click "Open Okta Verify" on the browser prompt',
  "customUri.required.content.prompt": "Didn’t get a prompt?",
  "customUri.required.content.download.title": "Don’t have Okta Verify?",
  "customUri.required.content.download.linkText": "Download here",
  "customUri.required.content.button": "Launch Okta Verify",
  "universalLink.title": "Sign in with Okta FastPass",
  "universalLink.content": "If Okta Verify did not open automatically, tap Open Okta Verify.",
  "appLink.title": "Sign in with Okta FastPass",
  "appLink.content": "If Okta Verify did not open automatically, tap Open Okta Verify.",
  "oktaVerify.open.button": "Open Okta Verify",
  "oktaVerify.reopen.button": "Reopen Okta Verify",
  "consent.required.text": "<b>{0}</b> would like to access:",
  "consent.required.description": "By clicking Allow Access, you allow the actions listed above.",
  "consent.required.termsOfService": "Terms of Service",
  "consent.required.privacyPolicy": "Privacy Policy",
  "consent.required.consentButton": "Allow Access",
  "consent.required.cancelButton": "Don't Allow",
  "granular.consent.scopes.title": "<$1>{0}</$1> <$2>requests access to your account</$2>",
  "granular.consent.scopes.description": "Allowing access will share",
  "admin.consent.group.user.group": "User and groups",
  "admin.consent.group.resource.policy": "Resource and policies",
  "admin.consent.group.hook": "Hooks",
  "admin.consent.group.system": "System",
  "polling.title": "There are too many users trying to sign in right now. We will automatically retry in {0} seconds.",
  "poll.form.title": "Unable to complete your request",
  "poll.form.message": "We will automatically retry in <$1>{0}</$1> seconds.",
  "cert.authentication.title": "Certificate authentication",
  "common.logo.alt": "aria logo",
  "oie.authenticator.enroll.error.fail": "Unable to enroll authenticator. Try again.",
  "oie.authenticator.verify.error.fail": "Unable to verify authenticator. Try again.",
  "oie.configuration.error": "Something went wrong. Potential misconfiguration detected. Please contact support.",
  "oie.auth.logo.aria.label": "Authenticator logo",
  "oie.form.field.optional": "Optional",
  "oie.password.label": "Password",
  "oie.password.newPasswordLabel": "New password",
  "oie.password.authenticator.description": "Choose a password for your account",
  "oie.password.challenge.title": "Verify with your password",
  "oie.password.enroll.title": "Set up password",
  "oie.password.passwordLabel": "Enter password",
  "oie.password.confirmPasswordLabel": "Re-enter password",
  "oie.password.reset.verification": "Verify with one of the following security methods to reset your password.",
  "idx.password.expiring.message": "When your password expires you will be locked out of your Okta account.",
  "oie.password.incorrect.message": "Password is incorrect",
  "oie.selfservice.reset.password.not.allowed": "Reset password is not allowed at this time. Please contact support for assistance.",
  "password.common": "This password was found in a list of commonly used passwords. Please try another password.",
  "idx.recovery.completed": "You can now sign in with your existing username and new password.",
  "oie.phone.label": "Phone",
  "oie.phone.authenticator.description": "Verify with a code sent to your phone",
  "oie.phone.enroll.sms.label": "SMS",
  "oie.phone.enroll.voice.label": "Voice call",
  "oie.phone.enroll.title": "Set up phone authentication",
  "oie.phone.enroll.call.subtitle": "Enter your phone number to receive a verification code via voice call.",
  "oie.phone.enroll.sms.subtitle": "Enter your phone number to receive a verification code via SMS.",
  "oie.phone.sms.primaryButton": "Receive a code via SMS",
  "oie.phone.sms.secondaryButton": "Receive an SMS instead",
  "oie.phone.call.primaryButton": "Receive a code via voice call",
  "oie.phone.call.secondaryButton": "Receive a voice call instead",
  "oie.phone.verify.sms.resendText": "Haven't received an SMS?",
  "oie.phone.verify.sms.codeSentText": "A code was sent to",
  "oie.phone.verify.sms.sendText": "Send a code via SMS to",
  "oie.phone.verify.call.sendText": "Send a code via voice call to",
  "oie.phone.verify.call.resendText": "Haven't received a call?",
  "oie.phone.verify.call.resendLinkText": "Call again",
  "oie.phone.verify.sms.resendLinkText": "Send again",
  "oie.phone.verify.enterCodeText": "Enter the code below to verify.",
  "oie.phone.verify.title": "Verify with your phone",
  "oie.phone.alternate.title": "your phone",
  "oie.phone.carrier.charges": "Carrier messaging charges may apply",
  "oie.phone.invalid": "Invalid Phone Number.",
  "oie.email.label": "Email",
  "oie.email.authenticator.description": "Verify with a link or code sent to your email",
  "oie.email.mfa.title": "Verify with your email",
  "oie.email.challenge.mfa.title": "Get a verification email",
  "oie.email.verify.primaryButton": "Send me an email",
  "oie.email.verify.subtitle.text.with.email": 'Send a verification email to <$1>{0}</$1> by clicking on "Send me an email".',
  "oie.email.verify.subtitle.text.without.email": 'Send a verification email by clicking on "Send me an email".',
  "oie.email.verify.alternate.magicLinkToEmailAddress": "We sent an email to <$1>{0}</$1>. ",
  "oie.email.verify.alternate.magicLinkToYourEmail": "We sent you a verification email. ",
  "oie.email.verify.alternate.instructions": "Click the verification link in your email to continue or enter the code below.",
  "oie.email.verify.alternate.show.verificationCode.text": "Enter a verification code instead",
  "oie.email.verify.alternate.verificationCode.instructions": "Enter the verification code in the text box.",
  "oie.email.enroll.subtitle": "Please check your email and enter the code below.",
  "oie.email.return.link.expired.title": "Verify with your email",
  "oie.profile.additional.title": "Additional Profile information",
  "oie.profile.additional.secondemail.subtitle": "Use a second email to <$1> recover your account </$1> in case you become locked out. This email must be verified after setup.",
  "oie.webauthn.label": "Security Key or Biometric Authenticator",
  "oie.webauthn.description": "Use a security key or a biometric authenticator to sign in",
  "oie.enroll.webauthn.title": "Set up security key or biometric authenticator",
  "oie.enroll.webauthn.instructions": "You will be prompted to register a security key or biometric authenticator (Windows Hello, Touch ID, Face ID, etc.). Follow the instructions to complete set up.",
  "oie.enroll.webauthn.uv.required.instructions": "Biometric verification or a PIN is required to setup this authenticator.",
  "oie.enroll.webauthn.instructions.edge": "Note: If you are enrolling a security key and Windows Hello or PIN is enabled, you will need to select 'Cancel' in the prompt before continuing.",
  "oie.enroll.webauthn.save": "Set up",
  "oie.webauthn.error.not.supported": "Security key or biometric authenticator is not supported on this browser. Contact your admin for assistance.",
  "oie.verify.webauth.title": "Verify with Security Key or Biometric Authenticator",
  "oie.verify.webauthn.instructions": "You will be prompted to use a security key or biometric verification (Windows Hello, Touch ID, etc.). Follow the instructions to complete verification.",
  "oie.verify.webauthn.uv.required.instructions": "Biometric verification or a PIN is required to sign in with this authenticator.",
  "oie.verify.webauthn.cant.verify": "Can't verify?",
  "oie.verify.webauthn.cant.verify.biometric.authenticator.title": "Are you trying to use a biometric authenticator?",
  "oie.verify.webauthn.cant.verify.biometric.authenticator.description1": "Biometric authenticators (fingerprint, face recognition, PIN) will only work on the same device on which they were set up.",
  "oie.verify.webauthn.cant.verify.biometric.authenticator.description2": "If available, set up another security method on the device you used to set up your biometric authenticator.",
  "oie.verify.webauthn.cant.verify.security.key.title": "Are you trying to use a security key?",
  "oie.verify.webauthn.cant.verify.security.key.description": "If you have set up a security key, insert it in a USB port when prompted by the browser and tap on the button or gold disk. Security keys can work on multiple devices.",
  "oie.verify.webauthn.cant.verify.enrollment.step1": "Open your Okta Dashboard (e.g. yourcompany.okta.com) on the device you used to setup your security key or biometric authenticator",
  "oie.verify.webauthn.cant.verify.enrollment.step2": "Go to Settings > Security Methods",
  "oie.verify.webauthn.cant.verify.enrollment.step3": 'On Okta Verify, click "Set up"',
  "oie.verify.webauthn.cant.verify.enrollment.step4": "Scan the QR code using Okta Verify and follow instructions to finish enrolling your account",
  "oie.enroll.webauthn.rk.link": `If you haven't set up your security key or biometric authentication, you can complete the process after you sign in using <a href="#" class="setup-webauthn-residentkey-link">this link</a>.`,
  "oie.security.question.label": "Security Question",
  "oie.security.question.enroll.title": "Set up security question",
  "oie.security.question.challenge.title": "Verify with your Security Question",
  "oie.security.question.questionKey.label": "Choose a security question",
  "oie.security.question.createQuestion.label": "Create my own security question",
  "oie.security.question.authenticator.description": "Choose a security question and answer that will be used for signing in",
  "securityQuestion.answer.tooShort.arg": "The security question answer must be at least {0} characters in length",
  "oie.okta_verify.label": "Okta Verify",
  "oie.okta_verify.authenticator.description": "Okta Verify is an authenticator app, installed on your phone, used to prove your identity",
  "oie.enroll.okta_verify.setup.title": "Set up Okta Verify",
  "oie.enroll.okta_verify.setup.email.title": "Check your email",
  "oie.enroll.okta_verify.setup.sms.title": "Check your text messages",
  "oie.enroll.okta_verify.select.channel.description": "Which option do you want to try?",
  "oie.enroll.okta_verify.select.channel.qrcode.label": "Scan a QR code",
  "oie.enroll.okta_verify.select.channel.email.label": "Email me a setup link",
  "oie.enroll.okta_verify.select.channel.sms.label": "Text me a setup link",
  "oie.enroll.okta_verify.select.channel.title": "More options",
  "oie.enroll.okta_verify.channel.email.label": "Email",
  "oie.enroll.okta_verify.enroll.channel.email.title": "Set up Okta Verify via email link",
  "oie.enroll.okta_verify.enroll.channel.sms.title": "Set up Okta Verify via SMS",
  "oie.enroll.okta_verify.channel.email.description": "Make sure you can access the email on your mobile device.",
  "oie.enroll.okta_verify.channel.sms.description": "Make sure you can access the text on your mobile device.",
  "oie.enroll.okta_verify.qrcode.step1": "On your mobile device, download the Okta Verify app from the App Store (iPhone and iPad) or Google Play (Android devices).",
  "oie.enroll.okta_verify.qrcode.step2": "Open the app and follow the instructions to add your account",
  "oie.enroll.okta_verify.qrcode.step3": "When prompted, tap Scan a QR code, then scan the QR code below:",
  "oie.enroll.okta_verify.qrcode.cannotScan": "Can't scan?",
  "oie.enroll.okta_verify.switch.channel.link.text": 'Or <a href="#" class="switch-channel-link">try a different way</a> to set up Okta Verify.',
  "oie.enroll.okta_verify.email.info": 'We sent an email to <span class="strong">{0}</span> with an Okta Verify setup link. To continue, open the link on your mobile device.',
  "oie.enroll.okta_verify.email.notReceived": 'Haven’t received an email? Check your spam folder or <a href="#" class="resend-link">send again</a>',
  "oie.enroll.okta_verify.sms.info": 'We sent an SMS to <span class="strong">{0}</span> with an Okta Verify setup link. To continue, open the link on your mobile device.',
  "oie.enroll.okta_verify.sms.notReceived": 'Haven’t received an SMS? <a href="#" class="resend-link">Send again</a>',
  "oie.enroll.okta_verify.setupLink": "Send me the setup link",
  "oie.okta_verify.totp.title": "Enter a code",
  "oie.okta_verify.totp.enterCodeText": "Enter code from Okta Verify app",
  "oie.okta_verify.push.title": "Get a push notification",
  "oie.okta_verify.push.sent": "Push notification sent",
  "oie.okta_verify.push.resend": "Resend push notification",
  "oie.okta_verify.sendPushButton": "Send push",
  "oie.okta_verify.signed_nonce.label": "Use Okta FastPass",
  "oie.okta_verify.enroll.force.upgrade.title": "Update Okta Verify",
  "oie.authenticator.app.non_fips_compliant_enrollment_device_incompatible": "The device used to set up Okta Verify does not meet your organization’s security requirements because it is not FIPS compliant. Contact your administrator for help.",
  "oie.authenticator.app.non_fips_compliant_enrollment_app_update_required": "The Okta Verify version on the device used does not meet your organization’s security requirements. To add your account, update Okta Verify to the latest version, then try again.",
  "oie.authenticator.app.method.push.verify.enable.biometrics": "Your response was received, but your organization requires biometrics. Make sure your device supports biometrics, Okta Verify is up-to-date and biometrics are enabled for your account in Okta Verify, then try again.",
  "oie.authenticator.app.method.push.verify.enable.biometrics.title": "Enable biometrics in Okta Verify",
  "oie.authenticator.app.method.push.verify.enable.biometrics.description": "Your response was received, but your organization requires biometrics. Make sure you meet the following requirements, then try again:",
  "oie.authenticator.app.method.push.verify.enable.biometrics.point1": "Your device supports biometrics",
  "oie.authenticator.app.method.push.verify.enable.biometrics.point2": "Okta Verify is up-to-date",
  "oie.authenticator.app.method.push.verify.enable.biometrics.point3": "In Okta Verify, biometrics are enabled for your account",
  "oie.authenticator.app.method.push.enroll.enable.biometrics": "Your organization requires biometrics. To proceed, ensure your device supports biometrics, then add your account and enable biometrics when prompted.",
  "oie.authenticator.app.method.push.enroll.enable.biometrics.title": "Enable biometrics to add an account in Okta Verify",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics": "Your response was received, but your organization requires biometrics. Make sure your device supports biometrics, Okta Verify is up-to-date and biometrics are enabled for your account in Okta Verify, then try again.",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics.title": "Enable biometrics in Okta Verify",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics.description": "Your response was received, but your organization requires biometrics. Make sure you meet the following requirements, then try again:",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics.point1": "Your device supports biometrics",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics.point2": "Okta Verify is up-to-date",
  "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics.point3": "In Okta Verify, biometrics are enabled for your account",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.mobile": "Your response was received, but your organization requires biometrics. Make sure your device supports biometrics, Okta Verify is up-to-date and biometrics are enabled for your account in Okta Verify, then try again.",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.desktop": "Your response was received, but your organization requires biometrics. Make sure your device supports biometrics, Okta Verify is up-to-date, biometrics are enabled for your account in Okta Verify and your device's biometric sensors are accessible, then try again.",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.title": "Biometrics needed for Okta Verify",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.description": "Your response was received, but your organization requires biometrics. Make sure you meet the following requirements, then try again:",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point1": "Your device supports biometrics",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point2": "Okta Verify is up-to-date",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point3": "In Okta Verify, biometrics are enabled for your account",
  "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point4": "Your device's biometric sensors are accessible",
  "oie.google_authenticator.label": "Google Authenticator",
  "oie.google_authenticator.authenticator.description": "Enter a temporary code generated from the Google Authenticator app.",
  "oie.enroll.google_authenticator.setup.title": "Set up Google Authenticator",
  "oie.enroll.google_authenticator.scanBarcode.title": "Scan barcode",
  "oie.enroll.google_authenticator.scanBarcode.description": 'Launch Google Authenticator, tap the "+" icon, then select "Scan barcode".',
  "oie.enroll.google_authenticator.scanBarcode.cannotScan": "Can't scan?",
  "oie.enroll.google_authenticator.cannotScanBarcode.title": "Can't scan barcode?",
  "oie.enroll.google_authenticator.manualSetupInstructions": "To set up manually enter your Okta Account username and then input the following in the Secret Key Field",
  "oie.enroll.google_authenticator.enterCode.title": "Enter code displayed from application",
  "oie.verify.google_authenticator.otp.title": "Verify with Google Authenticator",
  "oie.verify.google_authenticator.otp.description": "Enter the temporary code generated in your Google Authenticator app",
  "oie.google_authenticator.otp.enterCodeText": "Enter code",
  "oie.verify.custom_otp.title": "Verify with {0}",
  "oie.verify.custom_otp.description": "Enter the code generated on your authenticator and verify.",
  "oie.custom_otp.description": "Enter a temporary code generated from an authenticator device.",
  "oie.custom_otp.authenticator.default.vendorName": "Custom OTP Authenticator",
  "oie.custom_otp.verify.passcode.label": "Enter code",
  "oie.verify.custom_app.title": "Verify with {0}",
  "oie.custom_app.push.sent": "Push notification sent",
  "oie.custom_app.push.resend": "Resend push notification",
  "oie.custom_app.push.warning": "Haven't received a push notification yet? Try opening {0} on your phone.",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics": "Your response was received, but your organization requires biometrics—like a fingerprint or facial scan—for access. Make sure your device meets the following requirements, then try again:",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics.title": "Enable biometrics in {0}",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics.description": "Your response was received, but your organization requires biometrics—like a fingerprint or facial scan—for access. Make sure your device meets the following requirements, then try again:",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics.point1": "Your device supports biometrics",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics.point2": "{0} is up-to-date",
  "oie.authenticator.custom_app.method.push.verify.enable.biometrics.point3": "In {0}, biometrics are enabled for your account",
  "oie.custom_app.sendPushButton": "Send push",
  "oie.custom_app.push.title": "Get a push notification",
  "oie.on_prem.authenticator.description": "Verify by entering a code generated by {0}.",
  "oie.on_prem.authenticator.default.vendorName": "Custom On-prem Authenticator",
  "oie.on_prem.enroll.title": "Set up {0}",
  "oie.on_prem.verify.title": "Verify with {0}",
  "oie.numberchallenge.warning": "Haven't received a push notification yet? Try opening the Okta Verify app on your device, or <$1>resend the push notification</$1>.",
  "oie.numberchallenge.instruction": "On your mobile device, open the Okta Verify prompt, then tap <$1>{0}</$1> in Okta Verify to continue.",
  "oie.numberchallenge.force.upgrade.title": "Update Okta Verify",
  "oie.authenticator.app.method.push.force.upgrade.number_challenge": "Your response was received, but your Okta Verify version is no longer supported by your organization. To verify your identity with push notifications, update Okta Verify to the latest version, then try again.",
  "oie.rsa.authenticator.description": "Verify by entering a code generated by RSA SecurID",
  "oie.duo.authenticator.description": "Verify your identity using Duo Security.",
  "oie.duo.enroll.title": "Set up Duo Security",
  "oie.duo.verify.title": "Verify with Duo Security",
  "oie.duo.iFrameError": "Error loading Duo. Try again or contact your admin for assistance.",
  "oie.authenticator.duo.error": "We were unable to verify with Duo. Try again.",
  "oie.idp.authenticator.description": "Redirect to verify with {0}.",
  "oie.idp.enroll.title": "Set up {0}",
  "oie.idp.enroll.description": "You will be redirected to enroll in {0}",
  "oie.idp.challenge.title": "Verify with {0}",
  "oie.idp.challenge.description": "You will be redirected to verify with {0}",
  "idx.identity.provider.auth.error": "There was a problem signing you into your identity provider. Please contact your administrator for help.",
  "oie.symantecVip.authenticator.description": "Verify by entering a temporary code from the {0} app.",
  "oie.symantecVip.enroll.title": "Set up {0}",
  "oie.symantecVip.enroll.description": "From the {0} app, enter your credential ID and two consecutive generated codes",
  "oie.symantecVip.challenge.title": "Verify with {0}",
  "oie.symantecVip.challenge.description": "Enter the generated security code from the {0} app.",
  "oie.symantecVip.verify.passcode.label": "Enter security code",
  "oie.yubikey.label": "YubiKey Authenticator",
  "oie.yubikey.authenticator.description": "Verify your identity using YubiKey",
  "oie.yubikey.enroll.title": "Set up YubiKey",
  "oie.yubikey.challenge.title": "Verify with YubiKey",
  "oie.yubikey.description": "Insert the YubiKey into a USB port and tap it to generate a verification code.",
  "oie.yubikey.passcode.label": "Insert then tap your YubiKey",
  "oie.custom.app.authenticator.title": "Get a push notification",
  "oie.custom.app.authenticator.description": "{0} is an authenticator app, installed on your phone, used to prove your identity",
  "oie.select.authenticators.enroll.title": "Set up security methods",
  "oie.select.authenticators.enroll.subtitle": "Security methods help protect your account by ensuring only you have access.",
  "oie.select.authenticators.enroll.subtitle.custom": "Security methods help protect your {0} account by ensuring only you have access.",
  "oie.setup.required": "Set up required",
  "oie.setup.optional": "Set up optional",
  "oie.optional.authenticator.button.title": "Set up later",
  "oie.verify.authenticator.button.text": "Select",
  "oie.enroll.authenticator.button.text": "Set up",
  "oie.enroll.authenticator.usage.text.access.recovery": "Used for access or recovery",
  "oie.enroll.authenticator.usage.text.recovery": "Used for recovery",
  "oie.enroll.authenticator.usage.text.access": "Used for access",
  "oie.select.authenticators.verify.title": "Verify it's you with a security method",
  "oie.select.authenticators.verify.subtitle": "Select from the following options",
  "oie.success.text.signingIn": "Signing in",
  "oie.success.text.signingIn.with.ellipsis": "Signing in...",
  "oie.success.text.signingIn.with.appName": "Signing in to {0}",
  "oie.success.text.signingIn.with.appName.and.identifier": "Signing in to {0} as {1}",
  "oie.go.back": "Go back",
  "oie.enroll.switch.authenticator": "Return to authenticator list",
  "oie.enroll.skip.setup": "Skip set up",
  "oie.enroll.skip.profile": "Skip Profile",
  "oie.verification.switch.authenticator": "Verify with something else",
  "oie.remember": "Keep me signed in",
  "oie.try.again": "Try again",
  "enroll.title.oda": "Download Okta Verify",
  "enroll.title.oda.with.account": "Additional setup required to use Okta FastPass",
  "enroll.title.oda.without.account": "Set up an Okta Verify account",
  "enroll.title.mdm": "Additional setup required",
  "enroll.subtitle.fastpass": "On this device, do you already have an Okta Verify account for {0}?",
  "enroll.option.noaccount.fastpass": "No, I don’t have an account",
  "enroll.option.account.fastpass": "Yes, I already have an account",
  "enroll.explanation.p1": "To sign in using Okta Verify, you will need to set up Okta Verify on this device.",
  "enroll.explanation.p2": 'In the app, follow the instructions to add an organizational account. When prompted, choose <span class="semi-strong">Sign In</span>, then enter the <span class="semi-strong">sign-in URL</span>:',
  "enroll.oda.android.step1": "On Google Play, download the Okta Verify app.",
  "enroll.oda.step1": "Open Okta Verify and follow the steps to add your account.",
  "enroll.oda.step2": "When prompted, choose Sign In, then enter the sign-in URL:",
  "enroll.oda.step3": "Download the Okta Verify app.",
  "enroll.oda.step6": "Finish setting up your account in Okta Verify, then try accessing this app again.",
  "enroll.oda.with.account.explanation": "Okta FastPass is a security method that can sign you in without needing your username.",
  "enroll.oda.with.account.subtitile1": "Already have Okta FastPass enabled for your account?",
  "enroll.oda.with.account.subtitile2": "Need to set up Okta FastPass for your account?",
  "enroll.oda.with.account.step1": "Make sure your Okta Verify is up-to-date, then try signing in again.",
  "enroll.oda.with.account.step2": "If your device has a work profile, make sure you are signing in from the same profile that Okta Verify is installed in.",
  "enroll.oda.with.account.step3": "On certain browsers and applications, Okta FastPass is not supported.",
  "enroll.oda.with.account.step4": "On this device, open the Okta Verify app.",
  "enroll.oda.with.account.step5": "On the list of accounts, tap your account for {0}.",
  "enroll.oda.with.account.step6": "Under the “Okta FastPass” section, tap Setup, then follow the instructions.",
  "enroll.oda.with.account.step7": "After your setup is complete, return here to try signing in again.",
  "enroll.oda.without.account.explanation": "To sign in with Okta FastPass, you’ll need to set up Okta Verify on this device.",
  "enroll.oda.without.account.step1": 'If you don’t have Okta Verify installed, <a href="{0}" target="_blank" class="download-ov-link" id="download-ov">download the app.</a>',
  "enroll.oda.without.account.step4": "Finish setting up your account in Okta Verify, then try signing in again.",
  "enroll.appleStore": "the App Store",
  "enroll.googleStore": "Google Play",
  "enroll.copy.ios": "Apple®, App Store, and the Apple logo are trademarks of Apple Inc.",
  "enroll.copy.android": "Google Play and the Google Play logo are trademarks of Google LLC.",
  "enroll.explanation.mdm": "To access this app, your device needs to meet your organization's security requirements. Follow the instructions below to continue.",
  "enroll.oda.org.copyLink": "Copy sign-in URL to clipboard",
  "enroll.oda.org.copyLink.success": "Sign-in URL copied.",
  "enroll.mdm.copyLink": "Copy link to clipboard",
  "enroll.mdm.copyLink.success": "Link copied.",
  "enroll.mdm.step.copyLink": "Tap the Copy Link button below.",
  "enroll.mdm.step.pasteLink": "On this device, open your browser, then paste the copied link into the address bar.",
  "enroll.mdm.step.followInstructions": "Follow the instructions in your browser to set up <$1>{0}</$1>.",
  "enroll.mdm.step.relogin": "Logout and re-login and then try accessing the app again.",
  "oie.safe.mode.title": "Authenticator set up unavailable",
  "idx.error.server.safe.mode.enrollment.unavailable": "Set up is temporarily unavailable due to server maintenance. Try again later.",
  "oie.primaryauth.submit": "Sign in",
  "oie.registration.form.title": "Sign up",
  "oie.registration.form.submit": "Sign Up",
  "oie.registration.form.update.submit": "Submit",
  "oie.registration.form.customize.label": "{0}",
  "oie.registration.form.customize.buttonLabel": "{0}",
  "oie.user.profile.lastname": "Last name",
  "oie.user.profile.firstname": "First name",
  "oie.user.profile.primary.email": "Email",
  "oie.user.profile.secondary.email": "Secondary email",
  "oie.user.profile.middleName": "Middle name",
  "oie.user.profile.honorificPrefix": "Honorific prefix",
  "oie.user.profile.honorificSuffix": "Honorific suffix",
  "oie.user.profile.primaryEmail": "Primary email",
  "oie.user.profile.title": "Title",
  "oie.user.profile.displayName": "Display name",
  "oie.user.profile.nickName": "Nickname",
  "oie.user.profile.profileUrl": "Profile URL",
  "oie.user.profile.mobilePhone": "Mobile phone",
  "oie.user.profile.primaryPhone": "Primary phone",
  "oie.user.profile.streetAddress": "Street address",
  "oie.user.profile.city": "City",
  "oie.user.profile.state": "State",
  "oie.user.profile.zipCode": "ZIP Code",
  "oie.user.profile.postalCode": "Postal code",
  "oie.user.profile.countryCode": "Country code",
  "oie.user.profile.postalAddress": "Postal address",
  "oie.user.profile.preferredLanguage": "Preferred language",
  "oie.user.profile.locale": "Locale",
  "oie.user.profile.timezone": "Time zone",
  "oie.user.profile.userType": "User type",
  "oie.user.profile.employeeNumber": "Employee number",
  "oie.user.profile.costCenter": "Cost center",
  "oie.user.profile.organization": "Organization",
  "oie.user.profile.division": "Division",
  "oie.user.profile.department": "Department",
  "oie.user.profile.managerId": "Manager ID",
  "oie.user.profile.manager": "Manager",
  "oie.selfservice.unlock_user.landing.to.app.success.message": "Account successfully unlocked! Verify your account with a security method to continue.",
  "oie.selfservice.unlock_user.landing.to.app.signing.in.message": "Account successfully unlocked!",
  "oie.selfservice.unlock_user.success.message": "You can log in using your existing username and password.",
  "oie.selfservice.unlock_user.failed.message": "We are unable to unlock your account at this time, please contact your administrator",
  "oie.selfservice.user.unlock.not.allowed": "Self Service Unlock is not allowed at this time. Please contact support for assistance.",
  "idx.session.expired": "You have been logged out due to inactivity. Refresh or return to the sign in screen.",
  "oie.registration.is.not.enabled": "Sign up is not enabled for this organization.",
  "oie.forgot.password.is.not.enabled": "Forgot password is not enabled for this organization.",
  "idx.return.error": "Could not process this email link. Return to the screen where you requested it.",
  "idx.return.stale": "This email link is out of date. Return to the screen where you requested it.",
  "idx.invalid.forgot.password.token": "Your reset password token is no longer valid.",
  "idx.invalid.reset.password.token": "Your reset password token is no longer valid. Contact your administrator to obtain a new token.",
  "idx.reset.password.activating.user": "Reset password cannot be performed while the user is activating. Contact your administrator to obtain a new token.",
  tagsNotAllowed,
  "api.authn.error.PASSCODE_INVALID": "Invalid code. Try again.",
  "oie.feature.disabled": "The requested feature is not enabled in this environment.",
  "authfactor.challenge.suspended_factor": "This factor is suspended for your account due to too many failed attempts",
  "oie.post.password.update.auth.failure.error": "Your password has been updated but there was a problem signing you in. Please try again or contact your administrator.",
  "oie.assurance.unsatisfiable": 'Unable to login to "{0}" at this time. For assistance, please contact your administrator.',
  "errors.E0000150": "You have reached the limit of sms requests, please try again later.",
  "errors.E0000151": "You have reached the limit of call requests, please try again later.",
  "oie.invalid.recovery.token": "The recovery token is invalid.",
  "oie.consent.scopes.admin.title": "would like to access:",
  "oie.consent.scopes.enduser.title": "would like to:",
  "oie.consent.scopes.granular.title": "<$1>{0}</$1> <$2>requests access to</$2>",
  "oie.consent.scopes.granular.description": "Allowing access will share",
  "oie.consent.enduser.accept.label": "Yes, it's me",
  "oie.consent.enduser.deny.label": "No, it's not me",
  "oie.consent.enduser.title": "Did you just try to sign in?",
  "oie.consent.enduser.email.allow.title": "Success! Return to the original tab or window",
  "oie.consent.enduser.email.allow.description": "To continue, please return to the original browser tab or window you used to verify.",
  "oie.consent.enduser.deny.description": "Close this window anytime.",
  "oie.return.to.original.tab": "Close this window anytime.",
  "idx.operation.cancelled.by.user": "Operation cancelled by user.",
  "idx.transferred.to.new.tab": "Flow continued in a new tab.",
  "idx.return.link.expired": "This email link has expired. To resend it, return to the screen where you requested it.",
  "idx.return.link.otponly.your.verification.code": "Your verification code",
  "idx.return.link.otponly.enter.code.on.page": "Enter this code on the {0} page.",
  "idx.return.link.otponly.enter.code.on.page.sign.in": "sign-in",
  "idx.return.link.otponly.enter.code.on.page.password.reset": "password reset",
  "idx.return.link.otponly.enter.code.on.page.account.unlock": "account unlock",
  "idx.return.link.otponly.enter.code.on.page.registration": "sign up",
  "idx.return.link.otponly.request": "Request from:",
  "idx.return.link.otponly.warning.text": "If you didn’t request this code, you can ignore this message. Your account is safe and can only be accessed with this code.",
  "idx.enter.otp.in.original.tab": "Enter the OTP in your original authentication location.",
  "idx.return.link.otponly.app": "{0}",
  "idx.return.link.otponly.browser.on.os": "{0} on {1}",
  "geolocation.formatting.all": "{0}, {1}, {2}",
  "geolocation.formatting.partial": "{0}, {1}",
  "consent.scopes.email.label": "View your email address.",
  "consent.scopes.profile.label": "View your profile information.",
  "consent.scopes.phone.label": "View your phone number.",
  "consent.scopes.address.label": "View your address.",
  "consent.scopes.offlineAccess.label": "Keep you signed in to the app.",
  "consent.scopes.onlineAccess.label": "Keep you signed in to the app.",
  "consent.scopes.deviceSSO.label": "Request device secret.",
  "consent.scopes.openid.desc": "Signals that a request is an OpenID request.",
  "consent.scopes.profile.desc": "The exact data varies based on what profile information you have provided, such as: name, time zone, picture, or birthday.",
  "consent.scopes.email.desc": "This allows the app to view your email address.",
  "consent.scopes.address.desc": "This allows the app to view your address, such as: street address, city, state, and zip code.",
  "consent.scopes.phone.desc": "This allows the app to view your phone number.",
  "consent.scopes.offlineAccess.desc": "This keeps you signed in to the app, even when you are not using it.",
  "consent.scopes.onlineAccess.desc": "This allows the app to access your data only when you are logged in to the application.",
  "consent.scopes.deviceSSO.desc": "This allows you to single sign on between native client applications on your device.",
  "consent.scopes.okta.users.manage.desc": "Allows the app to create new users and to manage all users'' profile and credentials information.",
  "consent.scopes.okta.users.manage.self.desc": "Allows the app to manage the signed-in user''s profile and credentials.",
  "consent.scopes.okta.users.read.desc": "Allows the app to read the existing users'' profiles and credentials.",
  "consent.scopes.okta.users.read.self.desc": "Allows the app to read the signed-in user''s profile and credentials.",
  "consent.scopes.okta.linkedObjects.manage.desc": "Allows the app to manage linked object definitions in your Okta organization.",
  "consent.scopes.okta.linkedObjects.read.desc": "Allows the app to read linked object definitions in your Okta organization.",
  "consent.scopes.okta.myAccount.manage.desc": "Allows the end-user to manage their account profile.",
  "consent.scopes.okta.myAccount.read.desc": "Allows the end-user to read their account profile.",
  "consent.scopes.okta.riskEvents.manage.desc": "Allows the app to publish risk events to your Okta organization.",
  "consent.scopes.okta.clients.manage.desc": "Allows the app to manage clients in your Okta organization.",
  "consent.scopes.okta.clients.read.desc": "Allows the app to read information about clients in your Okta organization.",
  "consent.scopes.okta.clients.register.desc": "Allows the app to create new clients in your Okta organization.",
  "consent.scopes.okta.authorizationServers.manage.desc": "Allows the app to create and manage Authorization Servers in your Okta organization.",
  "consent.scopes.okta.authorizationServers.read.desc": "Allows the app to read information about Authorization Servers in your Okta organization.",
  "consent.scopes.okta.groups.manage.desc": "Allows the app to manage existing groups in your Okta organization.",
  "consent.scopes.okta.groups.read.desc": "Allows the app to read information about groups and their members in your Okta organization.",
  "consent.scopes.okta.groups.register.desc": "Allows the app to create new groups in your Okta organization.",
  "consent.scopes.okta.events.read.desc": "Allows the app to read information about deprecated Events v1 API entries in your Okta organization.",
  "consent.scopes.okta.logs.read.desc": "Allows the app to read information about System Log entries in your Okta organization.",
  "consent.scopes.okta.inlineHooks.manage.desc": "Allows the app to create and manage Inline Hooks in your Okta organization.",
  "consent.scopes.okta.inlineHooks.read.desc": "Allows the app to read information about Inline Hooks in your Okta organization.",
  "consent.scopes.okta.eventHooks.manage.desc": "Allows the app to create and manage Event Hooks in your Okta organization.",
  "consent.scopes.okta.eventHooks.read.desc": "Allows the app to read information about Event Hooks in your Okta organization.",
  "consent.scopes.okta.apps.manage.desc": "Allows the app to create and manage Apps in your Okta organization.",
  "consent.scopes.okta.apps.read.desc": "Allows the app to read information about Apps in your Okta organization.",
  "consent.scopes.okta.schemas.manage.desc": "Allows the app to create and manage Schemas in your Okta organization.",
  "consent.scopes.okta.schemas.read.desc": "Allows the app to read information about Schemas in your Okta organization.",
  "consent.scopes.okta.idps.manage.desc": "Allows the app to create and manage Identity Providers in your Okta organization.",
  "consent.scopes.okta.idps.read.desc": "Allows the app to read information about Identity Providers in your Okta organization.",
  "consent.scopes.okta.roles.manage.desc": "Allows the app to manage administrative role assignments for users in your Okta organization.",
  "consent.scopes.okta.roles.read.desc": "Allows the app to read administrative role assignments for users in your Okta organization.",
  "consent.scopes.okta.policies.manage.desc": "Allows the app to manage policies in your Okta organization.",
  "consent.scopes.okta.policies.read.desc": "Allows the app to read information about policies in your Okta organization.",
  "consent.scopes.okta.orgs.manage.desc": "Allows the app to manage organization-specific details for your Okta organization.",
  "consent.scopes.okta.orgs.read.desc": "Allows the app to read organization-specific details about your Okta organization.",
  "consent.scopes.okta.captchas.manage.desc": "Allows the app to create and manage CAPTCHAs in your Okta organization.",
  "consent.scopes.okta.captchas.read.desc": "Allows the app to read information about CAPTCHAs in your Okta organization.",
  "consent.scopes.okta.sessions.manage.desc": "Allows the app to manage all sessions in your Okta organization.",
  "consent.scopes.okta.sessions.read.desc": "Allows the app to read all sessions in your Okta organization.",
  "consent.scopes.okta.trustedOrigins.manage.desc": "Allows the app to manage all Trusted Origins in your Okta organization.",
  "consent.scopes.okta.trustedOrigins.read.desc": "Allows the app to read all Trusted Origins in your Okta organization.",
  "consent.scopes.okta.templates.manage.desc": "Allows the app to manage all custom templates in your Okta organization.",
  "consent.scopes.okta.templates.read.desc": "Allows the app to read all custom templates in your Okta organization.",
  "consent.scopes.okta.factors.manage.desc": "Allows the app to manage all admin operations for org factors (e.g. activate, deactivate, read).",
  "consent.scopes.okta.factors.read.desc": "Allows the app to read org factors information.",
  "consent.scopes.okta.authenticators.manage.desc": "Allows the app to manage all security methods (e.g. enrollments, reset).",
  "consent.scopes.okta.authenticators.read.desc": "Allows the app to read org security method information.",
  "consent.scopes.okta.authenticators.manage.self.desc": "Allows the app to manage users own security methods (e.g. enrollments, reset).",
  "consent.scopes.idSnapshot.read.desc": "Allows the app to read your identity snapshot attestation.",
  "consent.scopes.idSnapshot.manage.desc": "Allows the app to create and manage your identity snapshot attestation.",
  "logo.for.the.app.alt.text": "Logo for the app",
  "device.code.activate.title": "Activate your device",
  "device.code.activate.subtitle": "Follow the instructions on your device to get an activation code",
  "device.code.activate.label": "Activation Code",
  "device.code.activated.success.title": "Device activated",
  "device.code.activated.error.title": "Device not activated",
  "idx.device.activated": "Follow the instructions on your device for next steps",
  "idx.device.not.activated.consent.denied": "Your device cannot be activated because you did not allow access",
  "idx.device.not.activated.internal.error": "Your device cannot be activated because of an internal error",
  "idx.invalid.device.code": "Invalid code. Try again.",
  "idx.operation.cancelled.on.other.device": "Access denied on other device.",
  "idx.expired.activation.token": "Your account activation link is no longer valid. Request a new activation email below.",
  "idx.missing.activation.token": "This can happen if you have already activated your account, or if the URL you are trying to use is invalid. Contact your administrator for further assistance.",
  "idx.activating.inactive.user": "Your account has been temporarily suspended. Contact your administrator for further assistance.",
  "idx.request.activation.email": "New activation link requested. If your information matches our records, you will receive a new activation link in your inbox soon.",
  "oie.activation.request.email.title.expire": "Activation link has expired",
  "oie.activation.request.email.title.invalid": "Activation link no longer valid",
  "oie.activation.request.email.title.suspended": "Account suspended",
  "oie.activation.request.email.title.submitted": "Request submitted",
  "oie.activation.request.email.button": "Request activation email",
  "oie.browser.error.NotAllowedError": "The operation either timed out or was not allowed.",
  "authfactor.challenge.soft_token.invalid_passcode": "Your code doesn't match our records. Please try again.",
  "authfactor.challenge.soft_token.used_passcode": "Each code can only be used once. Please wait for a new code and try again.",
  "oie.tooManyRequests": "Too many attempts. Try again later.",
  E0000010,
  "idx.error.registration.unavailable": "Registration is currently unavailable.",
  "idx.error.user.not.assigned.to.app": "User is not assigned to this application.",
  "idx.error.code.user_not_assigned": "You are not allowed to access this app. To request access, contact an admin."
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Bundles.js
var import_q = __toESM(require_q());

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/BrowserFeatures.js
var fn = {};
var hasFullCorsSupport = "withCredentials" in new window.XMLHttpRequest();
var hasXDomainRequest = typeof window.XDomainRequest !== "undefined";
fn.corsIsNotSupported = function() {
  return !(hasFullCorsSupport || hasXDomainRequest);
};
fn.corsIsNotEnabled = function(jqXhr) {
  return jqXhr.status === 0;
};
fn.localStorageIsNotSupported = function() {
  const test = "test";
  try {
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return false;
  } catch (e) {
    return true;
  }
};
fn.supportsPushState = function(win) {
  win = win || window;
  return !!(win.history && win.history.pushState);
};
fn.isIE = function() {
  return /(msie|trident)/i.test(navigator.userAgent);
};
fn.isFirefox = function() {
  return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
};
fn.isEdge = function() {
  return navigator.userAgent.toLowerCase().indexOf("edge") > -1;
};
fn.isSafari = function() {
  return navigator.userAgent.toLowerCase().indexOf("safari") > -1 && navigator.userAgent.toLowerCase().indexOf("chrome") === -1;
};
fn.isMac = function() {
  return navigator.platform.toUpperCase().indexOf("MAC") >= 0;
};
fn.isAndroid = function() {
  return /android/i.test(navigator.userAgent) && !/windows phone/i.test(navigator.userAgent);
};
fn.isIOS = function() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
};
fn.getUserLanguages = function() {
  if (navigator.languages) {
    return [...navigator.languages];
  }
  const languages = [];
  const properties = [
    "language",
    // Safari, IE11
    "userLanguage",
    // IE
    "browserLanguage",
    // IE
    "systemLanguage"
    // IE
  ];
  properties.forEach(function(property) {
    if (navigator[property]) {
      languages.push(navigator[property]);
    }
  });
  return languages;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Logger.js
function log3(level, args) {
  if (level === "error") {
    window.console[level].apply(window.console, args);
  }
}
var Logger = {
  trace: function() {
    return log3("trace", arguments);
  },
  dir: function() {
    return log3("dir", arguments);
  },
  time: function() {
    return log3("time", arguments);
  },
  timeEnd: function() {
    return log3("timeEnd", arguments);
  },
  group: function() {
    return log3("group", arguments);
  },
  groupEnd: function() {
    return log3("groupEnd", arguments);
  },
  assert: function() {
    return log3("assert", arguments);
  },
  log: function() {
    return log3("log", arguments);
  },
  info: function() {
    return log3("info", arguments);
  },
  warn: function() {
    return log3("warn", arguments);
  },
  error: function() {
    return log3("error", arguments);
  },
  deprecate: function(msg) {
    return log3("warn", ["[okta-signin-widget] DEPRECATED:", msg]);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Bundles.js
var STORAGE_KEY = "osw.languages";
function parseOverrides(i18n2) {
  if (!i18n2) {
    return {};
  }
  const i18nWithLowerCaseKeys = {};
  _.each(_.keys(i18n2), function(key) {
    i18nWithLowerCaseKeys[key.toLowerCase()] = i18n2[key];
  });
  return _.mapObject(i18nWithLowerCaseKeys, function(props6) {
    const mapped = {
      login: {},
      country: {}
    };
    if (!_.isObject(props6)) {
      throw new Error('Invalid format for "i18n"');
    }
    _.each(props6, function(val, key) {
      const split = key.split(/^country\./);
      if (split.length > 1) {
        mapped.country[split[1]] = val;
      } else {
        mapped.login[split[0]] = val;
      }
    });
    return mapped;
  });
}
function getCachedLanguages() {
  let storage = JSON.parse(localStorage.getItem(STORAGE_KEY));
  if (!storage || storage.version !== config.version) {
    storage = {
      version: config.version
    };
  }
  return storage;
}
function addLanguageToCache(language, loginJson, countryJson) {
  const current = getCachedLanguages();
  current[language] = {
    login: loginJson,
    country: countryJson
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(current));
}
function fetchJson(bundle, language, assets) {
  const languageCode = language.replace("-", "_");
  const path = assets.rewrite(encodeURI(`/labels/json/${bundle}_${languageCode}.json`));
  const headers = {
    Accept: "application/json",
    "Content-Type": "text/plain"
  };
  const mode = "no-cors";
  return (0, import_cross_fetch.default)(assets.baseUrl + path, {
    method: "GET",
    headers,
    mode
  }).then((res) => res.text()).then((txt) => JSON.parse(txt));
}
function getBundles(language, assets, supportedLanguages2) {
  if (language === config.defaultLanguage || !_.contains(supportedLanguages2, language)) {
    return (0, import_q.default)({});
  }
  const localStorageIsSupported = !fn.localStorageIsNotSupported();
  if (localStorageIsSupported) {
    const cached = getCachedLanguages();
    if (cached[language]) {
      return (0, import_q.default)(cached[language]);
    }
  }
  return import_q.default.all([fetchJson("login", language, assets), fetchJson("country", language, assets)]).spread(function(loginJson, countryJson) {
    if (localStorageIsSupported) {
      addLanguageToCache(language, loginJson, countryJson);
    }
    return {
      login: loginJson,
      country: countryJson
    };
  }).catch(function() {
    Logger.warn("Unable to load language: " + language);
    return {};
  });
}
var Bundles = {
  login,
  country,
  // Courage components within the sign in widget point to courage bundle to look
  // up i18nkeys. Since we dont have courage.properties inside the sign in widget
  // we are pointing courage bundle to login.
  courage: login,
  currentLanguage: null,
  isLoaded: function(language) {
    return this.currentLanguage === language;
  },
  remove: function() {
    this.currentLanguage = null;
  },
  loadLanguage: function(language, overrides, assets, supportedLanguages2) {
    const parsedOverrides = parseOverrides(overrides);
    const lowerCaseLanguage = language.toLowerCase();
    return getBundles(language, assets, supportedLanguages2).then((bundles) => {
      this.login = _.extend({}, login, bundles.login);
      this.country = _.extend({}, country, bundles.country);
      this.courage = _.extend({}, login, bundles.login);
      if (parsedOverrides[lowerCaseLanguage]) {
        _.extend(this.login, parsedOverrides[lowerCaseLanguage]["login"]);
        _.extend(this.country, parsedOverrides[lowerCaseLanguage]["country"]);
        _.extend(this.courage, parsedOverrides[lowerCaseLanguage]["login"]);
      }
      this.currentLanguage = language;
    });
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/StringUtil.js
var entityMap = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'",
  "&#039;": "'",
  "&#x2F;": "/"
};
var emailValidator = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@(?!-)((\[?[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\]?)|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var parseLocale = (locale) => {
  if (/-/.test(locale)) {
    const parts = locale.split("-");
    parts[1] = parts[1].toUpperCase();
    return parts.join("_");
  }
  return locale;
};
function getBundle(bundleName) {
  if (!bundleName) {
    return Bundles[oktaUnderscore.keys(Bundles)[0]];
  }
  const locale = parseLocale(window && window.okta && window.okta.locale) || "en";
  return Bundles[`${bundleName}_${locale}`] || Bundles[bundleName];
}
function IECustomEvent(event, params) {
  params = params || {
    bubbles: false,
    cancelable: false,
    detail: null
  };
  var evt = document.createEvent("CustomEvent");
  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
  return evt;
}
function emitL10nError(key, bundleName, reason) {
  if (!window.CustomEvent) {
    window.CustomEvent = IECustomEvent;
  }
  if (typeof window.CustomEvent === "function") {
    const event = new CustomEvent("okta-i18n-error", {
      detail: {
        type: "l10n-error",
        key,
        bundleName,
        reason
      }
    });
    document.dispatchEvent(event);
  }
}
var StringUtil = (
  /** @lends module:Okta.internal.util.StringUtil */
  {
    /** @static */
    sprintf: function() {
      const args = Array.prototype.slice.apply(arguments);
      let value = args.shift();
      let oldValue = value;
      function triggerError() {
        throw new Error("Mismatch number of variables: " + arguments[0] + ", " + JSON.stringify(args));
      }
      for (var i = 0, l = args.length; i < l; i++) {
        const entity = args[i];
        const regex = new RegExp("\\{" + i + "\\}", "g");
        value = value.replace(regex, entity);
        if (entity === void 0 || entity === null || value === oldValue) {
          triggerError();
        }
        oldValue = value;
      }
      if (/\{[\d+]\}/.test(value)) {
        triggerError();
      }
      return value;
    },
    /**
     * Converts a URI encoded query string into a hash map
     * @param  {String} query The query string
     * @return {Object} The map
     * @static
     * @example
     * StringUtil.parseQuery('foo=bar&baz=qux') // {foo: 'bar', baz: 'qux'}
     */
    parseQuery: function(query) {
      const params = {};
      const pairs = decodeURIComponent(query.replace(/\+/g, " ")).split("&");
      for (var i = 0; i < pairs.length; i++) {
        const pair = pairs[i];
        const data = pair.split("=");
        params[data.shift()] = data.join("=");
      }
      return params;
    },
    /** @static */
    encodeJSObject: function(jsObj) {
      return encodeURIComponent(JSON.stringify(jsObj));
    },
    /** @static */
    decodeJSObject: function(jsObj) {
      try {
        return JSON.parse(decodeURIComponent(jsObj));
      } catch (e) {
        return null;
      }
    },
    /** @static */
    unescapeHtml: function(string) {
      return String(string).replace(/&[\w#\d]{2,};/g, function(s) {
        return entityMap[s] || s;
      });
    },
    /**
     * Get the original i18n template directly without string format with parameters
     * @param {String} key The key
     * @param {String} bundle="messages"] The name of the i18n bundle. Defaults to the first bundle in the list.
     */
    getTemplate: function(key, bundleName) {
      const bundle = getBundle(bundleName);
      if (!bundle) {
        emitL10nError(key, bundleName, "bundle");
        return "L10N_ERROR[" + bundleName + "]";
      }
      if (bundle[key]) {
        return bundle[key];
      } else {
        emitL10nError(key, bundleName, "key");
        return "L10N_ERROR[" + key + "]";
      }
    },
    /**
     * Translate a key to the localized value
     * @static
     * @param  {String} key The key
     * @param  {String} [bundle="messages"] The name of the i18n bundle. Defaults to the first bundle in the list.
     * @param  {Array} [params] A list of parameters to apply as tokens to the i18n value
     * @return {String} The localized value
     */
    localize: function(key, bundleName, params) {
      const bundle = getBundle(bundleName);
      if (!bundle) {
        emitL10nError(key, bundleName, "bundle");
        return "L10N_ERROR[" + bundleName + "]";
      }
      let value = bundle[key];
      try {
        params = params && params.slice ? params.slice(0) : [];
        params.unshift(value);
        value = StringUtil.sprintf.apply(null, params);
        if (value) {
          return value;
        } else {
          emitL10nError(key, bundleName, "key");
          return "L10N_ERROR[" + key + "]";
        }
      } catch (e) {
        emitL10nError(key, bundleName, "parameters");
        return "L10N_ERROR[" + key + "]";
      }
    },
    /**
     * Convert a string to a float if valid, otherwise return the string.
     * Valid numbers may contain a negative sign and a decimal point.
     * @static
     * @param {String} string The string to convert to a number
     * @return {String|Number} Returns a number if the string can be casted, otherwise returns the original string
     */
    parseFloat: function(string) {
      const number = +string;
      return typeof string === "string" && number === parseFloat(string) ? number : string;
    },
    /**
     * Convert a string to an integer if valid, otherwise return the string
     * @static
     * @param {String} string The string to convert to an integer
     * @return {String|integer} Returns an integer if the string can be casted, otherwise, returns the original string
     */
    parseInt: function(string) {
      const int = +string;
      return oktaUnderscore.isString(string) && int === parseInt(string, 10) ? int : string;
    },
    /**
     * Convert a string to an object if valid, otherwise return the string
     * @static
     * @param {String} string The string to convert to an object
     * @return {String|object} Returns an object if the string can be casted, otherwise, returns the original string
     */
    parseObject: function(string) {
      if (!oktaUnderscore.isString(string)) {
        return string;
      }
      try {
        const object = JSON.parse(string);
        return oktaJQueryStatic.isPlainObject(object) ? object : string;
      } catch (e) {
        return string;
      }
    },
    /**
     * Returns a random string from [a-z][A-Z][0-9] of a given length
     * @static
     * @param {Number} length The length of the random string.
     * @return {String} Returns a random string from [a-z][A-Z][0-9] of a given length
     */
    randomString: function(length) {
      const characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
      if (length === void 0) {
        length = oktaUnderscore.random(characters.length);
      } else if (length === 0) {
        return "";
      }
      const stringArray = [];
      while (length--) {
        stringArray.push(characters[oktaUnderscore.random(characters.length - 1)]);
      }
      return stringArray.join("");
    },
    /**
     * Returns if a str ends with another string
     * @static
     * @param {String} str The string to search
     * @param {String} ends The string it should end with
     *
     * @return {Boolean} Returns if the str ends with ends
     */
    endsWith: function(str, ends) {
      str += "";
      ends += "";
      return str.length >= ends.length && str.substring(str.length - ends.length) === ends;
    },
    /** @static */
    isEmail: function(str) {
      const target = oktaJQueryStatic.trim(str);
      return !oktaUnderscore.isEmpty(target) && emailValidator.test(target);
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/SchemaUtil.js
var loc = StringUtil.localize;
var SchemaUtils = {
  STRING: "string",
  NUMBER: "number",
  INTEGER: "integer",
  BOOLEAN: "boolean",
  OBJECT: "object",
  FORMATDISPLAYTYPE: {
    "date-time": "date",
    uri: "uri",
    email: "email",
    // TODO: settle on using EITHER underscores OR hyphens --- not both (OKTA-202818)
    "country-code": "country-code",
    "language-code": "language-code",
    "country_code": "country_code",
    "language_code": "language_code",
    locale: "locale",
    timezone: "timezone",
    "ref-id": "reference"
  },
  ARRAYDISPLAYTYPE: {
    arrayofobject: "arrayofobject",
    arrayofstring: "arrayofstring",
    arrayofnumber: "arrayofnumber",
    arrayofinteger: "arrayofinteger",
    "arrayofref-id": "arrayofref-id"
  },
  DISPLAYTYPES: {
    date: {
      type: "string",
      format: "date-time"
    },
    uri: {
      type: "string",
      format: "uri"
    },
    email: {
      type: "string",
      format: "email"
    },
    // TODO: Resolve inconsistencies in hyphens vs. underscores for these properties (OKTA-202818)
    // use country-code if attribute should be restricted to country code type
    "country-code": {
      type: "string",
      format: "country-code"
    },
    "language-code": {
      type: "string",
      format: "language-code"
    },
    "country_code": {
      type: "string"
    },
    "language_code": {
      type: "string"
    },
    locale: {
      type: "string",
      format: "locale"
    },
    timezone: {
      type: "string",
      format: "timezone"
    },
    string: {
      type: "string"
    },
    number: {
      type: "number"
    },
    boolean: {
      type: "boolean"
    },
    integer: {
      type: "integer"
    },
    reference: {
      type: "string",
      format: "ref-id"
    },
    arrayofobject: {
      type: "array",
      items: {
        type: "object"
      }
    },
    arrayofstring: {
      type: "array",
      items: {
        type: "string"
      }
    },
    arrayofnumber: {
      type: "array",
      items: {
        type: "number"
      }
    },
    arrayofinteger: {
      type: "array",
      items: {
        type: "integer"
      }
    },
    "arrayofref-id": {
      type: "array",
      items: {
        type: "string",
        format: "ref-id"
      }
    },
    image: {
      type: "image"
    },
    password: {
      type: "string"
    }
  },
  SUPPORTSMINMAX: ["string", "number", "integer", "password"],
  SUPPORTENUM: ["string", "number", "integer", "object", "arrayofstring", "arrayofnumber", "arrayofinteger", "arrayofobject"],
  DATATYPE: {
    string: "string",
    number: "number",
    boolean: "boolean",
    integer: "integer",
    date: "datetime",
    object: "object",
    arrayofobject: "object array",
    arrayofstring: "string array",
    arrayofnumber: "number array",
    arrayofinteger: "integer array",
    "arrayofref-id": "reference array",
    // TODO: settle on using EITHER underscores OR hyphens --- not both (OKTA-202818)
    "country-code": "country code",
    "language-code": "language code",
    "country_code": "country code",
    "language_code": "language code",
    reference: "reference",
    timezone: "timezone",
    image: "image"
  },
  MUTABILITY: {
    READONLY: "READ_ONLY",
    WRITEONLY: "WRITE_ONLY",
    READWRITE: "READ_WRITE",
    IMMUTABLE: "IMMUTABLE"
  },
  SCOPE: {
    NONE: "NONE",
    SELF: "SELF",
    SYSTEM: "SYSTEM"
  },
  DISPLAYSCOPE: {
    SELF: "User personal",
    SYSTEM: "System",
    NA: "None"
  },
  UNION: {
    DISABLE: "DISABLE",
    ENABLE: "ENABLE"
  },
  UNION_OPTIONS: {
    DISABLE: loc("universal-directory.profiles.attribute.form.union.enable.display", "courage"),
    ENABLE: loc("universal-directory.profiles.attribute.form.union.disable.display", "courage")
  },
  PERMISSION: {
    HIDE: "HIDE",
    READ_ONLY: "READ_ONLY",
    WRITE_ONLY: "WRITE_ONLY",
    READ_WRITE: "READ_WRITE"
  },
  ENDUSER_ATTRIBUTE_PERMISSION_OPTIONS: {
    HIDE: loc("universal-directory.profiles.attribute.enduser.permission.hide", "courage"),
    READ_ONLY: loc("universal-directory.profiles.attribute.enduser.permission.readonly", "courage"),
    READ_WRITE: loc("universal-directory.profiles.attribute.enduser.permission.readwrite", "courage")
  },
  ATTRIBUTE_LEVEL_MASTERING_OPTIONS: {
    INHERIT: loc("universal-directory.profiles.attribute.source.inherit", "courage"),
    // eslint-disable-next-line @okta/okta/no-exclusive-language
    OKTA_MASTERED: loc("universal-directory.profiles.attribute.source.oktamastered", "courage"),
    OVERRIDE: loc("universal-directory.profiles.attribute.source.override", "courage")
  },
  USERNAMETYPE: {
    NONE: "non-username",
    OKTA_TO_APP: "okta-to-app-username",
    OKTA_TO_AD: "okta-to-ad-username",
    APP_TO_OKTA: "app-to-okta-username",
    IDP_TO_OKTA: "idp-to-okta-username"
  },
  LOGINPATTERNFORMAT: {
    EMAIL: "EMAIL",
    CUSTOM: "CUSTOM",
    NONE: "NONE"
  },
  UNIQUENESS: {
    NOT_UNIQUE: "NOT_UNIQUE",
    PENDING_UNIQUENESS: "PENDING_UNIQUENESS",
    UNIQUE_VALIDATED: "UNIQUE_VALIDATED"
  },
  /*
   * Get a display string for a schema attribute type.
   * @param {String} type Type of an attribute
   * @param {String} format Format of an attribute
   * @param {String} itemType Item type of an attribute if an array
   * @param {String} defaultValue The default value if an attribute type is undefined
   * @return {String} the display value
   */
  getDisplayType: function(type, format, itemType, defaultValue) {
    let displayType;
    if (type) {
      if (format) {
        displayType = this.FORMATDISPLAYTYPE[format];
      } else {
        displayType = itemType ? this.ARRAYDISPLAYTYPE[type + "of" + itemType] : type;
      }
    }
    if (!displayType) {
      displayType = typeof defaultValue === "undefined" ? "" : defaultValue;
    }
    return displayType;
  },
  /*
   * Get attribute mapping source attribute username type
   * @param {String} mappingDirection
   * @param {String} targetName The mapping target attribute name
   * @param {String} appName The app name that's mapped to/from Okta
   * @return {String} the source attribute username type value
   */
  getSourceUsernameType: function(mappingDirection, targetName, appName) {
    let sourceUsernameType = this.USERNAMETYPE.NONE;
    if (mappingDirection === "oktaToApp") {
      if (targetName === "userName") {
        sourceUsernameType = this.USERNAMETYPE.OKTA_TO_APP;
      } else if (targetName === "cn") {
        sourceUsernameType = this.USERNAMETYPE.OKTA_TO_AD;
      }
    } else if (mappingDirection === "appToOkta" && targetName === "login") {
      if (appName === "saml_idp") {
        sourceUsernameType = this.USERNAMETYPE.IDP_TO_OKTA;
      } else {
        sourceUsernameType = this.USERNAMETYPE.APP_TO_OKTA;
      }
    }
    return sourceUsernameType;
  },
  isArrayDataType: function(type) {
    return oktaUnderscore.contains(oktaUnderscore.values(this.ARRAYDISPLAYTYPE), type);
  },
  isObjectDataType: function(type) {
    return this.DATATYPE.object === type;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/EnumTypeHelper.js
var NAME = "name";
var ENUM_KEY_PREFIX = "_enum_";
function getEnumInputOptions(config2) {
  const enumOneOf = convertToOneOf(config2.enumValues);
  const inputOptions = {
    name: config2.name,
    label: config2.title,
    readOnly: config2.readOnly,
    customExplain: config2.explain,
    params: {
      enumOneOf
    },
    options: getDropdownOptionsFromOneOf(enumOneOf)
  };
  if (SchemaUtils.isArrayDataType(config2.displayType)) {
    inputOptions.type = "checkboxset";
    inputOptions.to = valuesToEnumObjects;
    inputOptions.from = enumObjectsToValues;
  } else {
    inputOptions.type = "select";
    inputOptions.to = valueToEnumObject;
    inputOptions.from = enumObjectToValue;
  }
  inputOptions.input = null;
  return inputOptions;
}
function getDropdownOptions(values) {
  return oktaUnderscore.isArray(values) ? getDropdownOptionsFromOneOf(convertToOneOf(values)) : {};
}
function getDropdownOptionsFromOneOf(values) {
  if (!isOneOfEnumObject(values)) {
    return {};
  }
  return oktaUnderscore.reduce(values, function(options2, value, index) {
    options2[convertIndexToEnumIndex(index)] = value.title;
    return options2;
  }, {});
}
function convertToOneOf(values) {
  if (!oktaUnderscore.all(values, oktaJQueryStatic.isPlainObject)) {
    return convertEnumToOneOf(values);
  } else if (!isOneOfEnumObject(values)) {
    return convertEnumObjectToOneOf(values);
  }
  return values;
}
function isOneOfEnumObject(values) {
  return oktaUnderscore.isArray(values) && oktaUnderscore.all(values, function(value) {
    return oktaUnderscore.has(value, "const") && oktaUnderscore.has(value, "title");
  });
}
function convertEnumToOneOf(values) {
  return oktaUnderscore.map(values, function(value) {
    return {
      const: value,
      title: valueToTitle(value)
    };
  });
}
function valueToTitle(value) {
  if (oktaUnderscore.isObject(value)) {
    return JSON.stringify(value);
  }
  if (oktaUnderscore.isNumber(value)) {
    return value + "";
  }
  return value;
}
function convertEnumObjectToOneOf(values) {
  const findKey = oktaUnderscore.partial(oktaUnderscore.has, oktaUnderscore, NAME);
  if (oktaUnderscore.all(values, findKey)) {
    return oktaUnderscore.chain(values).filter(function(value) {
      return oktaJQueryStatic.isPlainObject(value) && oktaUnderscore.has(value, NAME);
    }).map(function(value) {
      return {
        const: value,
        title: value[NAME]
      };
    }).value();
  }
  return convertEnumToOneOf(values);
}
function convertIndexToEnumIndex(index) {
  return `${ENUM_KEY_PREFIX}${index}`;
}
function enumObjectToValue(obj) {
  const index = oktaUnderscore.findIndex(this.options.params.enumOneOf, function(oneOfObj) {
    return oktaUnderscore.isObject(obj) ? oktaUnderscore.isEqual(oneOfObj.const, obj) : oneOfObj.const === obj;
  });
  return index > -1 ? convertIndexToEnumIndex(index) : obj;
}
function valueToEnumObject(val) {
  if (!oktaUnderscore.isString(val) || val.indexOf(ENUM_KEY_PREFIX) !== 0) {
    return val;
  }
  const index = val.replace(ENUM_KEY_PREFIX, "");
  const enumValue = this.options.params && oktaUnderscore.isArray(this.options.params.enumOneOf) ? this.options.params.enumOneOf[index] : null;
  return oktaUnderscore.has(enumValue, "const") ? enumValue.const : enumValue;
}
function valuesToEnumObjects(values) {
  return oktaUnderscore.map(values, valueToEnumObject.bind(this));
}
function enumObjectsToValues(values) {
  return oktaUnderscore.map(values, enumObjectToValue.bind(this));
}
function isStringConstraint(value) {
  return oktaUnderscore.isString(value) && oktaJQueryStatic.trim(value) !== "";
}
function isNumberConstraint(value) {
  return oktaUnderscore.isNumber(value) || oktaUnderscore.isNumber(StringUtil.parseFloat(oktaJQueryStatic.trim(value)));
}
function isIntegerConstraint(value) {
  const integer = oktaUnderscore.isNumber(value) ? value : StringUtil.parseInt(oktaJQueryStatic.trim(value));
  return typeof integer === "number" && isFinite(integer) && Math.floor(integer) === integer;
}
function isObjectConstraint(value) {
  if (oktaUnderscore.isObject(value) && !oktaUnderscore.isArray(value)) {
    return true;
  }
  const object = StringUtil.parseObject(oktaJQueryStatic.trim(value));
  return oktaUnderscore.isObject(object) && !oktaUnderscore.isArray(object);
}
function isConstraintValueMatchType(value, type) {
  switch (type) {
    case SchemaUtils.STRING:
      return isStringConstraint(value);
    case SchemaUtils.NUMBER:
      return isNumberConstraint(value);
    case SchemaUtils.INTEGER:
      return isIntegerConstraint(value);
    case SchemaUtils.OBJECT:
      return isObjectConstraint(value);
  }
}
var EnumTypeHelper = {
  getEnumInputOptions,
  getDropdownOptions,
  convertToOneOf,
  isConstraintValueMatchType
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/models/SchemaProperty.js
var loc2 = StringUtil.localize;
var STRING = SchemaUtils.STRING;
var NUMBER = SchemaUtils.NUMBER;
var INTEGER = SchemaUtils.INTEGER;
var OBJECT = SchemaUtils.OBJECT;
var getArrayTypeName = function(type, elementType) {
  return type + "of" + elementType;
};
var SchemaPropertySubSchema = BaseModel.extend({
  defaults: {
    description: void 0,
    minLength: void 0,
    maxLength: void 0,
    format: void 0
  },
  parse: function(resp) {
    if (oktaUnderscore.isString(resp.format)) {
      const matcher = /^\/(.+)\/$/.exec(resp.format);
      if (matcher) {
        resp.format = matcher[1];
      }
    }
    return resp;
  }
});
var SchemaPropertySubSchemaCollection = BaseCollection.extend({
  model: SchemaPropertySubSchema
});
var SchemaPropertySubSchemaAllOfCollection = SchemaPropertySubSchemaCollection.extend({
  _type: "allOf"
});
var SchemaPropertySubSchemaOneOfCollection = SchemaPropertySubSchemaCollection.extend({
  _type: "oneOf"
});
var SchemaPropertySubSchemaNoneOfCollection = SchemaPropertySubSchemaCollection.extend({
  _type: "noneOf"
});
var constraintTypeErrorMessages = {
  string: loc2("schema.validation.field.value.must.string", "courage"),
  number: loc2("schema.validation.field.value.must.number", "courage"),
  integer: loc2("schema.validation.field.value.must.integer", "courage"),
  object: loc2("schema.validation.field.value.must.object", "courage")
};
var loginFormatNonePattern = ".+";
var escapedLoginCharsRe = /[^a-zA-Z0-9-]/;
var constraintHandlers = {
  between: "_checkBetweenConstraints",
  greaterThan: "_checkGreaterThanConstraint",
  lessThan: "_checkLessThanConstraint",
  equals: "_checkEqualsConstraint"
};
var SchemaPropertySchemaProperty = BaseModel.extend({
  idAttribute: "name",
  local: {
    __oneOf__: {
      type: "array",
      minItems: 1
    }
  },
  defaults: {
    // OKTA-28445, set empty string by default as the key for each property when syncing with server
    // so that server can respond with error when a name is not provided
    name: "",
    title: void 0,
    type: void 0,
    description: void 0,
    required: false,
    format: void 0,
    // choose disable option be default.
    union: void 0,
    subSchemas: void 0,
    settings: {
      permissions: {
        SELF: SchemaUtils.PERMISSION.READ_ONLY
      }
    },
    unique: void 0,
    __metadata__: void 0,
    __isSensitive__: BaseModel.ComputedProperty(["settings"], function(settings) {
      return !!(settings && settings.sensitive && settings.sensitive !== "NOT_SENSITIVE");
    }),
    __isPendingSensitive__: BaseModel.ComputedProperty(["settings"], function(settings) {
      return !!(settings && settings.sensitive && settings.sensitive === "PENDING_SENSITIVE");
    }),
    __unique__: false,
    __isUniqueValidated__: BaseModel.ComputedProperty(["unique"], function(unique) {
      return unique === SchemaUtils.UNIQUENESS.UNIQUE_VALIDATED;
    }),
    __isPendingUniqueness__: BaseModel.ComputedProperty(["unique"], function(unique) {
      return unique === SchemaUtils.UNIQUENESS.PENDING_UNIQUENESS;
    }),
    __isUniqueness__: BaseModel.ComputedProperty(["__isUniqueValidated__", "__isPendingUniqueness__"], function(isValidated, isPending) {
      return isValidated || isPending;
    }),
    __canBeSensitive__: BaseModel.ComputedProperty(["__metadata__"], function(metadata) {
      return !!(metadata && metadata.sensitivizable);
    }),
    __userPermission__: SchemaUtils.PERMISSION.READ_ONLY,
    __displayType__: void 0,
    __displayTypeLabel__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return SchemaUtils.DATATYPE[displayType] || displayType;
    }),
    __supportsMinMax__: false,
    // use the private naming convention for these computed properties,
    // to deal with the complexity in cloning schema with properties (toJSON({verbose: true})),
    // to make sure these attributes are being excluded from api request
    __isReadOnly__: BaseModel.ComputedProperty(["mutability"], function(mutability) {
      return mutability === SchemaUtils.MUTABILITY.READONLY;
    }),
    __isWriteOnly__: BaseModel.ComputedProperty(["mutability"], function(mutability) {
      return mutability === SchemaUtils.MUTABILITY.WRITEONLY;
    }),
    __displayScope__: void 0,
    __isScopeSelf__: BaseModel.ComputedProperty(["scope"], function(scope) {
      return scope === SchemaUtils.SCOPE.SELF;
    }),
    __isNoneScopeArrayType__: BaseModel.ComputedProperty(["__isScopeSelf__", "__displayType__"], function(isScopeSelf, displayType) {
      return !isScopeSelf && SchemaUtils.isArrayDataType(displayType);
    }),
    __isImported__: BaseModel.ComputedProperty(["externalName"], function(externalName) {
      return !!externalName;
    }),
    __isFromBaseSchema__: BaseModel.ComputedProperty(["__schemaMeta__"], function(schemaMeta) {
      return schemaMeta && schemaMeta.name === "base";
    }),
    // Only UI can turn on __enumDefined__ and reprocess the enum/oneOf value; otherwise,
    // it should leave existing value untouch
    __enumDefined__: false,
    __supportEnum__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return oktaUnderscore.contains(SchemaUtils.SUPPORTENUM, displayType);
    }),
    __isNumberTypeEnum__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return oktaUnderscore.contains([SchemaUtils.NUMBER, SchemaUtils.ARRAYDISPLAYTYPE.arrayofnumber], displayType);
    }),
    __isIntegerTypeEnum__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return oktaUnderscore.contains([SchemaUtils.INTEGER, SchemaUtils.ARRAYDISPLAYTYPE.arrayofinteger], displayType);
    }),
    __isObjectTypeEnum__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return oktaUnderscore.contains([SchemaUtils.OBJECT, SchemaUtils.ARRAYDISPLAYTYPE.arrayofobject], displayType);
    }),
    __isStringTypeEnum__: BaseModel.ComputedProperty(["__displayType__"], function(displayType) {
      return oktaUnderscore.contains([SchemaUtils.STRING, SchemaUtils.ARRAYDISPLAYTYPE.arrayofstring], displayType);
    }),
    __enumConstraintType__: BaseModel.ComputedProperty(["__isStringTypeEnum__", "__isNumberTypeEnum__", "__isIntegerTypeEnum__", "__isObjectTypeEnum__"], function(isStringType, isNumberType, isIntegerType, isObjectType) {
      if (isStringType) {
        return STRING;
      }
      if (isNumberType) {
        return NUMBER;
      }
      if (isIntegerType) {
        return INTEGER;
      }
      if (isObjectType) {
        return OBJECT;
      }
    }),
    __isEnumDefinedAndSupported__: BaseModel.ComputedProperty(["__enumDefined__", "__supportEnum__"], function(enumDefined, supportEnum) {
      return enumDefined && supportEnum;
    }),
    __isLoginOfBaseSchema__: BaseModel.ComputedProperty(["__isFromBaseSchema__", "name"], function(isFromBaseSchema, name) {
      return isFromBaseSchema && name === "login";
    }),
    __isLoginFormatRestrictionToEmail__: BaseModel.ComputedProperty(["__loginFormatRestriction__"], function(loginFormatRestriction) {
      return loginFormatRestriction === SchemaUtils.LOGINPATTERNFORMAT.EMAIL;
    })
  },
  initialize: function() {
    BaseModel.prototype.initialize.apply(this, arguments);
    this.listenTo(this, "change:__displayType__", this._updateTypeFormatConstraints);
    this.listenTo(this, "change:type change:format change:items", this._updateDisplayType);
    this.listenTo(this, "change:__minVal__ change:__maxVal__", this._updateMinMax);
    this.listenTo(this, "change:__equals__", this._convertEqualsToMinMax);
    this.listenTo(this, "change:__constraint__", this._setConstraintText);
    this._setConstraintText();
    this._setLoginPattern();
  },
  parse: function(resp) {
    resp = oktaUnderscore.clone(resp);
    if (resp.type === "object" && resp.extendedType === "image") {
      resp.type = "image";
    }
    resp["__displayType__"] = SchemaUtils.getDisplayType(resp.type, resp.format, resp.items ? resp.items.format ? resp.items.format : resp.items.type : void 0);
    this._setRangeConstraints(resp);
    resp["__supportsMinMax__"] = SchemaUtils.SUPPORTSMINMAX.indexOf(resp["__displayType__"]) !== -1;
    resp["__displayScope__"] = SchemaUtils.DISPLAYSCOPE[resp.scope] || SchemaUtils.DISPLAYSCOPE.NA;
    if (resp.settings && resp.settings.permissions && resp.settings.permissions.SELF) {
      resp["__userPermission__"] = resp.settings.permissions.SELF;
    }
    this._setMasterOverride(resp);
    this._setSubSchemas(resp);
    this._setUniqueness(resp);
    return resp;
  },
  validate: function() {
    const enumValidationError = this._validateEnumOneOf();
    if (enumValidationError) {
      return enumValidationError;
    }
    if (!this.get("__supportsMinMax__") || !this.get("__constraint__")) {
      return void 0;
    }
    const constraitType = this.get("__constraint__");
    const constraitHandler = this[constraintHandlers[constraitType]];
    if (oktaUnderscore.isFunction(constraitHandler)) {
      return constraitHandler.call(this);
    } else {
      return void 0;
    }
  },
  _checkBetweenConstraints: function() {
    const minVal = this.get("__minVal__");
    const maxVal = this.get("__maxVal__");
    if (!minVal && !maxVal) {
      return;
    }
    if (!minVal) {
      return {
        __minVal__: "Min value is required"
      };
    }
    if (!maxVal) {
      return {
        __maxVal__: "Max value is required"
      };
    }
    let val = this._checkIntegerConstraints("__minVal__", "Min value");
    if (val) {
      return val;
    }
    val = this._checkIntegerConstraints("__maxVal__", "Max value");
    if (val) {
      return val;
    }
    if (+minVal >= +maxVal) {
      return {
        __maxVal__: "Max val must be greater than min val"
      };
    }
  },
  _checkGreaterThanConstraint: function() {
    const minVal = this.get("__minVal__");
    if (!minVal) {
      return;
    }
    const val = this._checkIntegerConstraints("__minVal__", "Min value");
    if (val) {
      return val;
    }
  },
  _checkLessThanConstraint: function() {
    const maxVal = this.get("__maxVal__");
    if (!maxVal) {
      return;
    }
    const val = this._checkIntegerConstraints("__maxVal__", "Max value");
    if (val) {
      return val;
    }
  },
  _checkEqualsConstraint: function() {
    const equals = this.get("__equals__");
    if (!equals) {
      return;
    }
    const val = this._checkIntegerConstraints("__equals__", "Constraint");
    if (val) {
      return val;
    }
  },
  _checkIntegerConstraints: function(field, name) {
    const val = this.get(field);
    const error = {};
    if (isNaN(val)) {
      error[field] = name + " must be a number";
      return error;
    }
    if (+val < 0) {
      error[field] = name + " must be greater than 0";
      return error;
    }
  },
  _setMasterOverride: function(resp) {
    if (resp.settings && resp.settings.masterOverride && resp.settings.masterOverride) {
      const masterOverrideValue = resp.settings.masterOverride.value;
      if (oktaUnderscore.isArray(masterOverrideValue) && !oktaUnderscore.isEmpty(masterOverrideValue)) {
        resp["__masterOverrideType__"] = "OVERRIDE";
        resp["__masterOverrideValue__"] = masterOverrideValue || [];
      } else {
        resp["__masterOverrideType__"] = resp.settings.masterOverride.type;
      }
    } else {
      resp["__masterOverrideType__"] = "INHERIT";
    }
  },
  _setRangeConstraints: function(resp) {
    if (resp["__displayType__"] === STRING) {
      resp["__minVal__"] = resp.minLength;
      resp["__maxVal__"] = resp.maxLength;
    } else if (resp["__displayType__"] === INTEGER || resp["__displayType__"] === NUMBER) {
      resp["__minVal__"] = resp.minimum;
      resp["__maxVal__"] = resp.maximum;
    }
    if (resp["__minVal__"] && resp["__maxVal__"]) {
      if (resp["__minVal__"] === resp["__maxVal__"]) {
        resp["__constraint__"] = "equals";
        resp["__equals__"] = resp["__minVal__"];
      } else {
        resp["__constraint__"] = "between";
      }
    } else if (!resp["__minVal__"] && resp["__maxVal__"]) {
      resp["__constraint__"] = "lessThan";
    } else if (!resp["__maxVal__"] && resp["__minVal__"]) {
      resp["__constraint__"] = "greaterThan";
    }
  },
  _setSubSchemas: function(resp) {
    if (resp.allOf) {
      resp["subSchemas"] = new SchemaPropertySubSchemaAllOfCollection(resp.allOf, {
        parse: true
      });
    } else if (resp.oneOf) {
      resp["subSchemas"] = new SchemaPropertySubSchemaOneOfCollection(resp.oneOf, {
        parse: true
      });
    } else if (resp.noneOf) {
      resp["subSchemas"] = new SchemaPropertySubSchemaNoneOfCollection(resp.noneOf, {
        parse: true
      });
    }
  },
  _setUniqueness: function(resp) {
    const unique = resp && resp.unique;
    resp["__unique__"] = !!(unique && (unique === SchemaUtils.UNIQUENESS.UNIQUE_VALIDATED || unique === SchemaUtils.UNIQUENESS.PENDING_UNIQUENESS));
  },
  _setLoginPattern: function() {
    if (!this.get("__isLoginOfBaseSchema__")) {
      return;
    }
    const pattern = this.get("pattern");
    if (pattern === loginFormatNonePattern) {
      this.set("__loginFormatRestriction__", SchemaUtils.LOGINPATTERNFORMAT.NONE);
    } else if (pattern) {
      this.set("__loginFormatRestriction__", SchemaUtils.LOGINPATTERNFORMAT.CUSTOM);
      this.set("__loginFormatRestrictionCustom__", this._extractLoginPattern(pattern));
    } else {
      this.set("__loginFormatRestriction__", SchemaUtils.LOGINPATTERNFORMAT.EMAIL);
    }
  },
  _updateDisplayType: function() {
    const type = this.get("type");
    if (type === STRING && this.get("format")) {
      this.set("__displayType__", SchemaUtils.FORMATDISPLAYTYPE[this.get("format")]);
    } else {
      const items = this.get("items");
      const arraytype = items && (items.format ? items.format : items.type);
      if (type && arraytype) {
        this.set("__displayType__", SchemaUtils.ARRAYDISPLAYTYPE[getArrayTypeName(type, arraytype)]);
      } else {
        this.set("__displayType__", type);
      }
    }
  },
  _validateEnumOneOf: function() {
    if (!this.get("__isEnumDefinedAndSupported__")) {
      return;
    }
    const enumOneOf = this.get("__oneOf__") || [];
    if (oktaUnderscore.isEmpty(enumOneOf)) {
      return {
        __oneOf__: loc2("model.validation.field.blank", "courage")
      };
    }
    if (!this._isValidateOneOfConstraint(enumOneOf)) {
      const constraintType = this.get("__enumConstraintType__");
      const errorTypeMsg = constraintTypeErrorMessages[constraintType];
      return {
        __oneOf__: errorTypeMsg
      };
    }
  },
  _isValidateOneOfConstraint: function(values) {
    const constraintType = this.get("__enumConstraintType__");
    return oktaUnderscore.all(values, function(value) {
      return EnumTypeHelper.isConstraintValueMatchType(value.const, constraintType);
    });
  },
  toJSON: function() {
    let json = BaseModel.prototype.toJSON.apply(this, arguments);
    json.settings = {
      permissions: {}
    };
    json.settings.permissions["SELF"] = this.get("__userPermission__");
    if (this.get("__isSensitive__")) {
      json.settings.sensitive = this.get("__isSensitive__");
    }
    if (this.get("type") === "image") {
      json.type = "object";
      json.extendedType = "image";
    }
    json = this._enumAssignment(json);
    json = this._attributeOverrideToJson(json);
    json = this._normalizeUnionValue(json);
    json = this._patternAssignment(json);
    json = this._uniquenessAssignment(json);
    return json;
  },
  _attributeOverrideToJson: function(json) {
    const masterOverrideType = this.get("__masterOverrideType__");
    const masterOverrideValue = this.get("__masterOverrideValue__");
    if (masterOverrideType === "OKTA_MASTERED") {
      json.settings.masterOverride = {
        type: "OKTA_MASTERED"
      };
    } else if (masterOverrideType === "OVERRIDE") {
      json.settings.masterOverride = {
        type: "ORDERED_LIST",
        value: []
      };
      if (masterOverrideValue instanceof BaseCollection) {
        oktaUnderscore.each(masterOverrideValue.toJSON(), function(overrideProfile) {
          json.settings.masterOverride.value.push(overrideProfile.id);
        });
      } else if (masterOverrideValue instanceof Array) {
        json.settings.masterOverride.value = masterOverrideValue;
      }
      if (oktaUnderscore.isEmpty(json.settings.masterOverride.value)) {
        delete json.settings.masterOverride;
      }
    }
    if (masterOverrideType === "INHERIT") {
      delete json.settings.masterOverride;
    }
    return json;
  },
  /**
   * Only allow set "union" value when isScopeSelf is NONE and displayType is
   * array of (string/number/integer), otherwise reset to default.
   *
   * @see /universal-directory/shared/views/components/UnionGroupValuesRadio.js
   */
  _normalizeUnionValue: function(json) {
    if (!this.get("__isNoneScopeArrayType__")) {
      json["union"] = void 0;
    }
    return json;
  },
  _enumAssignment: function(json) {
    if (!this.get("__isEnumDefinedAndSupported__")) {
      return json;
    }
    const enumOneOf = this._getEnumOneOfWithTitleCheck();
    if (this.get("type") === "array") {
      delete json.items.enum;
      json.items.oneOf = enumOneOf;
    } else {
      delete json.enum;
      json.oneOf = enumOneOf;
    }
    return json;
  },
  _patternAssignment: function(json) {
    if (!this.get("__isLoginOfBaseSchema__") || !this.get("__loginFormatRestriction__")) {
      return json;
    }
    switch (this.get("__loginFormatRestriction__")) {
      case SchemaUtils.LOGINPATTERNFORMAT.EMAIL:
        delete json.pattern;
        break;
      case SchemaUtils.LOGINPATTERNFORMAT.CUSTOM:
        json.pattern = this._buildLoginPattern(this.get("__loginFormatRestrictionCustom__"));
        break;
      case SchemaUtils.LOGINPATTERNFORMAT.NONE:
        json.pattern = loginFormatNonePattern;
        break;
    }
    return json;
  },
  _uniquenessAssignment: function(json) {
    if (!this.get("__unique__")) {
      delete json.unique;
    } else if (!this.get("__isUniqueness__")) {
      json.unique = SchemaUtils.UNIQUENESS.UNIQUE_VALIDATED;
    }
    return json;
  },
  /**
   * Character should be escaped except letters, digits and hyphen
   */
  _escapedRegexChar: function(pattern, index) {
    const char = pattern.charAt(index);
    if (escapedLoginCharsRe.test(char)) {
      return "\\" + char;
    }
    return char;
  },
  _buildLoginPattern: function(pattern) {
    let result = "";
    for (var i = 0; i < pattern.length; i++) {
      result += this._escapedRegexChar(pattern, i);
    }
    return "[" + result + "]+";
  },
  _extractLoginPattern: function(pattern) {
    const re = /^\[(.*)\]\+/;
    const matches = pattern.match(re);
    return matches ? matches[1].replace(/\\(.)/g, "$1") : pattern;
  },
  _getEnumOneOfWithTitleCheck: function() {
    const enumOneOf = this.get("__oneOf__");
    return oktaUnderscore.map(enumOneOf, function(value) {
      if (oktaJQueryStatic.trim(value.title) !== "") {
        return value;
      }
      value.title = !oktaUnderscore.isString(value.const) ? JSON.stringify(value.const) : value.const;
      return value;
    });
  },
  _updateTypeFormatConstraints: function() {
    const displayType = this.get("__displayType__");
    this.unset("format", {
      silent: true
    });
    this.unset("items", {
      silent: true
    });
    this.set(SchemaUtils.DISPLAYTYPES[displayType]);
    if (displayType !== NUMBER && displayType !== INTEGER) {
      this.unset("minimum");
      this.unset("maximum");
    }
    if (displayType !== STRING) {
      this.unset("minLength");
      this.unset("maxLength");
    }
    this.unset("__minVal__");
    this.unset("__maxVal__");
    this.unset("__equals__");
    this.set("__supportsMinMax__", SchemaUtils.SUPPORTSMINMAX.indexOf(this.get("__displayType__")) !== -1);
  },
  _updateMinMax: function() {
    let min;
    let max;
    const displayType = this.get("__displayType__");
    if (displayType === STRING) {
      min = "minLength";
      max = "maxLength";
    } else if (displayType === INTEGER || displayType === NUMBER) {
      min = "minimum";
      max = "maximum";
    }
    if (this.get("__minVal__")) {
      this.set(min, parseInt(this.get("__minVal__"), 10));
    } else {
      this.unset(min);
    }
    if (this.get("__maxVal__")) {
      this.set(max, parseInt(this.get("__maxVal__"), 10));
    } else {
      this.unset(max);
    }
  },
  _convertEqualsToMinMax: function() {
    const equals = this.get("__equals__");
    if (equals) {
      this.set("__minVal__", equals);
      this.set("__maxVal__", equals);
    }
  },
  /*
   Normally we would use a derived property here but derived properties do not work with the model Clone function
   so we use this workaround instead.
   */
  _setConstraintText: function() {
    const constraint = this.get("__constraint__");
    const min = this.get("__minVal__");
    const max = this.get("__maxVal__");
    const equals = this.get("__equals__");
    switch (constraint) {
      case "between":
        this.set("__constraintText__", "Between " + min + " and " + max);
        break;
      case "greaterThan":
        this.set("__constraintText__", "Greater than " + min);
        break;
      case "lessThan":
        this.set("__constraintText__", "Less than " + max);
        break;
      case "equals":
        this.set("__constraintText__", "Equals " + equals);
        break;
      default:
        this.set("__constraintText__", "");
        break;
    }
  },
  cleanup: function() {
    if (this.get("__constraint__") === "lessThan") {
      this.unset("__minVal__");
    } else if (this.get("__constraint__") === "greaterThan") {
      this.unset("__maxVal__");
    }
    if (this.get("scope") !== SchemaUtils.SCOPE.SYSTEM) {
      if (this.get("__isScopeSelf__") === true) {
        this.set({
          scope: SchemaUtils.SCOPE.SELF
        }, {
          silent: true
        });
      } else {
        this.unset("scope");
      }
    }
    if (!this.get("__unique__")) {
      this.unset("unique");
    }
  },
  /**
   * Since there is not an dedicated attribute to flag enum type,
   * use enum values to determine whether the property is enum type or not.
   */
  isEnumType: function() {
    return !!this.getEnumValues();
  },
  getEnumValues: function() {
    return this.get("oneOf") || this.get("enum") || this.get("items") && this.get("items")["oneOf"] || this.get("items") && this.get("items")["enum"];
  },
  detectHasEnumDefined: function() {
    const enumValues = this.getEnumValues();
    if (!enumValues) {
      return;
    }
    this.set("__oneOf__", EnumTypeHelper.convertToOneOf(enumValues));
    this.set("__enumDefined__", true);
  }
});
var SchemaPropertySchemaProperties = BaseCollection.extend({
  model: SchemaPropertySchemaProperty,
  clone: function() {
    return new this.constructor(this.toJSON({
      verbose: true
    }), {
      parse: true
    });
  },
  areAllReadOnly: function() {
    return oktaUnderscore.all(this.pluck("__isReadOnly__"));
  },
  createModelProperties: function() {
    return this.reduce(function(p, schemaProperty) {
      const type = schemaProperty.get("type");
      p[schemaProperty.id] = oktaUnderscore.clone(SchemaUtils.DISPLAYTYPES[type]);
      if (SchemaUtils.SUPPORTSMINMAX.indexOf(type) !== -1) {
        p[schemaProperty.id].minLength = schemaProperty.get("minLength");
        p[schemaProperty.id].maxLength = schemaProperty.get("maxLength");
      }
      if (type === "string") {
        p[schemaProperty.id].format = schemaProperty.get("format");
      }
      return p;
    }, {});
  }
});
var SchemaProperty = {
  Model: SchemaPropertySchemaProperty,
  Collection: SchemaPropertySchemaProperties
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/models/BaseSchema.js
var parseProperties = function(resp) {
  const schemaMeta = oktaUnderscore.pick(resp, "id", "name", "displayName");
  const properties = oktaUnderscore.map(resp.schema.properties, function(property, name) {
    return oktaUnderscore.extend({
      name
    }, property);
  });
  oktaUnderscore.each(properties, function(property) {
    property["__schemaMeta__"] = schemaMeta;
    if (property.__metadata) {
      property["__metadata__"] = property.__metadata;
      delete property.__metadata;
    }
  });
  return properties;
};
var BaseSchemaSchema = BaseModel.extend({
  defaults: {
    id: void 0,
    displayName: void 0,
    name: void 0
  },
  constructor: function() {
    this.properties = new SchemaProperty.Collection();
    BaseModel.apply(this, arguments);
  },
  getProperties: function() {
    return this.properties;
  },
  clone: function() {
    const model = BaseModel.prototype.clone.apply(this, arguments);
    model.getProperties().set(this.getProperties().toJSON({
      verbose: true
    }));
    return model;
  },
  parse: function(resp) {
    const properties = parseProperties(resp);
    this.properties.set(properties, {
      parse: true
    });
    return oktaUnderscore.omit(resp, "schema");
  },
  trimProperty: function(property) {
    return oktaUnderscore.omit(property, "name");
  },
  toJSON: function() {
    const json = BaseModel.prototype.toJSON.apply(this, arguments);
    json.schema = {
      properties: {}
    };
    this.getProperties().each(function(model) {
      const property = model.toJSON();
      json.schema.properties[property.name] = this.trimProperty(property);
    }, this);
    return json;
  },
  save: function() {
    this.getProperties().each(function(model) {
      model.cleanup();
    });
    return BaseModel.prototype.save.apply(this, arguments);
  }
});
var BaseSchemaSchemas = BaseCollection.extend({
  model: BaseSchemaSchema
});
var BaseSchema = {
  parseProperties,
  Model: BaseSchemaSchema,
  Collection: BaseSchemaSchemas
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/empty.js
var ConfirmationDialog = {
  extend: () => {
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Logger.js
function log4(level, ...args) {
  if (window.console && window.okta && window.okta.debug) {
    window.console[level](...args);
  }
}
var Logger2 = (
  /** @lends module:Okta.Logger */
  {
    /**
     * See [console.trace](https://developer.mozilla.org/en-US/docs/Web/API/Console.trace)
     * @static
     */
    trace: function(...args) {
      return log4("trace", ...args);
    },
    /**
     * See [console.dir](https://developer.mozilla.org/en-US/docs/Web/API/Console.dir)
     * @static
     */
    dir: function(...args) {
      return log4("dir", ...args);
    },
    /**
     * See [console.time](https://developer.mozilla.org/en-US/docs/Web/API/Console.time)
     * @static
     */
    time: function(...args) {
      return log4("time", ...args);
    },
    /**
     * See [console.timeEnd](https://developer.mozilla.org/en-US/docs/Web/API/Console.timeEnd)
     * @static
     */
    timeEnd: function(...args) {
      return log4("timeEnd", ...args);
    },
    /**
     * See [console.group](https://developer.mozilla.org/en-US/docs/Web/API/Console.group)
     * @static
     */
    group: function(...args) {
      return log4("group", ...args);
    },
    /**
     * See [console.groupEnd](https://developer.mozilla.org/en-US/docs/Web/API/Console.groupEnd)
     * @static
     */
    groupEnd: function(...args) {
      return log4("groupEnd", ...args);
    },
    /**
     * See [console.assert](https://developer.mozilla.org/en-US/docs/Web/API/Console.assert)
     * @static
     */
    assert: function(...args) {
      return log4("assert", ...args);
    },
    /**
     * See [console.log](https://developer.mozilla.org/en-US/docs/Web/API/Console.log)
     * @static
     */
    log: function(...args) {
      return log4("log", ...args);
    },
    /**
     * See [console.info](https://developer.mozilla.org/en-US/docs/Web/API/Console.info)
     * @static
     */
    info: function(...args) {
      return log4("info", ...args);
    },
    /**
     * See [console.warn](https://developer.mozilla.org/en-US/docs/Web/API/Console.warn)
     * @static
     */
    warn: function(...args) {
      return log4("warn", ...args);
    },
    /**
     * See [console.error](https://developer.mozilla.org/en-US/docs/Web/API/Console.error)
     * @static
     */
    error: function(...args) {
      return log4("error", ...args);
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/SettingsModel.js
var props3 = {
  local: function() {
    const settings = window.okta && window.okta.settings || {};
    const theme = window.okta && window.okta.theme || "";
    return {
      orgId: ["string", false, settings.orgId],
      orgName: ["string", false, settings.orgName],
      serverStatus: ["string", false, settings.serverStatus],
      persona: ["string", false, settings.persona],
      isDeveloperConsole: ["boolean", false, settings.isDeveloperConsole],
      isPreview: ["boolean", false, settings.isPreview],
      permissions: ["array", true, settings.permissions || []],
      theme: ["string", false, theme]
    };
  },
  constructor: function() {
    Model2.apply(this, arguments);
    this.features = window._features || [];
  },
  /**
   * Checks if the user have a feature flag enabled (Based of the org level feature flag)
   * @param  {String}  feature Feature name
   * @return {Boolean}
   */
  hasFeature: function(feature) {
    return oktaUnderscore.contains(this.features, feature);
  },
  /**
   * Checks if any of the given feature flags are enabled (Based of the org level feature flags)
   * @param  {Array}  featureArray Features names
   * @return {Boolean} true if any of the give features are enabled. False otherwise
   */
  hasAnyFeature: function(featureArray) {
    return oktaUnderscore.some(featureArray, this.hasFeature, this);
  },
  /**
   * Checks if the user have a specific permission (based on data passed from JSP)
   * @param  {String}  permission Permission name
   * @return {Boolean}
   */
  hasPermission: function(permission) {
    return oktaUnderscore.contains(this.get("permissions"), permission);
  },
  /**
   * Checks if the org has ds theme set
   * @return {Boolean}
   */
  isDsTheme: function() {
    return this.get("theme") === "dstheme";
  }
};
var SettingsModel = Model2.extend(props3);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/framework/View.js
var CHILDREN = "__children__";
var RENDERED = "__rendered__";
var PARENT = "__parent__";
var CHILD_DEFINITIONS = "__children_definitions__";
var ADD_TO_CONTAINER = "__add_to_container__";
function getIndex(container, view) {
  for (var i = 0; i < container[CHILDREN].length; i++) {
    if (view.cid === container[CHILDREN][i].cid) {
      return i;
    }
  }
}
function noop2() {
}
function doRender(view) {
  view[RENDERED] = true;
  var html = view.renderTemplate(view.template);
  if (html) {
    view.$el.html(html);
  } else if (view.length) {
    view.$el.empty();
  }
  view.each(function(view2) {
    view2[ADD_TO_CONTAINER]();
  });
}
function subscribeEvents(view) {
  var isEventPropertyRe = /^(?!(?:delegate|undelegate|_))([a-zA-Z0-9]+)(?:Events)$/;
  oktaUnderscore.each(oktaUnderscore.allKeys(view), function(key) {
    var matchKeys = key.match(isEventPropertyRe);
    if (!matchKeys) {
      return;
    }
    var bindings = oktaUnderscore.result(view, key);
    var entity = view.options[matchKeys[1]] || view[matchKeys[1]];
    if (!entity || !oktaUnderscore.isObject(bindings) || !oktaUnderscore.isFunction(entity.trigger)) {
      return;
    }
    oktaUnderscore.each(bindings, function(callback, event) {
      var callbacks = oktaUnderscore.isFunction(callback) ? [callback] : oktaUnderscore.reduce(callback.split(/\s+/), (arr, name) => {
        if (oktaUnderscore.isFunction(view[name])) {
          arr.push(view[name]);
        }
        return arr;
      }, []);
      oktaUnderscore.each(callbacks, function(cb) {
        view.listenTo(entity, event, cb);
      });
    });
  });
}
var View;
var proto = {
  /**
     * An object listing events and callback bind to this.{entity}
     * @name *Events
     * @memberof src/framework/View
     * @type {(Object|Function)}
     * @instance
     * @example
     * var FooView = View.extend({
     *   modelEvents: {
     *     'change:name': 'render'
     *   }
     * })
     * //equivalent to ==>
     * var FooView = View.extend({
     *   initialize: function() {
     *     this.listenTo(this.model, 'change:name', this.render);
     *   }
     * });
     *
     *
     * //Multiple callbacks:
     * var FooView = View.extend({
     *   modelEvents: {
     *     'change:name': 'render foo'
     *   },
     *   foo: function() {}
     * });
     *
     * //Callbacks As Function:
     * var FooView = View.extend({
     *   stateEvents: {
     *     'change': function() {
     *   }
     * });
     *
     * //Event Configuration As Function
     * var FooView = View.extend({
     *   collectionEvents: function() {
     *     var events = { 'change:name deleteItem': 'render' };
     *     events['changeItem'] = 'spin';
     *     events['addItem'] = function() {};
     *     return events;
     *   }
     * });
     */
  preinitialize: function(options2) {
    this.options = options2 || {};
    oktaUnderscore.extend(this, oktaUnderscore.pick(this.options, "state", "settings"));
    this[CHILDREN] = [];
    this[RENDERED] = false;
    this[PARENT] = null;
    this[CHILD_DEFINITIONS] = this.children;
    this.__original_initialize__ = this.initialize;
    this.initialize = noop2;
  },
  constructor: function(options2, ...rest) {
    Backbone.View.call(this, options2);
    oktaUnderscore.each(oktaUnderscore.result(this, CHILD_DEFINITIONS), function(childDefinition) {
      this.add.apply(this, oktaUnderscore.isArray(childDefinition) ? childDefinition : [childDefinition]);
    }, this);
    delete this[CHILD_DEFINITIONS];
    const autoRender = oktaUnderscore.result(this, "autoRender");
    if (autoRender && this.model) {
      var event = oktaUnderscore.isArray(autoRender) ? oktaUnderscore.map(autoRender, function(field) {
        return "change:" + field;
      }).join(" ") : "change";
      this.listenTo(this.model, event, function() {
        this.render();
      });
    }
    this.initialize = this.__original_initialize__;
    this.initialize.call(this, options2, ...rest);
    subscribeEvents(this);
  },
  /**
     * Unregister view from container
     * Note: this will not remove the view from the dom
     * and will not call the `remove` method on the view
     *
     * @param {src/framework/View} view the view to unregister
     * @private
     */
  unregister: function(view) {
    this.stopListening(view);
    var viewIndex = getIndex(this, view);
    if (oktaUnderscore.isNumber(viewIndex)) {
      this[CHILDREN].splice(viewIndex, 1);
    }
  },
  /**
     * Should we auto render the view upon model change. Boolean or array of field names to listen to.
     * @type {Boolean|Array}
     * @deprecated Instead, please use modelEvents
     * @example
     * modelEvents: {
     *   change:name: 'render'
     * }
     */
  autoRender: false,
  /**
     *
     * When the template is an underscore template, the render method will pass the options has to the template
     * And the associated model, if exists, when it will prefer the model over the options in case of a conflict.
     * {@link #render View.render}
     * @type {(String|Function)}
     * @example
     * var View = View.extend({
     *   template: '<p class="name">{{name}}</p>'
     * };
     */
  template: null,
  /**
     * A list of child view definitions to be passed to {@link #add this.add()}.
     * Note: these definitions will be added **before** the {@link #constructor initiliaze} method invokes.
     * @type {(Array|Function)}
     * @example
     * var Container = View.extend({
     *    template: '<p class="content"></p>',
     *    children: [
     *      [ContentView, '.content'],
     *      [OtherContentView, '.content'],
     *      OtherView
     *    ]
     *  })
     *
     * var Container = View.extend({
     *    template: '<dov class="form-wrap"></div>',
     *    children: function () {
     *      return [
     *        [FormView, '.form-wrap', {options: {model: this.optiosn.otherModel}}]
     *      ]
     *    }
     *  })
     */
  children: [],
  /**
     * Add a child view to the container.
     * If the container is already rendered, will also render the view  and append it to the DOM.
     * Otherwise will render and append once the container is rendered.
     *
     * *We believe that for the sake of encapsulation, a view should control its own chilren, so we treat this method as
     * protected and even though technically you can call `view.add` externally we strongly discourage it.*
     *
     * @param {(src/framework/View|String)} view A class (or an instance which is discouraged) of a View - or an HTML
     * string/template
     * @param {String} [selector] selector in the view's template on which the view will be added to
     * @param {Object} [options]
     * @param {Boolean} [options.bubble=false] Bubble (proxy) events from this view up the chain
     * @param {Boolean} [options.prepend=false] Prepend the view instend of appending
     * @param {String} [options.selector] Selector in the view's template on which the view will be added to
     * @param {Object} [options.options] Extra options to pass to the child constructor
     * @protected
     * @returns {src/framework/View} - The instance of itself for the sake of chaining
     * @example
     * var Container = View.extend({
     *
     *   template: [
     *     '<h1></h1>',
     *     '<section></section>',
     *   ].join(''),
     *
     *   initalize: function () {
     *
     *     this.add(TitleView, 'h1'); // will be added to <h1>
     *
     *     this.add(ContentView1, 'section'); // will be added to <section>
     *
     *     this.add(ContentView2, 'section', {prepend: true}); // will be add into <section> **before** ContentView1
     *
     *     this.add(OtherView, {
     *       options: {
     *         model: new Model()
     *       }
     *     }); // will be added **after** the <section> element
     *
     *     this.add('<p class="name">some html</p>'); //=> "<p class="name">some html</p>"
     *     this.add('<p class="name">{{name}}</p>'); //=> "<p class="name">John Doe</p>"
     *     this.add('{{name}}') //=> "<div>John Doe</div>"
     *     this.add('<span>{{name}}</span> w00t') //=> "<div><span>John Doe</span> w00t</div>"
     *   }
     *
     * });
     *
     * var container - new View({name: 'John Doe'});
     */
  add: function(view, selector, bubble, prepend, extraOptions) {
    var options2 = {};
    var args = oktaUnderscore.toArray(arguments);
    if (oktaUnderscore.isFunction(view) && (!view.prototype || !view.prototype.render)) {
      throw new Error("Type passed to add() is not a View");
    }
    if (oktaUnderscore.isObject(selector)) {
      options2 = selector;
      selector = options2.selector;
      bubble = options2.bubble;
      prepend = options2.prepend;
      extraOptions = options2.options;
    } else if (oktaUnderscore.isObject(bubble)) {
      options2 = bubble;
      bubble = options2.bubble;
      prepend = options2.prepend;
      extraOptions = options2.options;
    }
    if (oktaUnderscore.isString(view)) {
      view = function(template8) {
        return View.extend({
          constructor: function() {
            try {
              var $el = Backbone.$(template8);
              if ($el.length !== 1) {
                throw new Error("invalid Element");
              }
              var unescapingRexExp = /&(\w+|#x\d+);/g;
              var elementUnescapedOuterHTMLLength = $el.prop("outerHTML").replace(unescapingRexExp, " ").length;
              var templateUnescapedLength = template8.replace(unescapingRexExp, " ").length;
              if (elementUnescapedOuterHTMLLength !== templateUnescapedLength) {
                throw new Error("invalid Element");
              }
              this.template = $el.html();
              this.el = $el.empty()[0];
            } catch (e) {
              this.template = template8;
            }
            View.apply(this, arguments);
          }
        });
      }(view);
    }
    if (view.prototype && view.prototype instanceof View) {
      var viewOptions = oktaUnderscore.omit(oktaUnderscore.extend({}, this.options, extraOptions), "el");
      args[0] = new view(viewOptions);
      return this.add.apply(this, args);
    }
    if (oktaUnderscore.isNumber(getIndex(this, view))) {
      throw new Error("Duplicate child");
    }
    view[PARENT] = this;
    view[ADD_TO_CONTAINER] = (function(selector2) {
      return function() {
        if (selector2 && view[PARENT].$(selector2).length !== 1) {
          throw new Error("Invalid selector: " + selector2);
        }
        var $el = selector2 ? this[PARENT].$(selector2) : this[PARENT].$el;
        this.render();
        this.delegateEvents();
        prepend ? $el.prepend(this.el) : $el.append(this.el);
      };
    }).call(view, selector);
    if (bubble) {
      this.listenTo(view, "all", function() {
        this.trigger.apply(this, arguments);
      });
    }
    if (this.rendered()) {
      view[ADD_TO_CONTAINER]();
    }
    this[CHILDREN].push(view);
    return this;
  },
  /**
     * Remove all children from container
     */
  removeChildren: function() {
    this.each(function(view) {
      view.remove();
    });
    return this;
  },
  /**
     *  Removes a view from the DOM, and calls stopListening to remove any bound events that the view has listenTo'd.
     *  Also removes all childern of the view if any, and removes itself from its parent view(s)
     */
  remove: function() {
    this.removeChildren();
    if (this[PARENT]) {
      this[PARENT].unregister(this);
    }
    return Backbone.View.prototype.remove.apply(this, arguments);
  },
  /**
     * Compile the template to function you can apply tokens on on render time.
     * Uses the underscore tempalting engine by default
     * @protected
     * @param  {String} template
     * @return {Function} a compiled template
     */
  // TODO: This will be deprecated at some point. Views should use precompiled templates
  compileTemplate: function(template8) {
    return oktaUnderscore.template(template8, void 0);
  },
  /**
     * Render a template with `this.model` and `this.options` as parameters
     * preferring the model over the options.
     *
     * @param  {(String|Function)} template The template to build
     * @return {String} An HTML string
     * @protected
     */
  renderTemplate: function(template8) {
    if (oktaUnderscore.isString(template8)) {
      template8 = this.compileTemplate(template8);
    }
    if (oktaUnderscore.isFunction(template8)) {
      return template8(this.getTemplateData());
    }
  },
  /**
     * The data hash passed to the compiled template
     * @return {Object}
     * @protected
     */
  getTemplateData: function() {
    var modelData = this.model && this.model.toJSON({
      verbose: true
    }) || {};
    var options2 = oktaUnderscore.omit(this.options, ["state", "settings", "model", "collection"]);
    return oktaUnderscore.defaults({}, modelData, options2);
  },
  /**
     * Renders the template to `$el` and append all children in order
     * {@link #template View.template}
     */
  render: function() {
    this.preRender();
    doRender(this);
    this.postRender();
    return this;
  },
  /**
     * Pre render routine. Will be called right *before* the logic in {@link #render} is executed
     * @method
     */
  preRender: noop2,
  /**
     * Post render routine. Will be called right *after* the logic in {@link #render} is executed
     * @method
     */
  postRender: noop2,
  /**
     * Was this instance rendered
     */
  rendered: function() {
    return this[RENDERED];
  },
  /**
     * Get all direct child views.
     * @returns {src/framework/View[]}
     * @example
     * var container = View.extend({
     *   children: [View1, View2]
     * }).render();
     * container.getChildren() //=> [view1, view2];
     */
  getChildren: function() {
    return this.toArray();
  },
  /**
     * Get a child by index
     * @param {number} index
     * @returns {src/framework/View} The child view
     */
  at: function(index) {
    return this.getChildren()[index];
  },
  /**
     * Invokes a method on all children down the tree
     *
     * @param {String} method The method to invoke
     */
  invoke: function(methodName) {
    var args = oktaUnderscore.toArray(arguments);
    this.each(function(child) {
      if (child.size()) {
        child.invoke.apply(child, args);
      }
      if (oktaUnderscore.isFunction(child[methodName])) {
        child[methodName].apply(child, args.slice(1));
      }
    });
    return this;
  }
};
View = Backbone.View.extend(
  /** @lends src/framework/View.prototype */
  proto
);
var methods = ["each", "map", "reduce", "reduceRight", "find", "filter", "reject", "every", "some", "contains", "toArray", "size", "first", "initial", "rest", "last", "without", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain", "where", "findWhere"];
oktaUnderscore.each(methods, function(method) {
  View.prototype[method] = function() {
    var args = oktaUnderscore.toArray(arguments);
    args.unshift(oktaUnderscore.toArray(this[CHILDREN]));
    return oktaUnderscore[method].apply(oktaUnderscore, args);
  };
});
View.isCourageView = true;
var FrameworkView = View;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/TemplateUtil.js
var TemplateUtil = (
  /** @lends module:Okta.internal.util.TemplateUtil */
  {
    /**
     * Compiles a Handlebars template
     * @static
     * @method
     */
    // TODO: This will be deprecated at some point. Views should use pre-compiled templates
    tpl: oktaUnderscore.memoize(function(tpl) {
      return function(context) {
        return _Handlebars2.compile(tpl)(context);
      };
    })
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/BaseView.js
var eventBus = oktaUnderscore.clone(Backbone.Events);
var proto2 = {
  constructor: function(options2, ...rest) {
    FrameworkView.call(this, options2, ...rest);
    this.module && this.$el.attr("data-view", this.module.id);
  },
  /**
   * @deprecated Use {@link #removeChildren}
   */
  empty: function() {
    return this.removeChildren();
  },
  compileTemplate: TemplateUtil.tpl,
  /**
   *
   * Broadcasts a global event that all views and controllers can subscribe to
   * for framework use only - prefer using a shared model
   *
   * @param {String} eventName A unique identifier for the event
   * @param {...String} param Parameter to pass with the event (can pass more than one parameter)
   * @deprecated For internal use only
   * @private
   */
  broadcast: function() {
    eventBus.trigger.apply(eventBus, arguments);
    return this;
  },
  /**
   * Subscribe to broadcast events
   * for framework use only - prefer using a shared model
   *
   * @param {String} eventName The event identifier to subscribe
   * @param {Function} fn The callback function to invoke
   * @deprecated For internal use only
   * @private
   */
  listen: function(name, fn11) {
    eventBus.off(name, fn11);
    this.listenTo(eventBus, name, fn11);
    return this;
  },
  /**
   * Shows a notification box
   * @param {String} level success / warning / error
   * @param {String} message The message to display
   * @param {Object} [options]
   * @param {Number} [options.width] Set a custom width
   * @param {String} [options.title] Set a custom title
   * @param {Boolean} [options.hide=true] Do we want to auto-hide this notification?
   * @param {Boolean} [options.dismissable] Show a dismiss button
   * @example
   * view.notify('success', 'Group created successfully');
   */
  notify: function(level, message, options2) {
    this.broadcast("notification", oktaUnderscore.defaults({
      message,
      level
    }, options2));
    return this;
  },
  /**
   * Shows a confirmation dialog
   *
   * Uses https://www.ericmmartin.com/projects/simplemodal/.
   * If you want to configure the simplemodal options use ConfirmationDialog instead.
   *
   * The main difference between this and the native javascript `confirm` method
   * Is this method is non blocking (note the callback pattern).
   *
   * The callback function will run in the context (`this`) of the invoking view.
   *
   * @param {String} [title] The title of the confirmation dialog
   * @param {String} [message] The message of the confirmation dialog
   * @param {Function} [okfn] The callback to run when the user hits "OK" (runs in the context of the invoking view)
   * @param {Function} [cancelfn] The callback to run when the user hits "Cancel"
   *        (runs in the context of the invoking view)
   * @example
   * view.confirm('Delete Group', 'Are you sure you want to delete the selected group?', function () {
   *   model.destroy();
   * });
   *
   * // title will be auto-set to "Okta"
   * view.confirm('Are you sure you want to delete the selected group?', function () {
   *   model.destroy();
   * });
   *
   * view.confirm({
   *   title: 'Delete Group', //=> Modal title
   *   subtitle: 'Are you sure you want to delete the selected group?', //=> Modal subtitle
   *   content: '<h3 color="red">THIS WILL DELETE THE GROUP!</h3>', //=> A template or a view to add to the modal
   *   save: 'Delete Group', //=> Button label
   *   ok: _.bind(model.save, model) // Callback function on hitting "ok" button
   *   cancel: 'Cancel', //=> Button label
   *   cancelFn: _.bind(model.destroy, model) // Callback function on hitting "cancel" button
   * });
   */
  confirm: function(title, message, okfn, cancelfn) {
    let options2;
    if (typeof title === "object") {
      options2 = title;
    } else {
      if (arguments.length === 2 && oktaUnderscore.isFunction(message)) {
        options2 = {
          title: "Okta",
          // eslint-disable-line @okta/okta/no-unlocalized-text
          subtitle: title,
          ok: message
        };
      } else {
        options2 = {
          title,
          subtitle: message,
          ok: okfn,
          cancelFn: cancelfn
        };
      }
    }
    if (oktaUnderscore.isFunction(options2.ok)) {
      options2.ok = oktaUnderscore.bind(options2.ok, this);
    }
    if (oktaUnderscore.isFunction(options2.cancelFn)) {
      options2.cancelFn = oktaUnderscore.bind(options2.cancelFn, this);
    }
    this.broadcast("confirmation", options2);
    return this;
  },
  /**
   * Shows an alert box
   *
   * The main difference between this and the native javascript `alert` method
   * Is this method is non blocking.
   *
   * @param {String} message The message
   * @example
   * view.alert('Mission complete');
   */
  alert: function(params) {
    if (oktaUnderscore.isString(params)) {
      params = {
        subtitle: params
      };
    }
    this.confirm(oktaUnderscore.extend({}, params, {
      noCancelButton: true
    }));
    return this;
  }
};
var BaseView = FrameworkView.extend(
  proto2,
  /** @lends View.prototype */
  {
    /** @method */
    decorate: function(TargetView) {
      const BaseViewView = TargetView.extend({});
      oktaUnderscore.defaults(BaseViewView.prototype, proto2);
      return BaseViewView;
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/components/Notification.js
var defaults = {
  level: "success",
  hide: true,
  fade: 400,
  delay: 3e3,
  width: 0,
  dismissable: false
};
var Notification = BaseView.extend({
  className: "infobox infobox-confirm infobox-confirm-fixed",
  events: {
    "click .infobox-dismiss-link": function(e) {
      e.preventDefault();
      this.fadeOut();
    }
  },
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a class="infobox-dismiss-link" title="' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "courage",
          "code": "component.dismiss"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 108
          }
        }
      })) + '" href="#"><span class="dismiss-icon"></span></a>';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<h3>" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "title",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 220
          },
          "end": {
            "line": 1,
            "column": 229
          }
        }
      }) : helper)) + "</h3>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "dismissable") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 164
          }
        }
      })) != null ? stack1 : "") + '<span class="icon ' + alias4((helper = (helper = lookupProperty(helpers2, "level") || (depth0 != null ? lookupProperty(depth0, "level") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "level",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 182
          },
          "end": {
            "line": 1,
            "column": 191
          }
        }
      }) : helper)) + '-16"></span>' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "title") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 203
          },
          "end": {
            "line": 1,
            "column": 241
          }
        }
      })) != null ? stack1 : "") + "<p>" + alias4((helper = (helper = lookupProperty(helpers2, "message") || (depth0 != null ? lookupProperty(depth0, "message") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "message",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 244
          },
          "end": {
            "line": 1,
            "column": 255
          }
        }
      }) : helper)) + "</p>";
    },
    "useData": true
  }),
  initialize: function() {
    this.options = oktaUnderscore.defaults({}, this.options, defaults);
    if (!this.options.message) {
      switch (this.options.level) {
        case "success":
          this.options.message = StringUtil.localize("notification.default.message.success", "courage");
          break;
        case "error":
          this.options.message = StringUtil.localize("notification.default.message.error", "courage");
          break;
        case "warning":
          this.options.message = StringUtil.localize("notification.default.message.warning", "courage");
          break;
      }
    }
    this.$el.addClass("infobox-" + this.options.level);
    if (this.options.width) {
      this.$el.width(this.options.width);
    }
  },
  getTemplateData: function() {
    return oktaUnderscore.extend(oktaUnderscore.pick(this.options, "level", "message", "title"), {
      dismissable: this.options.hide === false || this.options.dismissable === true
    });
  },
  postRender: function() {
    if (this.options.hide) {
      oktaUnderscore.delay(oktaUnderscore.bind(this.fadeOut, this), this.options.delay);
    }
  },
  fadeOut: function() {
    this.$el.fadeOut(this.options.fade, oktaUnderscore.bind(this.remove, this));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/BaseRouter.js
function getRoute(router, route) {
  const root = oktaUnderscore.result(router, "root") || "";
  if (root && oktaUnderscore.isString(route)) {
    return [root, route].join("/").replace(/\/{2,}/g, "/");
  }
  return route;
}
var props4 = (
  /** @lends module:Okta.Router.prototype */
  {
    /**
     * The root URL for the router. When setting {@link http://backbonejs.org/#Router-routes|routes},
     * it will be prepended to each route.
     * @type {String|Function}
     */
    root: "",
    listen: Notification.prototype.listen,
    constructor: function(options2 = {}) {
      this.el = options2.el;
      this.settings = new SettingsModel(oktaUnderscore.omit(options2, "el"));
      if (options2.root) {
        this.root = options2.root;
      }
      Backbone.Router.apply(this, arguments);
      this.listen("notification", this._notify);
      this.listen("confirmation", this._confirm);
    },
    /**
     * Fires up a confirmation dialog
     *
     * @param  {Object} options Options Hash
     * @param  {String} options.title The title
     * @param  {Array<string>} buttonOrder The order of the buttons
     * @param  {String} options.subtitle The explain text
     * @param  {String} options.save The text for the save button
     * @param  {Function} options.ok The callback function to run when hitting "OK"
     * @param  {String} options.cancel The text for the cancel button
     * @param  {Function} options.cancelFn The callback function to run when hitting "Cancel"
     * @param  {Boolean} options.noCancelButton Don't render the cancel button (useful for alert dialogs)
     * @param  {Boolean} options.noSubmitButton Don't render the primary button (useful for alert dialogs)
     * @private
     *
     * @return {Okta.View} the dialog view
     */
    _confirm: function(options2 = {}) {
      const Dialog = ConfirmationDialog.extend(oktaUnderscore.pick(options2, "title", "subtitle", "save", "ok", "cancel", "cancelFn", "noCancelButton", "noSubmitButton", "content", "danger", "type", "closeOnOverlayClick", "buttonOrder"));
      const dialog = new Dialog({
        model: this.settings
      });
      dialog.render();
      return dialog;
    },
    /**
     * Fires up a notification banner
     *
     * @param  {Object} options Options Hash
     * @return {Okta.View} the notification view
     * @private
     */
    _notify: function(options2) {
      const notification = new Notification(options2);
      oktaJQueryStatic("#content").prepend(notification.render().el);
      return notification;
    },
    /**
     * Renders a Controller
     * This will initialize new instance of a controller and call render on it
     *
     * @param  {Okta.Controller} Controller The controller Class we which to render
     * @param  {Object} [options] Extra options to the controller constructor
     */
    render: function(Controller2, options2) {
      this.unload();
      options2 = oktaUnderscore.extend(oktaUnderscore.pick(this, "settings", "el"), options2 || {});
      this.controller = new Controller2(options2);
      this.controller.render();
    },
    /**
     * Starts the backbone history object
     *
     * Waits for the dom to be ready before calling `Backbone.history.start()` (IE issue).
     *
     * See [Backbone History](http://backbonejs.org/#History) for more information.
     */
    start: function(...args) {
      oktaJQueryStatic(function() {
        if (Backbone.History.started) {
          Logger2.error("History has already been started");
          return;
        }
        Backbone.history.start(...args);
      });
    },
    /**
     * Removes active controller and frees up event listeners
     */
    unload: function() {
      if (this.controller) {
        this.stopListening(this.controller);
        this.stopListening(this.controller.state);
        this.controller.remove();
      }
    },
    route: function(route, name, callback) {
      return Backbone.Router.prototype.route.call(this, getRoute(this, route), name, callback);
    },
    navigate: function(fragment, options2) {
      return Backbone.Router.prototype.navigate.call(this, getRoute(this, fragment), options2);
    }
  }
);
var BaseRouter = Backbone.Router.extend(props4);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/StateMachine.js
var StateMachine = Model2.extend({
  /**
   * Invokes a method on the applicable {@link Okta.Controller}
   *
   * ```javascript
   * state.invoke('methodName', 'param1', 'param2')
   * // Will call
   * contoller.methodName('param1', 'param2')
   * ```
   * @param {String} methodName the name of the controller method to invoke on the controller
   */
  invoke: function() {
    const args = oktaUnderscore.toArray(arguments);
    args.unshift("__invoke__");
    this.trigger.apply(this, args);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/BaseController.js
function clean(obj) {
  const res = {};
  oktaUnderscore.each(obj, function(value, key) {
    if (!oktaUnderscore.isNull(value)) {
      res[key] = value;
    }
  });
  return res;
}
var proto3 = (
  /** @lends module:Okta.Controller.prototype */
  {
    preinitialize: function(options2 = {}) {
      this.state = oktaUnderscore.result(this, "state");
      const hasStateBeenInitialized = this.state instanceof StateMachine || options2.state instanceof StateMachine;
      if (!hasStateBeenInitialized) {
        const stateData = oktaUnderscore.defaults(clean(options2.state), this.state || {});
        this.state = new StateMachine(stateData);
        delete options2.state;
      }
      if (!options2.settings) {
        options2.settings = new SettingsModel(oktaUnderscore.omit(options2 || {}, "el"));
        this.listen("notification", BaseRouter.prototype._notify);
        this.listen("confirmation", BaseRouter.prototype._confirm);
      }
      BaseView.prototype.preinitialize.call(this, options2);
    },
    constructor: function(options2 = {}) {
      BaseView.call(this, options2);
      this.listenTo(this.state, "__invoke__", function() {
        const args = oktaUnderscore.toArray(arguments);
        const method = args.shift();
        if (oktaUnderscore.isFunction(this[method])) {
          this[method].apply(this, args);
        }
      });
      let MainView;
      if (this.View && this.View.isCourageView) {
        MainView = this.View;
      } else if (oktaUnderscore.result(this, "View") && oktaUnderscore.result(this, "View").isCourageView) {
        MainView = oktaUnderscore.result(this, "View");
      }
      if (MainView) {
        this.add(new MainView(this.toJSON()));
      }
    },
    /**
     * The default values of our application state
     * @type {Object}
     * @default {}
     */
    state: {},
    /**
     * The main view this controller operate on
     * @type {module:Okta.View}
     * @default null
     */
    View: null,
    /**
     * Renders the {@link module:Okta.Controller#View|main view} after the DOM is ready
     * in case the controller is the root component of the page (e.g there's no router)
     */
    render: function() {
      const args = arguments;
      const self2 = this;
      oktaJQueryStatic(function() {
        BaseView.prototype.render.apply(self2, args);
      });
      return this;
    },
    /**
     * Creates the view constructor options
     * @param {Object} [options] Extra options
     * @return {Object} The view constructor options
     */
    toJSON: function(options2) {
      return oktaUnderscore.extend(oktaUnderscore.pick(this, "state", "settings", "collection", "model"), options2 || {});
    },
    /**
     * Removes the child views, empty the DOM element and stop listening to events
     */
    remove: function() {
      this.removeChildren();
      this.stopListening();
      this.$el.empty();
      return this;
    }
  }
);
var BaseController = BaseView.extend(proto3);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/ViewUtil.js
function changeEventString(doWhen) {
  return "change:" + oktaUnderscore.keys(doWhen).join(" change:");
}
function calcDoWhen(value, key) {
  const modelValue = this.model.get(key);
  if (oktaUnderscore.isFunction(value)) {
    return value.call(this, modelValue);
  } else {
    return value === modelValue;
  }
}
function _doWhen(view, doWhen, fn11) {
  const toggle = oktaUnderscore.bind(fn11, view, view, doWhen);
  view.render = oktaUnderscore.wrap(view.render, function(render) {
    const val = render.call(view);
    toggle({
      animate: false
    });
    return val;
  });
  view.listenTo(view.model, changeEventString(doWhen), function() {
    toggle({
      animate: true
    });
  });
}
var ViewUtil = {
  applyDoWhen: function(view, doWhen, fn11) {
    if (!(view.model && oktaUnderscore.isObject(doWhen) && oktaUnderscore.size(doWhen) && oktaUnderscore.isFunction(fn11))) {
      return;
    }
    _doWhen(view, doWhen, function(view2, doWhen2, options2) {
      const result = oktaUnderscore.every(oktaUnderscore.map(doWhen2, calcDoWhen, view2));
      fn11.call(view2, result, options2);
    });
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/components/BaseButtonLink.js
var disabledEvents = {
  click: function(e) {
    e.preventDefault();
    e.stopPropagation();
  }
};
var BaseButtonLink = BaseView.extend(
  /** @lends module:Okta.internal.views.components.BaseButtonLink.prototype */
  {
    attributes: function() {
      const defaultAttrs = {
        "data-se": "button"
      };
      const additionalAttr = this.__getAttribute("attrs");
      return oktaUnderscore.extend(defaultAttrs, additionalAttr);
    },
    /**
     * The main text for the button
     * @name title
     * @memberof module:Okta.internal.views.components.BaseButtonLink
     * @type {(String|Function)}
     * @instance
     */
    /**
     * The link for the button
     * @name href
     * @memberof module:Okta.internal.views.components.BaseButtonLink
     * @type {(String|Function)}
     * @instance
     */
    /**
     * CSS class for the icon to display. See [Style guide](http://rain.okta1.com:1802/su/dev/style-guide#icons)
     * @name icon
     * @memberof module:Okta.internal.views.components.BaseButtonLink
     * @type {(String|Function)}
     * @instance
     */
    /**
     * A [Backbone events](http://backbonejs.org/#View-delegateEvents) hash
     * @name events
     * @memberof module:Okta.internal.views.components.BaseButtonLink
     * @type {Object}
     * @instance
     */
    tagName: "a",
    template: _Handlebars2.template({
      "1": function(container, depth0, helpers2, partials, data) {
        var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<span class="icon ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "icon") || (depth0 != null ? lookupProperty(depth0, "icon") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "icon",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 30
            },
            "end": {
              "line": 1,
              "column": 38
            }
          }
        }) : helper)) + '"></span>';
      },
      "3": function(container, depth0, helpers2, partials, data) {
        var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "title",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 67
            },
            "end": {
              "line": 1,
              "column": 76
            }
          }
        }) : helper));
      },
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "icon") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(1, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 0
            },
            "end": {
              "line": 1,
              "column": 54
            }
          }
        })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "title") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(3, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 54
            },
            "end": {
              "line": 1,
              "column": 83
            }
          }
        })) != null ? stack1 : "");
      },
      "useData": true
    }),
    /**
     * Make this button visible, default to true.
     * @type {(Boolean|Function)}
     * @default true
     */
    visible: true,
    /**
     * Make this button enabled, default to true.
     * @type {(Boolean|Function)}
     * @default true
     */
    enabled: true,
    /**
     * The setting to determine when the button is enabled, default to {} and
     * enabled takes a higher priority.
     * @type {(Object|Function)}
     * @default {}
     */
    enableWhen: {},
    /**
     * The setting to determine when the button is visible, default to {} and
     * visible takes a higher priority.
     * @type {(Object|Function)}
     * @default {}
     */
    showWhen: {},
    constructor: function(options2) {
      this.options = options2 || {};
      const data = this.getTemplateData();
      this.disabled = false;
      BaseView.apply(this, arguments);
      this.$el.addClass("link-button");
      if (data.icon) {
        this.$el.addClass("link-button-icon");
        if (!data.title) {
          this.$el.addClass("icon-only");
        }
      }
    },
    getTemplateData: function() {
      return {
        href: this.__getAttribute("href"),
        title: this.__getAttribute("title"),
        icon: this.__getAttribute("icon")
      };
    },
    initialize: function() {
      ViewUtil.applyDoWhen(this, oktaUnderscore.resultCtx(this, "enableWhen", this), this.toggle);
      ViewUtil.applyDoWhen(this, oktaUnderscore.resultCtx(this, "showWhen", this), this.toggleVisible);
    },
    render: function() {
      BaseView.prototype.render.apply(this, arguments);
      if (!oktaUnderscore.result(this, "enabled")) {
        this.toggle(false);
      }
      if (!oktaUnderscore.result(this, "visible")) {
        this.toggleVisible(false);
      }
      const data = this.getTemplateData();
      this.$el.attr("href", data.href || "#");
      return this;
    },
    __getAttribute: function(name, defaultValue) {
      let value = oktaUnderscore.resultCtx(this.options, name, this);
      if (oktaUnderscore.isUndefined(value)) {
        value = oktaUnderscore.result(this, name);
      }
      return !oktaUnderscore.isUndefined(value) ? value : defaultValue;
    },
    enable: function() {
      this.toggle(true);
    },
    disable: function() {
      this.toggle(false);
    },
    show: function() {
      this.toggleVisible(true);
    },
    hide: function() {
      this.toggleVisible(false);
    },
    toggle: function(enable) {
      const bool = !!enable && oktaUnderscore.result(this, "enabled");
      this.disabled = !bool;
      this.$el.toggleClass("link-button-disabled btn-disabled disabled", this.disabled);
      this.delegateEvents(this.disabled ? disabledEvents : null);
    },
    toggleVisible: function(visible) {
      const hidden = !visible || !oktaUnderscore.result(this, "visible");
      this.$el.toggleClass("hide", hidden);
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/ButtonFactory.js
function normalizeEvents(options2) {
  const events4 = oktaUnderscore.extend(options2.click ? {
    click: options2.click
  } : {}, options2.events || {});
  const target = {};
  oktaUnderscore.each(events4, function(fn11, eventName) {
    target[eventName] = function(e) {
      if (!options2.href) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (!(this.disabled && eventName === "click")) {
        fn11.apply(this, arguments);
      }
    };
  });
  return target;
}
var ButtonFactory = (
  /** @lends module:Okta.internal.util.ButtonFactory */
  {
    /**
     * Creates a {@link module:Okta.internal.views.components.BaseButtonLink|BaseButtonLink}.
     * @param  {Object} options Options hash
     * @param  {String} [options.title] The button text
     * @param  {String} [options.icon]
     * CSS class for the icon to display. See [Style guide](http://rain.okta1.com:1802/su/dev/style-guide#icons)
     * @param {String} [options.href] The button link
     * @param {Function} [options.click] On click callback
     * @param {Object} [options.events] a [Backbone events](http://backbonejs.org/#View-delegateEvents) hash
     * @returns {module:Okta.internal.views.components.BaseButtonLink} BaseButtonLink prototype ("class")
     */
    create: function(options2) {
      options2 = oktaUnderscore.clone(options2);
      options2.attrs = options2.attributes;
      delete options2.attributes;
      return BaseButtonLink.extend(oktaUnderscore.extend(options2, {
        events: normalizeEvents(options2)
      }));
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Class.js
function Class(options2) {
  this.options = oktaUnderscore.clone(options2 || {});
  this.cid = oktaUnderscore.uniqueId("class");
  this.initialize.apply(this, arguments);
}
oktaUnderscore.extend(Class.prototype, Backbone.Events, {
  initialize: function() {
  }
});
Class.extend = Backbone.Model.extend;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/_virtual/js.cookie.js
var js_cookie = {
  exports: {}
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/lib/js.cookie.js
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function() {
    function extend3() {
      var i = 0;
      var result = {};
      for (; i < arguments.length; i++) {
        var attributes2 = arguments[i];
        for (var key in attributes2) {
          result[key] = attributes2[key];
        }
      }
      return result;
    }
    function init(converter) {
      function api2(key, value, attributes2) {
        var result;
        if (arguments.length > 1) {
          attributes2 = extend3({
            path: "/"
          }, api2.defaults, attributes2);
          if (typeof attributes2.expires === "number") {
            var expires = /* @__PURE__ */ new Date();
            expires.setMilliseconds(expires.getMilliseconds() + attributes2.expires * 864e5);
            attributes2.expires = expires;
          }
          try {
            result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {
          }
          if (!converter.write) {
            value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          } else {
            value = converter.write(value, key);
          }
          key = encodeURIComponent(String(key));
          key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
          key = key.replace(/[\(\)]/g, escape);
          return document.cookie = [
            key,
            "=",
            value,
            attributes2.expires && "; expires=" + attributes2.expires.toUTCString(),
            // use expires attribute, max-age is not supported by IE
            attributes2.path && "; path=" + attributes2.path,
            attributes2.domain && "; domain=" + attributes2.domain,
            attributes2.secure ? "; secure" : ""
          ].join("");
        }
        if (!key) {
          result = {};
        }
        var cookies = document.cookie ? document.cookie.split("; ") : [];
        var rdecode = /(%[0-9A-Z]{2})+/g;
        var i = 0;
        for (; i < cookies.length; i++) {
          var parts = cookies[i].split("=");
          var name = parts[0].replace(rdecode, decodeURIComponent);
          var cookie = parts.slice(1).join("=");
          if (cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
          }
          try {
            cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);
            if (this.json) {
              try {
                cookie = JSON.parse(cookie);
              } catch (e) {
              }
            }
            if (key === name) {
              result = cookie;
              break;
            }
            if (!key) {
              result[name] = cookie;
            }
          } catch (e) {
          }
        }
        return result;
      }
      api2.get = api2.set = api2;
      api2.getJSON = function() {
        return api2.apply({
          json: true
        }, [].slice.call(arguments));
      };
      api2.defaults = {};
      api2.remove = function(key, attributes2) {
        api2(key, "", extend3(attributes2, {
          expires: -1
        }));
      };
      api2.withConverter = init;
      return api2;
    }
    return init(function() {
    });
  });
})(js_cookie);
var Cookie = js_cookie.exports;

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Cookie.js
var SECURED_COOKIE = /^https/.test(window.location.href);
var Cookie2 = {
  setCookie: function(name, value, options2) {
    Cookie.set(name, value, oktaUnderscore.defaults(options2 || {}, {
      secure: SECURED_COOKIE,
      path: "/"
    }));
  },
  getCookie: function() {
    return Cookie.get.apply(Cookie, arguments);
  },
  removeCookie: function() {
    return Cookie.remove.apply(Cookie, arguments);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Clipboard.js
var import_clipboard = __toESM(require_clipboard());
var Clipboard = import_clipboard.default;
var OPTIONS = ["success", "error", "target", "text"];
var ClipboardClipboardWrapper = Class.extend({
  initialize: function(el, options2) {
    options2 = oktaUnderscore.pick(options2 || {}, OPTIONS);
    let trigger;
    let target;
    let text;
    if (oktaUnderscore.isString(el)) {
      trigger = el;
    }
    if (oktaUnderscore.isElement(el)) {
      trigger = el;
    }
    if (el instanceof oktaJQueryStatic) {
      trigger = el.selector;
    }
    if (el instanceof FrameworkView) {
      trigger = el.el;
    }
    if (oktaUnderscore.isFunction(options2.target)) {
      target = options2.target;
    }
    if (oktaUnderscore.isElement(options2.target)) {
      target = oktaUnderscore.constant(options2.target);
    }
    if (oktaUnderscore.isString(options2.text)) {
      text = oktaUnderscore.constant(options2.text);
    } else if (oktaUnderscore.isFunction(options2.text)) {
      text = options2.text;
    }
    this.__instance = new Clipboard(trigger, {
      target,
      text
    });
    this.done = oktaUnderscore.partial(this.__setCallback, "success");
    this.error = oktaUnderscore.partial(this.__setCallback, "error");
    this.done(options2.success);
    this.error(options2.error);
  },
  __setCallback: function(event, callback) {
    if (!oktaUnderscore.isFunction(callback)) {
      return;
    }
    this.__instance.on(event, callback);
    return this.__instance;
  }
});
var Clipboard$1 = {
  /**
   * @param {String|Node|View|jQuery} [el] el could be a selector (recommended),
   *           a dom node, a view or a jquery object
   * @param {Object} [options] Options hash
   * @param  {Node|Function} [options.target] a static dom node
   *           or a function that takes trigger node and returns a target node
   * @param {String|Function} [options.text] a static string or a function that returns a string dynamically
   * @param {Function} [options.success] success callback
   * @param {Function} [options.error] error callback
   * @return {Object} The clipboard object
   */
  attach: function(el, options2) {
    return new ClipboardClipboardWrapper(el, options2);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Keys.js
var Keys = {
  UP: 38,
  DOWN: 40,
  DEL: 46,
  TAB: 9,
  RETURN: 13,
  ENTER: 13,
  ESC: 27,
  COMMA: 188,
  PAGEUP: 33,
  PAGEDOWN: 34,
  SPACE: 32,
  BACKSPACE: 8,
  __isKey: function(e, key) {
    return (e.which || e.keyCode) === this[key];
  },
  isEnter: function(e) {
    return this.__isKey(e, "ENTER");
  },
  isEsc: function(e) {
    return this.__isKey(e, "ESC");
  },
  isSpaceBar: function(e) {
    return this.__isKey(e, "SPACE");
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Util.js
var Util = {
  redirect: function(url) {
    window.location = url;
  },
  reloadPage: function() {
    window.location.reload();
  },
  constantError: function(errorMessage) {
    return function() {
      throw new Error(errorMessage);
    };
  },
  /**
   * Simply convert an URL query key value pair object into an URL query string.
   * Remember NOT to escape the query string when using this util.
   * example:
   * input: {userId: 123, instanceId: undefined, expand: 'schema,app'}
   * output: '?userId=123&expand=schema,app'
   */
  getUrlQueryString: function(queries) {
    oktaUnderscore.isObject(queries) || (queries = {});
    const queriesString = oktaUnderscore.without(oktaUnderscore.map(queries, function(value, key) {
      if (value !== void 0 && value !== null) {
        return key + "=" + encodeURIComponent(value);
      }
    }), void 0).join("&");
    return oktaUnderscore.isEmpty(queriesString) ? "" : "?" + queriesString;
  },
  isABaseView: function(obj) {
    return obj instanceof BaseView || obj.prototype instanceof BaseView || obj === BaseView;
  },
  isSafari: function() {
    return /^((?!chrome|android|crios).)*safari/i.test(navigator.userAgent);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/handle-url.js
var clonedEscapeExpression = _Handlebars2.Utils.escapeExpression;
_Handlebars2.Utils.escapeExpression = function(string) {
  return clonedEscapeExpression(string).replace(/&#x3D;/g, "=");
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/helper-base64.js
_Handlebars2.registerHelper("base64ToHex", function base64ToHex(base64String) {
  const raw = atob(base64String);
  let result = "";
  if (raw.length > 0) {
    const firstHex = raw.charCodeAt(0).toString(16);
    result += firstHex.length === 2 ? firstHex : `0${firstHex}`;
    for (let i = 1; i < raw.length; i += 1) {
      let hex = raw.charCodeAt(i).toString(16);
      hex = hex.length === 2 ? hex : `0${hex}`;
      result += ` ${hex}`;
    }
  }
  return result.toUpperCase();
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/helper-i18n.js
var hbsEscape = _Handlebars2.Utils.escapeExpression;
function trim(str) {
  return str && str.replace(/^\s+|\s+$/g, "");
}
function replaceTagsWithPlaceholders(source, tag, tagValue) {
  const escapedBeginningTag = hbsEscape(`<${tag}>`);
  const escapedEndTag = hbsEscape(`</${tag}>`);
  const [beginningTag, endTag] = tagValue.split(tag);
  if (!source.includes(escapedBeginningTag) && !source.includes(escapedEndTag)) {
    throw Error(`Parsed tag "${tag}" is not present in "${source}"`);
  } else if (!tagValue.includes(tag)) {
    throw Error(`Parsed tag "${tag}" is not present in "${tagValue}"`);
  } else if (!beginningTag || !endTag) {
    throw Error(`Template value "${tagValue}" must contain beginning and closing tags`);
  }
  return source.replace(escapedBeginningTag, beginningTag).replace(escapedEndTag, endTag);
}
_Handlebars2.registerHelper("i18n", function i18n(options2) {
  let params;
  const key = trim(options2.hash.code);
  const bundle = trim(options2.hash.bundle);
  const args = trim(options2.hash.arguments);
  const tags = Object.keys(options2.hash).filter((prop) => prop.match(/^\$\d+/)).map((prop) => ({
    tag: prop,
    value: options2.hash[prop]
  }));
  if (args) {
    params = oktaUnderscore.map(trim(args).split(";"), function mapParam(param) {
      param = trim(param);
      let val;
      oktaUnderscore.each(param.split("."), (p) => {
        val = val ? val[p] : this[p];
      });
      return val;
    }, this);
  }
  const localizedValue = StringUtil.localize(key, bundle, params);
  if (tags.length < 1) {
    return localizedValue;
  }
  let escapedString = hbsEscape(localizedValue);
  try {
    tags.forEach((tag) => {
      escapedString = replaceTagsWithPlaceholders(escapedString, tag.tag, tag.value);
    });
    return new _Handlebars2.SafeString(escapedString);
  } catch (err) {
    Logger2.error(err.toString());
    return localizedValue;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/helper-img.js
var CACHE_BUST_URL_PREFIX = "/assets";
function prependCachebustPrefix(path) {
  if (path.indexOf(CACHE_BUST_URL_PREFIX) === 0) {
    return path;
  }
  return CACHE_BUST_URL_PREFIX + path;
}
_Handlebars2.registerHelper("img", function img(options2) {
  const cdn = typeof okta !== "undefined" && okta.cdnUrlHostname || "";
  const hash = oktaUnderscore.pick(options2.hash, ["src", "alt", "width", "height", "class", "title"]);
  hash.src = `${cdn}${prependCachebustPrefix(hash.src)}`;
  const attrs = oktaUnderscore.map(hash, (value, attr) => {
    const encodedValue = attr === "src" ? encodeURI(value) : _Handlebars2.Utils.escapeExpression(value);
    return `${attr}="${encodedValue}"`;
  });
  return new _Handlebars2.SafeString(`<img ${attrs.join(" ")}/>`);
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/markdownToHtml.js
var RE_LINK = /\[[^\]]*\]\([^)]*\)/gi;
var RE_LINK_HREF = /\]\(([^)]*)\)/i;
var RE_LINK_TEXT = /\[([^\]]*)\]/i;
var RE_LINK_JS = /javascript:/gi;
function mdToHtml(Handlebars, markdownText) {
  const linkTemplate = Handlebars.compile('<a href="{{href}}">{{text}}</a>');
  let res;
  if (!oktaUnderscore.isString(markdownText)) {
    res = "";
  } else {
    res = Handlebars.Utils.escapeExpression(markdownText).replace(RE_LINK_JS, "").replace(RE_LINK, function(mdLink) {
      return linkTemplate({
        href: mdLink.match(RE_LINK_HREF)[1],
        text: mdLink.match(RE_LINK_TEXT)[1]
      });
    });
  }
  return new Handlebars.SafeString(res);
}

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/helper-markdown.js
_Handlebars2.registerHelper("markdown", function markdown(mdText) {
  return mdToHtml(_Handlebars2, mdText);
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/handlebars/helper-xsrfTokenInput.js
_Handlebars2.registerHelper("xsrfTokenInput", function xsrfTokenInput() {
  return new _Handlebars2.SafeString(`<input type="hidden" class="hide" name="_xsrfToken" value="${oktaJQueryStatic("#_xsrfToken").text()}">`);
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/framework/ListView.js
var ListView = FrameworkView.extend(
  /** @lends src/framework/ListView.prototype */
  {
    constructor: function() {
      FrameworkView.apply(this, arguments);
      if (!this.collection) {
        throw new Error("Missing collection");
      }
      this.listenTo(this.collection, "reset sort", this.reset);
      this.listenTo(this.collection, "add", this.addItem);
      if (this.fetchCollection) {
        this.collection.fetch();
      } else {
        this.collection.each(this.addItem, this);
      }
    },
    /**
       * The view/template we will use to render each model in the collection.
       * @type {String|module:Okta.View}
       */
    item: null,
    /**
       * A selector in the local template where to append each item
       * @type {String}
       */
    itemSelector: null,
    /**
       * Empty the list and re-add everything from the collection.
       * Usefull for handling `collection.reset()` or for handling the initial load
       * @protected
       */
    reset: function() {
      this.removeChildren();
      this.collection.each((model, index) => {
        this.addItem(model, index);
      });
      return this;
    },
    /**
       * Add an item view to the list that will represent one model from the collection
       *
       * Listen to the model so when it is destoyed or removed from the collection
       * this item will remove itself from the list
       *
       * @param {Backbone.Model} model The model this row operates on
       * @protected
       */
    addItem: function(model) {
      var view = this.add(this.item, this.itemSelector, {
        options: {
          model
        }
      }).last();
      if (this.state && this.state.get("trackItemAdded")) {
        this.state.trigger("itemAdded", view);
      }
      view.listenTo(model, "destroy remove", view.remove);
      return this;
    },
    addShowMore: oktaUnderscore.noop
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/Backbone.ListView.js
var Backbone_ListView = BaseView.decorate(ListView);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/components/BaseDropDown.js
var optionsTemplate = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<span class="icon ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "icon") || (depth0 != null ? lookupProperty(depth0, "icon") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "icon",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 96
        },
        "end": {
          "line": 1,
          "column": 104
        }
      }
    }) : helper)) + '"></span>';
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 133
        },
        "end": {
          "line": 1,
          "column": 142
        }
      }
    }) : helper));
  },
  "5": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<p class="option-subtitle">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "subtitle") || (depth0 != null ? lookupProperty(depth0, "subtitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "subtitle",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 192
        },
        "end": {
          "line": 1,
          "column": 204
        }
      }
    }) : helper)) + "</p>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<a href="" class="icon-16 ' + alias4((helper = (helper = lookupProperty(helpers2, "className") || (depth0 != null ? lookupProperty(depth0, "className") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "className",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 26
        },
        "end": {
          "line": 1,
          "column": 39
        }
      }
    }) : helper)) + '" data-se="' + alias4((helper = (helper = lookupProperty(helpers2, "seleniumId") || (depth0 != null ? lookupProperty(depth0, "seleniumId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "seleniumId",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 50
        },
        "end": {
          "line": 1,
          "column": 64
        }
      }
    }) : helper)) + '">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "icon") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 66
        },
        "end": {
          "line": 1,
          "column": 120
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "title") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 120
        },
        "end": {
          "line": 1,
          "column": 149
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "subtitle") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(5, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 149
        },
        "end": {
          "line": 1,
          "column": 215
        }
      }
    })) != null ? stack1 : "") + "</a>";
  },
  "useData": true
});
var BaseDropDownDropDownOption = BaseView.extend({
  tagName: "li",
  events: {
    click: function(e) {
      e.preventDefault();
      this.action && this.action.call(this);
    }
  },
  constructor: function() {
    BaseView.apply(this, arguments);
    this.$el.addClass("okta-dropdown-option option");
  },
  render: function() {
    this.$el.html(optionsTemplate({
      icon: oktaUnderscore.result(this, "icon"),
      className: oktaUnderscore.result(this, "className") || "",
      title: oktaUnderscore.result(this, "title"),
      subtitle: oktaUnderscore.result(this, "subtitle"),
      seleniumId: oktaUnderscore.result(this, "seleniumId")
    }));
    if (oktaUnderscore.result(this, "disabled")) {
      this.disable();
    }
    return this;
  },
  disable: function() {
    this.$el.addClass("option-disabled");
    this.$el.find("a").attr("tabindex", "-1");
  }
});
var BaseDropDown = BaseView.extend({
  events: {
    "click a.option-selected": function(e) {
      e.preventDefault();
      if (oktaUnderscore.result(this, "disabled")) {
        e.stopPropagation();
      }
    },
    "click .dropdown-disabled": function(e) {
      e.preventDefault();
      e.stopPropagation();
    }
  },
  items: [],
  constructor: function() {
    const className2 = this.className;
    this.className = null;
    BaseView.apply(this, arguments);
    this.className = className2;
    this.$el.addClass("dropdown more-actions float-l");
    oktaUnderscore.each(oktaUnderscore.result(this, "items"), function(option2) {
      this.addOption(option2, this.options);
    }, this);
  },
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "icon") || (depth0 != null ? lookupProperty(depth0, "icon") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "icon",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 176
          },
          "end": {
            "line": 1,
            "column": 184
          }
        }
      }) : helper)) + '"></span>';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="off-screen">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "screenReaderText") || (depth0 != null ? lookupProperty(depth0, "screenReaderText") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "screenReaderText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 249
          },
          "end": {
            "line": 1,
            "column": 269
          }
        }
      }) : helper)) + "</span>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link-button ' + alias4((helper = (helper = lookupProperty(helpers2, "className") || (depth0 != null ? lookupProperty(depth0, "className") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "className",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 31
          },
          "end": {
            "line": 1,
            "column": 44
          }
        }
      }) : helper)) + ' link-button-icon option-selected center" aria-expanded="false" aria-controls="okta-dropdown-options">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "icon") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 146
          },
          "end": {
            "line": 1,
            "column": 200
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "screenReaderText") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 200
          },
          "end": {
            "line": 1,
            "column": 283
          }
        }
      })) != null ? stack1 : "") + '<span class="option-selected-text">' + alias4((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "title",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 318
          },
          "end": {
            "line": 1,
            "column": 327
          }
        }
      }) : helper)) + '</span><span class="icon-dm"></span></a><div id="okta-dropdown-options" class="options clearfix" style="display: none;"><ul class="okta-dropdown-list options-wrap clearfix"></ul></div>';
    },
    "useData": true
  }),
  getTemplateData: function() {
    const className2 = [oktaUnderscore.result(this, "className") || "", oktaUnderscore.result(this, "disabled") ? "dropdown-disabled" : ""];
    return {
      icon: oktaUnderscore.result(this, "icon"),
      className: oktaJQueryStatic.trim(className2.join(" ")),
      title: oktaUnderscore.result(this, "title"),
      screenReaderText: oktaUnderscore.result(this, "screenReaderText")
    };
  },
  addOption: function(proto5, options2) {
    this.add(BaseDropDownDropDownOption.extend(proto5), "ul.options-wrap", {
      options: options2 || {}
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/FormUtil.js
var LABEL_OPTIONS = ["model", "id", "inputId", "type", "label", "sublabel", "tooltip", "name", "group"];
var CONTAINER_OPTIONS = ["wide", "multi", "input", "label-top", "explain", "explain-top", "customExplain", "model", "name", "type", "autoRender", "multirowError"];
var WRAPPER_OPTIONS = ["model", "name", "label-top", "readOnly", "events", "initialize", "showWhen", "bindings", "render", "className", "data-se", "toggleWhen", "group"];
var INPUT_OPTIONS = [
  "model",
  "name",
  "inputId",
  "type",
  // base options
  "input",
  // custom input
  "placeholder",
  "label",
  // labels
  "readOnly",
  "read",
  "disabled",
  "readModeString",
  // modes
  "options",
  // select/radio
  "deps",
  // used to specify inputs that have dependencies and show a callout to user on select
  "from",
  "to",
  // model transformers,
  "autoRender",
  // model attributes change event to trigger rerendering of the input
  "inlineValidation",
  // control inline validating against the model on focus lost
  "validateOnlyIfDirty",
  // check if field has been interacted with and then validate
  "ariaLabel",
  // 508 compliance for inputs that do not have label associated with them
  "params",
  "autoComplete",
  // autocomplete attribute
  "sortByKey"
];
var OTHER_OPTIONS = [
  "errorField"
  // widgets params - for input specific widgets
];
var ALL_OPTIONS = oktaUnderscore.uniq(oktaUnderscore.union(LABEL_OPTIONS, CONTAINER_OPTIONS, WRAPPER_OPTIONS, INPUT_OPTIONS, OTHER_OPTIONS));
var SAVE_BUTTON_PHASES = ["•         ", "•  •      ", "•  •  •   ", "•  •  •  •", "   •  •  •", "      •  •", "         •", "          ", "          ", "          "];
function decorateDoWhen(doWhen) {
  if (doWhen && !doWhen["__edit__"]) {
    return oktaUnderscore.extend({
      __edit__: oktaUnderscore.constant(true)
    }, doWhen);
  }
}
function createButton(options2) {
  options2 = oktaUnderscore.pick(options2 || {}, "action", "id", "className", "text", "type");
  let timeoutId;
  let intervalId;
  let phaseCount;
  return BaseView.extend({
    tagName: "input",
    className: "button",
    events: {
      click: function() {
        if (options2.action && !this.disabled()) {
          options2.action.call(this);
        }
      },
      keyup: function(e) {
        if (Keys.isEnter(e) && options2.action && !this.disabled()) {
          options2.action.call(this);
        }
      }
    },
    disabled: function() {
      return this.$el.prop("disabled") === true;
    },
    disable: function() {
      this.$el.prop("disabled", true);
      this.$el.addClass("btn-disabled");
    },
    enable: function() {
      this.$el.prop("disabled", false);
      this.$el.removeClass("btn-disabled");
    },
    initialize: function() {
      const self2 = this;
      this.$el.attr("type", options2.type === "save" ? "submit" : "button");
      this.$el.val(options2.text);
      if (options2.id) {
        this.$el.attr("id", options2.id);
      }
      if (options2.className) {
        this.$el.addClass(options2.className);
      }
      if (options2.type) {
        this.$el.attr("data-type", options2.type);
      }
      this.$el.mousedown(function() {
        self2.model.set("__pending__", true);
      });
      this.$el.mouseup(function() {
        self2.model.set("__pending__", false);
      });
      this.listenTo(this.model, "form:set-saving-state", function() {
        this.disable();
        if (options2.type === "save") {
          timeoutId = setTimeout(oktaUnderscore.bind(this.__changeSaveText, this), 1e3);
        }
      });
      this.listenTo(this.model, "form:clear-saving-state", function() {
        this.enable();
        if (options2.type === "save") {
          clearTimeout(timeoutId);
          clearInterval(intervalId);
          this.$el.val(options2.text);
        }
      });
    },
    __changeSaveText: function() {
      phaseCount = 0;
      intervalId = setInterval(oktaUnderscore.bind(this.__showLoadingText, this), 200);
    },
    __showLoadingText: function() {
      this.$el.val(SAVE_BUTTON_PHASES[phaseCount++ % SAVE_BUTTON_PHASES.length]);
    }
  });
}
function validateInput(options2, model) {
  options2 || (options2 = {});
  if (options2.type === "label") {
    if (!options2.label)
      ;
    return;
  }
  if (options2.type === "button") {
    if (!options2.title && !options2.icon)
      ;
    if (!options2.click && !options2.href)
      ;
    return;
  }
  if (!options2.name && !options2.input)
    ;
  if (oktaUnderscore.isArray(options2.name) && oktaUnderscore.isArray(options2.input)) {
    throw new Error('Not allowed to have both "name" and "input" defined as array.');
  }
  if (options2.type !== "list" && options2.name && model && model.allows) {
    let names = [];
    if (oktaUnderscore.isArray(options2.name)) {
      names = options2.name;
    } else {
      names.push(options2.name);
    }
    oktaUnderscore.each(names, function(name) {
      if (!model.allows(name)) {
        throw new Error("field not allowed: " + options2.name);
      }
    });
  }
  if (oktaUnderscore.isArray(options2.input) && options2.type !== "list") {
    oktaUnderscore.each(options2.input, function(input) {
      validateInput(input, model);
    });
  }
  const keys = oktaUnderscore.keys(options2);
  const intersection = oktaUnderscore.intersection(keys, ALL_OPTIONS);
  if (oktaUnderscore.size(intersection) !== oktaUnderscore.size(options2)) {
    oktaUnderscore.clone(ALL_OPTIONS);
  }
}
function generateInputOptions(options2, form2, createFn) {
  options2 = oktaUnderscore.clone(options2);
  if (oktaUnderscore.contains(["list", "group"], options2.type)) {
    options2.params = oktaUnderscore.defaults({
      create: createFn,
      inputs: oktaUnderscore.map(oktaUnderscore.isArray(options2.input) ? options2.input : [options2.input], function(input) {
        return oktaUnderscore.first(generateInputOptions(input, form2, createFn));
      })
    }, options2.params || {});
    delete options2.input;
  }
  const inputs = oktaUnderscore.isArray(options2.input) ? oktaUnderscore.clone(options2.input) : [options2];
  return oktaUnderscore.map(inputs, function(input) {
    const target = oktaUnderscore.defaults({
      model: form2.model
    }, input, oktaUnderscore.omit(options2, "input", "inputs"), form2.options, {
      id: oktaUnderscore.uniqueId("input"),
      readOnly: form2.isReadOnly(),
      read: form2.hasReadMode()
    });
    if (form2.isReadOnly()) {
      target.read = target.readOnly = true;
    }
    return target;
  });
}
var FormUtil = {
  LABEL_OPTIONS,
  CONTAINER_OPTIONS,
  WRAPPER_OPTIONS,
  INPUT_OPTIONS,
  generateInputOptions,
  changeEventString: function(fieldNames) {
    return "change:" + fieldNames.join(" change:");
  },
  createReadFormButton: function(options2) {
    let action2;
    let text;
    let ariaLabel;
    if (options2.type === "cancel") {
      text = ariaLabel = StringUtil.localize("oform.cancel", "courage");
      action2 = function() {
        this.model.trigger("form:cancel");
      };
    } else {
      text = StringUtil.localize("oform.edit", "courage");
      ariaLabel = text + " " + options2.formTitle;
      action2 = function() {
        this.model.set("__edit__", true);
      };
    }
    return BaseView.extend({
      tagName: "a",
      className: options2.className,
      attributes: {
        href: "#",
        "aria-label": ariaLabel
      },
      // TODO: refactor to enforce precompiled templates OKTA-309852
      // eslint-disable-next-line @okta/okta-ui/no-bare-templates
      template: function() {
        return oktaUnderscore.escape(text);
      },
      events: {
        click: function(e) {
          e.preventDefault();
          action2.call(this);
        }
      }
    });
  },
  createButton: function(options2) {
    options2 = oktaUnderscore.clone(options2);
    switch (options2.type) {
      case "save":
        oktaUnderscore.defaults(options2, {
          className: "button-primary"
        });
        break;
      case "cancel":
        oktaUnderscore.defaults(options2, {
          className: "button-clear",
          text: StringUtil.localize("oform.cancel", "courage"),
          action: function() {
            this.model.trigger("form:cancel");
          }
        });
        break;
      case "previous":
        oktaUnderscore.defaults(options2, {
          text: StringUtil.localize("oform.previous", "courage"),
          action: function() {
            this.model.trigger("form:previous");
          }
        });
        break;
    }
    return createButton(options2);
  },
  validateInput,
  /**
   * Applies a show-when logic on a view instance.
   * The show-when is a map of a model field name -> a boolean or a function that returns a boolean.
   * The view will toggle based on the field value.
   *
   * @param  {Okta.View} view a view instance that has a this.model attached to it
   * @param  {Object} showWhen
   */
  applyShowWhen: function(view, showWhen) {
    const toggleAndResize = function(bool) {
      return function() {
        view.$el.toggle(bool);
        view.model.trigger("form:resize");
      };
    };
    ViewUtil.applyDoWhen(view, decorateDoWhen(showWhen), function(bool, options2) {
      if (!options2.animate) {
        view.$el.toggle(bool);
      } else {
        view.$el["slide" + (bool ? "Down" : "Up")](200, toggleAndResize(bool));
      }
    });
  },
  applyToggleWhen: function(view, toggleWhen) {
    ViewUtil.applyDoWhen(view, decorateDoWhen(toggleWhen), function(bool, options2) {
      view.$el.toggle(bool);
      view.model.trigger("form:resize");
      if (options2.animate) {
        view.render();
      }
    });
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/components/ReadModeBar.js
var ReadModeBar = BaseView.extend({
  el: '<span class="o-form-toggle" data-type="header-btn"></span>',
  formTitle: "",
  modelEvents: {
    "change:__edit__": "toggle"
  },
  initialize: function() {
    this.addButton();
  },
  addButton: function() {
    if (this.model.get("__edit__")) {
      this.add(FormUtil.createReadFormButton({
        type: "cancel"
      }));
    } else {
      this.add(FormUtil.createReadFormButton({
        type: "edit",
        formTitle: this.formTitle,
        className: "disable-in-read-only"
      }));
    }
  },
  toggle: function() {
    this.removeChildren();
    this.addButton();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/components/Toolbar.js
var proto4 = {
  className: function() {
    return "o-form-button-bar";
  },
  buttonOrder: ["previous", "save", "cancel"],
  initialize: function(options2) {
    const buttonConfigs = {
      previous: {
        type: "previous"
      },
      save: {
        type: "save",
        text: oktaUnderscore.resultCtx(options2, "save", this),
        id: oktaUnderscore.resultCtx(options2, "saveId", this),
        className: oktaUnderscore.resultCtx(options2, "saveClassName", this)
      },
      cancel: {
        type: "cancel",
        text: oktaUnderscore.resultCtx(options2, "cancel", this)
      }
    };
    this.__getButtonOrder(options2).forEach((buttonName) => {
      this.addButton(buttonConfigs[buttonName]);
    });
  },
  /**
   * Adds a buttomn to the toolbar
   * @param {Object} params button parameters
   * @param {Object} options {@link Okta.View#add} options
   */
  addButton: function(params, options2) {
    return this.add(FormUtil.createButton(params), options2);
  },
  __getButtonOrder: function(options2) {
    const buttonOrder = oktaUnderscore.resultCtx(options2, "buttonOrder", this, this.buttonOrder);
    const buttonsToSkip = [];
    if (options2.noSubmitButton) {
      buttonsToSkip.push("save");
    }
    if (options2.noCancelButton) {
      buttonsToSkip.push("cancel");
    }
    if (!options2.hasPrevStep) {
      buttonsToSkip.push("previous");
    }
    return oktaUnderscore.without(buttonOrder, ...buttonsToSkip);
  }
};
var Toolbar = BaseView.extend(proto4);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/ErrorBanner.js
var ErrorBanner = BaseView.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "errorSummary") || (depth0 != null ? lookupProperty(depth0, "errorSummary") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "errorSummary",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 130
          },
          "end": {
            "line": 1,
            "column": 146
          }
        }
      }) : helper)) + "</p>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "courage",
          "code": "oform.errorbanner.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 161
          },
          "end": {
            "line": 1,
            "column": 217
          }
        }
      })) + "</p>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-infobox-error infobox infobox-error" role="alert"><span class="icon error-16"></span>' + ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "errorSummary") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 107
          },
          "end": {
            "line": 1,
            "column": 228
          }
        }
      })) != null ? stack1 : "") + "</div>";
    },
    "useData": true
  }),
  modelEvents: {
    "form:clear-errors": "remove"
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/ErrorParser.js
var FIELD_REGEX = /^([\S]+): (.+)$/;
var ErrorParser = {
  /**
   * Helper function that returns the json output of an xhr objext
   * @param  {jqXhr} xhr
   * @return {Object}
   */
  getResponseJSON: function(xhr) {
    try {
      return xhr.responseJSON || JSON.parse(xhr.responseText);
    } catch (e) {
    }
  },
  /**
   * Parses an error summary to extract a field name and an error message
   * @param  {String} errorSummary The raw error summary
   * @return {String[]} An array with two members: [field name, error message]
   */
  parseErrorSummary: function(errorSummary) {
    const matches = errorSummary.match(FIELD_REGEX);
    if (matches) {
      return [matches[1], matches[2]];
    }
  },
  /**
   * Parses an error cause object to extract a field name from property attribute
   * and an error message form errorSummary attribute. It looks to see if there is
   * a custom override/translation for the erorrCause.reason before using the errorSummary
   * @param  {Object} errorCause object
   * @return {String[]} An array with two members: [field name, error message]
   */
  parseErrorCauseObject: function(errorCause) {
    if (errorCause.property && errorCause.errorSummary) {
      const localizedMsg = StringUtil.localize(errorCause.reason);
      const apiMsg = errorCause.errorSummary;
      const field = errorCause.property;
      const errorMessage = localizedMsg.indexOf("L10N_ERROR[") === -1 ? localizedMsg : apiMsg;
      return [field, errorMessage];
    }
  },
  parseErrors: function(resp) {
    const responseJSON = this.getResponseJSON(resp);
    return oktaUnderscore.map(responseJSON && responseJSON.errorCauses || [], function(errorCause) {
      return ("" + errorCause.errorSummary).replace(FIELD_REGEX, "$2");
    });
  },
  /**
   * Parses the response for errors
   * Returns a map of field names > array or error messages
   * Example:
   * ```javascript
   * {
   *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],
   *   name: ['The field cannot be left blank']
   * }
   * ```
   * @param  {Object} resp
   * @return {Object}
   */
  parseFieldErrors: function(resp) {
    const responseJSON = this.getResponseJSON(resp);
    const errors = {};
    if (responseJSON) {
      oktaUnderscore.each(responseJSON.errorCauses || [], function(cause) {
        let res = [];
        if (cause.property && cause.errorSummary) {
          res = this.parseErrorCauseObject(cause);
        } else if (cause.location && cause.errorSummary) {
          res = [cause.location, cause.errorSummary];
        } else {
          res = this.parseErrorSummary(cause && cause.errorSummary || "");
        }
        if (res) {
          const fieldName = res[0];
          const message = res[1];
          errors[fieldName] || (errors[fieldName] = []);
          errors[fieldName].push(message);
        }
      }, this);
    } else if (oktaUnderscore.isObject(resp) && oktaUnderscore.size(resp)) {
      oktaUnderscore.each(resp, function(msg, field) {
        errors[field] = [msg];
      });
    }
    return oktaUnderscore.size(errors) ? errors : void 0;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/InputContainer.js
var isABaseView = Util.isABaseView;
var InputContainer = BaseView.extend({
  attributes: function() {
    return {
      "data-se": "o-form-input-container"
    };
  },
  className: function() {
    let className2 = "o-form-input";
    if (this.options.wide) {
      className2 += " o-form-wide";
    }
    if (oktaUnderscore.contains([1, 2, 3, 4], this.options.multi)) {
      className2 += " o-form-multi-input-" + this.options.multi;
      if (oktaUnderscore.isArray(this.options.input)) {
        const inputGroup = oktaUnderscore.find(this.options.input, function(input) {
          return oktaUnderscore.contains(["text+select", "select+text"], input.options.type);
        });
        inputGroup && (className2 += " o-form-multi-input-group-" + this.options.multi);
      }
    }
    return className2;
  },
  _getNames: function() {
    const names = oktaUnderscore.isArray(this.options.name) ? this.options.name : [this.options.name];
    if (this.options.type === "group") {
      names.push.apply(names, oktaUnderscore.pluck(this.options.input[0].options.params.inputs, "name"));
    } else if (oktaUnderscore.isArray(this.options.name)) {
      if (this.options.input && this.options.input.options && this.options.input.options.name) {
        names.push(this.options.input.options.name);
      }
    } else if (this.options.input) {
      if (oktaUnderscore.isArray(this.options.input)) {
        oktaUnderscore.each(this.options.input, function(inputItem) {
          names.push(inputItem.options.name);
        });
      } else {
        names.push(this.options.input.options.name);
      }
    }
    return oktaUnderscore.uniq(oktaUnderscore.compact(names));
  },
  _getInputElement: function() {
    const lastInput = Array.isArray(this.options.input) ? oktaUnderscore.last(this.options.input) : this.options.input;
    const id = lastInput && lastInput.options && lastInput.options.inputId;
    const el = id ? this.$("#" + id) : null;
    return el && el.length ? el : null;
  },
  constructor: function() {
    BaseView.apply(this, arguments);
    const explainTop = this.options["explain-top"] && this.options["label-top"];
    if (this.options.input) {
      if (oktaUnderscore.isArray(this.options.input)) {
        oktaUnderscore.each(this.options.input, function(inputItem) {
          this.add(inputItem, {
            prepend: !explainTop
          });
        }, this);
      } else {
        this.add(this.options.input, {
          prepend: !explainTop
        });
      }
    }
    this.__setExplain(this.options);
    const names = this._getNames();
    this.listenTo(this.model, "form:field-error", function(name, errors) {
      if (oktaUnderscore.contains(names, name)) {
        this.__setError(errors, explainTop);
      }
    });
    this.listenTo(this.model, "form:clear-errors change:" + names.join(" change:"), this.__clearError);
    this.listenTo(this.model, "form:clear-error:" + names.join(" form:clear-error:"), this.__clearError);
    if (oktaUnderscore.resultCtx(this.options, "autoRender", this)) {
      this.listenTo(this.model, "change:" + this.options.name, this.render);
    }
    this.__errorState = false;
  },
  /**
   * Populates the explain on the input container (if it exists). There are
   * two ways to use this:
   * 1. Raw text - wraps in the correct html template
   * 2. Custom html
   *    - pass in a View class (preferred)
   *    - pass in an instance of a View
   * Some additional notes:
   * - You can pass a function that returns any of the above
   * - This maintains support for the deprecated "customExplain" property
   *   that was used before. This pattern is superseded by explain, so use
   *   that instead.
   * @private
   */
  __setExplain: function(options2) {
    let explain;
    if (options2.customExplain) {
      this.add(this.options.customExplain);
      return;
    }
    explain = options2.explain;
    if (oktaUnderscore.isFunction(explain) && !isABaseView(explain)) {
      explain = oktaUnderscore.resultCtx(this.options, "explain", this);
    }
    if (!explain) {
      return;
    }
    if (isABaseView(explain)) {
      this.template = _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          return '<p class="o-form-explain"></p>';
        },
        "useData": true
      });
      this.add(explain, " > .o-form-explain");
    } else {
      this.template = _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return '<p class="o-form-explain">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "explain") || (depth0 != null ? lookupProperty(depth0, "explain") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "explain",
            "hash": {},
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 26
              },
              "end": {
                "line": 1,
                "column": 37
              }
            }
          }) : helper)) + "</p>";
        },
        "useData": true
      });
    }
  },
  /**
   * Highlight the input as invalid (validation failed)
   * Adds an explaination message of the error
   * @private
   */
  __setError: function(errors, explainTop) {
    this.__errorState = true;
    this.$el.addClass("o-form-has-errors");
    const errorId = oktaUnderscore.uniqueId("input-container-error");
    const html = this.__getHTMLForError(oktaUnderscore.flatten(errors), errorId);
    const $elExplain = this.$(".o-form-explain").not(".o-form-input-error").first();
    if ($elExplain.length && !explainTop) {
      $elExplain.before(html);
    } else {
      this.$el.append(html);
    }
    const target = this._getInputElement() || this.$el;
    target.attr("aria-describedby", errorId);
    target.attr("aria-invalid", true);
  },
  __getHTMLForError: function(errors, errorId) {
    const tmpl = _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<p id="' + alias4((helper = (helper = lookupProperty(helpers2, "errorId") || (depth0 != null ? lookupProperty(depth0, "errorId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "errorId",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 7
            },
            "end": {
              "line": 1,
              "column": 18
            }
          }
        }) : helper)) + '" class="okta-form-input-error o-form-input-error o-form-explain" role="alert"><span class="icon icon-16 error-16-small" role="img" aria-label="' + alias4((helper = (helper = lookupProperty(helpers2, "iconLabel") || (depth0 != null ? lookupProperty(depth0, "iconLabel") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "iconLabel",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 162
            },
            "end": {
              "line": 1,
              "column": 175
            }
          }
        }) : helper)) + '"></span>' + alias4((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "text",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 184
            },
            "end": {
              "line": 1,
              "column": 192
            }
          }
        }) : helper)) + "</p>";
      },
      "useData": true
    });
    const iconLabel = StringUtil.localize("oform.error.icon.ariaLabel", "courage");
    if (this.options.multirowError) {
      let html = "";
      errors.forEach((error) => {
        html = html + tmpl({
          errorId,
          iconLabel,
          text: error
        });
      });
      return html;
    }
    return tmpl({
      errorId,
      iconLabel,
      text: errors.join(", ")
    });
  },
  /**
   * Un-highlight the input and remove explaination text
   * @private
   */
  __clearError: function() {
    if (this.__errorState) {
      this.$(".o-form-input-error").remove();
      const target = this._getInputElement() || this.$el;
      target.attr("aria-describedby", null);
      target.attr("aria-invalid", null);
      this.$el.removeClass("o-form-has-errors");
      this.__errorState = false;
      oktaUnderscore.defer(() => {
        this.model.trigger("form:resize");
      });
    }
  },
  focus: function() {
    this.each(function(view) {
      if (view.focus) {
        return view.focus();
      }
    });
    return this;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/InputRegistry.js
var registry = {};
function isBaseInput(input) {
  if (oktaUnderscore.isFunction(input)) {
    return oktaUnderscore.isFunction(input.prototype.editMode) && oktaUnderscore.isFunction(input.prototype.readMode);
  } else {
    return oktaUnderscore.isObject(input) && oktaUnderscore.isFunction(input.editMode) && oktaUnderscore.isFunction(input.readMode);
  }
}
var InputRegistry = (
  /** @lends module:Okta.internal.views.forms.helpers.InputRegistry */
  {
    isBaseInput,
    /**
     * Register a form input
     * @param {String} type string identifier for the input
     * @param {BaseInput} input the input to register
     * @return {void}
     */
    register: function(type, input) {
      registry[type] = input;
    },
    /**
     * Get a form input by type
     * @param {Object} options input definition
     * @param {String} options.type string identifier for the input
     * @return {BaseInput} a matching input
     */
    get: function(options2) {
      const input = registry[options2.type];
      return input && (isBaseInput(input) ? input : input(options2));
    },
    /**
     * Unregister an input type
     * @param {String} type
     */
    unregister: function(type) {
      delete registry[type];
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/InputFactory.js
function createInput(Input, options2) {
  if (InputRegistry.isBaseInput(Input)) {
    return Input.prototype ? new Input(oktaUnderscore.omit(options2, "input")) : Input;
  } else {
    return Input;
  }
}
function create(options2) {
  options2 = oktaUnderscore.clone(options2);
  if (options2.input) {
    return createInput(options2.input, options2);
  }
  const Input = InputRegistry.get(options2);
  if (!Input) {
    throw new Error("unknown input: " + options2.type);
  }
  return createInput(Input, options2);
}
function supports(options2) {
  return !!options2.input || !!InputRegistry.get(options2);
}
var InputFactory = {
  create,
  supports
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/qtip2/dist/jquery.qtip.js
(function(window2, document2, undefined$1) {
  (function(factory) {
    if (!jQuery.fn.qtip) {
      factory(jQuery);
    }
  })(function($) {
    var TRUE = true, FALSE = false, NULL = null, X = "x", Y = "y", WIDTH = "width", HEIGHT = "height", TOP = "top", LEFT = "left", BOTTOM = "bottom", RIGHT = "right", CENTER = "center", FLIPINVERT = "flipinvert", SHIFT = "shift", QTIP, PROTOTYPE, CORNER, CHECKS, PLUGINS = {}, NAMESPACE = "qtip", ATTR_HAS = "data-hasqtip", ATTR_ID = "data-qtip-id", WIDGET = ["ui-widget", "ui-tooltip"], SELECTOR = "." + NAMESPACE, INACTIVE_EVENTS = "click dblclick mousedown mouseup mousemove mouseleave mouseenter".split(" "), CLASS_FIXED = NAMESPACE + "-fixed", CLASS_DEFAULT = NAMESPACE + "-default", CLASS_FOCUS = NAMESPACE + "-focus", CLASS_HOVER = NAMESPACE + "-hover", CLASS_DISABLED = NAMESPACE + "-disabled", replaceSuffix = "_replacedByqTip", oldtitle = "oldtitle", trackingBound, BROWSER = {
      /*
       * IE version detection
       *
       * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
       * Credit to James Padolsey for the original implemntation!
       */
      ie: function() {
        var v, i;
        for (v = 4, i = document2.createElement("div"); (i.innerHTML = "<!--[if gt IE " + v + "]><i></i><![endif]-->") && i.getElementsByTagName("i")[0]; v += 1) {
        }
        return v > 4 ? v : NaN;
      }(),
      /*
       * iOS version detection
       */
      iOS: parseFloat(("" + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) || FALSE
    };
    function QTip(target, options2, id, attr) {
      this.id = id;
      this.target = target;
      this.tooltip = NULL;
      this.elements = {
        target
      };
      this._id = NAMESPACE + "-" + id;
      this.timers = {
        img: {}
      };
      this.options = options2;
      this.plugins = {};
      this.cache = {
        event: {},
        target: $(),
        disabled: FALSE,
        attr,
        onTooltip: FALSE,
        lastClass: ""
      };
      this.rendered = this.destroyed = this.disabled = this.waiting = this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
    }
    PROTOTYPE = QTip.prototype;
    PROTOTYPE._when = function(deferreds) {
      return $.when.apply($, deferreds);
    };
    PROTOTYPE.render = function(show) {
      if (this.rendered || this.destroyed) {
        return this;
      }
      var self2 = this, options2 = this.options, cache = this.cache, elements = this.elements, text = options2.content.text, title = options2.content.title, button = options2.content.button, posOptions = options2.position, deferreds = [];
      $.attr(this.target[0], "aria-describedby", this._id);
      cache.posClass = this._createPosClass((this.position = {
        my: posOptions.my,
        at: posOptions.at
      }).my);
      this.tooltip = elements.tooltip = $("<div/>", {
        "id": this._id,
        "class": [NAMESPACE, CLASS_DEFAULT, options2.style.classes, cache.posClass].join(" "),
        "width": options2.style.width || "",
        "height": options2.style.height || "",
        "tracking": posOptions.target === "mouse" && posOptions.adjust.mouse,
        /* ARIA specific attributes */
        "role": "alert",
        "aria-live": "polite",
        "aria-atomic": FALSE,
        "aria-describedby": this._id + "-content",
        "aria-hidden": TRUE
      }).toggleClass(CLASS_DISABLED, this.disabled).attr(ATTR_ID, this.id).data(NAMESPACE, this).appendTo(posOptions.container).append(
        // Create content element
        elements.content = $("<div />", {
          "class": NAMESPACE + "-content",
          "id": this._id + "-content",
          "aria-atomic": TRUE
        })
      );
      this.rendered = -1;
      this.positioning = TRUE;
      if (title) {
        this._createTitle();
        if (!$.isFunction(title)) {
          deferreds.push(this._updateTitle(title, FALSE));
        }
      }
      if (button) {
        this._createButton();
      }
      if (!$.isFunction(text)) {
        deferreds.push(this._updateContent(text, FALSE));
      }
      this.rendered = TRUE;
      this._setWidget();
      $.each(PLUGINS, function(name) {
        var instance;
        if (this.initialize === "render" && (instance = this(self2))) {
          self2.plugins[name] = instance;
        }
      });
      this._unassignEvents();
      this._assignEvents();
      this._when(deferreds).then(function() {
        self2._trigger("render");
        self2.positioning = FALSE;
        if (!self2.hiddenDuringWait && (options2.show.ready || show)) {
          self2.toggle(TRUE, cache.event, FALSE);
        }
        self2.hiddenDuringWait = FALSE;
      });
      QTIP.api[this.id] = this;
      return this;
    };
    PROTOTYPE.destroy = function(immediate) {
      if (this.destroyed) {
        return this.target;
      }
      function process2() {
        if (this.destroyed) {
          return;
        }
        this.destroyed = TRUE;
        var target = this.target, title = target.attr(oldtitle), timer;
        if (this.rendered) {
          this.tooltip.stop(1, 0).find("*").remove().end().remove();
        }
        $.each(this.plugins, function() {
          this.destroy && this.destroy();
        });
        for (timer in this.timers) {
          if (this.timers.hasOwnProperty(timer)) {
            clearTimeout(this.timers[timer]);
          }
        }
        target.removeData(NAMESPACE).removeAttr(ATTR_ID).removeAttr(ATTR_HAS).removeAttr("aria-describedby");
        if (this.options.suppress && title) {
          target.attr("title", title).removeAttr(oldtitle);
        }
        this._unassignEvents();
        this.options = this.elements = this.cache = this.timers = this.plugins = this.mouse = NULL;
        delete QTIP.api[this.id];
      }
      if ((immediate !== TRUE || this.triggering === "hide") && this.rendered) {
        this.tooltip.one("tooltiphidden", $.proxy(process2, this));
        !this.triggering && this.hide();
      } else {
        process2.call(this);
      }
      return this.target;
    };
    function invalidOpt(a2) {
      return a2 === NULL || $.type(a2) !== "object";
    }
    function invalidContent(c2) {
      return !($.isFunction(c2) || c2 && c2.attr || c2.length || $.type(c2) === "object" && (c2.jquery || c2.then));
    }
    function sanitizeOptions(opts) {
      var content, text, ajax, once;
      if (invalidOpt(opts)) {
        return FALSE;
      }
      if (invalidOpt(opts.metadata)) {
        opts.metadata = {
          type: opts.metadata
        };
      }
      if ("content" in opts) {
        content = opts.content;
        if (invalidOpt(content) || content.jquery || content.done) {
          text = invalidContent(content) ? FALSE : content;
          content = opts.content = {
            text
          };
        } else {
          text = content.text;
        }
        if ("ajax" in content) {
          ajax = content.ajax;
          once = ajax && ajax.once !== FALSE;
          delete content.ajax;
          content.text = function(event, api2) {
            var loading = text || $(this).attr(api2.options.content.attr) || "Loading...", deferred = $.ajax($.extend({}, ajax, {
              context: api2
            })).then(ajax.success, NULL, ajax.error).then(function(newContent) {
              if (newContent && once) {
                api2.set("content.text", newContent);
              }
              return newContent;
            }, function(xhr, status, error) {
              if (api2.destroyed || xhr.status === 0) {
                return;
              }
              api2.set("content.text", status + ": " + error);
            });
            return !once ? (api2.set("content.text", loading), deferred) : loading;
          };
        }
        if ("title" in content) {
          if ($.isPlainObject(content.title)) {
            content.button = content.title.button;
            content.title = content.title.text;
          }
          if (invalidContent(content.title || FALSE)) {
            content.title = FALSE;
          }
        }
      }
      if ("position" in opts && invalidOpt(opts.position)) {
        opts.position = {
          my: opts.position,
          at: opts.position
        };
      }
      if ("show" in opts && invalidOpt(opts.show)) {
        opts.show = opts.show.jquery ? {
          target: opts.show
        } : opts.show === TRUE ? {
          ready: TRUE
        } : {
          event: opts.show
        };
      }
      if ("hide" in opts && invalidOpt(opts.hide)) {
        opts.hide = opts.hide.jquery ? {
          target: opts.hide
        } : {
          event: opts.hide
        };
      }
      if ("style" in opts && invalidOpt(opts.style)) {
        opts.style = {
          classes: opts.style
        };
      }
      $.each(PLUGINS, function() {
        this.sanitize && this.sanitize(opts);
      });
      return opts;
    }
    CHECKS = PROTOTYPE.checks = {
      builtin: {
        // Core checks
        "^id$": function(obj, o, v, prev) {
          var id = v === TRUE ? QTIP.nextid : v, newId = NAMESPACE + "-" + id;
          if (id !== FALSE && id.length > 0 && !$("#" + newId).length) {
            this._id = newId;
            if (this.rendered) {
              this.tooltip[0].id = this._id;
              this.elements.content[0].id = this._id + "-content";
              this.elements.title[0].id = this._id + "-title";
            }
          } else {
            obj[o] = prev;
          }
        },
        "^prerender": function(obj, o, v) {
          v && !this.rendered && this.render(this.options.show.ready);
        },
        // Content checks
        "^content.text$": function(obj, o, v) {
          this._updateContent(v);
        },
        "^content.attr$": function(obj, o, v, prev) {
          if (this.options.content.text === this.target.attr(prev)) {
            this._updateContent(this.target.attr(v));
          }
        },
        "^content.title$": function(obj, o, v) {
          if (!v) {
            return this._removeTitle();
          }
          v && !this.elements.title && this._createTitle();
          this._updateTitle(v);
        },
        "^content.button$": function(obj, o, v) {
          this._updateButton(v);
        },
        "^content.title.(text|button)$": function(obj, o, v) {
          this.set("content." + o, v);
        },
        // Position checks
        "^position.(my|at)$": function(obj, o, v) {
          if ("string" === typeof v) {
            this.position[o] = obj[o] = new CORNER(v, o === "at");
          }
        },
        "^position.container$": function(obj, o, v) {
          this.rendered && this.tooltip.appendTo(v);
        },
        // Show checks
        "^show.ready$": function(obj, o, v) {
          v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
        },
        // Style checks
        "^style.classes$": function(obj, o, v, p) {
          this.rendered && this.tooltip.removeClass(p).addClass(v);
        },
        "^style.(width|height)": function(obj, o, v) {
          this.rendered && this.tooltip.css(o, v);
        },
        "^style.widget|content.title": function() {
          this.rendered && this._setWidget();
        },
        "^style.def": function(obj, o, v) {
          this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
        },
        // Events check
        "^events.(render|show|move|hide|focus|blur)$": function(obj, o, v) {
          this.rendered && this.tooltip[($.isFunction(v) ? "" : "un") + "bind"]("tooltip" + o, v);
        },
        // Properties which require event reassignment
        "^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)": function() {
          if (!this.rendered) {
            return;
          }
          var posOptions = this.options.position;
          this.tooltip.attr("tracking", posOptions.target === "mouse" && posOptions.adjust.mouse);
          this._unassignEvents();
          this._assignEvents();
        }
      }
    };
    function convertNotation(options2, notation) {
      var i = 0, obj, option2 = options2, levels = notation.split(".");
      while (option2 = option2[levels[i++]]) {
        if (i < levels.length) {
          obj = option2;
        }
      }
      return [obj || options2, levels.pop()];
    }
    PROTOTYPE.get = function(notation) {
      if (this.destroyed) {
        return this;
      }
      var o = convertNotation(this.options, notation.toLowerCase()), result = o[0][o[1]];
      return result.precedance ? result.string() : result;
    };
    function setCallback(notation, args) {
      var category, rule, match;
      for (category in this.checks) {
        if (!this.checks.hasOwnProperty(category)) {
          continue;
        }
        for (rule in this.checks[category]) {
          if (!this.checks[category].hasOwnProperty(rule)) {
            continue;
          }
          if (match = new RegExp(rule, "i").exec(notation)) {
            args.push(match);
            if (category === "builtin" || this.plugins[category]) {
              this.checks[category][rule].apply(this.plugins[category] || this, args);
            }
          }
        }
      }
    }
    var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i, rrender = /^prerender|show\.ready/i;
    PROTOTYPE.set = function(option2, value) {
      if (this.destroyed) {
        return this;
      }
      var rendered = this.rendered, reposition = FALSE, options2 = this.options, name;
      if ("string" === typeof option2) {
        name = option2;
        option2 = {};
        option2[name] = value;
      } else {
        option2 = $.extend({}, option2);
      }
      $.each(option2, function(notation, val) {
        if (rendered && rrender.test(notation)) {
          delete option2[notation];
          return;
        }
        var obj = convertNotation(options2, notation.toLowerCase()), previous;
        previous = obj[0][obj[1]];
        obj[0][obj[1]] = val && val.nodeType ? $(val) : val;
        reposition = rmove.test(notation) || reposition;
        option2[notation] = [obj[0], obj[1], val, previous];
      });
      sanitizeOptions(options2);
      this.positioning = TRUE;
      $.each(option2, $.proxy(setCallback, this));
      this.positioning = FALSE;
      if (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
        this.reposition(options2.position.target === "mouse" ? NULL : this.cache.event);
      }
      return this;
    };
    PROTOTYPE._update = function(content, element) {
      var self2 = this, cache = this.cache;
      if (!this.rendered || !content) {
        return FALSE;
      }
      if ($.isFunction(content)) {
        content = content.call(this.elements.target, cache.event, this) || "";
      }
      if ($.isFunction(content.then)) {
        cache.waiting = TRUE;
        return content.then(function(c2) {
          cache.waiting = FALSE;
          return self2._update(c2, element);
        }, NULL, function(e) {
          return self2._update(e, element);
        });
      }
      if (content === FALSE || !content && content !== "") {
        return FALSE;
      }
      if (content.jquery && content.length > 0) {
        element.empty().append(content.css({
          display: "block",
          visibility: "visible"
        }));
      } else {
        element.html(content);
      }
      return this._waitForContent(element).then(function(images) {
        if (self2.rendered && self2.tooltip[0].offsetWidth > 0) {
          self2.reposition(cache.event, !images.length);
        }
      });
    };
    PROTOTYPE._waitForContent = function(element) {
      var cache = this.cache;
      cache.waiting = TRUE;
      return ($.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([])).done(function() {
        cache.waiting = FALSE;
      }).promise();
    };
    PROTOTYPE._updateContent = function(content, reposition) {
      this._update(content, this.elements.content, reposition);
    };
    PROTOTYPE._updateTitle = function(content, reposition) {
      if (this._update(content, this.elements.title, reposition) === FALSE) {
        this._removeTitle(FALSE);
      }
    };
    PROTOTYPE._createTitle = function() {
      var elements = this.elements, id = this._id + "-title";
      if (elements.titlebar) {
        this._removeTitle();
      }
      elements.titlebar = $("<div />", {
        "class": NAMESPACE + "-titlebar " + (this.options.style.widget ? createWidgetClass("header") : "")
      }).append(elements.title = $("<div />", {
        "id": id,
        "class": NAMESPACE + "-title",
        "aria-atomic": TRUE
      })).insertBefore(elements.content).delegate(".qtip-close", "mousedown keydown mouseup keyup mouseout", function(event) {
        $(this).toggleClass("ui-state-active ui-state-focus", event.type.substr(-4) === "down");
      }).delegate(".qtip-close", "mouseover mouseout", function(event) {
        $(this).toggleClass("ui-state-hover", event.type === "mouseover");
      });
      if (this.options.content.button) {
        this._createButton();
      }
    };
    PROTOTYPE._removeTitle = function(reposition) {
      var elements = this.elements;
      if (elements.title) {
        elements.titlebar.remove();
        elements.titlebar = elements.title = elements.button = NULL;
        if (reposition !== FALSE) {
          this.reposition();
        }
      }
    };
    PROTOTYPE._createPosClass = function(my) {
      return NAMESPACE + "-pos-" + (my || this.options.position.my).abbrev();
    };
    PROTOTYPE.reposition = function(event, effect) {
      if (!this.rendered || this.positioning || this.destroyed) {
        return this;
      }
      this.positioning = TRUE;
      var cache = this.cache, tooltip = this.tooltip, posOptions = this.options.position, target = posOptions.target, my = posOptions.my, at = posOptions.at, viewport = posOptions.viewport, container = posOptions.container, adjust = posOptions.adjust, method = adjust.method.split(" "), tooltipWidth = tooltip.outerWidth(FALSE), tooltipHeight = tooltip.outerHeight(FALSE), targetWidth = 0, targetHeight = 0, type = tooltip.css("position"), position = {
        left: 0,
        top: 0
      }, visible = tooltip[0].offsetWidth > 0, isScroll = event && event.type === "scroll", win = $(window2), doc = container[0].ownerDocument, mouse = this.mouse, pluginCalculations, offset, adjusted, newClass;
      if ($.isArray(target) && target.length === 2) {
        at = {
          x: LEFT,
          y: TOP
        };
        position = {
          left: target[0],
          top: target[1]
        };
      } else if (target === "mouse") {
        at = {
          x: LEFT,
          y: TOP
        };
        if ((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {
          event = cache.origin;
        } else if (!event || event && (event.type === "resize" || event.type === "scroll")) {
          event = cache.event;
        } else if (mouse && mouse.pageX) {
          event = mouse;
        }
        if (type !== "static") {
          position = container.offset();
        }
        if (doc.body.offsetWidth !== (window2.innerWidth || doc.documentElement.clientWidth)) {
          offset = $(document2.body).offset();
        }
        position = {
          left: event.pageX - position.left + (offset && offset.left || 0),
          top: event.pageY - position.top + (offset && offset.top || 0)
        };
        if (adjust.mouse && isScroll && mouse) {
          position.left -= (mouse.scrollX || 0) - win.scrollLeft();
          position.top -= (mouse.scrollY || 0) - win.scrollTop();
        }
      } else {
        if (target === "event") {
          if (event && event.target && event.type !== "scroll" && event.type !== "resize") {
            cache.target = $(event.target);
          } else if (!event.target) {
            cache.target = this.elements.target;
          }
        } else if (target !== "event") {
          cache.target = $(target.jquery ? target : this.elements.target);
        }
        target = cache.target;
        target = $(target).eq(0);
        if (target.length === 0) {
          return this;
        } else if (target[0] === document2 || target[0] === window2) {
          targetWidth = BROWSER.iOS ? window2.innerWidth : target.width();
          targetHeight = BROWSER.iOS ? window2.innerHeight : target.height();
          if (target[0] === window2) {
            position = {
              top: (viewport || target).scrollTop(),
              left: (viewport || target).scrollLeft()
            };
          }
        } else if (PLUGINS.imagemap && target.is("area")) {
          pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
        } else if (PLUGINS.svg && target && target[0].ownerSVGElement) {
          pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
        } else {
          targetWidth = target.outerWidth(FALSE);
          targetHeight = target.outerHeight(FALSE);
          position = target.offset();
        }
        if (pluginCalculations) {
          targetWidth = pluginCalculations.width;
          targetHeight = pluginCalculations.height;
          offset = pluginCalculations.offset;
          position = pluginCalculations.position;
        }
        position = this.reposition.offset(target, position, container);
        if (BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 || BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 || !BROWSER.iOS && type === "fixed") {
          position.left -= win.scrollLeft();
          position.top -= win.scrollTop();
        }
        if (!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {
          position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
          position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
        }
      }
      position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
      position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);
      if (PLUGINS.viewport) {
        adjusted = position.adjusted = PLUGINS.viewport(this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight);
        if (offset && adjusted.left) {
          position.left += offset.left;
        }
        if (offset && adjusted.top) {
          position.top += offset.top;
        }
        if (adjusted.my) {
          this.position.my = adjusted.my;
        }
      } else {
        position.adjusted = {
          left: 0,
          top: 0
        };
      }
      if (cache.posClass !== (newClass = this._createPosClass(this.position.my))) {
        cache.posClass = newClass;
        tooltip.removeClass(cache.posClass).addClass(newClass);
      }
      if (!this._trigger("move", [position, viewport.elem || viewport], event)) {
        return this;
      }
      delete position.adjusted;
      if (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === "mouse" || !$.isFunction(posOptions.effect)) {
        tooltip.css(position);
      } else if ($.isFunction(posOptions.effect)) {
        posOptions.effect.call(tooltip, this, $.extend({}, position));
        tooltip.queue(function(next) {
          $(this).css({
            opacity: "",
            height: ""
          });
          if (BROWSER.ie) {
            this.style.removeAttribute("filter");
          }
          next();
        });
      }
      this.positioning = FALSE;
      return this;
    };
    PROTOTYPE.reposition.offset = function(elem, pos, container) {
      if (!container[0]) {
        return pos;
      }
      var ownerDocument = $(elem[0].ownerDocument), quirks = !!BROWSER.ie && document2.compatMode !== "CSS1Compat", parent = container[0], scrolled, position, parentOffset, overflow;
      function scroll(e, i) {
        pos.left += i * e.scrollLeft();
        pos.top += i * e.scrollTop();
      }
      do {
        if ((position = $.css(parent, "position")) !== "static") {
          if (position === "fixed") {
            parentOffset = parent.getBoundingClientRect();
            scroll(ownerDocument, -1);
          } else {
            parentOffset = $(parent).position();
            parentOffset.left += parseFloat($.css(parent, "borderLeftWidth")) || 0;
            parentOffset.top += parseFloat($.css(parent, "borderTopWidth")) || 0;
          }
          pos.left -= parentOffset.left + (parseFloat($.css(parent, "marginLeft")) || 0);
          pos.top -= parentOffset.top + (parseFloat($.css(parent, "marginTop")) || 0);
          if (!scrolled && (overflow = $.css(parent, "overflow")) !== "hidden" && overflow !== "visible" && $.prop(parent, "tagName") !== "BODY") {
            scrolled = $(parent);
          }
        }
      } while (parent = parent.offsetParent);
      if (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
        scroll(scrolled, 1);
      }
      return pos;
    };
    var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
      corner = ("" + corner).replace(/([A-Z])/, " $1").replace(/middle/gi, CENTER).toLowerCase();
      this.x = (corner.match(/left|right/i) || corner.match(/center/) || ["inherit"])[0].toLowerCase();
      this.y = (corner.match(/top|bottom|center/i) || ["inherit"])[0].toLowerCase();
      this.forceY = !!forceY;
      var f = corner.charAt(0);
      this.precedance = f === "t" || f === "b" ? Y : X;
    }).prototype;
    C.invert = function(z, center) {
      this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
    };
    C.string = function(join) {
      var x = this.x, y = this.y;
      var result = x !== y ? x === "center" || y !== "center" && (this.precedance === Y || this.forceY) ? [y, x] : [x, y] : [x];
      return join !== false ? result.join(" ") : result;
    };
    C.abbrev = function() {
      var result = this.string(false);
      return result[0].charAt(0) + (result[1] && result[1].charAt(0) || "");
    };
    C.clone = function() {
      return new CORNER(this.string(), this.forceY);
    };
    PROTOTYPE.toggle = function(state, event) {
      var cache = this.cache, options2 = this.options, tooltip = this.tooltip;
      if (event) {
        if (/over|enter/.test(event.type) && cache.event && /out|leave/.test(cache.event.type) && options2.show.target.add(event.target).length === options2.show.target.length && tooltip.has(event.relatedTarget).length) {
          return this;
        }
        cache.event = $.event.fix(event);
      }
      this.waiting && !state && (this.hiddenDuringWait = TRUE);
      if (!this.rendered) {
        return state ? this.render(1) : this;
      } else if (this.destroyed || this.disabled) {
        return this;
      }
      var type = state ? "show" : "hide", opts = this.options[type], posOptions = this.options.position, contentOptions = this.options.content, width = this.tooltip.css("width"), visible = this.tooltip.is(":visible"), animate = state || opts.target.length === 1, sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target, identicalState, allow, after;
      if ((typeof state).search("boolean|number")) {
        state = !visible;
      }
      identicalState = !tooltip.is(":animated") && visible === state && sameTarget;
      allow = !identicalState ? !!this._trigger(type, [90]) : NULL;
      if (this.destroyed) {
        return this;
      }
      if (allow !== FALSE && state) {
        this.focus(event);
      }
      if (!allow || identicalState) {
        return this;
      }
      $.attr(tooltip[0], "aria-hidden", !!!state);
      if (state) {
        this.mouse && (cache.origin = $.event.fix(this.mouse));
        if ($.isFunction(contentOptions.text)) {
          this._updateContent(contentOptions.text, FALSE);
        }
        if ($.isFunction(contentOptions.title)) {
          this._updateTitle(contentOptions.title, FALSE);
        }
        if (!trackingBound && posOptions.target === "mouse" && posOptions.adjust.mouse) {
          $(document2).bind("mousemove." + NAMESPACE, this._storeMouse);
          trackingBound = TRUE;
        }
        if (!width) {
          tooltip.css("width", tooltip.outerWidth(FALSE));
        }
        this.reposition(event, arguments[2]);
        if (!width) {
          tooltip.css("width", "");
        }
        if (!!opts.solo) {
          (typeof opts.solo === "string" ? $(opts.solo) : $(SELECTOR, opts.solo)).not(tooltip).not(opts.target).qtip("hide", new $.Event("tooltipsolo"));
        }
      } else {
        clearTimeout(this.timers.show);
        delete cache.origin;
        if (trackingBound && !$(SELECTOR + '[tracking="true"]:visible', opts.solo).not(tooltip).length) {
          $(document2).unbind("mousemove." + NAMESPACE);
          trackingBound = FALSE;
        }
        this.blur(event);
      }
      after = $.proxy(function() {
        if (state) {
          if (BROWSER.ie) {
            tooltip[0].style.removeAttribute("filter");
          }
          tooltip.css("overflow", "");
          if ("string" === typeof opts.autofocus) {
            $(this.options.show.autofocus, tooltip).focus();
          }
          this.options.show.target.trigger("qtip-" + this.id + "-inactive");
        } else {
          tooltip.css({
            display: "",
            visibility: "",
            opacity: "",
            left: "",
            top: ""
          });
        }
        this._trigger(state ? "visible" : "hidden");
      }, this);
      if (opts.effect === FALSE || animate === FALSE) {
        tooltip[type]();
        after();
      } else if ($.isFunction(opts.effect)) {
        tooltip.stop(1, 1);
        opts.effect.call(tooltip, this);
        tooltip.queue("fx", function(n) {
          after();
          n();
        });
      } else {
        tooltip.fadeTo(90, state ? 1 : 0, after);
      }
      if (state) {
        opts.target.trigger("qtip-" + this.id + "-inactive");
      }
      return this;
    };
    PROTOTYPE.show = function(event) {
      return this.toggle(TRUE, event);
    };
    PROTOTYPE.hide = function(event) {
      return this.toggle(FALSE, event);
    };
    PROTOTYPE.focus = function(event) {
      if (!this.rendered || this.destroyed) {
        return this;
      }
      var qtips = $(SELECTOR), tooltip = this.tooltip, curIndex = parseInt(tooltip[0].style.zIndex, 10), newIndex = QTIP.zindex + qtips.length;
      if (!tooltip.hasClass(CLASS_FOCUS)) {
        if (this._trigger("focus", [newIndex], event)) {
          if (curIndex !== newIndex) {
            qtips.each(function() {
              if (this.style.zIndex > curIndex) {
                this.style.zIndex = this.style.zIndex - 1;
              }
            });
            qtips.filter("." + CLASS_FOCUS).qtip("blur", event);
          }
          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
        }
      }
      return this;
    };
    PROTOTYPE.blur = function(event) {
      if (!this.rendered || this.destroyed) {
        return this;
      }
      this.tooltip.removeClass(CLASS_FOCUS);
      this._trigger("blur", [this.tooltip.css("zIndex")], event);
      return this;
    };
    PROTOTYPE.disable = function(state) {
      if (this.destroyed) {
        return this;
      }
      if (state === "toggle") {
        state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
      } else if ("boolean" !== typeof state) {
        state = TRUE;
      }
      if (this.rendered) {
        this.tooltip.toggleClass(CLASS_DISABLED, state).attr("aria-disabled", state);
      }
      this.disabled = !!state;
      return this;
    };
    PROTOTYPE.enable = function() {
      return this.disable(FALSE);
    };
    PROTOTYPE._createButton = function() {
      var self2 = this, elements = this.elements, tooltip = elements.tooltip, button = this.options.content.button, isString2 = typeof button === "string", close = isString2 ? button : "Close tooltip";
      if (elements.button) {
        elements.button.remove();
      }
      if (button.jquery) {
        elements.button = button;
      } else {
        elements.button = $("<a />", {
          "class": "qtip-close " + (this.options.style.widget ? "" : NAMESPACE + "-icon"),
          "title": close,
          "aria-label": close
        }).prepend($("<span />", {
          "class": "ui-icon ui-icon-close",
          "html": "&times;"
        }));
      }
      elements.button.appendTo(elements.titlebar || tooltip).attr("role", "button").click(function(event) {
        if (!tooltip.hasClass(CLASS_DISABLED)) {
          self2.hide(event);
        }
        return FALSE;
      });
    };
    PROTOTYPE._updateButton = function(button) {
      if (!this.rendered) {
        return FALSE;
      }
      var elem = this.elements.button;
      if (button) {
        this._createButton();
      } else {
        elem.remove();
      }
    };
    function createWidgetClass(cls) {
      return WIDGET.concat("").join(cls ? "-" + cls + " " : " ");
    }
    PROTOTYPE._setWidget = function() {
      var on = this.options.style.widget, elements = this.elements, tooltip = elements.tooltip, disabled = tooltip.hasClass(CLASS_DISABLED);
      tooltip.removeClass(CLASS_DISABLED);
      CLASS_DISABLED = on ? "ui-state-disabled" : "qtip-disabled";
      tooltip.toggleClass(CLASS_DISABLED, disabled);
      tooltip.toggleClass("ui-helper-reset " + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);
      if (elements.content) {
        elements.content.toggleClass(createWidgetClass("content"), on);
      }
      if (elements.titlebar) {
        elements.titlebar.toggleClass(createWidgetClass("header"), on);
      }
      if (elements.button) {
        elements.button.toggleClass(NAMESPACE + "-icon", !on);
      }
    };
    function delay2(callback, duration) {
      if (duration > 0) {
        return setTimeout($.proxy(callback, this), duration);
      } else {
        callback.call(this);
      }
    }
    function showMethod(event) {
      if (this.tooltip.hasClass(CLASS_DISABLED)) {
        return;
      }
      clearTimeout(this.timers.show);
      clearTimeout(this.timers.hide);
      this.timers.show = delay2.call(this, function() {
        this.toggle(TRUE, event);
      }, this.options.show.delay);
    }
    function hideMethod(event) {
      if (this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) {
        return;
      }
      var relatedTarget = $(event.relatedTarget), ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0], ontoTarget = relatedTarget[0] === this.options.show.target[0];
      clearTimeout(this.timers.show);
      clearTimeout(this.timers.hide);
      if (this !== relatedTarget[0] && this.options.position.target === "mouse" && ontoTooltip || this.options.hide.fixed && /mouse(out|leave|move)/.test(event.type) && (ontoTooltip || ontoTarget)) {
        try {
          event.preventDefault();
          event.stopImmediatePropagation();
        } catch (e) {
        }
        return;
      }
      this.timers.hide = delay2.call(this, function() {
        this.toggle(FALSE, event);
      }, this.options.hide.delay, this);
    }
    function inactiveMethod(event) {
      if (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) {
        return;
      }
      clearTimeout(this.timers.inactive);
      this.timers.inactive = delay2.call(this, function() {
        this.hide(event);
      }, this.options.hide.inactive);
    }
    function repositionMethod(event) {
      if (this.rendered && this.tooltip[0].offsetWidth > 0) {
        this.reposition(event);
      }
    }
    PROTOTYPE._storeMouse = function(event) {
      (this.mouse = $.event.fix(event)).type = "mousemove";
      return this;
    };
    PROTOTYPE._bind = function(targets, events4, method, suffix, context) {
      if (!targets || !method || !events4.length) {
        return;
      }
      var ns = "." + this._id + (suffix ? "-" + suffix : "");
      $(targets).bind((events4.split ? events4 : events4.join(ns + " ")) + ns, $.proxy(method, context || this));
      return this;
    };
    PROTOTYPE._unbind = function(targets, suffix) {
      targets && $(targets).unbind("." + this._id + (suffix ? "-" + suffix : ""));
      return this;
    };
    function delegate(selector, events4, method) {
      $(document2.body).delegate(selector, (events4.split ? events4 : events4.join("." + NAMESPACE + " ")) + "." + NAMESPACE, function() {
        var api2 = QTIP.api[$.attr(this, ATTR_ID)];
        api2 && !api2.disabled && method.apply(api2, arguments);
      });
    }
    PROTOTYPE._trigger = function(type, args, event) {
      var callback = new $.Event("tooltip" + type);
      callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;
      this.triggering = type;
      this.tooltip.trigger(callback, [this].concat(args || []));
      this.triggering = FALSE;
      return !callback.isDefaultPrevented();
    };
    PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {
      var similarTargets = showTargets.filter(hideTargets).add(hideTargets.filter(showTargets)), toggleEvents = [];
      if (similarTargets.length) {
        $.each(hideEvents, function(i, type) {
          var showIndex = $.inArray(type, showEvents);
          showIndex > -1 && toggleEvents.push(showEvents.splice(showIndex, 1)[0]);
        });
        if (toggleEvents.length) {
          this._bind(similarTargets, toggleEvents, function(event) {
            var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
            (state ? hideCallback : showCallback).call(this, event);
          });
          showTargets = showTargets.not(similarTargets);
          hideTargets = hideTargets.not(similarTargets);
        }
      }
      this._bind(showTargets, showEvents, showCallback);
      this._bind(hideTargets, hideEvents, hideCallback);
    };
    PROTOTYPE._assignInitialEvents = function(event) {
      var options2 = this.options, showTarget = options2.show.target, hideTarget = options2.hide.target, showEvents = options2.show.event ? $.trim("" + options2.show.event).split(" ") : [], hideEvents = options2.hide.event ? $.trim("" + options2.hide.event).split(" ") : [];
      this._bind(this.elements.target, ["remove", "removeqtip"], function() {
        this.destroy(true);
      }, "destroy");
      if (/mouse(over|enter)/i.test(options2.show.event) && !/mouse(out|leave)/i.test(options2.hide.event)) {
        hideEvents.push("mouseleave");
      }
      this._bind(showTarget, "mousemove", function(moveEvent) {
        this._storeMouse(moveEvent);
        this.cache.onTarget = TRUE;
      });
      function hoverIntent(hoverEvent) {
        if (this.disabled || this.destroyed) {
          return FALSE;
        }
        this.cache.event = hoverEvent && $.event.fix(hoverEvent);
        this.cache.target = hoverEvent && $(hoverEvent.target);
        clearTimeout(this.timers.show);
        this.timers.show = delay2.call(this, function() {
          this.render(typeof hoverEvent === "object" || options2.show.ready);
        }, options2.prerender ? 0 : options2.show.delay);
      }
      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
        if (!this.timers) {
          return FALSE;
        }
        clearTimeout(this.timers.show);
      });
      if (options2.show.ready || options2.prerender) {
        hoverIntent.call(this, event);
      }
    };
    PROTOTYPE._assignEvents = function() {
      var self2 = this, options2 = this.options, posOptions = options2.position, tooltip = this.tooltip, showTarget = options2.show.target, hideTarget = options2.hide.target, containerTarget = posOptions.container, viewportTarget = posOptions.viewport, documentTarget = $(document2), windowTarget = $(window2), showEvents = options2.show.event ? $.trim("" + options2.show.event).split(" ") : [], hideEvents = options2.hide.event ? $.trim("" + options2.hide.event).split(" ") : [];
      $.each(options2.events, function(name, callback) {
        self2._bind(tooltip, name === "toggle" ? ["tooltipshow", "tooltiphide"] : ["tooltip" + name], callback, null, tooltip);
      });
      if (/mouse(out|leave)/i.test(options2.hide.event) && options2.hide.leave === "window") {
        this._bind(documentTarget, ["mouseout", "blur"], function(event) {
          if (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
            this.hide(event);
          }
        });
      }
      if (options2.hide.fixed) {
        hideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));
      } else if (/mouse(over|enter)/i.test(options2.show.event)) {
        this._bind(hideTarget, "mouseleave", function() {
          clearTimeout(this.timers.show);
        });
      }
      if (("" + options2.hide.event).indexOf("unfocus") > -1) {
        this._bind(containerTarget.closest("html"), ["mousedown", "touchstart"], function(event) {
          var elem = $(event.target), enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0, isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;
          if (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor && !this.target.has(elem[0]).length && enabled) {
            this.hide(event);
          }
        });
      }
      if ("number" === typeof options2.hide.inactive) {
        this._bind(showTarget, "qtip-" + this.id + "-inactive", inactiveMethod, "inactive");
        this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);
      }
      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);
      this._bind(showTarget.add(tooltip), "mousemove", function(event) {
        if ("number" === typeof options2.hide.distance) {
          var origin = this.cache.origin || {}, limit = this.options.hide.distance, abs = Math.abs;
          if (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
            this.hide(event);
          }
        }
        this._storeMouse(event);
      });
      if (posOptions.target === "mouse") {
        if (posOptions.adjust.mouse) {
          if (options2.hide.event) {
            this._bind(showTarget, ["mouseenter", "mouseleave"], function(event) {
              if (!this.cache) {
                return FALSE;
              }
              this.cache.onTarget = event.type === "mouseenter";
            });
          }
          this._bind(documentTarget, "mousemove", function(event) {
            if (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
              this.reposition(event);
            }
          });
        }
      }
      if (posOptions.adjust.resize || viewportTarget.length) {
        this._bind($.event.special.resize ? viewportTarget : windowTarget, "resize", repositionMethod);
      }
      if (posOptions.adjust.scroll) {
        this._bind(windowTarget.add(posOptions.container), "scroll", repositionMethod);
      }
    };
    PROTOTYPE._unassignEvents = function() {
      var options2 = this.options, showTargets = options2.show.target, hideTargets = options2.hide.target, targets = $.grep([
        this.elements.target[0],
        this.rendered && this.tooltip[0],
        options2.position.container[0],
        options2.position.viewport[0],
        options2.position.container.closest("html")[0],
        // unfocus
        window2,
        document2
      ], function(i) {
        return typeof i === "object";
      });
      if (showTargets && showTargets.toArray) {
        targets = targets.concat(showTargets.toArray());
      }
      if (hideTargets && hideTargets.toArray) {
        targets = targets.concat(hideTargets.toArray());
      }
      this._unbind(targets)._unbind(targets, "destroy")._unbind(targets, "inactive");
    };
    $(function() {
      delegate(SELECTOR, ["mouseenter", "mouseleave"], function(event) {
        var state = event.type === "mouseenter", tooltip = $(event.currentTarget), target = $(event.relatedTarget || event.target), options2 = this.options;
        if (state) {
          this.focus(event);
          tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
        } else {
          if (options2.position.target === "mouse" && options2.position.adjust.mouse && options2.hide.event && options2.show.target && !target.closest(options2.show.target[0]).length) {
            this.hide(event);
          }
        }
        tooltip.toggleClass(CLASS_HOVER, state);
      });
      delegate("[" + ATTR_ID + "]", INACTIVE_EVENTS, inactiveMethod);
    });
    function init(elem, id, opts) {
      var obj, posOptions, attr, config2, title, docBody = $(document2.body), newTarget = elem[0] === document2 ? docBody : elem, metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL, metadata5 = opts.metadata.type === "html5" && metadata ? metadata[opts.metadata.name] : NULL, html5 = elem.data(opts.metadata.name || "qtipopts");
      try {
        html5 = typeof html5 === "string" ? $.parseJSON(html5) : html5;
      } catch (e) {
      }
      config2 = $.extend(TRUE, {}, QTIP.defaults, opts, typeof html5 === "object" ? sanitizeOptions(html5) : NULL, sanitizeOptions(metadata5 || metadata));
      posOptions = config2.position;
      config2.id = id;
      if ("boolean" === typeof config2.content.text) {
        attr = elem.attr(config2.content.attr);
        if (config2.content.attr !== FALSE && attr) {
          config2.content.text = attr;
        } else {
          return FALSE;
        }
      }
      if (!posOptions.container.length) {
        posOptions.container = docBody;
      }
      if (posOptions.target === FALSE) {
        posOptions.target = newTarget;
      }
      if (config2.show.target === FALSE) {
        config2.show.target = newTarget;
      }
      if (config2.show.solo === TRUE) {
        config2.show.solo = posOptions.container.closest("body");
      }
      if (config2.hide.target === FALSE) {
        config2.hide.target = newTarget;
      }
      if (config2.position.viewport === TRUE) {
        config2.position.viewport = posOptions.container;
      }
      posOptions.container = posOptions.container.eq(0);
      posOptions.at = new CORNER(posOptions.at, TRUE);
      posOptions.my = new CORNER(posOptions.my);
      if (elem.data(NAMESPACE)) {
        if (config2.overwrite) {
          elem.qtip("destroy", true);
        } else if (config2.overwrite === FALSE) {
          return FALSE;
        }
      }
      elem.attr(ATTR_HAS, id);
      if (config2.suppress && (title = elem.attr("title"))) {
        elem.removeAttr("title").attr(oldtitle, title).attr("title", "");
      }
      obj = new QTip(elem, config2, id, !!attr);
      elem.data(NAMESPACE, obj);
      return obj;
    }
    QTIP = $.fn.qtip = function(options2, notation, newValue) {
      var command = ("" + options2).toLowerCase(), returned = NULL, args = $.makeArray(arguments).slice(1), event = args[args.length - 1], opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;
      if (!arguments.length && opts || command === "api") {
        return opts;
      } else if ("string" === typeof options2) {
        this.each(function() {
          var api2 = $.data(this, NAMESPACE);
          if (!api2) {
            return TRUE;
          }
          if (event && event.timeStamp) {
            api2.cache.event = event;
          }
          if (notation && (command === "option" || command === "options")) {
            if (newValue !== undefined$1 || $.isPlainObject(notation)) {
              api2.set(notation, newValue);
            } else {
              returned = api2.get(notation);
              return FALSE;
            }
          } else if (api2[command]) {
            api2[command].apply(api2, args);
          }
        });
        return returned !== NULL ? returned : this;
      } else if ("object" === typeof options2 || !arguments.length) {
        opts = sanitizeOptions($.extend(TRUE, {}, options2));
        return this.each(function(i) {
          var api2, id;
          id = $.isArray(opts.id) ? opts.id[i] : opts.id;
          id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;
          api2 = init($(this), id, opts);
          if (api2 === FALSE) {
            return TRUE;
          } else {
            QTIP.api[id] = api2;
          }
          $.each(PLUGINS, function() {
            if (this.initialize === "initialize") {
              this(api2);
            }
          });
          api2._assignInitialEvents(event);
        });
      }
    };
    $.qtip = QTip;
    QTIP.api = {};
    $.each({
      /* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
      attr: function(attr, val) {
        if (this.length) {
          var self2 = this[0], title = "title", api2 = $.data(self2, "qtip");
          if (attr === title && api2 && api2.options && "object" === typeof api2 && "object" === typeof api2.options && api2.options.suppress) {
            if (arguments.length < 2) {
              return $.attr(self2, oldtitle);
            }
            if (api2 && api2.options.content.attr === title && api2.cache.attr) {
              api2.set("content.text", val);
            }
            return this.attr(oldtitle, val);
          }
        }
        return $.fn["attr" + replaceSuffix].apply(this, arguments);
      },
      /* Allow clone to correctly retrieve cached title attributes */
      clone: function(keepData) {
        var elems = $.fn["clone" + replaceSuffix].apply(this, arguments);
        if (!keepData) {
          elems.filter("[" + oldtitle + "]").attr("title", function() {
            return $.attr(this, oldtitle);
          }).removeAttr(oldtitle);
        }
        return elems;
      }
    }, function(name, func) {
      if (!func || $.fn[name + replaceSuffix]) {
        return TRUE;
      }
      var old = $.fn[name + replaceSuffix] = $.fn[name];
      $.fn[name] = function() {
        return func.apply(this, arguments) || old.apply(this, arguments);
      };
    });
    if (!$.ui) {
      $["cleanData" + replaceSuffix] = $.cleanData;
      $.cleanData = function(elems) {
        for (var i = 0, elem; (elem = $(elems[i])).length; i++) {
          if (elem.attr(ATTR_HAS)) {
            try {
              elem.triggerHandler("removeqtip");
            } catch (e) {
            }
          }
        }
        $["cleanData" + replaceSuffix].apply(this, arguments);
      };
    }
    QTIP.version = "3.0.3-5-g";
    QTIP.nextid = 0;
    QTIP.inactiveEvents = INACTIVE_EVENTS;
    QTIP.zindex = 15e3;
    QTIP.defaults = {
      prerender: FALSE,
      id: FALSE,
      overwrite: TRUE,
      suppress: TRUE,
      content: {
        text: TRUE,
        attr: "title",
        title: FALSE,
        button: FALSE
      },
      position: {
        my: "top left",
        at: "bottom right",
        target: FALSE,
        container: FALSE,
        viewport: FALSE,
        adjust: {
          x: 0,
          y: 0,
          mouse: TRUE,
          scroll: TRUE,
          resize: TRUE,
          method: "flipinvert flipinvert"
        },
        effect: function(api2, pos) {
          $(this).animate(pos, {
            duration: 200,
            queue: FALSE
          });
        }
      },
      show: {
        target: FALSE,
        event: "mouseenter",
        effect: TRUE,
        delay: 90,
        solo: FALSE,
        ready: FALSE,
        autofocus: FALSE
      },
      hide: {
        target: FALSE,
        event: "mouseleave",
        effect: TRUE,
        delay: 0,
        fixed: FALSE,
        inactive: FALSE,
        leave: "window",
        distance: FALSE
      },
      style: {
        classes: "",
        widget: FALSE,
        width: FALSE,
        height: FALSE,
        def: TRUE
      },
      events: {
        render: NULL,
        move: NULL,
        show: NULL,
        hide: NULL,
        toggle: NULL,
        visible: NULL,
        hidden: NULL,
        focus: NULL,
        blur: NULL
      }
    };
    var TIP, createVML, SCALE, PIXEL_RATIO, BACKING_STORE_RATIO, MARGIN = "margin", BORDER = "border", COLOR = "color", BG_COLOR = "background-color", TRANSPARENT = "transparent", IMPORTANT = " !important", HASCANVAS = !!document2.createElement("canvas").getContext, INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;
    function camel(s) {
      return s.charAt(0).toUpperCase() + s.slice(1);
    }
    var cssProps = {}, cssPrefixes = ["Webkit", "O", "Moz", "ms"];
    function vendorCss(elem, prop) {
      var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), props6 = (prop + " " + cssPrefixes.join(ucProp + " ") + ucProp).split(" "), cur, val, i = 0;
      if (cssProps[prop]) {
        return elem.css(cssProps[prop]);
      }
      while (cur = props6[i++]) {
        if ((val = elem.css(cur)) !== undefined$1) {
          cssProps[prop] = cur;
          return val;
        }
      }
    }
    function intCss(elem, prop) {
      return Math.ceil(parseFloat(vendorCss(elem, prop)));
    }
    if (!HASCANVAS) {
      createVML = function(tag, props6, style) {
        return "<qtipvml:" + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" ' + (props6 || "") + ' style="behavior: url(#default#VML); ' + (style || "") + '" />';
      };
    } else {
      PIXEL_RATIO = window2.devicePixelRatio || 1;
      BACKING_STORE_RATIO = function() {
        var context = document2.createElement("canvas").getContext("2d");
        return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
      }();
      SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
    }
    function Tip(qtip, options2) {
      this._ns = "tip";
      this.options = options2;
      this.offset = options2.offset;
      this.size = [options2.width, options2.height];
      this.qtip = qtip;
      this.init(qtip);
    }
    $.extend(Tip.prototype, {
      init: function(qtip) {
        var context, tip;
        tip = this.element = qtip.elements.tip = $("<div />", {
          "class": NAMESPACE + "-tip"
        }).prependTo(qtip.tooltip);
        if (HASCANVAS) {
          context = $("<canvas />").appendTo(this.element)[0].getContext("2d");
          context.lineJoin = "miter";
          context.miterLimit = 1e5;
          context.save();
        } else {
          context = createVML("shape", 'coordorigin="0,0"', "position:absolute;");
          this.element.html(context + context);
          qtip._bind($("*", tip).add(tip), ["click", "mousedown"], function(event) {
            event.stopPropagation();
          }, this._ns);
        }
        qtip._bind(qtip.tooltip, "tooltipmove", this.reposition, this._ns, this);
        this.create();
      },
      _swapDimensions: function() {
        this.size[0] = this.options.height;
        this.size[1] = this.options.width;
      },
      _resetDimensions: function() {
        this.size[0] = this.options.width;
        this.size[1] = this.options.height;
      },
      _useTitle: function(corner) {
        var titlebar = this.qtip.elements.titlebar;
        return titlebar && (corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE));
      },
      _parseCorner: function(corner) {
        var my = this.qtip.options.position.my;
        if (corner === FALSE || my === FALSE) {
          corner = FALSE;
        } else if (corner === TRUE) {
          corner = new CORNER(my.string());
        } else if (!corner.string) {
          corner = new CORNER(corner);
          corner.fixed = TRUE;
        }
        return corner;
      },
      _parseWidth: function(corner, side, use) {
        var elements = this.qtip.elements, prop = BORDER + camel(side) + "Width";
        return (use ? intCss(use, prop) : intCss(elements.content, prop) || intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop)) || 0;
      },
      _parseRadius: function(corner) {
        var elements = this.qtip.elements, prop = BORDER + camel(corner.y) + camel(corner.x) + "Radius";
        return BROWSER.ie < 9 ? 0 : intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop) || 0;
      },
      _invalidColour: function(elem, prop, compare) {
        var val = elem.css(prop);
        return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;
      },
      _parseColours: function(corner) {
        var elements = this.qtip.elements, tip = this.element.css("cssText", ""), borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR), colorElem = this._useTitle(corner) && elements.titlebar || elements.content, css = this._invalidColour, color = [];
        color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);
        color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);
        $("*", tip).add(tip).css("cssText", BG_COLOR + ":" + TRANSPARENT + IMPORTANT + ";" + BORDER + ":0" + IMPORTANT + ";");
        return color;
      },
      _calculateSize: function(corner) {
        var y = corner.precedance === Y, width = this.options.width, height = this.options.height, isCenter = corner.abbrev() === "c", base2 = (y ? width : height) * (isCenter ? 0.5 : 1), pow = Math.pow, round = Math.round, bigHyp, ratio, result, smallHyp = Math.sqrt(pow(base2, 2) + pow(height, 2)), hyp = [this.border / base2 * smallHyp, this.border / height * smallHyp];
        hyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));
        hyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));
        bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
        ratio = bigHyp / smallHyp;
        result = [round(ratio * width), round(ratio * height)];
        return y ? result : result.reverse();
      },
      // Tip coordinates calculator
      _calculateTip: function(corner, size, scale) {
        scale = scale || 1;
        size = size || this.size;
        var width = size[0] * scale, height = size[1] * scale, width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2), tips = {
          br: [0, 0, width, height, width, 0],
          bl: [0, 0, width, 0, 0, height],
          tr: [0, height, width, 0, width, height],
          tl: [0, 0, 0, height, width, height],
          tc: [0, height, width2, 0, width, height],
          bc: [0, 0, width, 0, width2, height],
          rc: [0, 0, width, height2, 0, height],
          lc: [width, 0, width, height, 0, height2]
        };
        tips.lt = tips.br;
        tips.rt = tips.bl;
        tips.lb = tips.tr;
        tips.rb = tips.tl;
        return tips[corner.abbrev()];
      },
      // Tip coordinates drawer (canvas)
      _drawCoords: function(context, coords) {
        context.beginPath();
        context.moveTo(coords[0], coords[1]);
        context.lineTo(coords[2], coords[3]);
        context.lineTo(coords[4], coords[5]);
        context.closePath();
      },
      create: function() {
        var c2 = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);
        this.enabled = !!this.corner && this.corner.abbrev() !== "c";
        if (this.enabled) {
          this.qtip.cache.corner = c2.clone();
          this.update();
        }
        this.element.toggle(this.enabled);
        return this.corner;
      },
      update: function(corner, position) {
        if (!this.enabled) {
          return this;
        }
        var elements = this.qtip.elements, tip = this.element, inner = tip.children(), options2 = this.options, curSize = this.size, mimic = options2.mimic, round = Math.round, color, precedance, context, coords, bigCoords, translate, newSize, border;
        if (!corner) {
          corner = this.qtip.cache.corner || this.corner;
        }
        if (mimic === FALSE) {
          mimic = corner;
        } else {
          mimic = new CORNER(mimic);
          mimic.precedance = corner.precedance;
          if (mimic.x === "inherit") {
            mimic.x = corner.x;
          } else if (mimic.y === "inherit") {
            mimic.y = corner.y;
          } else if (mimic.x === mimic.y) {
            mimic[corner.precedance] = corner[corner.precedance];
          }
        }
        precedance = mimic.precedance;
        if (corner.precedance === X) {
          this._swapDimensions();
        } else {
          this._resetDimensions();
        }
        color = this.color = this._parseColours(corner);
        if (color[1] !== TRANSPARENT) {
          border = this.border = this._parseWidth(corner, corner[corner.precedance]);
          if (options2.border && border < 1 && !INVALID.test(color[1])) {
            color[0] = color[1];
          }
          this.border = border = options2.border !== TRUE ? options2.border : border;
        } else {
          this.border = border = 0;
        }
        newSize = this.size = this._calculateSize(corner);
        tip.css({
          width: newSize[0],
          height: newSize[1],
          lineHeight: newSize[1] + "px"
        });
        if (corner.precedance === Y) {
          translate = [round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2), round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)];
        } else {
          translate = [round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0), round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)];
        }
        if (HASCANVAS) {
          context = inner[0].getContext("2d");
          context.restore();
          context.save();
          context.clearRect(0, 0, 6e3, 6e3);
          coords = this._calculateTip(mimic, curSize, SCALE);
          bigCoords = this._calculateTip(mimic, this.size, SCALE);
          inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
          inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);
          this._drawCoords(context, bigCoords);
          context.fillStyle = color[1];
          context.fill();
          context.translate(translate[0] * SCALE, translate[1] * SCALE);
          this._drawCoords(context, coords);
          context.fillStyle = color[0];
          context.fill();
        } else {
          coords = this._calculateTip(mimic);
          coords = "m" + coords[0] + "," + coords[1] + " l" + coords[2] + "," + coords[3] + " " + coords[4] + "," + coords[5] + " xe";
          translate[2] = border && /^(r|b)/i.test(corner.string()) ? BROWSER.ie === 8 ? 2 : 1 : 0;
          inner.css({
            coordsize: newSize[0] + border + " " + newSize[1] + border,
            antialias: "" + (mimic.string().indexOf(CENTER) > -1),
            left: translate[0] - translate[2] * Number(precedance === X),
            top: translate[1] - translate[2] * Number(precedance === Y),
            width: newSize[0] + border,
            height: newSize[1] + border
          }).each(function(i) {
            var $this = $(this);
            $this[$this.prop ? "prop" : "attr"]({
              coordsize: newSize[0] + border + " " + newSize[1] + border,
              path: coords,
              fillcolor: color[0],
              filled: !!i,
              stroked: !i
            }).toggle(!!(border || i));
            !i && $this.html(createVML("stroke", 'weight="' + border * 2 + 'px" color="' + color[1] + '" miterlimit="1000" joinstyle="miter"'));
          });
        }
        window2.opera && setTimeout(function() {
          elements.tip.css({
            display: "inline-block",
            visibility: "visible"
          });
        }, 1);
        if (position !== FALSE) {
          this.calculate(corner, newSize);
        }
      },
      calculate: function(corner, size) {
        if (!this.enabled) {
          return FALSE;
        }
        var self2 = this, elements = this.qtip.elements, tip = this.element, userOffset = this.options.offset, position = {}, precedance, corners;
        corner = corner || this.corner;
        precedance = corner.precedance;
        size = size || this._calculateSize(corner);
        corners = [corner.x, corner.y];
        if (precedance === X) {
          corners.reverse();
        }
        $.each(corners, function(i, side) {
          var b2, bc, br;
          if (side === CENTER) {
            b2 = precedance === Y ? LEFT : TOP;
            position[b2] = "50%";
            position[MARGIN + "-" + b2] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;
          } else {
            b2 = self2._parseWidth(corner, side, elements.tooltip);
            bc = self2._parseWidth(corner, side, elements.content);
            br = self2._parseRadius(corner);
            position[side] = Math.max(-self2.border, i ? bc : userOffset + (br > b2 ? br : -b2));
          }
        });
        position[corner[precedance]] -= size[precedance === X ? 0 : 1];
        tip.css({
          margin: "",
          top: "",
          bottom: "",
          left: "",
          right: ""
        }).css(position);
        return position;
      },
      reposition: function(event, api2, pos) {
        if (!this.enabled) {
          return;
        }
        var cache = api2.cache, newCorner = this.corner.clone(), adjust = pos.adjusted, method = api2.options.position.adjust.method.split(" "), horizontal = method[0], vertical = method[1] || method[0], shift = {
          left: FALSE,
          top: FALSE,
          x: 0,
          y: 0
        }, offset, css = {}, props6;
        function shiftflip(direction, precedance, popposite, side, opposite) {
          if (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
            newCorner.precedance = newCorner.precedance === X ? Y : X;
          } else if (direction !== SHIFT && adjust[side]) {
            newCorner[precedance] = newCorner[precedance] === CENTER ? adjust[side] > 0 ? side : opposite : newCorner[precedance] === side ? opposite : side;
          }
        }
        function shiftonly(xy, side, opposite) {
          if (newCorner[xy] === CENTER) {
            css[MARGIN + "-" + side] = shift[xy] = offset[MARGIN + "-" + side] - adjust[side];
          } else {
            props6 = offset[opposite] !== undefined$1 ? [adjust[side], -offset[side]] : [-adjust[side], offset[side]];
            if ((shift[xy] = Math.max(props6[0], props6[1])) > props6[0]) {
              pos[side] -= adjust[side];
              shift[side] = FALSE;
            }
            css[offset[opposite] !== undefined$1 ? opposite : side] = shift[xy];
          }
        }
        if (this.corner.fixed !== TRUE) {
          shiftflip(horizontal, X, Y, LEFT, RIGHT);
          shiftflip(vertical, Y, X, TOP, BOTTOM);
          if (newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {
            this.update(newCorner, FALSE);
          }
        }
        offset = this.calculate(newCorner);
        if (offset.right !== undefined$1) {
          offset.left = -offset.right;
        }
        if (offset.bottom !== undefined$1) {
          offset.top = -offset.bottom;
        }
        offset.user = this.offset;
        shift.left = horizontal === SHIFT && !!adjust.left;
        if (shift.left) {
          shiftonly(X, LEFT, RIGHT);
        }
        shift.top = vertical === SHIFT && !!adjust.top;
        if (shift.top) {
          shiftonly(Y, TOP, BOTTOM);
        }
        this.element.css(css).toggle(!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x));
        pos.left -= offset.left.charAt ? offset.user : horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
        pos.top -= offset.top.charAt ? offset.user : vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;
        cache.cornerLeft = adjust.left;
        cache.cornerTop = adjust.top;
        cache.corner = newCorner.clone();
      },
      destroy: function() {
        this.qtip._unbind(this.qtip.tooltip, this._ns);
        if (this.qtip.elements.tip) {
          this.qtip.elements.tip.find("*").remove().end().remove();
        }
      }
    });
    TIP = PLUGINS.tip = function(api2) {
      return new Tip(api2, api2.options.style.tip);
    };
    TIP.initialize = "render";
    TIP.sanitize = function(options2) {
      if (options2.style && "tip" in options2.style) {
        var opts = options2.style.tip;
        if (typeof opts !== "object") {
          opts = options2.style.tip = {
            corner: opts
          };
        }
        if (!/string|boolean/i.test(typeof opts.corner)) {
          opts.corner = TRUE;
        }
      }
    };
    CHECKS.tip = {
      "^position.my|style.tip.(corner|mimic|border)$": function() {
        this.create();
        this.qtip.reposition();
      },
      "^style.tip.(height|width)$": function(obj) {
        this.size = [obj.width, obj.height];
        this.update();
        this.qtip.reposition();
      },
      "^content.title|style.(classes|widget)$": function() {
        this.update();
      }
    };
    $.extend(TRUE, QTIP.defaults, {
      style: {
        tip: {
          corner: TRUE,
          mimic: FALSE,
          width: 6,
          height: 6,
          border: TRUE,
          offset: 0
        }
      }
    });
    var MODAL, OVERLAY, MODALCLASS = "qtip-modal", MODALSELECTOR = "." + MODALCLASS;
    OVERLAY = function() {
      var self2 = this, focusableElems = {}, current, prevState, elem;
      function focusable(element) {
        if ($.expr[":"].focusable) {
          return $.expr[":"].focusable;
        }
        var isTabIndexNotNaN = !isNaN($.attr(element, "tabindex")), nodeName = element.nodeName && element.nodeName.toLowerCase(), map, mapName, img2;
        if ("area" === nodeName) {
          map = element.parentNode;
          mapName = map.name;
          if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
            return false;
          }
          img2 = $("img[usemap=#" + mapName + "]")[0];
          return !!img2 && img2.is(":visible");
        }
        return /input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN;
      }
      function focusInputs(blurElems) {
        if (focusableElems.length < 1 && blurElems.length) {
          blurElems.not("body").blur();
        } else {
          focusableElems.first().focus();
        }
      }
      function stealFocus(event) {
        if (!elem.is(":visible")) {
          return;
        }
        var target = $(event.target), tooltip = current.tooltip, container = target.closest(SELECTOR), targetOnTop;
        targetOnTop = container.length < 1 ? FALSE : parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);
        if (!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {
          focusInputs(target);
        }
      }
      $.extend(self2, {
        init: function() {
          elem = self2.elem = $("<div />", {
            id: "qtip-overlay",
            html: "<div></div>",
            mousedown: function() {
              return FALSE;
            }
          }).hide();
          $(document2.body).bind("focusin" + MODALSELECTOR, stealFocus);
          $(document2).bind("keydown" + MODALSELECTOR, function(event) {
            if (current && current.options.show.modal.escape && event.keyCode === 27) {
              current.hide(event);
            }
          });
          elem.bind("click" + MODALSELECTOR, function(event) {
            if (current && current.options.show.modal.blur) {
              current.hide(event);
            }
          });
          return self2;
        },
        update: function(api2) {
          current = api2;
          if (api2.options.show.modal.stealfocus !== FALSE) {
            focusableElems = api2.tooltip.find("*").filter(function() {
              return focusable(this);
            });
          } else {
            focusableElems = [];
          }
        },
        toggle: function(api2, state, duration) {
          var tooltip = api2.tooltip, options2 = api2.options.show.modal, effect = options2.effect, type = state ? "show" : "hide", visible = elem.is(":visible"), visibleModals = $(MODALSELECTOR).filter(":visible:not(:animated)").not(tooltip);
          self2.update(api2);
          if (state && options2.stealfocus !== FALSE) {
            focusInputs($(":focus"));
          }
          elem.toggleClass("blurs", options2.blur);
          if (state) {
            elem.appendTo(document2.body);
          }
          if (elem.is(":animated") && visible === state && prevState !== FALSE || !state && visibleModals.length) {
            return self2;
          }
          elem.stop(TRUE, FALSE);
          if ($.isFunction(effect)) {
            effect.call(elem, state);
          } else if (effect === FALSE) {
            elem[type]();
          } else {
            elem.fadeTo(parseInt(duration, 10) || 90, state ? 1 : 0, function() {
              if (!state) {
                elem.hide();
              }
            });
          }
          if (!state) {
            elem.queue(function(next) {
              elem.css({
                left: "",
                top: ""
              });
              if (!$(MODALSELECTOR).length) {
                elem.detach();
              }
              next();
            });
          }
          prevState = state;
          if (current.destroyed) {
            current = NULL;
          }
          return self2;
        }
      });
      self2.init();
    };
    OVERLAY = new OVERLAY();
    function Modal(api2, options2) {
      this.options = options2;
      this._ns = "-modal";
      this.qtip = api2;
      this.init(api2);
    }
    $.extend(Modal.prototype, {
      init: function(qtip) {
        var tooltip = qtip.tooltip;
        if (!this.options.on) {
          return this;
        }
        qtip.elements.overlay = OVERLAY.elem;
        tooltip.addClass(MODALCLASS).css("z-index", QTIP.modal_zindex + $(MODALSELECTOR).length);
        qtip._bind(tooltip, ["tooltipshow", "tooltiphide"], function(event, api2, duration) {
          var oEvent = event.originalEvent;
          if (event.target === tooltip[0]) {
            if (oEvent && event.type === "tooltiphide" && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {
              try {
                event.preventDefault();
              } catch (e) {
              }
            } else if (!oEvent || oEvent && oEvent.type !== "tooltipsolo") {
              this.toggle(event, event.type === "tooltipshow", duration);
            }
          }
        }, this._ns, this);
        qtip._bind(tooltip, "tooltipfocus", function(event, api2) {
          if (event.isDefaultPrevented() || event.target !== tooltip[0]) {
            return;
          }
          var qtips = $(MODALSELECTOR), newIndex = QTIP.modal_zindex + qtips.length, curIndex = parseInt(tooltip[0].style.zIndex, 10);
          OVERLAY.elem[0].style.zIndex = newIndex - 1;
          qtips.each(function() {
            if (this.style.zIndex > curIndex) {
              this.style.zIndex -= 1;
            }
          });
          qtips.filter("." + CLASS_FOCUS).qtip("blur", event.originalEvent);
          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
          OVERLAY.update(api2);
          try {
            event.preventDefault();
          } catch (e) {
          }
        }, this._ns, this);
        qtip._bind(tooltip, "tooltiphide", function(event) {
          if (event.target === tooltip[0]) {
            $(MODALSELECTOR).filter(":visible").not(tooltip).last().qtip("focus", event);
          }
        }, this._ns, this);
      },
      toggle: function(event, state, duration) {
        if (event && event.isDefaultPrevented()) {
          return this;
        }
        OVERLAY.toggle(this.qtip, !!state, duration);
      },
      destroy: function() {
        this.qtip.tooltip.removeClass(MODALCLASS);
        this.qtip._unbind(this.qtip.tooltip, this._ns);
        OVERLAY.toggle(this.qtip, FALSE);
        delete this.qtip.elements.overlay;
      }
    });
    MODAL = PLUGINS.modal = function(api2) {
      return new Modal(api2, api2.options.show.modal);
    };
    MODAL.sanitize = function(opts) {
      if (opts.show) {
        if (typeof opts.show.modal !== "object") {
          opts.show.modal = {
            on: !!opts.show.modal
          };
        } else if (typeof opts.show.modal.on === "undefined") {
          opts.show.modal.on = TRUE;
        }
      }
    };
    QTIP.modal_zindex = QTIP.zindex - 200;
    MODAL.initialize = "render";
    CHECKS.modal = {
      "^show.modal.(on|blur)$": function() {
        this.destroy();
        this.init();
        this.qtip.elems.overlay.toggle(this.qtip.tooltip[0].offsetWidth > 0);
      }
    };
    $.extend(TRUE, QTIP.defaults, {
      show: {
        modal: {
          on: FALSE,
          effect: TRUE,
          blur: TRUE,
          stealfocus: TRUE,
          escape: TRUE
        }
      }
    });
    PLUGINS.viewport = function(api2, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight) {
      var target = posOptions.target, tooltip = api2.elements.tooltip, my = posOptions.my, at = posOptions.at, adjust = posOptions.adjust, method = adjust.method.split(" "), methodX = method[0], methodY = method[1] || method[0], viewport = posOptions.viewport, container = posOptions.container, adjusted = {
        left: 0,
        top: 0
      }, fixed, newMy, containerOffset, containerStatic, viewportWidth, viewportHeight, viewportScroll, viewportOffset;
      if (!viewport.jquery || target[0] === window2 || target[0] === document2.body || adjust.method === "none") {
        return adjusted;
      }
      containerOffset = container.offset() || adjusted;
      containerStatic = container.css("position") === "static";
      fixed = tooltip.css("position") === "fixed";
      viewportWidth = viewport[0] === window2 ? viewport.width() : viewport.outerWidth(FALSE);
      viewportHeight = viewport[0] === window2 ? viewport.height() : viewport.outerHeight(FALSE);
      viewportScroll = {
        left: fixed ? 0 : viewport.scrollLeft(),
        top: fixed ? 0 : viewport.scrollTop()
      };
      viewportOffset = viewport.offset() || adjusted;
      function calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength2, elemLength) {
        var initialPos = position[side1], mySide = my[side], atSide = at[side], isShift = type === SHIFT, myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2, atLength = atSide === side1 ? targetLength2 : atSide === side2 ? -targetLength2 : -targetLength2 / 2, sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]), overflow1 = sideOffset - initialPos, overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset, offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength2 / 2 : 0);
        if (isShift) {
          offset = (mySide === side1 ? 1 : -1) * myLength;
          position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
          position[side1] = Math.max(-containerOffset[side1] + viewportOffset[side1], initialPos - offset, Math.min(
            Math.max(-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight), initialPos + offset),
            position[side1],
            // Make sure we don't adjust complete off the element when using 'center'
            mySide === "center" ? initialPos - myLength : 1e9
          ));
        } else {
          adjustment *= type === FLIPINVERT ? 2 : 0;
          if (overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
            position[side1] -= offset + adjustment;
            newMy.invert(side, side1);
          } else if (overflow2 > 0 && (mySide !== side2 || overflow1 > 0)) {
            position[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;
            newMy.invert(side, side2);
          }
          if (position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {
            position[side1] = initialPos;
            newMy = my.clone();
          }
        }
        return position[side1] - initialPos;
      }
      if (methodX !== "shift" || methodY !== "shift") {
        newMy = my.clone();
      }
      adjusted = {
        left: methodX !== "none" ? calculate(X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth) : 0,
        top: methodY !== "none" ? calculate(Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight) : 0,
        my: newMy
      };
      return adjusted;
    };
    PLUGINS.polys = {
      // POLY area coordinate calculator
      //	Special thanks to Ed Cradock for helping out with this.
      //	Uses a binary search algorithm to find suitable coordinates.
      polygon: function(baseCoords, corner) {
        var result = {
          width: 0,
          height: 0,
          position: {
            top: 1e10,
            right: 0,
            bottom: 0,
            left: 1e10
          },
          adjustable: FALSE
        }, i = 0, next, coords = [], compareX = 1, compareY = 1, realX = 0, realY = 0, newWidth, newHeight;
        i = baseCoords.length;
        while (i--) {
          next = [parseInt(baseCoords[--i], 10), parseInt(baseCoords[i + 1], 10)];
          if (next[0] > result.position.right) {
            result.position.right = next[0];
          }
          if (next[0] < result.position.left) {
            result.position.left = next[0];
          }
          if (next[1] > result.position.bottom) {
            result.position.bottom = next[1];
          }
          if (next[1] < result.position.top) {
            result.position.top = next[1];
          }
          coords.push(next);
        }
        newWidth = result.width = Math.abs(result.position.right - result.position.left);
        newHeight = result.height = Math.abs(result.position.bottom - result.position.top);
        if (corner.abbrev() === "c") {
          result.position = {
            left: result.position.left + result.width / 2,
            top: result.position.top + result.height / 2
          };
        } else {
          while (newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0) {
            newWidth = Math.floor(newWidth / 2);
            newHeight = Math.floor(newHeight / 2);
            if (corner.x === LEFT) {
              compareX = newWidth;
            } else if (corner.x === RIGHT) {
              compareX = result.width - newWidth;
            } else {
              compareX += Math.floor(newWidth / 2);
            }
            if (corner.y === TOP) {
              compareY = newHeight;
            } else if (corner.y === BOTTOM) {
              compareY = result.height - newHeight;
            } else {
              compareY += Math.floor(newHeight / 2);
            }
            i = coords.length;
            while (i--) {
              if (coords.length < 2) {
                break;
              }
              realX = coords[i][0] - result.position.left;
              realY = coords[i][1] - result.position.top;
              if (corner.x === LEFT && realX >= compareX || corner.x === RIGHT && realX <= compareX || corner.x === CENTER && (realX < compareX || realX > result.width - compareX) || corner.y === TOP && realY >= compareY || corner.y === BOTTOM && realY <= compareY || corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {
                coords.splice(i, 1);
              }
            }
          }
          result.position = {
            left: coords[0][0],
            top: coords[0][1]
          };
        }
        return result;
      },
      rect: function(ax, ay, bx, by) {
        return {
          width: Math.abs(bx - ax),
          height: Math.abs(by - ay),
          position: {
            left: Math.min(ax, bx),
            top: Math.min(ay, by)
          }
        };
      },
      _angles: {
        tc: 3 / 2,
        tr: 7 / 4,
        tl: 5 / 4,
        bc: 1 / 2,
        br: 1 / 4,
        bl: 3 / 4,
        rc: 2,
        lc: 1,
        c: 0
      },
      ellipse: function(cx, cy, rx, ry, corner) {
        var c2 = PLUGINS.polys._angles[corner.abbrev()], rxc = c2 === 0 ? 0 : rx * Math.cos(c2 * Math.PI), rys = ry * Math.sin(c2 * Math.PI);
        return {
          width: rx * 2 - Math.abs(rxc),
          height: ry * 2 - Math.abs(rys),
          position: {
            left: cx + rxc,
            top: cy + rys
          },
          adjustable: FALSE
        };
      },
      circle: function(cx, cy, r, corner) {
        return PLUGINS.polys.ellipse(cx, cy, r, r, corner);
      }
    };
    PLUGINS.svg = function(api2, svg, corner) {
      var elem = svg[0], root = $(elem.ownerSVGElement), ownerDocument = elem.ownerDocument, strokeWidth2 = (parseInt(svg.css("stroke-width"), 10) || 0) / 2, frameOffset, mtx, transformed, len, next, i, points, result, position;
      while (!elem.getBBox) {
        elem = elem.parentNode;
      }
      if (!elem.getBBox || !elem.parentNode) {
        return FALSE;
      }
      switch (elem.nodeName) {
        case "ellipse":
        case "circle":
          result = PLUGINS.polys.ellipse(elem.cx.baseVal.value, elem.cy.baseVal.value, (elem.rx || elem.r).baseVal.value + strokeWidth2, (elem.ry || elem.r).baseVal.value + strokeWidth2, corner);
          break;
        case "line":
        case "polygon":
        case "polyline":
          points = elem.points || [{
            x: elem.x1.baseVal.value,
            y: elem.y1.baseVal.value
          }, {
            x: elem.x2.baseVal.value,
            y: elem.y2.baseVal.value
          }];
          for (result = [], i = -1, len = points.numberOfItems || points.length; ++i < len; ) {
            next = points.getItem ? points.getItem(i) : points[i];
            result.push.apply(result, [next.x, next.y]);
          }
          result = PLUGINS.polys.polygon(result, corner);
          break;
        default:
          result = elem.getBBox();
          result = {
            width: result.width,
            height: result.height,
            position: {
              left: result.x,
              top: result.y
            }
          };
          break;
      }
      position = result.position;
      root = root[0];
      if (root.createSVGPoint) {
        mtx = elem.getScreenCTM();
        points = root.createSVGPoint();
        points.x = position.left;
        points.y = position.top;
        transformed = points.matrixTransform(mtx);
        position.left = transformed.x;
        position.top = transformed.y;
      }
      if (ownerDocument !== document2 && api2.position.target !== "mouse") {
        frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();
        if (frameOffset) {
          position.left += frameOffset.left;
          position.top += frameOffset.top;
        }
      }
      ownerDocument = $(ownerDocument);
      position.left += ownerDocument.scrollLeft();
      position.top += ownerDocument.scrollTop();
      return result;
    };
    PLUGINS.imagemap = function(api2, area, corner) {
      if (!area.jquery) {
        area = $(area);
      }
      var shape = (area.attr("shape") || "rect").toLowerCase().replace("poly", "polygon"), image = $('img[usemap="#' + area.parent("map").attr("name") + '"]'), coordsString = $.trim(area.attr("coords")), coordsArray = coordsString.replace(/,$/, "").split(","), imageOffset, coords, i, result, len;
      if (!image.length) {
        return FALSE;
      }
      if (shape === "polygon") {
        result = PLUGINS.polys.polygon(coordsArray, corner);
      } else if (PLUGINS.polys[shape]) {
        for (i = -1, len = coordsArray.length, coords = []; ++i < len; ) {
          coords.push(parseInt(coordsArray[i], 10));
        }
        result = PLUGINS.polys[shape].apply(this, coords.concat(corner));
      } else {
        return FALSE;
      }
      imageOffset = image.offset();
      imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);
      imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);
      result.position.left += imageOffset.left;
      result.position.top += imageOffset.top;
      return result;
    };
    var IE6, BGIFRAME = `<iframe class="qtip-bgiframe" frameborder="0" tabindex="-1" src="javascript:'';"  style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>`;
    function Ie6(api2) {
      this._ns = "ie6";
      this.qtip = api2;
      this.init(api2);
    }
    $.extend(Ie6.prototype, {
      _scroll: function() {
        var overlay = this.qtip.elements.overlay;
        overlay && (overlay[0].style.top = $(window2).scrollTop() + "px");
      },
      init: function(qtip) {
        var tooltip = qtip.tooltip;
        if ($("select, object").length < 1) {
          this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);
          qtip._bind(tooltip, "tooltipmove", this.adjustBGIFrame, this._ns, this);
        }
        this.redrawContainer = $("<div/>", {
          id: NAMESPACE + "-rcontainer"
        }).appendTo(document2.body);
        if (qtip.elements.overlay && qtip.elements.overlay.addClass("qtipmodal-ie6fix")) {
          qtip._bind(window2, ["scroll", "resize"], this._scroll, this._ns, this);
          qtip._bind(tooltip, ["tooltipshow"], this._scroll, this._ns, this);
        }
        this.redraw();
      },
      adjustBGIFrame: function() {
        var tooltip = this.qtip.tooltip, dimensions = {
          height: tooltip.outerHeight(FALSE),
          width: tooltip.outerWidth(FALSE)
        }, plugin = this.qtip.plugins.tip, tip = this.qtip.elements.tip, tipAdjust, offset;
        offset = parseInt(tooltip.css("borderLeftWidth"), 10) || 0;
        offset = {
          left: -offset,
          top: -offset
        };
        if (plugin && tip) {
          tipAdjust = plugin.corner.precedance === "x" ? [WIDTH, LEFT] : [HEIGHT, TOP];
          offset[tipAdjust[1]] -= tip[tipAdjust[0]]();
        }
        this.bgiframe.css(offset).css(dimensions);
      },
      // Max/min width simulator function
      redraw: function() {
        if (this.qtip.rendered < 1 || this.drawing) {
          return this;
        }
        var tooltip = this.qtip.tooltip, style = this.qtip.options.style, container = this.qtip.options.position.container, perc, width, max, min;
        this.qtip.drawing = 1;
        if (style.height) {
          tooltip.css(HEIGHT, style.height);
        }
        if (style.width) {
          tooltip.css(WIDTH, style.width);
        } else {
          tooltip.css(WIDTH, "").appendTo(this.redrawContainer);
          width = tooltip.width();
          if (width % 2 < 1) {
            width += 1;
          }
          max = tooltip.css("maxWidth") || "";
          min = tooltip.css("minWidth") || "";
          perc = (max + min).indexOf("%") > -1 ? container.width() / 100 : 0;
          max = (max.indexOf("%") > -1 ? perc : 1 * parseInt(max, 10)) || width;
          min = (min.indexOf("%") > -1 ? perc : 1 * parseInt(min, 10)) || 0;
          width = max + min ? Math.min(Math.max(width, min), max) : width;
          tooltip.css(WIDTH, Math.round(width)).appendTo(container);
        }
        this.drawing = 0;
        return this;
      },
      destroy: function() {
        this.bgiframe && this.bgiframe.remove();
        this.qtip._unbind([window2, this.qtip.tooltip], this._ns);
      }
    });
    IE6 = PLUGINS.ie6 = function(api2) {
      return BROWSER.ie === 6 ? new Ie6(api2) : FALSE;
    };
    IE6.initialize = "render";
    CHECKS.ie6 = {
      "^content|style$": function() {
        this.redraw();
      }
    };
  });
})(window, document);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/InputLabel.js
var InputLabel = BaseView.extend({
  className: "okta-form-label o-form-label",
  attributes: {
    "data-se": "o-form-label"
  },
  /**
   * @constructor
   * @param  {Object} options options hash
   * @param  {String} [options.type] Input type
   * @param  {String|Function} [options.label] Label text
   * @param  {String|Function} [options.sublabel] Sub label text
   * @param  {String|Function} [options.tooltip] Tooltip text
   * @param  {String|Function} [options.inputId] Id of the inputs
   * @param  {String|Function} [options.id] Id of the inputs
   */
  constructor: function(options2) {
    oktaUnderscore.defaults(options2, {
      inputId: options2.id
    });
    delete options2.id;
    BaseView.apply(this, arguments);
  },
  // standardLabel: space added in the end of the label to avoid selecting label text with double click in read mode
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      return "<legend>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<label for="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 61
          },
          "end": {
            "line": 1,
            "column": 72
          }
        }
      }) : helper)) + '"></label>';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 116
          },
          "end": {
            "line": 1,
            "column": 125
          }
        }
      }) : helper));
    },
    "7": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<label for="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 167
          },
          "end": {
            "line": 1,
            "column": 178
          }
        }
      }) : helper)) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 180
          },
          "end": {
            "line": 1,
            "column": 189
          }
        }
      }) : helper)) + "&nbsp;</label>";
    },
    "9": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="o-form-explain">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "sublabel") || (depth0 != null ? lookupProperty(depth0, "sublabel") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "sublabel",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 256
          },
          "end": {
            "line": 1,
            "column": 268
          }
        }
      }) : helper)) + "</span>";
    },
    "11": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="o-form-tooltip icon-16 icon-only form-help-16" title="' + container.escapeExpression(container.lambda((stack1 = depth0 != null ? lookupProperty(depth0, "tooltip") : depth0) != null ? lookupProperty(stack1, "text") : stack1, depth0)) + '"></span>';
    },
    "13": function(container, depth0, helpers2, partials, data) {
      return "</legend>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "group") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 28
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "_isLabelView") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 28
          },
          "end": {
            "line": 1,
            "column": 89
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "_isRadioOrCheckbox") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 89
          },
          "end": {
            "line": 1,
            "column": 132
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "_standardLabel") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 132
          },
          "end": {
            "line": 1,
            "column": 210
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "sublabel") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 210
          },
          "end": {
            "line": 1,
            "column": 282
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "tooltip") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(11, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 282
          },
          "end": {
            "line": 1,
            "column": 397
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "group") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(13, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 397
          },
          "end": {
            "line": 1,
            "column": 426
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    const options2 = {
      label: ""
    };
    oktaUnderscore.each(["inputId", "label", "sublabel", "tooltip", "group"], function(option2) {
      options2[option2] = oktaUnderscore.resultCtx(this.options, option2, this);
    }, this);
    if (this._isLabelView(options2.label)) {
      options2._isLabelView = true;
    } else if (oktaUnderscore.contains(["radio", "checkbox"], this.options.type) || !options2.label) {
      options2._isRadioOrCheckbox = true;
    } else {
      options2._standardLabel = true;
    }
    if (options2.tooltip) {
      if (oktaUnderscore.isString(options2.tooltip)) {
        options2.tooltip = {
          text: options2.tooltip
        };
      }
    }
    return options2;
  },
  _isLabelView: function(label) {
    return !oktaUnderscore.isUndefined(label) && label instanceof BaseView;
  },
  postRender: function() {
    const options2 = this.getTemplateData();
    if (this._isLabelView(options2.label)) {
      this.removeChildren();
      this.add(options2.label, "label");
    }
    if (options2.tooltip) {
      this.$(".o-form-tooltip").qtip(oktaUnderscore.extend({
        style: {
          classes: "qtip-custom qtip-shadow"
        },
        position: {
          my: window.okta && window.okta.theme === "dstheme" ? "bottom center" : "bottom left",
          at: "top center"
        },
        hide: {
          fixed: true
        },
        show: {
          delay: 0
        }
      }, options2.tooltip.options));
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/InputWrapper.js
function runCallback(callback, field) {
  callback.apply(this, oktaUnderscore.map(field.split(/\s+/), function(field2) {
    return this.model.get(field2);
  }, this));
}
function runIf(fn11, ctx) {
  if (oktaUnderscore.isFunction(fn11)) {
    fn11.call(ctx);
  }
}
var InputWrapper = BaseView.extend({
  tagName: function() {
    if (this.options.group) {
      return "fieldset";
    }
    return "div";
  },
  className: function() {
    let className2 = "o-form-fieldset";
    if (this.options["label-top"]) {
      className2 += " o-form-label-top";
    }
    if (this.options.readOnly) {
      className2 += " o-form-read-mode";
    }
    return className2;
  },
  attributes: function() {
    return {
      "data-se": this.options["data-se"] || "o-form-fieldset"
    };
  },
  /**
   * @constructor
   * @param  {Object} options options hash
   * @param  {Object} [options.events]
   * @param  {Object} [options.bindings]
   * @param  {Object} [options.showWhen]
   * @param  {Function} [options.initialize] post initialize callback
   * @param  {Function} [options.render] post render callback
   */
  constructor: function(options2) {
    if (options2.className) {
      this.inputWrapperClassName = this.className;
      this.optionsClassName = options2.className;
      options2.className = function() {
        return oktaUnderscore.result(this, "inputWrapperClassName", "") + " " + oktaUnderscore.result(this, "optionsClassName");
      };
    }
    BaseView.apply(this, arguments);
    oktaUnderscore.each(options2.events || {}, function(callback, event) {
      this.listenTo(this.model, event, callback);
    }, this);
    oktaUnderscore.each(options2.bindings || {}, function(callback, field) {
      this.listenTo(this.model, FormUtil.changeEventString(field.split(/\s+/)), oktaUnderscore.bind(runCallback, this, callback, field));
    }, this);
    FormUtil.applyShowWhen(this, options2.showWhen);
    FormUtil.applyToggleWhen(this, options2.toggleWhen);
    runIf(options2.initialize, this);
  },
  postRender: function() {
    oktaUnderscore.each(this.options.bindings || {}, runCallback, this);
    runIf(this.options.render, this);
  },
  /**
   * @return {InputLabel}
   */
  getLabel: function() {
    return this.size() > 1 ? this.at(0) : null;
  },
  /**
   * @deprecated ambiguous naming, use {@link #getInputContainer}
   */
  getInput: function() {
    return this.getInputContainer();
  },
  /**
   * @return {InputContainer}
   */
  getInputContainer: function() {
    return this.at(this.size() > 1 ? 1 : 0);
  },
  /**
   * @return {BaseInput[]}
   */
  getInputs: function() {
    return this.getInputContainer().toArray();
  },
  focus: function() {
    return this.getInput().focus();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/BaseForm.js
var template2 = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<h2 class="o-form-title-bar" data-se="o-form-title-bar">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 75
        },
        "end": {
          "line": 1,
          "column": 84
        }
      }
    }) : helper)) + "</h2>";
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "title") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(4, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 192
        },
        "end": {
          "line": 1,
          "column": 288
        }
      }
    })) != null ? stack1 : "";
  },
  "4": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<h2 data-se="o-form-head" class="okta-form-title o-form-head">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 267
        },
        "end": {
          "line": 1,
          "column": 276
        }
      }
    }) : helper)) + "</h2>";
  },
  "6": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<p class="okta-form-subtitle o-form-explain" data-se="o-form-explain">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "subtitle") || (depth0 != null ? lookupProperty(depth0, "subtitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "subtitle",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 385
        },
        "end": {
          "line": 1,
          "column": 397
        }
      }
    }) : helper)) + "</p>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "hasReadMode") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 96
        }
      }
    })) != null ? stack1 : "") + '<div data-se="o-form-content" class="o-form-content ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "layout") || (depth0 != null ? lookupProperty(depth0, "layout") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
      "name": "layout",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 148
        },
        "end": {
          "line": 1,
          "column": 158
        }
      }
    }) : helper)) + ' clearfix">' + ((stack1 = lookupProperty(helpers2, "unless").call(alias1, depth0 != null ? lookupProperty(depth0, "hasReadMode") : depth0, {
      "name": "unless",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 169
        },
        "end": {
          "line": 1,
          "column": 299
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "subtitle") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(6, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 299
        },
        "end": {
          "line": 1,
          "column": 408
        }
      }
    })) != null ? stack1 : "") + '<div class="o-form-error-container" data-se="o-form-error-container"></div><div class="o-form-fieldset-container" data-se="o-form-fieldset-container"></div></div>';
  },
  "useData": true
});
var sectionTitleTemplate = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<h2 class="o-form-head">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 24
        },
        "end": {
          "line": 1,
          "column": 33
        }
      }
    }) : helper)) + "</h2>";
  },
  "useData": true
});
var pointerEventsSupported = oktaJQueryStatic("<div>").css({
  "pointer-events": "auto"
})[0].style.pointerEvents === "auto";
function pointerEventsPolyfill(e) {
  if (!pointerEventsSupported && this.$el.hasClass("o-form-saving")) {
    const $el = oktaJQueryStatic(e.currentTarget);
    $el.css("display", "none");
    const underneathElem = document.elementFromPoint(e.clientX, e.clientY);
    $el.css("display", "block");
    e.target = underneathElem;
    oktaJQueryStatic(underneathElem).trigger(e);
    return false;
  }
}
var events = {
  submit: function(e) {
    e.preventDefault();
    this.__save();
  }
};
oktaUnderscore.each(["click", "dblclick", "mousedown", "mouseup"], function(event) {
  events[event + " .o-form-input"] = pointerEventsPolyfill;
});
var attributes = function(model) {
  model || (model = {});
  const collection = model && model.collection || {};
  return {
    method: "POST",
    action: oktaUnderscore.result(model, "urlRoot") || oktaUnderscore.result(collection, "url") || window.location.pathname,
    "data-se": "o-form",
    slot: "content"
  };
};
var convertSavingState = function(rawSavingStateEvent, defaultEvent) {
  rawSavingStateEvent || (rawSavingStateEvent = "");
  let savingStateEvent = [];
  if (oktaUnderscore.isString(rawSavingStateEvent)) {
    savingStateEvent = rawSavingStateEvent.split(" ");
  }
  savingStateEvent = oktaUnderscore.union(savingStateEvent, defaultEvent);
  return savingStateEvent.join(" ");
};
var getErrorSummary = function(responseJSON = {}) {
  if (Array.isArray(responseJSON.errorCauses) && responseJSON.errorCauses.length > 0) {
    return responseJSON.errorCauses[0].errorSummary;
  } else {
    return responseJSON.errorSummary;
  }
};
var BaseForm = BaseView.extend(
  /** @lends module:Okta.Form.prototype */
  {
    /**
     * Specifies how to validate form:
     * - In case "local" string provided as a value of the property,
     * the form will validate only fields added as inputs to the form;
     * - In case array is provided, the validation will be performed only for fields specified in array;
     * - In case function is provided, provided function will be used as a validation function,
     * it must return an error object with the format {fieldName: 'error text'} with as many fields as you need.
     * @name validate
     * @memberof module:Okta.Form
     * @type {String|Array|Function}
     * @instance
     */
    constructor: function(options2) {
      options2 || (options2 = {});
      this.options = options2;
      if (options2.settings) {
        this.settings = options2.settings;
      } else {
        this.settings = options2.settings = new SettingsModel();
      }
      this.id = oktaUnderscore.uniqueId("form");
      this.tagName = "form";
      oktaUnderscore.defaults(this.events, events);
      oktaUnderscore.defaults(this.attributes, attributes(options2.model));
      this.__buttons = [];
      this.__errorFields = {};
      this.__saveModelState(options2.model);
      const step = oktaUnderscore.result(this, "step");
      if (step) {
        if (!this.save) {
          const totalStep = oktaUnderscore.result(this, "totalSteps");
          this.save = !totalStep || step === totalStep ? StringUtil.localize("oform.button.finish", "courage") : StringUtil.localize("oform.button.next", "courage");
        }
        this.className = oktaUnderscore.result(this, "className") + " wizard";
      }
      this.className = oktaUnderscore.result(this, "className") + " o-form";
      this.__toolbar = this.__createToolbar(options2);
      BaseView.call(this, options2);
      oktaUnderscore.each(oktaUnderscore.result(this, "inputs") || [], function(input) {
        this.__addLayoutItem(input);
      }, this);
      this.add(this.__toolbar, "");
      this.listenTo(this.model, "change:__edit__", this.__applyMode);
      this.listenTo(this.model, "invalid error", oktaUnderscore.throttle(function(model, resp, showBanner) {
        this.__showErrors(model, resp, showBanner !== false);
      }, 100, {
        trailing: false
      }));
      this.listenTo(this.model, "form:resize", function() {
        this.trigger("resize");
      });
      this.listenTo(this.model, "form:cancel", oktaUnderscore.throttle(this.__cancel, 100, {
        trailing: false
      }));
      this.listenTo(this.model, "form:previous", oktaUnderscore.throttle(this.__previous, 100, {
        trailing: false
      }));
      this.__save = oktaUnderscore.throttle(this.__save, 200, {
        trailing: false
      });
      this.listenTo(this.model, "form:save", function() {
        this.$el.submit();
      });
      this.listenTo(this.model, "sync", function() {
        if (this.model.get("__edit__")) {
          this.model.set("__edit__", false, {
            silent: true
          });
        }
        this.__saveModelState(this.model);
        this.render();
      });
      let hasSavingState = this.getAttribute("hasSavingState");
      if (this.getAttribute("autoSave")) {
        this.listenTo(this, "save", function(model) {
          const xhr = model.save();
          if (xhr && xhr.done) {
            xhr.done(() => {
              this.trigger("saved", model);
            });
          }
        });
        if (oktaUnderscore.isUndefined(hasSavingState)) {
          hasSavingState = true;
        }
      }
      if (hasSavingState) {
        const customSavingState = this.getAttribute("customSavingState", {});
        this.listenTo(this.model, convertSavingState(customSavingState.start || "", ["request"]), this.__setSavingState);
        this.listenTo(this.model, convertSavingState(customSavingState.stop || "", ["error", "sync"]), this.__clearSavingState);
      }
    },
    /**
     * Create the bottom button bar
     * @param  {Object} options options h
     * @return {Okta.View} The toolbar
     * @private
     */
    __createToolbar: function(options2) {
      const danger = this.getAttribute("danger");
      const saveBtnClassName = danger === true ? "button-error" : "button-primary";
      const step = oktaUnderscore.result(this, "step");
      const toolbar = new Toolbar(oktaUnderscore.extend({
        save: this.save || StringUtil.localize("oform.save", "courage"),
        saveId: this.saveId,
        saveClassName: saveBtnClassName,
        cancel: this.cancel || StringUtil.localize("oform.cancel", "courage"),
        noCancelButton: this.noCancelButton || false,
        noSubmitButton: this.noSubmitButton || false,
        buttonOrder: this.buttonOrder,
        hasPrevStep: step && step > 1
      }, options2 || this.options));
      oktaUnderscore.each(this.__buttons, function(args) {
        toolbar.addButton.apply(toolbar, args);
      });
      return toolbar;
    },
    className: "",
    attributes: {},
    events: {},
    /**
     * An array of input configurations to render in the form
     * @type {Array}
     */
    inputs: [],
    template: null,
    /**
     * Does the form support read/edit toggle.
     * @type {Boolean|Function}
     * @default false
     */
    read: false,
    /**
     * Is the form in readOnly mode.
     * @type {Boolean|Function}
     * @default false
     */
    readOnly: false,
    /**
     * Should we not render the button bar
     * @type {Boolean|Function}
     * @default false
     */
    noButtonBar: false,
    /**
     * Should we not render a cancel button
     * @type {Boolean|Function}
     * @default false
     */
    noCancelButton: false,
    /**
     * Should we not render a save button
     * @type {Boolean}
     * @default false
     */
    noSubmitButton: false,
    /**
     * Set the order of the save, cancel and previous buttons (left to right).
     * @type {Array.<string>}
     * @default ['previous', 'save', 'cancel']
     */
    buttonOrder: ["previous", "save", "cancel"],
    /**
     * The text on the save button
     * @type {String}
     * @default "Save"
     */
    save: null,
    /**
     * The text on the cancel button
     * @type {String}
     * @default "Cancel"
     */
    cancel: null,
    /**
     * To use button-error to style the submit button instead of button-primary.
     * @type {Boolean|Function}
     * @default false
     */
    danger: false,
    /**
     * A layout CSS class to add to the form
     * @type {String|Function}
     * @default ""
     */
    layout: "",
    /**
     * The step this form is in the context of a wizard
     * @type {Number}
     */
    step: void 0,
    /**
     * The total numbers of steps the wizard this form is a part of has
     * @type {Number}
     */
    totalSteps: void 0,
    /**
     * The form's title
     * @type {String|Function}
     */
    title: null,
    /**
     * The form's subtitle
     * @type {String|Function}
     */
    subtitle: null,
    /**
     * Auto-save the model when hitting save. Triggers a `saved` event when done
     * @type {Boolean}
     * @default false
     */
    autoSave: false,
    /**
     * Scroll to the top of the form on error
     * @type {Boolean|Function}
     * @default true
     */
    scrollOnError: true,
    /**
     * Show the error banner upon error
     * @type {Boolean|Function}
     * @default true
     */
    showErrors: true,
    /**
     * The form's scrollable area
     * @type {String}
     * @default ".o-form-content"
     */
    resizeSelector: ".o-form-content",
    /**
     * Sets whether or not the form shows the saving state when
     * the model is saved.  Has no effect on setSavingState and clearSavingState as those are manual calls
     * to trigger/clear the saving state.
     * @name hasSavingState
     * @memberof module:Okta.Form
     * @type {Boolean}
     * @default false
     * @instance
     */
    /**
     * Get an attribute value from options or instance.
     * Prefer options value over instance value
     * @param  {String} name Name of the attribute
     * @param  {Object} defaultValue the default value to return if the attribute is not found
     * @return {Object} The value
     */
    getAttribute: function(name, defaultValue) {
      let value = oktaUnderscore.resultCtx(this.options, name, this);
      if (oktaUnderscore.isUndefined(value)) {
        value = oktaUnderscore.result(this, name);
      }
      return !oktaUnderscore.isUndefined(value) ? value : defaultValue;
    },
    /**
     * Does this form have a "read" mode
     * @return {Boolean}
     */
    hasReadMode: function() {
      return !!this.getAttribute("read");
    },
    /**
     * Is this form in "read only" mode
     * @return {Boolean}
     */
    isReadOnly: function() {
      return !!this.getAttribute("readOnly");
    },
    /**
     * Does this form have a button bar
     * @return {Boolean}
     */
    hasButtonBar: function() {
      return !(this.getAttribute("noButtonBar") || this.isReadOnly());
    },
    render: function() {
      this.__readModeBar && this.__readModeBar.remove();
      if (this.hasReadMode() && !this.isReadOnly()) {
        const readModeBar = ReadModeBar.extend({
          formTitle: this.getAttribute("title", "")
        });
        this.__readModeBar = this.add(readModeBar, ".o-form-title-bar").last();
      }
      const html = template2({
        layout: this.getAttribute("layout", ""),
        title: this.getAttribute("title", "", true),
        subtitle: this.getAttribute("subtitle", "", true),
        hasReadMode: this.hasReadMode()
      });
      this.$el.html(html);
      delete this.template;
      BaseView.prototype.render.apply(this, arguments);
      this.__applyMode();
      return this;
    },
    /**
     * Changes form UI to indicate saving.  Disables all inputs and buttons.  Use this function if you have set
     * hasSavingState to false on the the form
     * @private
     */
    __setSavingState: function() {
      this.model.trigger("form:set-saving-state");
      this.$el.addClass("o-form-saving");
    },
    /**
     * Changes form UI back to normal from the saving state.  Use this function if you are have set hasSavingState
     * to false on the form
     * @private
     */
    __clearSavingState: function() {
      this.model.trigger("form:clear-saving-state");
      this.$el.removeClass("o-form-saving");
    },
    /**
     * Toggles the visibility of the bottom button bar
     * @private
     */
    __toggleToolbar: function() {
      this.__toolbar && this.__toolbar.remove();
      if (this.hasButtonBar() && this._editMode()) {
        this.__toolbar = this.__createToolbar();
        this.add(this.__toolbar, "");
      }
      this.trigger("resize");
    },
    /**
     * Cancels this form
     * - Reset the model to the previous state
     * - Clears all errors
     * - Triggers a `cancel` event
     * - Sets the model to read mode (if applicable)
     * @private
     * @fires cancel
     */
    __cancel: function() {
      const edit = this.model.get("__edit__");
      this.model.clear({
        silent: true
      });
      let data;
      if (this.model.sanitizeAttributes) {
        data = this.model.sanitizeAttributes(this.__originalModel);
      } else {
        data = oktaUnderscore.clone(this.__originalModel);
      }
      this.model.set(data, {
        silent: true
      });
      this.trigger("cancel", this.model);
      this.model.trigger("cache:clear");
      if (edit) {
        this.model.set("__edit__", false, {
          silent: true
        });
        this.model.trigger("change:__edit__", this.model, false);
      }
      this.clearErrors();
    },
    /**
     * Runs {@link module:Okta.Form#validate|validate} to check the model state.
     * Triggers an "invalid" event on the model if validation fails
     * @returns {Boolean}
     */
    isValid: function() {
      let res;
      const self2 = this;
      function validateArray(arr) {
        return oktaUnderscore.reduce(arr, function(memo, fieldName) {
          return oktaUnderscore.extend(memo, self2.model.validateField(fieldName));
        }, {});
      }
      if (oktaUnderscore.isUndefined(this.validate)) {
        return this.model.isValid();
      } else if (oktaUnderscore.isFunction(this.validate)) {
        res = this.validate();
      } else if (oktaUnderscore.isArray(this.validate)) {
        res = validateArray(this.validate);
      } else if (this.validate === "local") {
        res = validateArray(this.getInputs().map(function(input) {
          return input.options.name;
        }));
      }
      if (!oktaUnderscore.isEmpty(res)) {
        this.model.trigger("invalid", this.model, res);
        return false;
      } else {
        return true;
      }
    },
    /**
     * A throttled function that saves the form not more than once every 100 ms
     * Basically all this method does is trigger a `save` event
     * @fires save
     * @private
     */
    __save: function() {
      this.clearErrors();
      if (this.isValid()) {
        this.trigger("save", this.model);
      }
    },
    /**
     * In the context of a wizard, go to previous state
     * Technically all this method does is trigger a `previous` event
     * @param  {Event} e
     * @private
     */
    __previous: function() {
      this.trigger("previous", this.model);
    },
    /**
     * Renders the form in the correct mode based on the model.
     * @private
     */
    __applyMode: function() {
      this.clearErrors();
      this.__toggleToolbar();
      if (this._editMode()) {
        this.$el.addClass("o-form-edit-mode");
        this.$el.removeClass("o-form-read-mode");
        this.$(".o-form-content").removeClass("rounded-btm-4");
        this.focus();
      } else {
        this.$el.removeClass("o-form-edit-mode");
        this.$el.addClass("o-form-read-mode");
        this.$(".o-form-content").addClass("rounded-btm-4");
      }
    },
    /**
     * Is the form in edit mode
     * @return {Boolean}
     * @private
     */
    _editMode: function() {
      return this.model.get("__edit__") || !this.hasReadMode();
    },
    /**
     * Function can be overridden to alter top level error summary.
     * @param {Object} responseJSON
     *
     * @example
     * // responseJSON object
     * {
     *  errorCauses: [{errorSummary: "At least one of Proxy Status, Location, or ASN should be configured."}]
     *  errorSummary: "At least one of Proxy Status, Location, or ASN should be configured."
     *  errorCode: "E0000001"
     *  errorId: "oaepsrTCHrhT-eIi8XTm6KWWg"
     *  errorLink: "E0000001"
     *  errorSummary: "Api validation failed: networkZone"
     * }
     *
     * @method
     * @default _.identity
     */
    parseErrorMessage: oktaUnderscore.identity,
    _handleErrorScroll: function() {
      if (!this.getAttribute("scrollOnError")) {
        return;
      }
      const $el = oktaJQueryStatic("#" + this.id + " .o-form-error-container");
      if ($el.length) {
        let $scrollContext = $el.scrollParent();
        let scrollTop;
        if ($scrollContext[0] === document) {
          $scrollContext = oktaJQueryStatic("html, body");
          scrollTop = $el.offset().top;
        } else {
          scrollTop = $scrollContext.scrollTop() + $el.offset().top - $scrollContext.offset().top;
        }
        $scrollContext.animate({
          scrollTop
        }, 400);
      }
    },
    /**
     * Show an error message based on an XHR error
     * @param  {Okta.BaseModel} model the model
     * @param  {jqXHR} xhr The jQuery XmlHttpRequest Object
     * @private
     */
    __showErrors: function(model, resp, showBanner) {
      this.trigger("error", model);
      if (!this.getAttribute("showErrors")) {
        return;
      }
      let errorSummary;
      let responseJSON = ErrorParser.getResponseJSON(resp);
      const validationErrors = ErrorParser.parseFieldErrors(resp);
      if (oktaUnderscore.size(validationErrors)) {
        oktaUnderscore.each(validationErrors, function(errors, field) {
          this.model.trigger("form:field-error", this.__errorFields[field] || field, oktaUnderscore.map(errors, function(error) {
            return /^model\.validation/.test(error) ? StringUtil.localize(error, "courage") : error;
          }));
        }, this);
      } else {
        responseJSON = this.parseErrorMessage(responseJSON);
        errorSummary = getErrorSummary(responseJSON);
      }
      if (showBanner) {
        this.$(".o-form-error-container").addClass("o-form-has-errors");
        this.add(ErrorBanner, ".o-form-error-container", {
          options: {
            errorSummary
          }
        });
      }
      this._handleErrorScroll();
      this.model.trigger("form:resize");
    },
    /**
     * Clears the error banner
     * @private
     */
    clearErrors: function() {
      this.$(".o-form-error-container").removeClass("o-form-has-errors");
      this.model.trigger("form:clear-errors");
      this.model.trigger("form:resize");
    },
    /**
     * Toggles between edit and read mode
     */
    toggle: function() {
      this.model.set("__edit__", !this.hasReadMode() || !this.model.get("__edit__"));
      return this;
    },
    __addLayoutItem: function(input) {
      if (InputFactory.supports(input)) {
        this.addInput(input);
      } else {
        this.__addNonInputLayoutItem(input);
      }
    },
    __addNonInputLayoutItem: function(item) {
      const itemOptions = oktaUnderscore.omit(item, "type");
      switch (item.type) {
        case "sectionTitle":
          this.addSectionTitle(item.title, oktaUnderscore.omit(itemOptions, "title"));
          break;
        case "divider":
          this.addDivider(itemOptions);
          break;
        default:
          throw new Error("unknown input: " + item.type);
      }
    },
    /**
     * Adds a view to the buttons tool bar
     * @param {Object} params parameterized button options
     * @param {Object} options options to send to {@link module:Okta.View#add|View.add}
     */
    addButton: function(params, options2) {
      this.__toolbar && this.__toolbar.addButton(params, options2);
      this.__buttons.push([params, options2]);
    },
    /**
     * Adds a divider
     */
    addDivider: function(options2) {
      this.add('<div class="okta-form-divider form-divider"></div>');
      FormUtil.applyShowWhen(this.last(), options2 && options2.showWhen);
      FormUtil.applyToggleWhen(this.last(), options2 && options2.toggleWhen);
      return this;
    },
    /**
     * Adds section header
     * @param {String} title
     */
    addSectionTitle: function(title, options2) {
      this.add(sectionTitleTemplate({
        title
      }));
      FormUtil.applyShowWhen(this.last(), options2 && options2.showWhen);
      FormUtil.applyToggleWhen(this.last(), options2 && options2.toggleWhen);
      return this;
    },
    /**
     * Add a form input
     * @param {Object} options Options to describe the input
     * @param {String} options.type The input type.
     * The options are: `text`, `textarea`, `select`, `checkbox`, `radio`, `switch`,
     * `password`, `number`, `textselect`, `date`, `grouppicker`, `admingrouppicker`, `su-orgspicker`
     * `file/image`, `file/cert`, `checkboxset`, `list`, `group`, `zonepicker`
     * @param {String} options.name The name of the model field this input mutates
     * @param {String|Function} [options.label]
     * The input label text.
     * When passed as a function, will invoke the function (in the context of the {@link InputLabel})
     * on render time, and use the returned value.
     * @param {String} [options.sublabel] The input sub label text
     * @param {String} [options.tooltip] A popover tooltip to be displayed next to the label
     * @param {String} [options.placeholder] Placeholder text.
     * @param {String} [options.explain] Explanation text to render below the input
     * @param {Okta.View} [options.customExplain] A custom view to render below the input (deprecated)
     * @param {Boolean} [options.disabled=false] Make this input disabled
     * @param {Boolean} [options.wide=false] Use a wide input layout
     * @param {Boolean} [options.label-top=false] position label on top of an input
     * @param {Boolean} [options.explain-top=false] position explain on top of an input (requires label-top=true)
     * @param {Number} [options.multi] have multiple in-line inputs. useful when `input` is passed as an array of inputs
     * @param {String} [options.errorField] The API error field here that maps to this input
     * @param {Boolean} [options.inlineValidation=true] Validate input on focusout
     * @param {String} [options.ariaLabel] Used to add aria-label attribute to the input when label is not present.
     * @param {Boolean} [options.group=false] Grouping set of inputs using fieldset and legend. Mainly for radio
     * @param {Object} [options.options]
     * In the context of `radio` and `select`, a key/value set of options
     *
     * @param {Object} [options.params]
     * Widget specific parameters. Varies per input.
     *
     * @param {BaseInput|Object[]} [options.input]
     * - A custom input "class" or instance - preferably a **class**, so we can automagically assign the right
     * parameters when initializing it
     * - An array of input definition object literals (such as this one)
     *
     * @param {Object} [options.showWhen]
     * Setting to define when to show (or hide) the input. The input is visible by default.
     *
     * @param {Object} [options.bindings]
     * Bind a certain model attribute to a callback function, so the function is being called on render,
     * and any time this model field changes.
     * This is similar to `showWhen` but is not limited to toggling.
     *
     * @param {Function} [options.render]
     * A post-render hook that will run upon render on InputWrapper
     *
     * @param {String|Function} className   A className to apply on the {@link InputWrapper}
     *
     * @param {Function} [options.initialize]
     * An `initialize` function to run when initializing the {@link InputWrapper}
     * Useful for state mutation on start time, and complex state logic
     *
     * @example
     * // showhen: the field will be visible when `advanced` is set to `true`
     * // and `mode` is set to `"ON"`.
     * showWhen: {
     *   'advanced': true,
     *   'mode': function (value) {
     *     return value == 'ON'; // this is identical to this.model.get('mode') == 'ON'
     *   }
     * }
     *
     * @example
     * // bindings
     * bindings: {
     *   'status mode': function (status, mode) {
     *      var labelView = this.getLabel();
     *      if (status == 1) {
     *        labelView.options.label = 'Something';
     *      }
     *      else {
     *        labelView.options.label = mode;
     *      }
     *      labelView.render();
     *   }
     * }
     */
    addInput: function(_options) {
      _options = oktaUnderscore.clone(_options);
      FormUtil.validateInput(_options, this.model);
      const inputsOptions = FormUtil.generateInputOptions(_options, this, this.__createInput).reverse();
      if (oktaUnderscore.isEmpty(this.getInputs().toArray())) {
        oktaUnderscore.extend(inputsOptions[0], {
          validateOnlyIfDirty: true
        });
      }
      const inputs = oktaUnderscore.map(inputsOptions, this.__createInput, this);
      oktaUnderscore.each(inputsOptions, function(input) {
        if (input.errorField) {
          this.__errorFields[input.errorField] = input.name;
        }
      }, this);
      const options2 = {
        inputId: oktaUnderscore.last(inputs).options.inputId,
        input: inputs,
        multi: inputsOptions.length > 1 ? inputsOptions.length : void 0
      };
      oktaUnderscore.extend(options2, oktaUnderscore.omit(this.options, "input"), oktaUnderscore.omit(_options, "input"));
      const inputWrapper = this.__createWrapper(options2);
      if (options2.label !== false) {
        inputWrapper.add(this.__createLabel(options2));
      }
      inputWrapper.add(this._createContainer(options2));
      inputWrapper.type = options2.type || options2.input.type || "custom";
      const args = [inputWrapper].concat(oktaUnderscore.rest(arguments));
      return this.add.apply(this, args);
    },
    /**
     * @private
     */
    __createInput: function(options2) {
      options2 = oktaUnderscore.pick(options2, FormUtil.INPUT_OPTIONS);
      return InputFactory.create(options2);
    },
    /**
     * @private
     */
    __createWrapper: function(options2) {
      options2 = oktaUnderscore.pick(options2, FormUtil.WRAPPER_OPTIONS);
      return new InputWrapper(options2);
    },
    /**
     * @private
     */
    __createLabel: function(options2) {
      options2 = oktaUnderscore.pick(options2, FormUtil.LABEL_OPTIONS);
      return new InputLabel(options2);
    },
    /**
     * @private
     */
    _createContainer: function(options2) {
      options2 = oktaUnderscore.pick(options2, FormUtil.CONTAINER_OPTIONS);
      return new InputContainer(options2);
    },
    /**
     * Stores the current attributes of the model to a private property
     * @param  {Okta.BaseModel} model The model
     * @private
     */
    __saveModelState: function(model) {
      this.__originalModel = oktaJQueryStatic.extend(true, {}, model.attributes);
    },
    /**
     * @override
     * @ignore
     */
    add: function(...args) {
      typeof args[1] === "undefined" && (args[1] = "> div.o-form-content > .o-form-fieldset-container");
      return BaseView.prototype.add.apply(this, args);
    },
    /**
     * Set the focus on the first input in the form
     */
    focus: function() {
      const first = this.getInputs().first();
      if (first && first.focus) {
        first.focus();
      }
      return this;
    },
    /**
     * Disable all inputs in the form
     * @deprecated not currently in use
     */
    disable: function() {
      this.invoke("disable");
      return this;
    },
    /**
     * Enable all inputs in the form
     * @deprecated not currently in use
     */
    enable: function() {
      this.invoke("enable");
    },
    /**
     * Set the max-height for o-form-content class container within the form if a height is provided,
     * otherwise, get its computed inner height
     * @param {Number} the height in pixel to set for class o-form-content
     * @return {Number}
     */
    contentHeight: function(height) {
      const content = this.$(".o-form-content");
      if (oktaUnderscore.isNumber(height)) {
        content.css("max-height", height);
      } else {
        return content.height();
      }
    },
    /**
     * Get only the input children
     * @return {InputWrapper[]} An underscore wrapped array of {@link InputWrapper} instances
     */
    getInputs: function() {
      return oktaUnderscore(this.filter(function(view) {
        return view instanceof InputWrapper;
      }));
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/plugins/chosen.jquery.js
(function() {
  var SelectParser;
  SelectParser = function() {
    function SelectParser2() {
      this.options_index = 0;
      this.parsed = [];
    }
    SelectParser2.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };
    SelectParser2.prototype.add_group = function(group) {
      var group_position, option2, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: group.label,
        children: 0,
        disabled: group.disabled
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option2 = _ref[_i];
        _results.push(this.add_option(option2, group_position, group.disabled));
      }
      return _results;
    };
    SelectParser2.prototype.add_option = function(option2, group_position, group_disabled) {
      if (option2.nodeName.toUpperCase() === "OPTION") {
        if (option2.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option2.value,
            text: option2.text,
            html: option2.innerHTML,
            selected: option2.selected,
            disabled: group_disabled === true ? group_disabled : option2.disabled,
            group_array_index: group_position,
            classes: option2.className,
            style: option2.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };
    return SelectParser2;
  }();
  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };
  this.SelectParser = SelectParser;
}).call(jQuery);
(function() {
  var AbstractChosen, root;
  root = this;
  AbstractChosen = function() {
    function AbstractChosen2(form_field, options2) {
      this.form_field = form_field;
      this.options = options2 != null ? options2 : {};
      if (!AbstractChosen2.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.finish_setup();
    }
    AbstractChosen2.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = this.options.allow_single_deselect != null && this.form_field.options[0] != null && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete || false;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      return this.inherit_select_classes = this.options.inherit_select_classes || false;
    };
    AbstractChosen2.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen2.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen2.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen2.default_no_result_text;
    };
    AbstractChosen2.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };
    AbstractChosen2.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };
    AbstractChosen2.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout(function() {
            return _this.container_mousedown();
          }, 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };
    AbstractChosen2.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout(function() {
          return _this.blur_test();
        }, 100);
      }
    };
    AbstractChosen2.prototype.result_add_option = function(option2) {
      var classes, style;
      option2.dom_id = this.container_id + "_o_" + option2.array_index;
      classes = [];
      if (!option2.disabled && !(option2.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option2.disabled && !(option2.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option2.selected) {
        classes.push("result-selected");
      }
      if (option2.group_array_index != null) {
        classes.push("group-option");
      }
      if (option2.classes !== "") {
        classes.push(option2.classes);
      }
      style = option2.style.cssText !== "" && option2.style !== "" ? ' style="' + option2.style + '"' : "";
      return '<li id="' + option2.dom_id + '" class="' + classes.join(" ") + '"' + style + ">" + option2.html + "</li>";
    };
    AbstractChosen2.prototype.results_update_field = function() {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.result_single_selected = null;
      return this.results_build();
    };
    AbstractChosen2.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };
    AbstractChosen2.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };
    AbstractChosen2.prototype.choices_count = function() {
      var option2, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option2 = _ref[_i];
        if (option2.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };
    AbstractChosen2.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };
    AbstractChosen2.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };
    AbstractChosen2.prototype.generate_field_id = function() {
      var new_id;
      new_id = this.generate_random_id();
      this.form_field.id = new_id;
      return new_id;
    };
    AbstractChosen2.prototype.generate_random_char = function() {
      var chars, rand;
      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      rand = Math.floor(Math.random() * chars.length);
      return chars.substring(rand, rand + 1);
    };
    AbstractChosen2.prototype.container_width = function() {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };
    AbstractChosen2.browser_is_supported = function() {
      var _ref;
      if (window.navigator.appName === "Microsoft Internet Explorer") {
        return null !== (_ref = document.documentMode) && _ref >= 8;
      }
      return true;
    };
    AbstractChosen2.default_multiple_text = "Select Some Options";
    AbstractChosen2.default_single_text = "Select an Option";
    AbstractChosen2.default_no_result_text = "No results match";
    return AbstractChosen2;
  }();
  root.AbstractChosen = AbstractChosen;
}).call(jQuery);
(function() {
  var $, Chosen, root, _ref, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
  root = this;
  var AbstractChosen = root.AbstractChosen;
  $ = jQuery;
  $.fn.extend({
    chosen: function(options2) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function(input_field) {
        var $this;
        $this = $(this);
        if (!$this.hasClass("chzn-done")) {
          return $this.data("chosen", new Chosen(this, options2));
        }
      });
    }
  });
  Chosen = function(_super) {
    __extends(Chosen2, _super);
    function Chosen2() {
      _ref = Chosen2.__super__.constructor.apply(this, arguments);
      return _ref;
    }
    Chosen2.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
    };
    Chosen2.prototype.finish_setup = function() {
      return this.form_field_jq.addClass("chzn-done");
    };
    Chosen2.prototype.set_up_html = function() {
      var container_classes, container_props;
      this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, "_") : this.generate_field_id();
      this.container_id += "_chzn";
      container_classes = ["chzn-container"];
      container_classes.push("chzn-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chzn-rtl");
      }
      container_props = {
        "id": this.container_id,
        "class": container_classes.join(" "),
        "style": "width: " + this.container_width() + ";",
        "title": this.form_field.title
      };
      this.container = $("<div></div>", container_props);
      if (this.is_multiple) {
        this.container.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop"><ul class="chzn-results"></ul></div>');
      } else {
        this.container.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find("div.chzn-drop").first();
      this.search_field = this.container.find("input").first();
      this.search_results = this.container.find("ul.chzn-results").first();
      this.search_field_scale();
      this.search_no_results = this.container.find("li.no-results").first();
      if (this.is_multiple) {
        this.search_choices = this.container.find("ul.chzn-choices").first();
        this.search_container = this.container.find("li.search-field").first();
      } else {
        this.search_container = this.container.find("div.chzn-search").first();
        this.selected_item = this.container.find(".chzn-single").first();
      }
      this.results_build();
      this.set_tab_index();
      this.set_label_behavior();
      return this.form_field_jq.trigger("liszt:ready", {
        chosen: this
      });
    };
    Chosen2.prototype.register_observers = function() {
      var _this = this;
      this.container.mousedown(function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.mouseup(function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.mouseenter(function(evt) {
        _this.mouse_enter(evt);
      });
      this.container.mouseleave(function(evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.mouseup(function(evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.mouseover(function(evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.mouseout(function(evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind("mousewheel DOMMouseScroll", function(evt) {
        _this.search_results_mousewheel(evt);
      });
      this.form_field_jq.bind("liszt:updated", function(evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("liszt:activate", function(evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("liszt:open", function(evt) {
        _this.container_mousedown(evt);
      });
      this.search_field.blur(function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.keyup(function(evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.keydown(function(evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.focus(function(evt) {
        _this.input_focus(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.click(function(evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.click(function(evt) {
          evt.preventDefault();
        });
      }
    };
    Chosen2.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass("chzn-disabled");
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass("chzn-disabled");
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus", this.activate_action);
        }
      }
    };
    Chosen2.prototype.container_mousedown = function(evt) {
      if (!this.is_disabled) {
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!(evt != null && $(evt.target).hasClass("search-choice-close"))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(document).click(this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && ($(evt.target)[0] === this.selected_item[0] || $(evt.target).parents("a.chzn-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };
    Chosen2.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };
    Chosen2.prototype.search_results_mousewheel = function(evt) {
      var delta, _ref1, _ref2;
      delta = -((_ref1 = evt.originalEvent) != null ? _ref1.wheelDelta : void 0) || ((_ref2 = evt.originialEvent) != null ? _ref2.detail : void 0);
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === "DOMMouseScroll") {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };
    Chosen2.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chzn-container-active")) {
        return this.close_field();
      }
    };
    Chosen2.prototype.close_field = function() {
      $(document).unbind("click", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chzn-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };
    Chosen2.prototype.activate_field = function() {
      this.container.addClass("chzn-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };
    Chosen2.prototype.test_active_click = function(evt) {
      if ($(evt.target).parents("#" + this.container_id).length) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };
    Chosen2.prototype.results_build = function() {
      var content, data, _i, _len, _ref1;
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = root.SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chzn-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chzn-container-single-nosearch");
        }
      }
      content = "";
      _ref1 = this.results_data;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        data = _ref1[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else if (!data.empty) {
          content += this.result_add_option(data);
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.selected_item.removeClass("chzn-default").find("span").text(data.text);
            if (this.allow_single_deselect) {
              this.single_deselect_control_build();
            }
          }
        }
      }
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      this.search_results.html(content);
      return this.parsing = false;
    };
    Chosen2.prototype.result_add_group = function(group) {
      group.dom_id = this.container_id + "_g_" + group.array_index;
      return '<li id="' + group.dom_id + '" class="group-result">' + $("<div></div>").text(group.label).html() + "</li>";
    };
    Chosen2.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop(high_bottom - maxHeight > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };
    Chosen2.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };
    Chosen2.prototype.results_show = function() {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("liszt:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chzn-with-drop");
      this.form_field_jq.trigger("liszt:showing_dropdown", {
        chosen: this
      });
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };
    Chosen2.prototype.results_hide = function() {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chzn-with-drop");
        this.form_field_jq.trigger("liszt:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };
    Chosen2.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field_jq.attr("tabindex")) {
        ti = this.form_field_jq.attr("tabindex");
        this.form_field_jq.attr("tabindex", -1);
        return this.search_field.attr("tabindex", ti);
      }
    };
    Chosen2.prototype.set_label_behavior = function() {
      var _this = this;
      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.click(function(evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };
    Chosen2.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };
    Chosen2.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };
    Chosen2.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };
    Chosen2.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result")) {
        return this.result_clear_highlight();
      }
    };
    Chosen2.prototype.choice_build = function(item) {
      var choice, close_link, _this = this;
      choice = $("<li></li>", {
        "class": "search-choice"
      }).html("<span>" + item.html + "</span>");
      if (item.disabled) {
        choice.addClass("search-choice-disabled");
      } else {
        close_link = $("<a></a>", {
          href: "#",
          "class": "search-choice-close",
          rel: item.array_index
        });
        close_link.click(function(evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };
    Chosen2.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };
    Chosen2.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link.attr("rel"))) {
        this.show_search_field_default();
        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents("li").first().remove();
        return this.search_field_scale();
      }
    };
    Chosen2.prototype.results_reset = function() {
      this.form_field.options[0].selected = true;
      this.selected_option_count = null;
      this.selected_item.find("span").text(this.default_text);
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default");
      }
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };
    Chosen2.prototype.results_reset_cleanup = function() {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };
    Chosen2.prototype.result_select = function(evt) {
      var high, high_id, item, position;
      if (this.result_highlight) {
        high = this.result_highlight;
        high_id = high.attr("id");
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("liszt:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          this.search_results.find(".result-selected").removeClass("result-selected");
          this.result_single_selected = high;
          this.selected_item.removeClass("chzn-default");
        }
        high.addClass("result-selected");
        position = high_id.substr(high_id.lastIndexOf("_") + 1);
        item = this.results_data[position];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.selected_item.find("span").first().text(item.text);
          if (this.allow_single_deselect) {
            this.single_deselect_control_build();
          }
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val("");
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger("change", {
            "selected": this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        return this.search_field_scale();
      }
    };
    Chosen2.prototype.result_activate = function(el, option2) {
      if (option2.disabled) {
        return el.addClass("disabled-result");
      } else if (this.is_multiple && option2.selected) {
        return el.addClass("result-selected");
      } else {
        return el.addClass("active-result");
      }
    };
    Chosen2.prototype.result_deactivate = function(el) {
      return el.removeClass("active-result result-selected disabled-result");
    };
    Chosen2.prototype.result_deselect = function(pos) {
      var result, result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        result = $("#" + this.container_id + "_o_" + pos);
        result.removeClass("result-selected").addClass("active-result").show();
        this.result_clear_highlight();
        this.winnow_results();
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };
    Chosen2.prototype.single_deselect_control_build = function() {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after('<abbr class="search-choice-close"></abbr>');
      }
      return this.selected_item.addClass("chzn-single-with-deselect");
    };
    Chosen2.prototype.winnow_results = function() {
      var found, option2, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref1;
      this.no_results_clear();
      results = 0;
      searchText = this.search_field.val() === this.default_text ? "" : $("<div></div>").text($.trim(this.search_field.val())).html();
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
      zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
      _ref1 = this.results_data;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        option2 = _ref1[_i];
        if (!option2.empty) {
          if (option2.group) {
            $("#" + option2.dom_id).css("display", "none");
          } else {
            found = false;
            result_id = option2.dom_id;
            result = $("#" + result_id);
            if (regex.test(option2.html)) {
              found = true;
              results += 1;
            } else if (this.enable_split_word_search && (option2.html.indexOf(" ") >= 0 || option2.html.indexOf("[") === 0)) {
              parts = option2.html.replace(/\[|\]/g, "").split(" ");
              if (parts.length) {
                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                  part = parts[_j];
                  if (regex.test(part)) {
                    found = true;
                    results += 1;
                  }
                }
              }
            }
            if (found) {
              if (searchText.length) {
                startpos = option2.html.search(zregex);
                text = option2.html.substr(0, startpos + searchText.length) + "</em>" + option2.html.substr(startpos + searchText.length);
                text = text.substr(0, startpos) + "<em>" + text.substr(startpos);
              } else {
                text = option2.html;
              }
              result.html(text);
              this.result_activate(result, option2);
              if (option2.group_array_index != null) {
                $("#" + this.results_data[option2.group_array_index].dom_id).css("display", "list-item");
              }
            } else {
              if (this.result_highlight && result_id === this.result_highlight.attr("id")) {
                this.result_clear_highlight();
              }
              this.result_deactivate(result);
            }
          }
        }
      }
      if (results < 1 && searchText.length) {
        return this.no_results(searchText);
      } else {
        return this.winnow_results_set_highlight();
      }
    };
    Chosen2.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      if (!this.result_highlight) {
        selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
        do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
        if (do_high != null) {
          return this.result_do_highlight(do_high);
        }
      }
    };
    Chosen2.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };
    Chosen2.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };
    Chosen2.prototype.keydown_arrow = function() {
      var next_sib;
      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };
    Chosen2.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };
    Chosen2.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };
    Chosen2.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };
    Chosen2.prototype.keydown_checker = function(evt) {
      var stroke, _ref1;
      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          evt.preventDefault();
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };
    Chosen2.prototype.search_field_scale = function() {
      var div, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ["font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing"];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $("<div></div>", {
          "style": style_block
        });
        div.text(this.search_field.val());
        $("body").append(div);
        w = div.width() + 25;
        div.remove();
        if (!this.f_width) {
          this.f_width = this.container.outerWidth();
        }
        if (w > this.f_width - 10) {
          w = this.f_width - 10;
        }
        return this.search_field.css({
          "width": w + "px"
        });
      }
    };
    Chosen2.prototype.generate_random_id = function() {
      var string;
      string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
      while ($("#" + string).length > 0) {
        string += this.generate_random_char();
      }
      return string;
    };
    return Chosen2;
  }(AbstractChosen);
  root.Chosen = Chosen;
}).call(jQuery);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/util/Time.js
var Time = {
  DEBOUNCE_DELAY: 200,
  LOADING_FADE: 400,
  UNLOADING_FADE: 400,
  ROW_EXPANDER_TRANSITION: 150,
  HIDE_ADD_MAPPING_FORM: 300
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/components/Callout.js
function getOption(callout, option2) {
  return oktaUnderscore.resultCtx(callout.options, option2, callout) || oktaUnderscore.result(callout, option2);
}
function getTopClass(callout) {
  let klass = "infobox clearfix infobox-" + getOption(callout, "type");
  switch (getOption(callout, "size")) {
    case "standard":
      klass += "";
      break;
    case "slim":
      klass += " infobox-slim";
      break;
    case "compact":
      klass += " infobox-compact";
      break;
    case "large":
      klass += " infobox-md";
      break;
  }
  if (getOption(callout, "dismissible")) {
    klass += " infobox-dismiss";
  }
  return klass;
}
var events2 = {
  "click .infobox-dismiss-link": function(e) {
    e.preventDefault();
    this.$el.fadeOut(Time.UNLOADING_FADE, () => {
      this.trigger("dismissed");
      this.remove();
    });
  }
};
var template3 = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<a data-se="dismiss-link" class="infobox-dismiss-link" title="' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "i18n",
      "hash": {
        "bundle": "courage",
        "code": "component.dismiss"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 81
        },
        "end": {
          "line": 1,
          "column": 131
        }
      }
    })) + '" href="#"><span data-se="icon" class="dismiss-icon"></span></a>';
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<h3 data-se="header">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 286
        },
        "end": {
          "line": 1,
          "column": 295
        }
      }
    }) : helper)) + "</h3>";
  },
  "5": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<p data-se="sub-header">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "subtitle") || (depth0 != null ? lookupProperty(depth0, "subtitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "subtitle",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 347
        },
        "end": {
          "line": 1,
          "column": 359
        }
      }
    }) : helper)) + "</p>";
  },
  "7": function(container, depth0, helpers2, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<ul data-se="list" class="bullets">' + ((stack1 = lookupProperty(helpers2, "each").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "bullets") : depth0, {
      "name": "each",
      "hash": {},
      "fn": container.program(8, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 420
        },
        "end": {
          "line": 1,
          "column": 483
        }
      }
    })) != null ? stack1 : "") + "</ul>";
  },
  "8": function(container, depth0, helpers2, partials, data) {
    return '<li data-se="list-item">' + container.escapeExpression(container.lambda(depth0, depth0)) + "</li>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "dismissible") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 202
        }
      }
    })) != null ? stack1 : "") + '<span data-se="icon" class="icon ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "icon") || (depth0 != null ? lookupProperty(depth0, "icon") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
      "name": "icon",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 235
        },
        "end": {
          "line": 1,
          "column": 243
        }
      }
    }) : helper)) + '"></span>' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "title") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 252
        },
        "end": {
          "line": 1,
          "column": 307
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "subtitle") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(5, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 307
        },
        "end": {
          "line": 1,
          "column": 370
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "bullets") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(7, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 370
        },
        "end": {
          "line": 1,
          "column": 495
        }
      }
    })) != null ? stack1 : "");
  },
  "useData": true
});
var CalloutCallout = BaseView.extend(
  /** @lends src/views/components/Callout.prototype */
  {
    attributes: {
      "data-se": "callout"
    },
    /**
     * Custom HTML or view to inject to the callout
     * @type {String|Okta.View}
     */
    content: null,
    /**
     * Size of icon. options are standard, large, compact
     * @type {String}
     */
    size: "standard",
    /**
     * Type of the callout. Valid values are: info, success, warning, error, tip
     * @type {String}
     */
    type: "info",
    /**
     * Can the callout be dismissed
     * @type {Boolean}
     */
    dismissible: false,
    /**
     * Callout title
     * @type {String}
     */
    title: null,
    /**
     * Callout subtitle
     * @type {String}
     */
    subtitle: null,
    /**
     * Array of strings to render as bullet points
     * @type {Array}
     */
    bullets: null,
    /**
     * Fired after the callout is dismised - applies when
     * {@link module:Okta.internal.views.components.Callout|dismissible} is set to true
     * @event src/views/components/Callout#dismissed
     */
    constructor: function() {
      this.events = oktaUnderscore.defaults(this.events || {}, events2);
      BaseView.apply(this, arguments);
      this.$el.addClass(getTopClass(this));
      this.template = template3;
      const content = getOption(this, "content");
      if (content) {
        this.add(content);
      }
    },
    getTemplateData: function() {
      let icon = getOption(this, "type");
      const size = getOption(this, "size");
      if (icon === "tip") {
        icon = "light-bulb";
      }
      switch (size) {
        case "slim":
          icon = "";
          break;
        case "large":
          icon = [icon, "-", "24"].join("");
          break;
        default:
          icon = [icon, "-", "16"].join("");
      }
      return {
        icon,
        title: getOption(this, "title"),
        subtitle: getOption(this, "subtitle"),
        bullets: getOption(this, "bullets"),
        dismissible: getOption(this, "dismissible")
      };
    }
  }
);
var Callout = (
  /** @lends module:Okta.internal.views.components.Callout */
  {
    /**
     * Creates a {@link src/views/components/Callout|Callout}.
     * @static
     * @param {Object} options
     * @param {String|Function} [options.size] Size of icon. options are standard, large, compact, slim
     * @param {String|Okta.View} [options.content] Custom HTML or view to inject to the callout
     * @param {String|Function} [options.title] Callout title
     * @param {String|Function} [options.subtitle] Callout subtitle
     * @param {Array|Function} [options.bullets] Array of strings to render as bullet points
     * @param {Boolean|Function} [options.dismissible] Can the callout be dismissed
     * @param {String|Function} [options.type] Callout type. Valid values are: info, success, warning, error, tip
     *
     * @return {src/views/components/Callout}
     */
    create: function(options2) {
      return new CalloutCallout(options2);
    }
  }
);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/BaseInput.js
var props5 = {
  tagName: "span",
  attributes: function() {
    return {
      "data-se": "o-form-input-" + this.getNameString()
    };
  },
  /**
   * default placeholder text when options.placeholder is not defined
   */
  defaultPlaceholder: "",
  constructor: function(options2) {
    options2 = oktaUnderscore.defaults(options2 || {}, {
      inputId: options2.id || oktaUnderscore.uniqueId("input"),
      placeholder: this.defaultPlaceholder,
      inlineValidation: true,
      validateOnlyIfDirty: false
    });
    delete options2.id;
    const self2 = this;
    oktaUnderscore.each({
      enable: "removeClass",
      disable: "addClass"
    }, function(method, action2) {
      self2[action2] = oktaUnderscore.wrap(self2[action2], function(fn11) {
        fn11.apply(self2, arguments);
        self2.$el[method]("o-form-disabled");
      });
    });
    BaseView.call(this, options2);
    if (oktaUnderscore.result(options2, "readOnly") !== true && oktaUnderscore.result(options2, "read") === true) {
      this.listenTo(this.model, "change:__edit__", this.render);
    }
    if (oktaUnderscore.isFunction(this.focus)) {
      this.focus = oktaUnderscore.debounce(oktaUnderscore.bind(this.focus, this), 50);
    }
    if (!oktaUnderscore.result(options2, "validateOnlyIfDirty")) {
      this.addInlineValidation();
    }
    this.addModelListeners();
    this.$el.addClass("o-form-input-name-" + this.getNameString());
  },
  addAriaLabel: function() {
    const ariaLabel = this.options.ariaLabel;
    if (ariaLabel) {
      this.$(":input").attr("aria-label", ariaLabel);
    }
  },
  addInlineValidation: function() {
    if (oktaUnderscore.result(this.options, "inlineValidation")) {
      this.$el.on("focusout", ":input", oktaUnderscore.bind(this.validate, this));
    }
  },
  toModelValue: function() {
    let value = this.val();
    if (oktaUnderscore.isFunction(this.to)) {
      value = this.to.call(this, value);
    }
    if (oktaUnderscore.isFunction(this.options.to)) {
      value = this.options.to.call(this, value);
    }
    return value;
  },
  __getDependencyCalloutBtn: function(btnConfig) {
    const self2 = this;
    const btnOptions = oktaUnderscore.clone(btnConfig);
    const originalClick = btnOptions.click || function() {
    };
    btnOptions.click = function() {
      oktaJQueryStatic(window).one("focus.dependency", function() {
        self2.__showInputDependencies();
      });
      originalClick.call(self2);
    };
    const BaseInputCalloutBtn = BaseView.extend({
      children: [ButtonFactory.create(btnOptions)]
    });
    return new BaseInputCalloutBtn();
  },
  getCalloutParent: function() {
    return this.$('input[value="' + this.getModelValue() + '"]').parent();
  },
  __getCalloutMsgContainer: function(calloutMsg) {
    return BaseView.extend({
      template: _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return '<span class="o-form-explain">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "msg") || (depth0 != null ? lookupProperty(depth0, "msg") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "msg",
            "hash": {},
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 29
              },
              "end": {
                "line": 1,
                "column": 36
              }
            }
          }) : helper)) + "</span>";
        },
        "useData": true
      }),
      getTemplateData: function() {
        return {
          msg: calloutMsg
        };
      }
    });
  },
  showCallout: function(calloutConfig, dependencyResolved) {
    const callout = oktaUnderscore.clone(calloutConfig);
    callout.className = "dependency-callout";
    if (callout.btn) {
      callout.content = this.__getDependencyCalloutBtn(callout.btn);
      delete callout.btn;
    }
    const dependencyCallout = Callout.create(callout);
    if (!dependencyResolved) {
      dependencyCallout.add(this.__getCalloutMsgContainer(StringUtil.localize("dependency.callout.msg", "courage")));
    }
    const calloutParent = this.getCalloutParent();
    calloutParent.append(dependencyCallout.render().el);
    if (callout.type === "success") {
      oktaUnderscore.delay(function() {
        dependencyCallout.$el.fadeOut(800);
      }, 1e3);
    }
  },
  removeCallout: function() {
    this.$el.find(".dependency-callout").remove();
  },
  __evaluateCalloutObject: function(dependencyResolved, calloutTitle) {
    let defaultCallout;
    if (dependencyResolved) {
      defaultCallout = {
        title: StringUtil.localize("dependency.action.completed", "courage"),
        size: "large",
        type: "success"
      };
    } else {
      defaultCallout = {
        title: StringUtil.localize("dependency.action.required", "courage", [calloutTitle]),
        size: "large",
        type: "warning"
      };
    }
    return defaultCallout;
  },
  __handleDependency: function(result, callout) {
    const self2 = this;
    const calloutConfig = oktaUnderscore.isFunction(callout) ? callout(result) : oktaUnderscore.extend({}, callout, self2.__evaluateCalloutObject(result.resolved, callout.title));
    self2.removeCallout();
    self2.showCallout(calloutConfig, result.resolved);
  },
  __showInputDependencies: function() {
    const self2 = this;
    const fieldDependency = self2.options.deps[self2.getModelValue()];
    if (fieldDependency && oktaUnderscore.isFunction(fieldDependency.func)) {
      fieldDependency.func().done(function(data) {
        self2.__handleDependency({
          resolved: true,
          data
        }, fieldDependency.callout);
      }).fail(function(data) {
        self2.__handleDependency({
          resolved: false,
          data
        }, fieldDependency.callout);
      });
    } else {
      self2.removeCallout();
    }
  },
  _isEdited: false,
  hasIMESupport: false,
  /**
   * updates the model with the input's value
   */
  update: function(e) {
    var _window, _window$okta;
    if (!this._isEdited && oktaUnderscore.result(this.options, "validateOnlyIfDirty")) {
      this._isEdited = true;
      this.addInlineValidation();
    }
    this.model.set(this.options.name, this.toModelValue());
    if (this.options.deps) {
      this.__showInputDependencies();
    }
    if (this.hasIMESupport && (_window = window) !== null && _window !== void 0 && (_window$okta = _window.okta) !== null && _window$okta !== void 0 && _window$okta.enableIMESupport) {
      if (this.isComposing) {
        return;
      }
      if (e && Keys.isEnter(e)) {
        this.model.trigger("form:save");
      }
    }
  },
  /**
   * Is the input in edit mode
   * @return {Boolean}
   */
  isEditMode: function() {
    const ret = !oktaUnderscore.result(this.options, "readOnly") && (oktaUnderscore.result(this.options, "read") !== true || this.model.get("__edit__") === true);
    return ret;
  },
  /**
   * Renders the input
   * @readonly
   */
  render: function() {
    this.preRender();
    const params = this.options.params;
    this.options.params = oktaUnderscore.resultCtx(this.options, "params", this);
    if (this.isEditMode()) {
      this.editMode();
      if (oktaUnderscore.resultCtx(this.options, "disabled", this)) {
        this.disable();
      } else {
        this.enable();
      }
    } else {
      this.readMode();
    }
    this.options.params = params;
    this.addAriaLabel();
    this.postRender();
    return this;
  },
  /**
   * checks if the current value in the model is valid for this field
   */
  validate: function() {
    if (!this.model.get("__pending__") && this.isEditMode() && oktaUnderscore.isFunction(this.model.validateField)) {
      const validationError = this.model.validateField(this.options.name);
      if (validationError) {
        oktaUnderscore.delay((function() {
          this.model.trigger("form:clear-error:" + this.options.name);
          this.model.trigger("invalid", this.model, validationError, false);
        }).bind(this), 100);
      }
    }
  },
  /**
   * Add model event listeners
   */
  addModelListeners: function() {
    this.listenTo(this.model, "form:field-error", function(name) {
      if (this.options.name === name) {
        this.__markError();
      }
    });
    this.listenTo(this.model, "form:clear-errors change:" + this.options.name, this.__clearError);
    this.listenTo(this.model, "form:clear-error:" + this.options.name, this.__clearError);
  },
  /**
   * The value of the input
   * @return {Mixed}
   */
  val: function() {
    throw new Error("val() is an abstract method");
  },
  /**
   * Set focus on the input
   */
  focus: function() {
    throw new Error("focus() is an abstract method");
  },
  /**
   * Default value in read mode
   * When model has no value for the field
   */
  defaultValue: function() {
    return "";
  },
  /**
   * Renders the input in edit mode
   */
  editMode: function() {
    const options2 = oktaUnderscore.extend({}, this.options, {
      value: this.getModelValue()
    });
    this.$el.html(this.template(options2));
    this.options.multi && this.$el.removeClass("margin-r");
    return this;
  },
  /**
   * Renders the readable value of the input in read mode
   */
  readMode: function() {
    this.$el.text(this.getReadModeString());
    this.$el.removeClass("error-field");
    this.options.multi && this.$el.addClass("margin-r");
    return this;
  },
  getReadModeString: function() {
    const readModeStr = oktaUnderscore.resultCtx(this.options, "readModeString", this);
    if (readModeStr) {
      return readModeStr;
    }
    return this.toStringValue();
  },
  /**
   * The model value off the field associated with the input
   * @return {Mixed}
   */
  getModelValue: function() {
    let value = this.model.get(this.options.name);
    if (oktaUnderscore.isFunction(this.from)) {
      value = this.from.call(this, value);
    }
    if (oktaUnderscore.isFunction(this.options.from)) {
      value = this.options.from.call(this, value);
    }
    return value;
  },
  /*
  * convenience method to get the textual value from the model
  * will return the textual label rather than value in case of select/radio
  * @return {String}
  */
  toStringValue: function() {
    let value = this.getModelValue();
    if (this.options.options) {
      value = this.options.options[value];
    }
    if (Number.isInteger(value) || typeof value === "boolean") {
      value = String(value);
    }
    return value || this.defaultValue();
  },
  /**
   * Triggers a form:resize event in order to tell dialogs content size has changed
   */
  resize: function() {
    this.model.trigger("form:resize");
  },
  /**
   * Disable the input
   */
  disable: function() {
    this.$(":input").prop("disabled", true);
  },
  /**
   * Enable the input
   */
  enable: function() {
    this.$(":input").prop("disabled", false);
  },
  /**
   * Change the type of the input field. (e.g., text <--> password)
   * @param type
   */
  changeType: function(type) {
    this.$(":input").prop("type", type);
    this.options.type = type;
  },
  getNameString: function() {
    if (oktaUnderscore.isArray(this.options.name)) {
      return this.options.name.join("-");
    }
    return this.options.name;
  },
  /**
   * Get parameters, computing _.result
   * @param  {[type]} options alternative options
   * @return {Object} the params
   */
  getParams: function(options2) {
    const opts = options2 || this.options || {};
    return oktaUnderscore.clone(oktaUnderscore.resultCtx(opts, "params", this) || {});
  },
  /**
   * get a parameter from options.params, compute _.result when needed.
   * @param  {String} key
   * @param  {Object} defaultValue
   * @return {Object} the params
   */
  getParam: function(key, defaultValue) {
    const result = oktaUnderscore.resultCtx(this.getParams(), key, this);
    return !oktaUnderscore.isUndefined(result) ? result : defaultValue;
  },
  /**
   * Get a parameter from options.params or if empty, object attribute.
   *
   * @param  {String} key
   * @return {Object} the param or attribute
   */
  getParamOrAttribute: function(key) {
    return this.getParam(key) || oktaUnderscore.result(this, key);
  },
  __markError: function() {
    this.$el.addClass("o-form-has-errors");
  },
  __clearError: function() {
    this.$el.removeClass("o-form-has-errors");
  }
};
var BaseInput = BaseView.extend(props5);

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/Select.js
var template4 = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<select id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "inputId",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 12
        },
        "end": {
          "line": 1,
          "column": 23
        }
      }
    }) : helper)) + '" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "name",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 31
        },
        "end": {
          "line": 1,
          "column": 39
        }
      }
    }) : helper)) + '"></select>';
  },
  "useData": true
});
var option = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<option value="' + alias4((helper = (helper = lookupProperty(helpers2, "key") || (depth0 != null ? lookupProperty(depth0, "key") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "key",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 15
        },
        "end": {
          "line": 1,
          "column": 22
        }
      }
    }) : helper)) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "value") || (depth0 != null ? lookupProperty(depth0, "value") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "value",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 24
        },
        "end": {
          "line": 1,
          "column": 33
        }
      }
    }) : helper)) + "</option>";
  },
  "useData": true
});
var CHOSEN_WINDOW_MARGIN = 20;
var isSafari = Util.isSafari;
var CHOSEN_MAX_HEIGHT = 240;
var CHOSEN_Z_INDEX = 5e4;
function defer(fn11) {
  if (this.params.autoWidth) {
    return fn11.call(this);
  } else {
    return oktaUnderscore.defer(oktaUnderscore.bind(fn11, this));
  }
}
function findSelectWidth(self2) {
  self2.$select.hide();
  const select = oktaJQueryStatic(self2.$select[0]).hide();
  oktaJQueryStatic("body").append(select);
  const width = self2.params.width = select.width() * 1.2 + "px";
  self2.$el.append(select.show());
  return width;
}
function recalculateChosen($chosen, $results, $clone) {
  const offset = $clone.offset();
  $chosen.css({
    left: offset.left,
    top: offset.top
  });
  const $win = oktaJQueryStatic(window);
  const rHeight = $results.outerHeight();
  const rBottom = rHeight + $results.offset().top - $win.scrollTop();
  const wHeight = $win.height() - CHOSEN_WINDOW_MARGIN;
  const maxHeight = Math.min(rHeight + wHeight - rBottom, CHOSEN_MAX_HEIGHT);
  $results.css("max-height", maxHeight);
}
function handleKeyUpEvent($select, $chosen, $results) {
  const $highlightedOption = $results.find(".active-result.highlighted");
  $chosen.find("#" + $select.attr("id") + "_txt").attr("aria-activedescendant", $highlightedOption.attr("id"));
  $results.find("[aria-selected=true]").attr("aria-selected", "false");
  $highlightedOption.attr("aria-selected", "true");
  if (isSafari()) {
    const message = StringUtil.localize("oform.selectInput.country", "courage", [$highlightedOption.text()]);
    const elementId = $select.attr("id");
    if (message !== "") {
      oktaJQueryStatic(`#${elementId}_aria_div_id`).text(message);
    }
  }
  const noResult = $results.find("li.no-results");
  if (noResult.length) {
    noResult.attr("role", "alert");
  }
}
function fixChosenModal($select, textPlaceholder) {
  const $chosen = $select.next(".chzn-container");
  const $clone = $chosen.clone();
  const $results = $chosen.find(".chzn-results");
  const $searchInput = $chosen.find(".chzn-search input[type=text]");
  $searchInput.on("keyup", () => {
    handleKeyUpEvent($select, $chosen, $results);
  });
  $chosen.addClass("closed");
  $clone.css("visibility", "hidden");
  $clone.removeAttr("id");
  $clone.find("li").removeAttr("id");
  const baseStyles = {
    left: $chosen.css("left"),
    top: $chosen.css("top"),
    position: $chosen.css("position"),
    float: $chosen.css("float"),
    "z-index": $chosen.css("z-index")
  };
  $results.hide();
  const resizeHandler = oktaUnderscore.debounce(function() {
    recalculateChosen($chosen, $results, $clone);
  }, 10);
  $select.off(".fixChosen");
  $select.on("liszt:showing_dropdown.fixChosen", function() {
    $chosen.width($chosen.width());
    $select.after($clone);
    $chosen.css({
      position: "absolute",
      float: "none",
      "z-index": CHOSEN_Z_INDEX,
      top: -999999
    });
    oktaJQueryStatic("body").append($chosen);
    oktaJQueryStatic(".chzn-search > :text").prop("placeholder", textPlaceholder);
    $results.show();
    recalculateChosen($chosen, $results, $clone);
    $select.parents().scroll(resizeHandler);
    oktaJQueryStatic(window).on("resize scroll", resizeHandler);
  });
  $select.on("liszt:showing_dropdown", function() {
    $chosen.removeClass("closed");
  });
  $select.on("liszt:hiding_dropdown.fixChosen remove.fixChosen", function() {
    $select.parents().off("scroll", resizeHandler);
    oktaJQueryStatic(window).off("resize scroll", resizeHandler);
    $chosen.css(baseStyles);
    $results.hide();
    $chosen.addClass("closed");
    $results.css("max-height", CHOSEN_MAX_HEIGHT);
    $clone.remove();
    $select.after($chosen);
  });
  $select.on("liszt:hiding_dropdown.fixChosen", function() {
    $searchInput.focus();
  });
}
var Select = BaseInput.extend({
  className: "o-form-select",
  /**
   * @Override
   */
  events: {
    "change select": "update",
    "keyup .chzn-search > :text": function(e) {
      if (Keys.isEsc(e)) {
        this.$(".chzn-search > :text").val("");
        e.stopPropagation();
      }
    }
  },
  constructor: function() {
    this.template = template4;
    this.option = this.option || option;
    BaseInput.apply(this, arguments);
    this.params = this.options.params || {};
  },
  /**
   * @Override
   */
  editMode: function() {
    this.$el.html(template4(this.options));
    this.$select = this.$("select");
    this.appendOptions();
    const value = this.getModelValue();
    if (value) {
      this.$select.val(value);
    } else {
      this.$("option:first-child").prop("selected", true);
    }
    this.$el.addClass("o-form-control");
    if (this.params.chosen !== false) {
      this.__applyChosen();
    }
    return this;
  },
  appendOptions: function() {
    if (!this.getOptions()) {
      return;
    }
    const options2 = this.getOptions();
    const keys = Object.keys(options2);
    this.applySortByKey(keys);
    keys.forEach((key) => {
      this.$select.append(this.option({
        key,
        value: options2[key]
      }));
    });
  },
  applySortByKey: function(keys) {
    const sortByKey = this.options.sortByKey;
    if (!sortByKey) {
      return;
    }
    if (sortByKey instanceof Function) {
      keys.sort(sortByKey);
    }
    if (sortByKey === "asc") {
      keys.sort();
    }
    if (sortByKey === "desc") {
      keys.sort();
      keys.reverse();
    }
  },
  __applyChosen: function(update) {
    let width = this.options.wide ? "100%" : this.params.width || "62%";
    if (this.params.autoWidth) {
      width = findSelectWidth(this);
    }
    defer.call(this, function() {
      const searchThreshold = this.getParam("searchThreshold", 10);
      if (!oktaUnderscore.result(this.options, "autoRender") && update !== false) {
        this.update();
      }
      this.$select.chosen({
        width,
        disable_search_threshold: searchThreshold,
        //eslint-disable-line camelcase
        placeholder_text: this.options["placeholder"],
        //eslint-disable-line camelcase
        search_contains: true
        //eslint-disable-line camelcase
      });
      const isComboBox = this.options && this.options.options && Object.keys(this.options.options).length > searchThreshold;
      this.accessibilityUpdate(isComboBox, this.params);
      fixChosenModal(this.$select, this.searchPlaceholder);
      if (this.params.autoWidth) {
        this.$el.width(0);
      }
      this.model.trigger("form:resize");
    });
  },
  /**
   * @Override
   */
  val: function() {
    return this.$select && this.$select.val();
  },
  /**
   * @Override
   */
  focus: function() {
    if (this.$select) {
      return this.$select.focus();
    }
  },
  /**
   * @Override
   */
  toStringValue: function() {
    const selectedOption = this.getModelValue();
    let displayString = selectedOption;
    const options2 = this.getOptions();
    if (!oktaUnderscore.isEmpty(options2)) {
      displayString = options2[selectedOption];
    }
    if (oktaUnderscore.isUndefined(displayString)) {
      displayString = this.defaultValue();
    }
    return displayString || "";
  },
  /**
   * Convert options to an object
   * support input options that is a
   * 1. a static object such as {key1: val1, key2: val2...}
   * 2. a function to be called to return a static object
   * will return an object with key-value pairs or with empty content
   * @return {Object} The value
   */
  getOptions: function() {
    let options2 = this.options.options;
    if (oktaUnderscore.isFunction(options2)) {
      options2 = options2.call(this);
    }
    return oktaUnderscore.isObject(options2) ? options2 : {};
  },
  remove: function() {
    if (this.$select) {
      this.$select.trigger("remove");
    }
    return BaseInput.prototype.remove.apply(this, arguments);
  },
  /**
   * @param ariaDivId id for div element
   * Create a div element and add it to chosen container.
   */
  createAriaLiveNode: function(ariaDivId) {
    const $chosen = this.$select.next(".chzn-container");
    const $node = oktaJQueryStatic("<div></div>").attr("role", "log").attr("aria-live", "polite").attr("id", ariaDivId).attr("aria-relevant", "additions").attr("aria-atomic", "false").attr("class", "off-screen");
    $node.insertAfter($chosen);
  },
  /**
   * Code to make the select/combobox component accessible with screen readers.
   *
   * @param {boolean} isComboBox - Is the select a combobox?
   * @param {object} params - params like aria label
   */
  // eslint-disable-next-line max-statements
  accessibilityUpdate: function(isComboBox, params) {
    const txtBoxId = this.$select.attr("id") + "_txt";
    const ariaDivId = this.$select.attr("id") + "_aria_div_id";
    const ulTagId = this.$select.attr("id") + "_ul";
    if (isSafari()) {
      this.createAriaLiveNode(ariaDivId);
    }
    this.$("ul[class=chzn-results]").attr("role", "listbox").attr("id", ulTagId);
    if (isComboBox) {
      this.$("input[type=text]").attr("id", txtBoxId).attr("aria-autocomplete", "list").attr("aria-activedescendant", "").attr("role", "combobox").attr("aria-expanded", "true").attr("aria-controls", ulTagId);
    } else {
      this.$("input[type=text]").attr("id", txtBoxId).attr("role", "listbox");
    }
    if (params && params.aria && params.aria.label) {
      const ariaLabel = params.aria.label.trim();
      this.$("input[type=text]").attr("id", txtBoxId).attr("aria-label", ariaLabel);
      this.$("ul[class=chzn-results]").attr("aria-label", ariaLabel);
    } else {
      const ariaLabel = this.$el.parent().prev(".o-form-label").find("label").text().trim();
      this.$("input[type=text]").attr("id", txtBoxId).attr("aria-label", ariaLabel);
      this.$("ul[class=chzn-results]").attr("aria-label", ariaLabel);
    }
    this.$(".chzn-results .active-result").attr("role", "option").attr("aria-selected", "false");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/BooleanSelect.js
var options = {
  undefined: "undefined",
  true: "true",
  false: "false"
};
var from = function(val) {
  if (val) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  return "undefined";
};
var to = function(val) {
  switch (val) {
    case "undefined":
      return null;
    case "true":
      return true;
    case "false":
      return false;
    default:
      return null;
  }
};
var BooleanSelect = Select.extend({
  initialize: function() {
    this.options.options = options;
    this.options.from = from;
    this.options.to = to;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/DeletableBox.js
var isVowel = function(string) {
  return /^[aeiou]/.test(string);
};
var getArticle = function(string) {
  return isVowel(string) ? "an" : "a";
};
var template5 = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="o-form-input-group-controls"><span class="input-fix o-form-control"><input type="text" class="o-form-text" name="' + alias4((helper = (helper = lookupProperty(helpers2, "key") || (depth0 != null ? lookupProperty(depth0, "key") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "key",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 125
        },
        "end": {
          "line": 1,
          "column": 132
        }
      }
    }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "key") || (depth0 != null ? lookupProperty(depth0, "key") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "key",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 138
        },
        "end": {
          "line": 1,
          "column": 145
        }
      }
    }) : helper)) + '" value="' + alias4((helper = (helper = lookupProperty(helpers2, "value") || (depth0 != null ? lookupProperty(depth0, "value") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "value",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 154
        },
        "end": {
          "line": 1,
          "column": 163
        }
      }
    }) : helper)) + '" placeholder="' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "placeholder",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 178
        },
        "end": {
          "line": 1,
          "column": 193
        }
      }
    }) : helper)) + '"/></span><a href="#" class="link-button link-button-icon icon-only"><span class="icon clear-input-16 "></span></a></div><p class="o-form-input-error o-form-explain"><span class="icon icon-16 error-16-small"></span>' + alias4((helper = (helper = lookupProperty(helpers2, "errorExplain") || (depth0 != null ? lookupProperty(depth0, "errorExplain") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "errorExplain",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 408
        },
        "end": {
          "line": 1,
          "column": 424
        }
      }
    }) : helper)) + "</p>";
  },
  "useData": true
});
var errorClass = "o-form-has-errors";
var updateArrayEvent = "updateArray";
var DeletableBox = BaseView.extend({
  tagName: "div",
  className: "o-form-input-group",
  events: {
    "click a": function(e) {
      e.preventDefault();
      this.remove();
    },
    "keyup input": function() {
      this.update();
    }
  },
  isEditMode: function() {
    return !this.options.readOnly && (this.options.read !== true || this.model.get("__edit__") === true);
  },
  initialize: function() {
    this.template = template5(oktaUnderscore.extend(this.options, {
      placeholder: this.getPlaceholderText(),
      errorExplain: this.getErrorExplainText()
    }));
    this.update = oktaUnderscore.debounce(this.update, this.options.debounceDelay || Time.DEBOUNCE_DELAY);
  },
  render: function() {
    if (this.isEditMode()) {
      this.$el.html(this.template);
    } else {
      this.$el.text(this.options.value);
      this.$("a").hide();
    }
    return this;
  },
  remove: function() {
    this.trigger(updateArrayEvent, null);
    this.$el.slideUp(() => {
      BaseView.prototype.remove.call(this, arguments);
    });
  },
  update: function() {
    let updatedValue = this.$("input").val();
    const parseFunc = oktaUnderscore.object([SchemaUtils.DATATYPE.number, SchemaUtils.DATATYPE.integer], [StringUtil.parseFloat, this.parseInt]);
    if (oktaUnderscore.has(parseFunc, this.options.itemType)) {
      updatedValue = parseFunc[this.options.itemType](updatedValue);
      !oktaUnderscore.isNumber(updatedValue) ? this.markInvalid() : this.clearInvalid();
    }
    this.trigger(updateArrayEvent, updatedValue);
  },
  markInvalid: function() {
    this.$el.addClass(errorClass);
  },
  clearInvalid: function() {
    this.$el.removeClass(errorClass);
  },
  getPlaceholderText: function() {
    const text = ["Enter"];
    text.push(getArticle(this.options.itemType));
    text.push(this.options.itemType.toLowerCase());
    return text.join(" ");
  },
  getErrorExplainText: function() {
    const text = ["Value must be"];
    text.push(getArticle(this.options.itemType));
    text.push(this.options.itemType.toLowerCase());
    return text.join(" ");
  },
  parseInt: function(string) {
    if (/^-?\d+$/.test(string)) {
      const num = parseInt(string, 10);
      return !oktaUnderscore.isNaN(num) ? num : string;
    }
    return string;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/TextBoxSet.js
var TextBoxSet = BaseInput.extend({
  className: "array-input",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="array-inputs-button link-button">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "courage",
          "code": "oform.add.another"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 52
          },
          "end": {
            "line": 1,
            "column": 102
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  params: {
    itemType: "string"
  },
  events: {
    "click .array-inputs-button": function(e) {
      e.preventDefault();
      if (this.isEditMode()) {
        this.addNewElement();
      }
    }
  },
  initialize: function(options2) {
    options2 || (options2 = {});
    this.params = oktaUnderscore.defaults(options2.params || {}, this.params);
    this.uniqueIdPrefix = "array";
  },
  // api returns null for an array that does not have value
  // convert it to an empty array
  from: function(val) {
    if (!oktaUnderscore.isArray(val)) {
      return [];
    }
    return val;
  },
  // @Override
  editMode: function() {
    this._setArrayObject();
    this.$el.html(this.template);
    oktaUnderscore.each(this.arrayObject, oktaUnderscore.bind(this._addDeletableBox, this));
    return this;
  },
  // @Override
  readMode: function() {
    this.editMode();
    this.$(".array-inputs-button").addClass("link-button-disabled");
  },
  // @Override
  // converts arrayObject to a plain array
  // for string type array, returns all values
  // for number/integer type array, returns values in number type
  val: function() {
    let values = oktaUnderscore.values(this.arrayObject);
    if (oktaUnderscore.contains([SchemaUtils.DATATYPE.number, SchemaUtils.DATATYPE.integer], this.params.itemType)) {
      values = oktaUnderscore.filter(values, oktaUnderscore.isNumber);
    }
    return values;
  },
  focus: function() {
  },
  addNewElement: function() {
    const value = "";
    const key = oktaUnderscore.uniqueId(this.uniqueIdPrefix);
    this.arrayObject[key] = value;
    this._addDeletableBox(value, key);
    this.update();
  },
  _addDeletableBox: function(value, key) {
    const deletableBox = new DeletableBox(oktaUnderscore.extend(oktaUnderscore.pick(this.options, "read", "readOnly", "model"), {
      key,
      value,
      itemType: this.params.itemType
    }));
    this.listenTo(deletableBox, "updateArray", function(updatedValue) {
      if (oktaUnderscore.isNull(updatedValue)) {
        delete this.arrayObject[key];
        this.stopListening(deletableBox);
      } else {
        this.arrayObject[key] = updatedValue;
      }
      this.update();
    });
    deletableBox.render().$el.hide();
    this.$(".array-inputs-button").before(deletableBox.el);
    deletableBox.$el.slideDown();
    return deletableBox;
  },
  _setArrayObject: function() {
    const array = this.model.get(this.options.name);
    this.arrayObject = {};
    if (oktaUnderscore.isArray(array) && !oktaUnderscore.isEmpty(array)) {
      const keys = [];
      const self2 = this;
      oktaUnderscore(array.length).times(function() {
        keys.push(oktaUnderscore.uniqueId(self2.uniqueIdPrefix));
      });
      this.arrayObject = oktaUnderscore.object(keys, array);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/helpers/SchemaFormFactory.js
function convertStringToNumber(string) {
  const number = StringUtil.parseFloat(string);
  return string === "" ? null : number;
}
function getChoices(values) {
  return oktaUnderscore.object(values, values);
}
function isArray2(type) {
  return type && type.indexOf("array") >= 0;
}
function getObjectName(schemaProp) {
  const items = schemaProp.get("items");
  if (items) {
    return items.objectName;
  }
  return schemaProp.get("objectName");
}
function isValidSchemaProp(schemaProp, values) {
  const objectName = getObjectName(schemaProp);
  const results = values[objectName];
  if (objectName && oktaUnderscore(results).isEmpty()) {
    return false;
  }
  return true;
}
function defaultOptions(property) {
  const type = property.get("__displayType__");
  const values = property.get("__possibleValues__");
  const name = property.get("name");
  const title = property.get("title");
  const inputOptions = {
    type: "text",
    name,
    label: title || name
  };
  switch (type) {
    case "arrayofstring":
      inputOptions.input = TextBoxSet;
      inputOptions.params = {
        itemType: "string"
      };
      break;
    case "arrayofnumber":
      inputOptions.input = TextBoxSet;
      inputOptions.params = {
        itemType: "number"
      };
      break;
    case "arrayofinteger":
      inputOptions.input = TextBoxSet;
      inputOptions.params = {
        itemType: "integer"
      };
      break;
    case "arrayofobject":
      inputOptions.input = TextBoxSet;
      inputOptions.params = {
        itemType: property.get("items").type
      };
      break;
    case "arrayofref-id":
      inputOptions.input = TextBoxSet;
      inputOptions.params = {
        itemType: property.get("items").format
      };
      break;
    case "boolean":
      inputOptions.input = BooleanSelect;
      break;
    case "integer":
    case "number":
      inputOptions.to = convertStringToNumber;
      break;
    case "reference":
      inputOptions.type = "select";
      inputOptions.options = getChoices(values);
      break;
    case "image":
      inputOptions.readOnly = true;
      inputOptions.from = function(value) {
        return oktaUnderscore.isEmpty(value) ? "" : StringUtil.localize("user.profile.image.image_set", "courage");
      };
      break;
    case "password":
      inputOptions.type = "password";
      break;
    case "date":
      inputOptions.type = "date";
      break;
    case "uri":
    case "country-code":
    case "country_code":
    case "language-code":
    case "language_code":
    case "email":
    case "locale":
    case "timezone":
    case "string":
    case "object":
      break;
    default:
      throw new Error(`unknown type: ${type}`);
  }
  return inputOptions;
}
function customOptions(property) {
  let inputOptions = {};
  const name = property.get("name");
  const type = property.get("__displayType__");
  const values = property.get("__possibleValues__");
  const prefix = property.get("__fieldNamePrefix__");
  if (prefix) {
    inputOptions.name = prefix + name;
    inputOptions.errorField = name;
  }
  if (property.isEnumType()) {
    const configs = {
      displayType: type,
      title: property.get("title"),
      enumValues: property.getEnumValues()
    };
    inputOptions = oktaUnderscore.extend({}, EnumTypeHelper.getEnumInputOptions(configs), inputOptions);
  } else if (isArray2(type) && values) {
    inputOptions.type = "checkboxset";
    inputOptions.input = null;
    inputOptions.options = getChoices(values);
  }
  return inputOptions;
}
function augmentSchemaProp(schemaProp, possibleValues, profile) {
  const name = schemaProp.get("name");
  const prefix = profile.__nestedProperty__;
  let defaultValues = possibleValues[name];
  const userValues = profile.get(name);
  let values;
  if (prefix) {
    schemaProp.set("__fieldNamePrefix__", prefix);
  }
  const fixedValues = possibleValues[getObjectName(schemaProp)];
  if (defaultValues && userValues) {
    defaultValues = oktaUnderscore.union(defaultValues, userValues);
  }
  if (fixedValues && fixedValues.length) {
    values = fixedValues;
  } else if (defaultValues && defaultValues.length) {
    values = defaultValues;
  }
  schemaProp.set("__possibleValues__", values);
}
function augmentSchemaProps(schemaProps, possibleValues, profile) {
  schemaProps.each(function(schemaProp) {
    augmentSchemaProp(schemaProp, possibleValues, profile);
  });
  return schemaProps;
}
function cleanSchema(properties, values) {
  return properties.filter(function(schema) {
    return isValidSchemaProp(schema, values);
  });
}
var SchemaFormFactory = {
  /**
   * Creates the options hash for BaseForm.addInput from a prepared schema
   * property.
   *
   * @param {Okta.Model} [preparedSchemaProp] A schema property backbone model
   * that has been standardized by the prepareSchema method.
   * @return {Object} An object containing all of the options needed by
   * BaseForm's addInput()
   */
  createInputOptions: function(preparedSchemaProp) {
    const custom = customOptions(preparedSchemaProp);
    const standard = defaultOptions(preparedSchemaProp);
    if (custom.params && standard.params) {
      custom.params = oktaUnderscore.defaults(custom.params, standard.params);
    }
    return oktaUnderscore.defaults(custom, standard);
  },
  hasValidSchemaProps: function(schemaProps, possibleValues) {
    if (oktaUnderscore.isEmpty(schemaProps)) {
      return false;
    }
    const validSchema = cleanSchema(schemaProps, possibleValues);
    return !!validSchema.length;
  },
  /**
   * This method is responsible for preparing a collection for the form
   * factory to use by putting all of the information to create an input
   * into the schema property and removing invalid properties.
   * The typical UD form takes 3 models:
   * The data model has the input values.
   * The schema model describes which input to use, such as a textbox or a checkbox.
   * The possible values model provide a list of default options to display, for example in a drop down menu.
   *
   * @param {SchemaProperty Collection} [schemaProps] A schema property backbone model.
   * @param {Object} [possibleValues] An object of the form { key: [value1, value2]}
   * @param {Okta.Model} [profile] A backbone model containing the property described by the schema property.
   * @return {SchemaProperty Collection} A schema property collection with standardized models.
   * The standard schema model adds a couple of additional private properties to
   * allow the form factory to reference lookup values or name prefixes without going to a second model.
   */
  prepareSchema: function(schemaProps, possibleValues, profile) {
    schemaProps.reset(cleanSchema(schemaProps, possibleValues));
    return augmentSchemaProps(schemaProps, possibleValues, profile);
  },
  /**
   * `prepareSchema` will reset the property list which may not be necessary at some case.
   * like when setting default value for schema properties.
   * (more detail about such case @see wiki UX, App+Entitlements+for+Provisioning)
   *
   * @param { }
   * @return {String}
   */
  augmentSchemaProps,
  augmentSchemaProp
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/plugins/jquery.custominput.js
(function() {
  var jQuery2 = jquery1_12_4.exports;
  var $ = jQuery2;
  jQuery2.fn.customInput = function() {
    return $(this).each(function() {
      if ($(this).is("[type=checkbox],[type=radio]")) {
        var input = $(this);
        var label = input.siblings('label[for="' + input.attr("id") + '"]:first');
        if (!label.length) {
          label = input.closest('label[for="' + input.attr("id") + '"]:first');
        }
        input.add(label).wrapAll('<div class="custom-' + input.attr("type") + '"></div>');
        label.hover(function() {
          $(this).addClass("hover");
        }, function() {
          $(this).removeClass("hover");
        });
        input.bind("updateState", function() {
          input.is(":checked") ? label.addClass("checked") : label.removeClass("checked checkedHover checkedFocus");
        }).trigger("updateState").click(function() {
          $('input[name="' + $(this).attr("name") + '"]').trigger("updateState");
        }).focus(function() {
          label.addClass("focus");
          if (input.is(":checked")) {
            $(this).addClass("checkedFocus");
          }
        }).blur(function() {
          label.removeClass("focus checkedFocus");
        });
      }
    });
  };
})();

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/CheckBox.js
var CheckBox = BaseInput.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<input type="checkbox" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 29
          },
          "end": {
            "line": 1,
            "column": 37
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 54
          }
        }
      }) : helper)) + '"/><label for="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 69
          },
          "end": {
            "line": 1,
            "column": 80
          }
        }
      }) : helper)) + '" data-se-for-name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 100
          },
          "end": {
            "line": 1,
            "column": 108
          }
        }
      }) : helper)) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 110
          },
          "end": {
            "line": 1,
            "column": 125
          }
        }
      }) : helper)) + "</label>";
    },
    "useData": true
  }),
  /**
   * @Override
   */
  events: {
    "change :checkbox": "update",
    keyup: function(e) {
      e.preventDefault();
      if (Keys.isSpaceBar(e)) {
        this.$(":checkbox").click();
      } else if (Keys.isEnter(e)) {
        this.model.trigger("form:save");
      }
    }
  },
  /**
   * @Override
   */
  editMode: function() {
    let placeholder = oktaUnderscore.resultCtx(this.options, "placeholder", this);
    if (placeholder === "") {
      placeholder = oktaUnderscore.resultCtx(this.options, "label", this);
    } else if (placeholder === false) {
      placeholder = "";
    }
    this.$el.html(this.template(oktaUnderscore.extend(oktaUnderscore.omit(this.options, "placeholder"), {
      placeholder
    })));
    const $input = this.$(":checkbox");
    $input.prop("checked", this.getModelValue() || false);
    this.$("input").customInput();
    this.model.trigger("form:resize");
    return this;
  },
  /**
   * @Override
   */
  readMode: function() {
    this.editMode();
    this.$(":checkbox").prop("disabled", true);
    return this;
  },
  /**
   * @Override
   */
  val: function() {
    return this.$(":checkbox").prop("checked");
  },
  /**
   * @Override
   */
  focus: function() {
    return this.$(":checkbox").focus();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/plugins/jquery.placeholder.js
(function() {
  var $ = jquery1_12_4.exports;
  var isInputSupported = "placeholder" in document.createElement("input"), isTextareaSupported = "placeholder" in document.createElement("textarea"), prototype = $.fn, valHooks = $.valHooks, hooks, placeholder;
  if (isInputSupported && isTextareaSupported) {
    placeholder = prototype.placeholder = function() {
      return this;
    };
    placeholder.input = placeholder.textarea = true;
  } else {
    placeholder = prototype.placeholder = function() {
      var $this = this;
      $this.filter((isInputSupported ? "textarea" : ":input") + "[placeholder]").not(".placeholder").bind({
        "focus.placeholder": clearPlaceholder,
        "blur.placeholder": setPlaceholder
      }).data("placeholder-enabled", true).trigger("blur.placeholder");
      return $this;
    };
    placeholder.input = isInputSupported;
    placeholder.textarea = isTextareaSupported;
    hooks = {
      "get": function(element) {
        var $element = $(element);
        return $element.data("placeholder-enabled") && $element.hasClass("placeholder") ? "" : element.value;
      },
      "set": function(element, value) {
        var $element = $(element);
        if (!$element.data("placeholder-enabled")) {
          return element.value = value;
        }
        if (value == "") {
          element.value = value;
          if (element != document.activeElement) {
            setPlaceholder.call(element);
          }
        } else if ($element.hasClass("placeholder")) {
          clearPlaceholder.call(element, true, value) || (element.value = value);
        } else {
          element.value = value;
        }
        return $element;
      }
    };
    isInputSupported || (valHooks.input = hooks);
    isTextareaSupported || (valHooks.textarea = hooks);
    $(function() {
      $(document).delegate("form", "submit.placeholder", function() {
        var $inputs = $(".placeholder", this).each(clearPlaceholder);
        setTimeout(function() {
          $inputs.each(setPlaceholder);
        }, 10);
      });
    });
    $(window).bind("beforeunload.placeholder", function() {
      $(".placeholder").each(function() {
        this.value = "";
      });
    });
  }
  function args(elem) {
    var newAttrs = {}, rinlinejQuery = /^jQuery\d+$/;
    $.each(elem.attributes, function(i, attr) {
      if (attr.specified && !rinlinejQuery.test(attr.name)) {
        newAttrs[attr.name] = attr.value;
      }
    });
    return newAttrs;
  }
  function clearPlaceholder(event, value) {
    var input = this, $input = $(input);
    if (input.value == $input.attr("placeholder") && $input.hasClass("placeholder")) {
      if ($input.data("placeholder-password")) {
        $input = $input.hide().next().show().attr("id", $input.removeAttr("id").data("placeholder-id"));
        if (event === true) {
          return $input[0].value = value;
        }
        $input.focus();
      } else {
        input.value = "";
        $input.removeClass("placeholder");
        input == document.activeElement && input.select();
      }
    }
  }
  function setPlaceholder() {
    var $replacement, input = this, $input = $(input), id = this.id;
    if (input.value == "") {
      if (input.type == "password") {
        if (!$input.data("placeholder-textinput")) {
          try {
            $replacement = $input.clone().attr({
              "type": "text"
            });
          } catch (e) {
            $replacement = $("<input>").attr($.extend(args(this), {
              "type": "text"
            }));
          }
          $replacement.removeAttr("name").data({
            "placeholder-password": true,
            "placeholder-id": id
          }).bind("focus.placeholder", clearPlaceholder);
          $input.data({
            "placeholder-textinput": $replacement,
            "placeholder-id": id
          }).before($replacement);
        }
        $input = $input.removeAttr("id").hide().prev().attr("id", id).show();
      }
      $input.addClass("placeholder");
      $input[0].value = $input.attr("placeholder");
    } else {
      $input.removeClass("placeholder");
    }
  }
})();

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/TextBox.js
var className = "okta-form-input-field input-fix";
function hasTitleAndText(options2) {
  const title = options2.title;
  const text = options2.text;
  return title && text && title !== text;
}
function createQtipContent(options2) {
  if (hasTitleAndText(options2)) {
    return options2;
  }
  return {
    text: options2.text || options2
  };
}
var TextBox = BaseInput.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      return '<span class="input-tooltip icon form-help-16"></span>';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon input-icon ' + container.escapeExpression(container.lambda((stack1 = depth0 != null ? lookupProperty(depth0, "params") : depth0) != null ? lookupProperty(stack1, "icon") : stack1, depth0)) + '"></span>';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "autoComplete") || (depth0 != null ? lookupProperty(depth0, "autoComplete") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "autoComplete",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 333
          },
          "end": {
            "line": 1,
            "column": 349
          }
        }
      }) : helper));
    },
    "7": function(container, depth0, helpers2, partials, data) {
      return "off";
    },
    "9": function(container, depth0, helpers2, partials, data) {
      return '<span class="input-icon-divider"></span>';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, (stack1 = depth0 != null ? lookupProperty(depth0, "params") : depth0) != null ? lookupProperty(stack1, "innerTooltip") : stack1, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 87
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, (stack1 = depth0 != null ? lookupProperty(depth0, "params") : depth0) != null ? lookupProperty(stack1, "icon") : stack1, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 87
          },
          "end": {
            "line": 1,
            "column": 166
          }
        }
      })) != null ? stack1 : "") + '<input type="' + alias4((helper = (helper = lookupProperty(helpers2, "type") || (depth0 != null ? lookupProperty(depth0, "type") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "type",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 179
          },
          "end": {
            "line": 1,
            "column": 187
          }
        }
      }) : helper)) + '" placeholder="' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 202
          },
          "end": {
            "line": 1,
            "column": 217
          }
        }
      }) : helper)) + '" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 225
          },
          "end": {
            "line": 1,
            "column": 233
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 239
          },
          "end": {
            "line": 1,
            "column": 250
          }
        }
      }) : helper)) + '" value="' + alias4((helper = (helper = lookupProperty(helpers2, "value") || (depth0 != null ? lookupProperty(depth0, "value") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "value",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 259
          },
          "end": {
            "line": 1,
            "column": 268
          }
        }
      }) : helper)) + '" aria-label="' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 282
          },
          "end": {
            "line": 1,
            "column": 297
          }
        }
      }) : helper)) + '" autocomplete="' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "autoComplete") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.program(7, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 313
          },
          "end": {
            "line": 1,
            "column": 367
          }
        }
      })) != null ? stack1 : "") + '" />' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, (stack1 = depth0 != null ? lookupProperty(depth0, "params") : depth0) != null ? lookupProperty(stack1, "iconDivider") : stack1, {
        "name": "if",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 371
          },
          "end": {
            "line": 1,
            "column": 444
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  /**
   * @Override
   */
  events: {
    "input input": "update",
    "change input": "update",
    "keydown input": "update",
    "compositionend input": function() {
      this.isComposing = false;
    },
    "compositionstart input": function() {
      this.isComposing = true;
    },
    "keyup input": function(e) {
      if (Keys.isEnter(e) && !(window.okta && window.okta.enableIMESupport)) {
        this.model.trigger("form:save");
      } else if (Keys.isEsc(e)) {
        this.model.trigger("form:cancel");
      }
    }
  },
  hasIMESupport: true,
  constructor: function() {
    BaseInput.apply(this, arguments);
    this.$el.addClass("o-form-control");
  },
  /**
   * @Override
   */
  editMode: function() {
    this.$el.addClass(className);
    BaseInput.prototype.editMode.apply(this, arguments);
    this.$("input").placeholder();
  },
  /**
   * @Override
   */
  readMode: function() {
    BaseInput.prototype.readMode.apply(this, arguments);
    if (this.options.type === "password") {
      this.$el.text("********");
    }
    this.$el.removeClass(className);
  },
  /**
   * @Override
   */
  val: function() {
    let inputValue = this.$('input[type="' + this.options.type + '"]').val();
    if (this.options.type !== "password") {
      inputValue = oktaJQueryStatic.trim(inputValue);
    }
    return inputValue;
  },
  /**
   * @Override
   */
  focus: function() {
    return this.$("input").focus();
  },
  postRender: function() {
    const {
      params
    } = this.options;
    if (params && params.innerTooltip) {
      const content = createQtipContent(params.innerTooltip);
      this.$(".input-tooltip").qtip({
        content,
        style: {
          classes: "okta-tooltip qtip-custom qtip-shadow"
        },
        position: {
          my: "bottom left",
          // Note: qTip2 has a known issue calculating the tooltip offset when:
          // 1. A container element has both:
          //    a) position: relative/absolute
          //    b) overlay: value other than 'visible'
          // 2. The page is scrolled
          //
          // We set position:relative and overlay:auto on the body element,
          // where both are required for:
          // - Positioning the footer correctly
          // - Displaying long pages in embedded browsers
          //
          // The original design called for a fixed position relative to the
          // tooltip icon - this has been switched to "relative to mouse, and
          // update position when mouse moves" because of this constraint.
          target: "mouse",
          adjust: {
            method: "flip",
            mouse: true,
            y: -5,
            x: 5
          },
          viewport: oktaJQueryStatic("body")
        }
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/PasswordBox.js
var toggleTemplate = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    return '<span class="password-toggle"><span class="eyeicon visibility-16 button-show"></span><span class="eyeicon visibility-off-16 button-hide"></span></span>';
  },
  "useData": true
});
var toggleTimeout = 3e4;
var PasswordBox = TextBox.extend({
  initialize: function() {
    if (this.__showPasswordToggle()) {
      this.events["click .password-toggle .button-show"] = "__showPassword";
      this.events["click .password-toggle .button-hide"] = "__hidePassword";
    }
    this.delegateEvents();
  },
  postRender: function() {
    if (this.isEditMode() && this.__showPasswordToggle()) {
      this.$el.append(toggleTemplate);
      this.$el.find('input[type="password"]').addClass("password-with-toggle");
    }
    TextBox.prototype.postRender.apply(this, arguments);
  },
  __showPasswordToggle: function() {
    return this.options.params && this.options.params.showPasswordToggle;
  },
  __showPassword: function() {
    TextBox.prototype.changeType.apply(this, ["text"]);
    this.$(".password-toggle .button-show").hide();
    this.$(".password-toggle .button-hide").show();
    this.passwordToggleTimer = oktaUnderscore.delay(() => {
      this.__hidePassword();
    }, toggleTimeout);
  },
  __hidePassword: function() {
    TextBox.prototype.changeType.apply(this, ["password"]);
    this.$(".password-toggle .button-show").show();
    this.$(".password-toggle .button-hide").hide();
    if (this.passwordToggleTimer) {
      clearTimeout(this.passwordToggleTimer);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/Radio.js
var isABaseView2 = Util.isABaseView;
var RadioRadioOption = BaseView.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<input type="radio" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 26
          },
          "end": {
            "line": 1,
            "column": 34
          }
        }
      }) : helper)) + '" data-se-name="' + alias4((helper = (helper = lookupProperty(helpers2, "realName") || (depth0 != null ? lookupProperty(depth0, "realName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "realName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 50
          },
          "end": {
            "line": 1,
            "column": 62
          }
        }
      }) : helper)) + '" value="' + alias4((helper = (helper = lookupProperty(helpers2, "value") || (depth0 != null ? lookupProperty(depth0, "value") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "value",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 71
          },
          "end": {
            "line": 1,
            "column": 80
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "optionId") || (depth0 != null ? lookupProperty(depth0, "optionId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "optionId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 86
          },
          "end": {
            "line": 1,
            "column": 98
          }
        }
      }) : helper)) + '"><label for="' + alias4((helper = (helper = lookupProperty(helpers2, "optionId") || (depth0 != null ? lookupProperty(depth0, "optionId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "optionId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 112
          },
          "end": {
            "line": 1,
            "column": 124
          }
        }
      }) : helper)) + '" data-se-for-name="' + alias4((helper = (helper = lookupProperty(helpers2, "realName") || (depth0 != null ? lookupProperty(depth0, "realName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "realName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 144
          },
          "end": {
            "line": 1,
            "column": 156
          }
        }
      }) : helper)) + '" class="radio-label">' + alias4((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 178
          },
          "end": {
            "line": 1,
            "column": 187
          }
        }
      }) : helper)) + "</label>";
    },
    "useData": true
  }),
  initialize: function(options2) {
    let explain;
    explain = options2.explain;
    if (oktaUnderscore.isFunction(explain) && !isABaseView2(explain)) {
      explain = oktaUnderscore.resultCtx(this.options, "explain", this);
    }
    if (!explain) {
      return;
    }
    if (isABaseView2(explain)) {
      this.add('<p class="o-form-explain"></p>', ".radio-label");
      this.add(explain, ".o-form-explain");
    } else {
      this.add(BaseView.extend({
        className: "o-form-explain",
        tagName: "p",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "explain") || (depth0 != null ? lookupProperty(depth0, "explain") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "explain",
              "hash": {},
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 0
                },
                "end": {
                  "line": 1,
                  "column": 11
                }
              }
            }) : helper));
          },
          "useData": true
        })
      }), ".radio-label");
    }
  }
});
var Radio = BaseInput.extend({
  /**
   * @Override
   */
  events: {
    "change :radio": "update",
    keyup: function(e) {
      if (Keys.isSpaceBar(e)) {
        oktaJQueryStatic(e.target).click();
      } else if (Keys.isEnter(e)) {
        this.model.trigger("form:save");
      }
    }
  },
  /**
   * @Override
   */
  editMode: function() {
    const templates = [];
    this.$el.empty();
    oktaUnderscore.each(this.options.options, function(value2, key) {
      const options2 = {
        optionId: oktaUnderscore.uniqueId("option"),
        name: this.options.inputId,
        realName: this.options.name,
        value: key
      };
      if (!oktaUnderscore.isObject(value2)) {
        value2 = {
          label: value2
        };
      }
      oktaUnderscore.extend(options2, value2);
      templates.push(new RadioRadioOption(options2).render().el);
    }, this);
    this.$el.append(templates);
    let value = this.getModelValue();
    if (value) {
      this.$(":radio[value=" + value + "]").prop("checked", true);
    }
    this.$("input").customInput();
    this.model.trigger("form:resize");
    if (this.getParam("inline") === true) {
      this.$("div.custom-radio").addClass("inline");
    }
    return this;
  },
  /**
   * @Override
   */
  readMode: function() {
    this.editMode();
    this.$(":radio").prop("disabled", true);
    return this;
  },
  /**
   * @Override
   */
  val: function() {
    return this.$(":radio:checked").val();
  },
  /**
   * @Override
   */
  focus: function() {
    return this.$("label:eq(0)").focus();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/views/forms/inputs/InputGroup.js
function countInputs(inputs) {
  return oktaUnderscore.filter(inputs || [], function(input) {
    return !oktaUnderscore.contains(["label", "button", "select"], input.type);
  }).length;
}
var InputGroupLabelInput = BaseInput.extend({
  tagName: "span",
  initialize: function() {
    this.$el.text(this.getModelValue());
  },
  editMode: function() {
    this.toggle(true);
  },
  readMode: function() {
    this.toggle(false);
  },
  getModelValue: function() {
    return this.options.label;
  },
  toggle: function(isEditMode) {
    this.$el.toggleClass("o-form-label-inline", isEditMode);
    this.$el.toggleClass("o-form-control", !isEditMode);
  },
  focus: oktaUnderscore.noop
});
function createButtonInput(options2) {
  return ButtonFactory.create(oktaUnderscore.defaults({
    getReadModeString: oktaUnderscore.constant(" "),
    focus: oktaUnderscore.noop
  }, oktaUnderscore.pick(options2, "click", "title", "href", "icon")));
}
var InputGroupInputGroupView = BaseView.extend({
  getParams: BaseInput.prototype.getParams,
  getParam: BaseInput.prototype.getParam,
  className: function() {
    let className2;
    if (this.getParam("noBaseClasses")) {
      return "";
    }
    if (this.getParam("display") === "text") {
      className2 = "o-form-input-group-subtle";
    } else {
      className2 = "o-form-input-group";
    }
    if (countInputs(this.getParam("inputs")) > 1) {
      className2 += " o-form-input-group-2";
    }
    return className2;
  },
  initialize: function() {
    oktaUnderscore.each(this.getParam("inputs"), function(input) {
      switch (input.type) {
        case "label":
          this.add(InputGroupLabelInput, {
            options: input
          });
          break;
        case "button":
          this.add(createButtonInput(input));
          break;
        default:
          input = oktaUnderscore.defaults({
            model: this.model,
            params: oktaUnderscore.extend({
              autoWidth: true
            }, input.params || {})
          }, input);
          this.add(this.getParams().create(input));
      }
    }, this);
  },
  focus: function() {
    this.first().focus();
  }
});
var InputGroup = BaseInput.extend({
  constructor: function(options2) {
    this.inputGroupView = new InputGroupInputGroupView(options2);
    BaseInput.apply(this, arguments);
  },
  editMode: function() {
    this.inputGroupView.remove();
    this.inputGroupView = new InputGroupInputGroupView(this.options);
    this.$el.html(this.inputGroupView.render().el);
  },
  readMode: function() {
    if (this.getParam("useChildInputsReadMode")) {
      this.editMode();
    } else {
      BaseInput.prototype.readMode.apply(this, arguments);
    }
  },
  toStringValue: function() {
    const strings = this.inputGroupView.map(function(input) {
      return input.getReadModeString();
    });
    return strings.length && oktaUnderscore.every(strings) ? strings.join(" ") : " ";
  },
  focus: function() {
    this.inputGroupView.focus();
  }
}, {
  // test hooks
  LabelInput: InputGroupLabelInput,
  InputGroupView: InputGroupInputGroupView
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/util/scrollParent.js
oktaJQueryStatic.fn.scrollParent = function(includeHidden) {
  const position = this.css("position"), excludeStaticParent = position === "absolute", overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
    const parent = oktaJQueryStatic(this);
    if (excludeStaticParent && parent.css("position") === "static") {
      return false;
    }
    return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
  }).eq(0);
  return position === "fixed" || !scrollParent.length ? oktaJQueryStatic(this[0].ownerDocument || document) : scrollParent;
};

// node_modules/@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/CourageForSigninWidget.js
FrameworkView.prototype.compileTemplate = function(str) {
  const compiledTmpl = function fakeTemplate() {
    return str;
  };
  compiledTmpl.source = "";
  return compiledTmpl;
};
var events3 = {
  "input input": "update",
  "change input": "update",
  "keydown input": "update",
  "keyup input": function(e) {
    if (Keys.isEsc(e)) {
      this.model.trigger("form:cancel");
    }
  }
};
var TextBoxForSigninWidget = TextBox.extend({
  events: events3
});
var PasswordBoxForSigninWidget = PasswordBox.extend({
  events: events3
});
var Form = BaseForm.extend({
  scrollOnError: function() {
    const {
      settings
    } = this.options;
    if (settings.get("features.scrollOnError") === false) {
      return false;
    }
    return true;
  }
});
var loc3 = StringUtil.localize;
var createButton2 = ButtonFactory.create;
var createCallout = Callout.create;
var registerInput = InputRegistry.register;
var Collection2 = BaseCollection;
var View2 = BaseView;
var Router = BaseRouter;
var Controller = BaseController;
var internal = {
  util: {
    Util,
    Cookie: Cookie2,
    Clipboard: Clipboard$1,
    Logger: Logger2,
    Class,
    Keys
  },
  views: {
    components: {
      BaseDropDown,
      Notification
    },
    forms: {
      helpers: {
        FormUtil,
        SchemaFormFactory
      },
      components: {
        Toolbar
      },
      inputs: {
        TextBox: TextBoxForSigninWidget,
        PasswordBox: PasswordBoxForSigninWidget,
        CheckBox,
        Radio,
        Select,
        InputGroup
      }
    }
  },
  models: {
    BaseSchema,
    SchemaProperty
  }
};
registerInput("text", TextBoxForSigninWidget);
registerInput("password", PasswordBoxForSigninWidget);
registerInput("checkbox", CheckBox);
registerInput("radio", Radio);
registerInput("select", Select);
registerInput("group", InputGroup);

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Enums.js
var Enums = {
  API_RATE_LIMIT: 3e4,
  //milliseconds
  WIDGET_LOGIN_CONTAINER_ID: "okta-login-container",
  WIDGET_CONTAINER_ID: "okta-sign-in",
  WIDGET_CONFIG_COLORS_ID: "okta-sign-in-config-colors",
  DIRECTION_BACK: "DIRECTION_BACK",
  RECOVERY_TYPE_PASSWORD: "PASSWORD",
  RECOVERY_TYPE_UNLOCK: "UNLOCK",
  RECOVERY_FACTOR_TYPE_SMS: "SMS",
  RECOVERY_FACTOR_TYPE_EMAIL: "EMAIL",
  RECOVERY_FACTOR_TYPE_CALL: "CALL",
  IOS: "ios",
  ANDROID: "android",
  ODA: "oda",
  MDM: "mdm",
  // Global success messages
  SUCCESS: "SUCCESS",
  FORGOT_PASSWORD_EMAIL_SENT: "FORGOT_PASSWORD_EMAIL_SENT",
  UNLOCK_ACCOUNT_EMAIL_SENT: "UNLOCK_ACCOUNT_EMAIL_SENT",
  // Global error messages
  CONFIG_ERROR: "CONFIG_ERROR",
  UNSUPPORTED_BROWSER_ERROR: "UNSUPPORTED_BROWSER_ERROR",
  OAUTH_ERROR: "OAUTH_ERROR",
  AUTH_STOP_POLL_INITIATION_ERROR: "AUTH_STOP_POLL_INITIATION_ERROR",
  U2F_ERROR: "U2F_ERROR",
  WEB_AUTHN_ERROR: "WEB_AUTHN_ERROR",
  WEBAUTHN_ABORT_ERROR: "WEBAUTHN_ABORT_ERROR",
  CONFIGURED_FLOW_ERROR: "CONFIGURED_FLOW_ERROR",
  // Enroll choice page types
  ALL_OPTIONAL_NONE_ENROLLED: "ALL_OPTIONAL_NONE_ENROLLED",
  ALL_OPTIONAL_SOME_ENROLLED: "ALL_OPTIONAL_SOME_ENROLLED",
  HAS_REQUIRED_NONE_ENROLLED: "HAS_REQUIRED_NONE_ENROLLED",
  HAS_REQUIRED_SOME_REQUIRED_ENROLLED: "HAS_REQUIRED_SOME_REQUIRED_ENROLLED",
  HAS_REQUIRED_ALL_REQUIRED_ENROLLED: "HAS_REQUIRED_ALL_REQUIRED_ENROLLED",
  // Operations
  PRIMARY_AUTH: "PRIMARY_AUTH",
  FORGOT_PASSWORD: "FORGOT_PASSWORD",
  UNLOCK_ACCOUNT: "UNLOCK_ACCOUNT",
  // Auth Types
  SESSION_SSO: "SESSION_SSO",
  SESSION_STEP_UP: "SESSION_STEP_UP",
  //Registration
  ACTIVATION_EMAIL_SENT: "ACTIVATION_EMAIL_SENT",
  REGISTRATION_COMPLETE: "REGISTRATION_COMPLETE",
  REGISTRATION_FAILED: "REGISTRATION_FAILED",
  //IDP Discovery
  IDP_DISCOVERY: "IDP_DISCOVERY",
  //App Store Links
  OKTA_VERIFY_APPLE_APP_STORE_URL: "https://apps.apple.com/us/app/okta-verify/id490179405",
  OKTA_VERIFY_GOOGLE_PLAY_STORE_URL: "https://play.google.com/store/apps/details?id=com.okta.android.auth",
  // Device Challenge Method
  LOOPBACK_CHALLENGE: "LOOPBACK",
  CUSTOM_URI_CHALLENGE: "CUSTOM_URI",
  UNIVERSAL_LINK_CHALLENGE: "UNIVERSAL_LINK",
  APP_LINK_CHALLENGE: "APP_LINK"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Errors.js
var CustomError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var ConfigError = class extends CustomError {
  constructor(message) {
    super(message || loc3("error.config"));
    this.name = Enums.CONFIG_ERROR;
  }
};
var UnsupportedBrowserError = class extends CustomError {
  constructor(message) {
    super(message || loc3("error.unsupported.browser"));
    this.name = Enums.UNSUPPORTED_BROWSER_ERROR;
  }
};
var OAuthError = class extends CustomError {
  constructor(...args) {
    super(...args);
    this.name = Enums.OAUTH_ERROR;
  }
};
var RegistrationError = class extends CustomError {
  constructor(...args) {
    super(...args);
    this.name = Enums.REGISTRATION_FAILED;
  }
};
var AuthStopPollInitiationError = class extends CustomError {
  constructor(...args) {
    super(...args);
    this.name = Enums.AUTH_STOP_POLL_INITIATION_ERROR;
  }
};
var U2FError = class extends CustomError {
  constructor(err) {
    super(err.xhr.responseJSON.errorSummary);
    this.xhr = void 0;
    this.name = Enums.U2F_ERROR;
    this.xhr = err.xhr;
  }
};
var WebAuthnError = class extends CustomError {
  constructor(err) {
    super(err.xhr.responseJSON.errorSummary);
    this.xhr = void 0;
    this.name = Enums.WEB_AUTHN_ERROR;
    this.xhr = err.xhr;
  }
};
var WebauthnAbortError = class extends CustomError {
  constructor(...args) {
    super(...args);
    this.name = Enums.WEBAUTHN_ABORT_ERROR;
  }
};
var ConfiguredFlowError = class extends CustomError {
  constructor(message, flowSetting) {
    super(message);
    this.flowSetting = void 0;
    this.name = Enums.CONFIGURED_FLOW_ERROR;
    this.flowSetting = flowSetting;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Util.js
var Util2 = {};
var buildInputForParameter = function(name, value) {
  const input = document.createElement("input");
  input.name = name;
  input.value = decodeURIComponent(value);
  input.type = "hidden";
  return input;
};
var buildSubmitInput = function() {
  const input = document.createElement("input");
  input.type = "submit";
  return input;
};
var buildDynamicForm = function(url = "", method) {
  const splitOnFragment = url.split("#");
  const fragment = splitOnFragment[1];
  const splitOnQuery = (splitOnFragment[0] || "").split("?");
  const query = splitOnQuery[1];
  let targetUrl = splitOnQuery[0];
  if (fragment) {
    targetUrl += "#" + fragment;
  }
  const form2 = document.createElement("form");
  form2.method = method;
  form2.setAttribute("style", "display: none;");
  form2.action = targetUrl;
  if (query && query.length) {
    const queryParts = query.split("&");
    queryParts.forEach((queryPart) => {
      const parameterParts = queryPart.split("=");
      const input = buildInputForParameter(parameterParts[0], parameterParts[1]);
      form2.appendChild(input);
    });
  }
  form2.appendChild(buildSubmitInput());
  return form2;
};
Util2.transformErrorXHR = function(xhr) {
  if (xhr.status === 0 && oktaUnderscore.isEmpty(xhr.responseJSON)) {
    xhr.responseJSON = {
      errorSummary: loc3("error.network.connection", "login")
    };
    return xhr;
  }
  if (!xhr.responseJSON) {
    if (!xhr.responseText) {
      xhr.responseJSON = {
        errorSummary: loc3("error.unsupported.response", "login")
      };
      return xhr;
    }
    if (typeof xhr.responseText === "string") {
      try {
        xhr.responseJSON = JSON.parse(xhr.responseText);
      } catch (e) {
        xhr.responseJSON = {
          errorSummary: loc3("error.unsupported.response", "login")
        };
        return xhr;
      }
    } else if (typeof xhr.responseText === "object") {
      xhr.responseJSON = xhr.responseText;
    }
  }
  if (xhr.responseJSON && xhr.responseJSON.errorCauses && xhr.responseJSON.errorCauses.length) {
    xhr.responseJSON.errorSummary = xhr.responseJSON.errorCauses[0].errorSummary;
  }
  if (!oktaUnderscore.isEmpty(xhr.responseJSON)) {
    const errorMsg = loc3("errors." + xhr.responseJSON.errorCode, "login");
    if (errorMsg.indexOf("L10N_ERROR[") === -1) {
      xhr.responseJSON.errorSummary = errorMsg;
      if (xhr.responseJSON && xhr.responseJSON.errorCauses && xhr.responseJSON.errorCauses.length) {
        delete xhr.responseJSON.errorCauses;
      }
    }
  }
  return xhr;
};
Util2.toLower = function(strings) {
  return oktaUnderscore.map(strings, function(str) {
    return str.toLowerCase();
  });
};
function expandLanguage(language) {
  const expanded = [language];
  const parts = language.split("-");
  while (parts.pop() && parts.length > 0) {
    expanded.push(parts.join("-"));
  }
  return expanded;
}
Util2.expandLanguages = function(languages) {
  return oktaUnderscore.chain(languages).map(expandLanguage).flatten().uniq().value();
};
Util2.callAfterTimeout = function(callback, time) {
  return setTimeout(callback, time);
};
Util2.debugMessage = function(message) {
};
Util2.logConsoleError = function(message) {
  Logger.error(message);
};
Util2.triggerAfterError = function(controller, err = {}) {
  if (!err.statusCode && err.xhr && err.xhr.status) {
    err.statusCode = err.xhr.status;
  }
  const className2 = oktaUnderscore.isFunction(controller.className) ? controller.className() : controller.className;
  const error = oktaUnderscore.pick(err, "name", "message", "statusCode", "xhr");
  controller.trigger("afterError", {
    controller: className2
  }, error);
};
Util2.redirect = function(url, win = window, isAppLink = false) {
  if (!url) {
    Logger.error(`Cannot redirect to empty URL: (${url})`);
    return;
  }
  if (fn.isAndroid() && !isAppLink) {
    Util2.redirectWithFormGet(url);
  } else {
    win.location.href = url;
  }
};
Util2.redirectWithFormGet = function(url) {
  Util2.redirectWithForm(url, "get");
};
Util2.redirectWithForm = function(url, method = "post") {
  if (!url) {
    Logger.error(`Cannot redirect to empty URL: (${url})`);
    return;
  }
  const mainContainer = document.getElementById(Enums.WIDGET_CONTAINER_ID);
  if (!mainContainer) {
    Logger.error("Cannot find okta-sign-in container append to which a form");
    return;
  }
  const form2 = buildDynamicForm(url, method);
  mainContainer.appendChild(form2);
  form2.querySelector('input[type="submit"]').click();
};
Util2.createInputExplain = function(explainKey, labelKey, bundleName, explainParams, labelParams) {
  const explain = explainParams ? loc3(explainKey, bundleName, explainParams) : loc3(explainKey, bundleName);
  const label = labelParams ? loc3(labelKey, bundleName, labelParams) : loc3(labelKey, bundleName);
  if (explain === label) {
    return false;
  }
  return explain;
};
Util2.isV1StateToken = function(token) {
  return !!(token && oktaUnderscore.isString(token) && token.startsWith("00"));
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/index.js
var crypto_exports = {};
__export(crypto_exports, {
  atob: () => a,
  base64ToBase64Url: () => base64ToBase64Url,
  base64UrlDecode: () => base64UrlDecode,
  base64UrlToBase64: () => base64UrlToBase64,
  base64UrlToBuffer: () => base64UrlToBuffer,
  base64UrlToString: () => base64UrlToString,
  btoa: () => b,
  bufferToBase64Url: () => bufferToBase64Url,
  getOidcHash: () => getOidcHash,
  stringToBase64Url: () => stringToBase64Url,
  stringToBuffer: () => stringToBuffer,
  verifyToken: () => verifyToken,
  webcrypto: () => c
});

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/CustomError.js
var CustomError2 = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/AuthSdkError.js
var AuthSdkError = class extends CustomError2 {
  constructor(msg, xhr) {
    super(msg);
    this.name = "AuthSdkError";
    this.errorCode = "INTERNAL";
    this.errorSummary = msg;
    this.errorLink = "INTERNAL";
    this.errorId = "INTERNAL";
    this.errorCauses = [];
    if (xhr) {
      this.xhr = xhr;
    }
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/browser.js
var a = function(str) {
  return atob(str);
};
var b = function(str) {
  return btoa(str);
};
var c = typeof crypto === "undefined" ? null : crypto;

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/base64.js
function stringToBase64Url(str) {
  var b64 = b(str);
  return base64ToBase64Url(b64);
}
function base64ToBase64Url(b64) {
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function base64UrlToBase64(b64u) {
  return b64u.replace(/-/g, "+").replace(/_/g, "/");
}
function base64UrlToString(b64u) {
  var b64 = base64UrlToBase64(b64u);
  switch (b64.length % 4) {
    case 0:
      break;
    case 2:
      b64 += "==";
      break;
    case 3:
      b64 += "=";
      break;
    default:
      throw new AuthSdkError("Not a valid Base64Url");
  }
  var utf8 = a(b64);
  try {
    return decodeURIComponent(escape(utf8));
  } catch (e) {
    return utf8;
  }
}
function stringToBuffer(str) {
  var buffer = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    buffer[i] = str.charCodeAt(i);
  }
  return buffer;
}
function base64UrlDecode(str) {
  return a(base64UrlToBase64(str));
}
function base64UrlToBuffer(b64u) {
  return Uint8Array.from(base64UrlDecode(b64u), (c2) => c2.charCodeAt(0));
}
function bufferToBase64Url(bin) {
  return b(new Uint8Array(bin).reduce((s, byte) => s + String.fromCharCode(byte), ""));
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/oidcHash.js
function getOidcHash(str) {
  var buffer = new TextEncoder().encode(str);
  return c.subtle.digest("SHA-256", buffer).then(function(arrayBuffer) {
    var intBuffer = new Uint8Array(arrayBuffer);
    var firstHalf = intBuffer.slice(0, 16);
    var hash = String.fromCharCode.apply(null, firstHalf);
    var b64u = stringToBase64Url(hash);
    return b64u;
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/object.js
function removeNils(obj) {
  var cleaned = {};
  for (var prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      var value = obj[prop];
      if (value !== null && value !== void 0) {
        cleaned[prop] = value;
      }
    }
  }
  return cleaned;
}
function clone(obj) {
  if (obj) {
    var str = JSON.stringify(obj);
    if (str) {
      return JSON.parse(str);
    }
  }
  return obj;
}
function omit(obj, ...props6) {
  var newobj = {};
  for (var p in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, p) && props6.indexOf(p) == -1) {
      newobj[p] = obj[p];
    }
  }
  return clone(newobj);
}
function find(collection, searchParams) {
  var c2 = collection.length;
  while (c2--) {
    var item = collection[c2];
    var found = true;
    for (var prop in searchParams) {
      if (!Object.prototype.hasOwnProperty.call(searchParams, prop)) {
        continue;
      }
      if (item[prop] !== searchParams[prop]) {
        found = false;
        break;
      }
    }
    if (found) {
      return item;
    }
  }
}
function getLink(obj, linkName, altName) {
  if (!obj || !obj._links) {
    return;
  }
  var link = clone(obj._links[linkName]);
  if (link && link.name && altName) {
    if (link.name === altName) {
      return link;
    }
  } else {
    return link;
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/verifyToken.js
function verifyToken(idToken, key) {
  key = clone(key);
  var format = "jwk";
  var algo = {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  };
  var extractable = true;
  var usages = ["verify"];
  delete key.use;
  return c.subtle.importKey(format, key, algo, extractable, usages).then(function(cryptoKey) {
    var jwt = idToken.split(".");
    var payload = stringToBuffer(jwt[0] + "." + jwt[1]);
    var b64Signature = base64UrlDecode(jwt[2]);
    var signature = stringToBuffer(b64Signature);
    return c.subtle.verify(algo, cryptoKey, signature, payload);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/_virtual/_tslib.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/constants.js
var constants_exports = {};
__export(constants_exports, {
  ACCESS_TOKEN_STORAGE_KEY: () => ACCESS_TOKEN_STORAGE_KEY,
  CACHE_STORAGE_NAME: () => CACHE_STORAGE_NAME,
  DEFAULT_CACHE_DURATION: () => DEFAULT_CACHE_DURATION,
  DEFAULT_CODE_CHALLENGE_METHOD: () => DEFAULT_CODE_CHALLENGE_METHOD,
  DEFAULT_MAX_CLOCK_SKEW: () => DEFAULT_MAX_CLOCK_SKEW,
  DEFAULT_POLLING_DELAY: () => DEFAULT_POLLING_DELAY,
  IDX_API_VERSION: () => IDX_API_VERSION,
  IDX_RESPONSE_STORAGE_NAME: () => IDX_RESPONSE_STORAGE_NAME,
  ID_TOKEN_STORAGE_KEY: () => ID_TOKEN_STORAGE_KEY,
  MAX_VERIFIER_LENGTH: () => MAX_VERIFIER_LENGTH,
  MIN_VERIFIER_LENGTH: () => MIN_VERIFIER_LENGTH,
  ORIGINAL_URI_STORAGE_NAME: () => ORIGINAL_URI_STORAGE_NAME,
  PKCE_STORAGE_NAME: () => PKCE_STORAGE_NAME,
  REDIRECT_NONCE_COOKIE_NAME: () => REDIRECT_NONCE_COOKIE_NAME,
  REDIRECT_OAUTH_PARAMS_NAME: () => REDIRECT_OAUTH_PARAMS_NAME,
  REDIRECT_STATE_COOKIE_NAME: () => REDIRECT_STATE_COOKIE_NAME,
  REFERRER_PATH_STORAGE_KEY: () => REFERRER_PATH_STORAGE_KEY,
  REFRESH_TOKEN_STORAGE_KEY: () => REFRESH_TOKEN_STORAGE_KEY,
  SHARED_TRANSACTION_STORAGE_NAME: () => SHARED_TRANSACTION_STORAGE_NAME,
  STATE_TOKEN_KEY_NAME: () => STATE_TOKEN_KEY_NAME,
  TOKEN_STORAGE_NAME: () => TOKEN_STORAGE_NAME,
  TRANSACTION_STORAGE_NAME: () => TRANSACTION_STORAGE_NAME
});
var STATE_TOKEN_KEY_NAME = "oktaStateToken";
var DEFAULT_POLLING_DELAY = 500;
var DEFAULT_MAX_CLOCK_SKEW = 300;
var DEFAULT_CACHE_DURATION = 86400;
var REDIRECT_OAUTH_PARAMS_NAME = "okta-oauth-redirect-params";
var REDIRECT_STATE_COOKIE_NAME = "okta-oauth-state";
var REDIRECT_NONCE_COOKIE_NAME = "okta-oauth-nonce";
var TOKEN_STORAGE_NAME = "okta-token-storage";
var CACHE_STORAGE_NAME = "okta-cache-storage";
var PKCE_STORAGE_NAME = "okta-pkce-storage";
var TRANSACTION_STORAGE_NAME = "okta-transaction-storage";
var SHARED_TRANSACTION_STORAGE_NAME = "okta-shared-transaction-storage";
var ORIGINAL_URI_STORAGE_NAME = "okta-original-uri-storage";
var IDX_RESPONSE_STORAGE_NAME = "okta-idx-response-storage";
var ACCESS_TOKEN_STORAGE_KEY = "accessToken";
var ID_TOKEN_STORAGE_KEY = "idToken";
var REFRESH_TOKEN_STORAGE_KEY = "refreshToken";
var REFERRER_PATH_STORAGE_KEY = "referrerPath";
var MIN_VERIFIER_LENGTH = 43;
var MAX_VERIFIER_LENGTH = 128;
var DEFAULT_CODE_CHALLENGE_METHOD = "S256";
var IDX_API_VERSION = "1.0.0";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/types.js
function isString(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
}
function isObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isNumber(obj) {
  return Object.prototype.toString.call(obj) === "[object Number]";
}
function isFunction3(fn11) {
  return !!fn11 && {}.toString.call(fn11) === "[object Function]";
}
function isPromise(obj) {
  return obj && obj.finally && typeof obj.finally === "function";
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/url.js
function isAbsoluteUrl(url) {
  return /^[a-z][a-z0-9+.-]*:/i.test(url);
}
function toAbsoluteUrl(url = "", baseUrl) {
  if (isAbsoluteUrl(url)) {
    return url;
  }
  baseUrl = removeTrailingSlash(baseUrl);
  return url[0] === "/" ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
}
function toQueryString(obj) {
  var str = [];
  if (obj !== null) {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && obj[key] !== void 0 && obj[key] !== null) {
        str.push(key + "=" + encodeURIComponent(obj[key]));
      }
    }
  }
  if (str.length) {
    return "?" + str.join("&");
  } else {
    return "";
  }
}
function removeTrailingSlash(path) {
  if (!path) {
    return;
  }
  var trimmed = path.replace(/^\s+|\s+$/gm, "");
  trimmed = trimmed.replace(/\/+$/, "");
  return trimmed;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/AuthApiError.js
var AuthApiError = class extends CustomError2 {
  constructor(err, xhr, meta) {
    const message = err.errorSummary;
    super(message);
    this.name = "AuthApiError";
    this.errorSummary = err.errorSummary;
    this.errorCode = err.errorCode;
    this.errorLink = err.errorLink;
    this.errorId = err.errorId;
    this.errorCauses = err.errorCauses;
    if (xhr) {
      this.xhr = xhr;
    }
    if (meta) {
      this.meta = meta;
    }
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/OAuthError.js
var OAuthError2 = class extends CustomError2 {
  constructor(errorCode, summary) {
    super(summary);
    this.name = "OAuthError";
    this.errorCode = errorCode;
    this.errorSummary = summary;
    this.error = errorCode;
    this.error_description = summary;
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/http/request.js
function httpRequest(sdk, options2) {
  options2 = options2 || {};
  if (sdk.options.httpRequestInterceptors) {
    for (const interceptor of sdk.options.httpRequestInterceptors) {
      interceptor(options2);
    }
  }
  var url = options2.url, method = options2.method, args = options2.args, saveAuthnState = options2.saveAuthnState, accessToken = options2.accessToken, withCredentials = options2.withCredentials === true, storageUtil2 = sdk.options.storageUtil, storage = storageUtil2.storage, httpCache = sdk.storageManager.getHttpCache(sdk.options.cookies);
  if (options2.cacheResponse) {
    var cacheContents = httpCache.getStorage();
    var cachedResponse = cacheContents[url];
    if (cachedResponse && Date.now() / 1e3 < cachedResponse.expiresAt) {
      return Promise.resolve(cachedResponse.response);
    }
  }
  var oktaUserAgentHeader = sdk._oktaUserAgent.getHttpHeader();
  var headers = Object.assign({ "Accept": "application/json", "Content-Type": "application/json" }, oktaUserAgentHeader);
  Object.assign(headers, sdk.options.headers, options2.headers);
  headers = removeNils(headers);
  if (accessToken && isString(accessToken)) {
    headers["Authorization"] = "Bearer " + accessToken;
  }
  var ajaxOptions = {
    headers,
    data: args || void 0,
    withCredentials
  };
  var err, res;
  return sdk.options.httpRequestClient(method, url, ajaxOptions).then(function(resp) {
    res = resp.responseText;
    if (res && isString(res)) {
      res = JSON.parse(res);
      if (res && typeof res === "object" && !res.headers) {
        if (Array.isArray(res)) {
          res.forEach((item) => {
            item.headers = resp.headers;
          });
        } else {
          res.headers = resp.headers;
        }
      }
    }
    if (saveAuthnState) {
      if (!res.stateToken) {
        storage.delete(STATE_TOKEN_KEY_NAME);
      }
    }
    if (res && res.stateToken && res.expiresAt) {
      storage.set(STATE_TOKEN_KEY_NAME, res.stateToken, res.expiresAt, sdk.options.cookies);
    }
    if (res && options2.cacheResponse) {
      httpCache.updateStorage(url, {
        expiresAt: Math.floor(Date.now() / 1e3) + DEFAULT_CACHE_DURATION,
        response: res
      });
    }
    return res;
  }).catch(function(resp) {
    var serverErr = resp.responseText || {};
    if (isString(serverErr)) {
      try {
        serverErr = JSON.parse(serverErr);
      } catch (e) {
        serverErr = {
          errorSummary: "Unknown error"
        };
      }
    }
    if (resp.status >= 500) {
      serverErr.errorSummary = "Unknown error";
    }
    if (sdk.options.transformErrorXHR) {
      resp = sdk.options.transformErrorXHR(clone(resp));
    }
    if (serverErr.error && serverErr.error_description) {
      err = new OAuthError2(serverErr.error, serverErr.error_description);
    } else {
      err = new AuthApiError(serverErr, resp);
    }
    if (err.errorCode === "E0000011") {
      storage.delete(STATE_TOKEN_KEY_NAME);
    }
    throw err;
  });
}
function get(sdk, url, options2) {
  url = isAbsoluteUrl(url) ? url : sdk.getIssuerOrigin() + url;
  var getOptions = {
    url,
    method: "GET"
  };
  Object.assign(getOptions, options2);
  return httpRequest(sdk, getOptions);
}
function post(sdk, url, args, options2) {
  url = isAbsoluteUrl(url) ? url : sdk.getIssuerOrigin() + url;
  var postOptions = {
    url,
    method: "POST",
    args,
    saveAuthnState: true
  };
  Object.assign(postOptions, options2);
  return httpRequest(sdk, postOptions);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/tx/util.js
function addStateToken(res, options2) {
  var builtArgs = {};
  Object.assign(builtArgs, options2);
  if (!builtArgs.stateToken && res.stateToken) {
    builtArgs.stateToken = res.stateToken;
  }
  return builtArgs;
}
function getStateToken(res) {
  return addStateToken(res);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/tx/api.js
function transactionStatus(sdk, args) {
  args = addStateToken(sdk, args);
  return post(sdk, sdk.getIssuerOrigin() + "/api/v1/authn", args, { withCredentials: true });
}
function resumeTransaction(sdk, args) {
  if (!args || !args.stateToken) {
    var stateToken = sdk.tx.exists._get(STATE_TOKEN_KEY_NAME);
    if (stateToken) {
      args = {
        stateToken
      };
    } else {
      return Promise.reject(new AuthSdkError("No transaction to resume"));
    }
  }
  return sdk.tx.status(args).then(function(res) {
    return sdk.tx.createTransaction(res);
  });
}
function introspectAuthn(sdk, args) {
  if (!args || !args.stateToken) {
    var stateToken = sdk.tx.exists._get(STATE_TOKEN_KEY_NAME);
    if (stateToken) {
      args = {
        stateToken
      };
    } else {
      return Promise.reject(new AuthSdkError("No transaction to evaluate"));
    }
  }
  return transactionStep(sdk, args).then(function(res) {
    return sdk.tx.createTransaction(res);
  });
}
function transactionStep(sdk, args) {
  args = addStateToken(sdk, args);
  return post(sdk, sdk.getIssuerOrigin() + "/api/v1/authn/introspect", args, { withCredentials: true });
}
function transactionExists(sdk) {
  return !!sdk.tx.exists._get(STATE_TOKEN_KEY_NAME);
}
function postToTransaction(sdk, url, args, options2) {
  options2 = Object.assign({ withCredentials: true }, options2);
  return post(sdk, url, args, options2).then(function(res) {
    return sdk.tx.createTransaction(res);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/misc.js
function genRandomString(length) {
  var randomCharset = "abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  var random = "";
  for (var c2 = 0, cl = randomCharset.length; c2 < length; ++c2) {
    random += randomCharset[Math.floor(Math.random() * cl)];
  }
  return random;
}
function delay(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
function split2(str, delim) {
  const parts = str.split(delim);
  return [
    parts[0],
    parts.splice(1, parts.length).join(delim)
  ];
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/AuthPollStopError.js
var AuthPollStopError = class extends CustomError2 {
  constructor() {
    const message = "The poll was stopped by the sdk";
    super(message);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/tx/poll.js
function getPollFn(sdk, res, ref) {
  return function(options2) {
    var delay$1;
    var rememberDevice2;
    var autoPush2;
    var transactionCallBack;
    if (isNumber(options2)) {
      delay$1 = options2;
    } else if (isObject(options2)) {
      options2 = options2;
      delay$1 = options2.delay;
      rememberDevice2 = options2.rememberDevice;
      autoPush2 = options2.autoPush;
      transactionCallBack = options2.transactionCallBack;
    }
    if (!delay$1 && delay$1 !== 0) {
      delay$1 = DEFAULT_POLLING_DELAY;
    }
    var pollLink = getLink(res, "next", "poll");
    function pollFn() {
      var opts = {};
      if (typeof autoPush2 === "function") {
        try {
          opts.autoPush = !!autoPush2();
        } catch (e) {
          return Promise.reject(new AuthSdkError("AutoPush resulted in an error."));
        }
      } else if (autoPush2 !== void 0 && autoPush2 !== null) {
        opts.autoPush = !!autoPush2;
      }
      if (typeof rememberDevice2 === "function") {
        try {
          opts.rememberDevice = !!rememberDevice2();
        } catch (e) {
          return Promise.reject(new AuthSdkError("RememberDevice resulted in an error."));
        }
      } else if (rememberDevice2 !== void 0 && rememberDevice2 !== null) {
        opts.rememberDevice = !!rememberDevice2;
      }
      var href = pollLink.href + toQueryString(opts);
      return post(sdk, href, getStateToken(res), {
        saveAuthnState: false,
        withCredentials: true
      });
    }
    ref.isPolling = true;
    var retryCount = 0;
    var recursivePoll = function() {
      if (!ref.isPolling) {
        return Promise.reject(new AuthPollStopError());
      }
      return pollFn().then(function(pollRes) {
        retryCount = 0;
        if (pollRes.factorResult && pollRes.factorResult === "WAITING") {
          if (!ref.isPolling) {
            throw new AuthPollStopError();
          }
          if (typeof transactionCallBack === "function") {
            transactionCallBack(pollRes);
          }
          return delay(delay$1).then(recursivePoll);
        } else {
          ref.isPolling = false;
          return sdk.tx.createTransaction(pollRes);
        }
      }).catch(function(err) {
        if (err.xhr && (err.xhr.status === 0 || err.xhr.status === 429) && retryCount <= 4) {
          var delayLength = Math.pow(2, retryCount) * 1e3;
          retryCount++;
          return delay(delayLength).then(recursivePoll);
        }
        throw err;
      });
    };
    return recursivePoll().catch(function(err) {
      ref.isPolling = false;
      throw err;
    });
  };
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/tx/AuthTransaction.js
var AuthTransaction = class {
  constructor(sdk, res = null) {
    this.data = void 0;
    this.status = void 0;
    if (res) {
      this.data = res;
      if (this.data.interactionHandle) {
        this.status = res.status;
        return;
      }
      Object.assign(this, flattenEmbedded(sdk, res, res, {}));
      delete this.stateToken;
      if (res.status === "RECOVERY_CHALLENGE" && !res._links) {
        this.cancel = function() {
          return Promise.resolve(sdk.tx.createTransaction());
        };
      }
    }
  }
};
function link2fn(sdk, res, obj, link, ref) {
  if (Array.isArray(link)) {
    return function(name, opts) {
      if (!name) {
        throw new AuthSdkError("Must provide a link name");
      }
      var lk = find(link, { name });
      if (!lk) {
        throw new AuthSdkError("No link found for that name");
      }
      return link2fn(sdk, res, obj, lk, ref)(opts);
    };
  } else if (link.hints && link.hints.allow && link.hints.allow.length === 1) {
    var method = link.hints.allow[0];
    switch (method) {
      case "GET":
        return function() {
          return get(sdk, link.href, { withCredentials: true });
        };
      case "POST":
        return function(opts) {
          if (ref && ref.isPolling) {
            ref.isPolling = false;
          }
          var data = addStateToken(res, opts);
          if (res.status === "MFA_ENROLL" || res.status === "FACTOR_ENROLL") {
            Object.assign(data, {
              factorType: obj.factorType,
              provider: obj.provider
            });
          }
          var params = {};
          var autoPush2 = data.autoPush;
          if (autoPush2 !== void 0) {
            if (typeof autoPush2 === "function") {
              try {
                params.autoPush = !!autoPush2();
              } catch (e) {
                return Promise.reject(new AuthSdkError("AutoPush resulted in an error."));
              }
            } else if (autoPush2 !== null) {
              params.autoPush = !!autoPush2;
            }
            data = omit(data, "autoPush");
          }
          var rememberDevice2 = data.rememberDevice;
          if (rememberDevice2 !== void 0) {
            if (typeof rememberDevice2 === "function") {
              try {
                params.rememberDevice = !!rememberDevice2();
              } catch (e) {
                return Promise.reject(new AuthSdkError("RememberDevice resulted in an error."));
              }
            } else if (rememberDevice2 !== null) {
              params.rememberDevice = !!rememberDevice2;
            }
            data = omit(data, "rememberDevice");
          } else if (data.profile && data.profile.updatePhone !== void 0) {
            if (data.profile.updatePhone) {
              params.updatePhone = true;
            }
            data.profile = omit(data.profile, "updatePhone");
          }
          var href = link.href + toQueryString(params);
          return postToTransaction(sdk, href, data);
        };
    }
  }
}
function links2fns(sdk, res, obj, ref) {
  var fns = {};
  for (var linkName in obj._links) {
    if (!Object.prototype.hasOwnProperty.call(obj._links, linkName)) {
      continue;
    }
    var link = obj._links[linkName];
    if (linkName === "next") {
      linkName = link.name;
    }
    if (link.type) {
      fns[linkName] = link;
      continue;
    }
    switch (linkName) {
      case "poll":
        fns.poll = getPollFn(sdk, res, ref);
        break;
      default:
        var fn11 = link2fn(sdk, res, obj, link, ref);
        if (fn11) {
          fns[linkName] = fn11;
        }
    }
  }
  return fns;
}
function flattenEmbedded(sdk, res, obj, ref) {
  obj = obj || res;
  obj = clone(obj);
  if (Array.isArray(obj)) {
    var objArr = [];
    for (var o = 0, ol = obj.length; o < ol; o++) {
      objArr.push(flattenEmbedded(sdk, res, obj[o], ref));
    }
    return objArr;
  }
  var embedded = obj._embedded || {};
  for (var key in embedded) {
    if (!Object.prototype.hasOwnProperty.call(embedded, key)) {
      continue;
    }
    if (isObject(embedded[key]) || Array.isArray(embedded[key])) {
      embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);
    }
  }
  var fns = links2fns(sdk, res, obj, ref);
  Object.assign(embedded, fns);
  obj = omit(obj, "_embedded", "_links");
  Object.assign(obj, embedded);
  return obj;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/http/headers.js
function setRequestHeader(authClient, headerName, headerValue) {
  authClient.options.headers = authClient.options.headers || {};
  authClient.options.headers[headerName] = headerValue;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/pkce.js
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function getRandomString(length) {
  var a2 = new Uint8Array(Math.ceil(length / 2));
  c.getRandomValues(a2);
  var str = Array.from(a2, dec2hex).join("");
  return str.slice(0, length);
}
function generateVerifier(prefix) {
  var verifier = prefix || "";
  if (verifier.length < MIN_VERIFIER_LENGTH) {
    verifier = verifier + getRandomString(MIN_VERIFIER_LENGTH - verifier.length);
  }
  return encodeURIComponent(verifier).slice(0, MAX_VERIFIER_LENGTH);
}
function computeChallenge(str) {
  var buffer = new TextEncoder().encode(str);
  return c.subtle.digest("SHA-256", buffer).then(function(arrayBuffer) {
    var hash = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
    var b64u = stringToBase64Url(hash);
    return b64u;
  });
}
var PKCE = {
  DEFAULT_CODE_CHALLENGE_METHOD,
  generateVerifier,
  computeChallenge
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/session.js
function sessionExists(sdk) {
  return sdk.session.get().then(function(res) {
    if (res.status === "ACTIVE") {
      return true;
    }
    return false;
  }).catch(function() {
    return false;
  });
}
function getSession(sdk) {
  return get(sdk, "/api/v1/sessions/me", { withCredentials: true }).then(function(session) {
    var res = omit(session, "_links");
    res.refresh = function() {
      return post(sdk, getLink(session, "refresh").href, {}, { withCredentials: true });
    };
    res.user = function() {
      return get(sdk, getLink(session, "user").href, { withCredentials: true });
    };
    return res;
  }).catch(function() {
    return { status: "INACTIVE" };
  });
}
function closeSession(sdk) {
  return httpRequest(sdk, {
    url: sdk.getIssuerOrigin() + "/api/v1/sessions/me",
    method: "DELETE",
    withCredentials: true
  });
}
function refreshSession(sdk) {
  return post(sdk, "/api/v1/sessions/me/lifecycle/refresh", {}, { withCredentials: true });
}
function setCookieAndRedirect(sdk, sessionToken, redirectUrl) {
  redirectUrl = redirectUrl || window.location.href;
  window.location.assign(sdk.getIssuerOrigin() + "/login/sessionCookieRedirect" + toQueryString({
    checkAccountSetupComplete: true,
    token: sessionToken,
    redirectUrl
  }));
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/oauth.js
function generateState() {
  return genRandomString(64);
}
function generateNonce() {
  return genRandomString(64);
}
function getIssuer(sdk, options2 = {}) {
  const issuer = removeTrailingSlash(options2.issuer) || sdk.options.issuer;
  return issuer;
}
function getOAuthBaseUrl(sdk, options2 = {}) {
  const issuer = getIssuer(sdk, options2);
  const baseUrl = issuer.indexOf("/oauth2") > 0 ? issuer : issuer + "/oauth2";
  return baseUrl;
}
function getOAuthDomain(sdk, options2 = {}) {
  const issuer = getIssuer(sdk, options2);
  const domain = issuer.split("/oauth2")[0];
  return domain;
}
function getOAuthUrls(sdk, options2) {
  if (arguments.length > 2) {
    throw new AuthSdkError('As of version 3.0, "getOAuthUrls" takes only a single set of options');
  }
  options2 = options2 || {};
  var authorizeUrl = removeTrailingSlash(options2.authorizeUrl) || sdk.options.authorizeUrl;
  var issuer = getIssuer(sdk, options2);
  var userinfoUrl = removeTrailingSlash(options2.userinfoUrl) || sdk.options.userinfoUrl;
  var tokenUrl = removeTrailingSlash(options2.tokenUrl) || sdk.options.tokenUrl;
  var logoutUrl = removeTrailingSlash(options2.logoutUrl) || sdk.options.logoutUrl;
  var revokeUrl = removeTrailingSlash(options2.revokeUrl) || sdk.options.revokeUrl;
  var baseUrl = getOAuthBaseUrl(sdk, options2);
  authorizeUrl = authorizeUrl || baseUrl + "/v1/authorize";
  userinfoUrl = userinfoUrl || baseUrl + "/v1/userinfo";
  tokenUrl = tokenUrl || baseUrl + "/v1/token";
  revokeUrl = revokeUrl || baseUrl + "/v1/revoke";
  logoutUrl = logoutUrl || baseUrl + "/v1/logout";
  return {
    issuer,
    authorizeUrl,
    userinfoUrl,
    tokenUrl,
    revokeUrl,
    logoutUrl
  };
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/features.js
var features_exports = {};
__export(features_exports, {
  getUserAgent: () => getUserAgent,
  hasTextEncoder: () => hasTextEncoder,
  isBrowser: () => isBrowser,
  isFingerprintSupported: () => isFingerprintSupported,
  isHTTPS: () => isHTTPS,
  isIE11OrLess: () => isIE11OrLess,
  isLocalhost: () => isLocalhost,
  isPKCESupported: () => isPKCESupported,
  isPopupPostMessageSupported: () => isPopupPostMessageSupported,
  isTokenVerifySupported: () => isTokenVerifySupported
});
var isWindowsPhone = /windows phone|iemobile|wpdesktop/i;
function isBrowser() {
  return typeof document !== "undefined" && typeof window !== "undefined";
}
function isIE11OrLess() {
  if (!isBrowser()) {
    return false;
  }
  const documentMode = document.documentMode;
  return !!documentMode && documentMode <= 11;
}
function getUserAgent() {
  return navigator.userAgent;
}
function isFingerprintSupported() {
  const agent = getUserAgent();
  return agent && !isWindowsPhone.test(agent);
}
function isPopupPostMessageSupported() {
  if (!isBrowser()) {
    return false;
  }
  const documentMode = document.documentMode;
  var isIE8or9 = documentMode && documentMode < 10;
  if (typeof window.postMessage !== "undefined" && !isIE8or9) {
    return true;
  }
  return false;
}
function isTokenVerifySupported() {
  return typeof c !== "undefined" && c !== null && typeof c.subtle !== "undefined" && typeof Uint8Array !== "undefined";
}
function hasTextEncoder() {
  return typeof TextEncoder !== "undefined";
}
function isPKCESupported() {
  return isTokenVerifySupported() && hasTextEncoder();
}
function isHTTPS() {
  if (!isBrowser()) {
    return false;
  }
  return window.location.protocol === "https:";
}
function isLocalhost() {
  return isBrowser() && window.location.hostname === "localhost";
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/errors/index.js
function isAuthApiError(obj) {
  return obj instanceof AuthApiError;
}
function isOAuthError(obj) {
  return obj instanceof OAuthError2;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/errors.js
function isInteractionRequiredError(error) {
  if (error.name !== "OAuthError") {
    return false;
  }
  const oauthError = error;
  return oauthError.errorCode === "interaction_required";
}
function isRefreshTokenInvalidError(error) {
  return isOAuthError(error) && error.errorCode === "invalid_grant" && error.errorSummary === "The refresh token is invalid or expired.";
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/loginRedirect.js
function hasTokensInHash(hash) {
  return /((id|access)_token=)/i.test(hash);
}
function hasAuthorizationCode(hashOrSearch) {
  return /(code=)/i.test(hashOrSearch);
}
function hasInteractionCode(hashOrSearch) {
  return /(interaction_code=)/i.test(hashOrSearch);
}
function hasErrorInUrl(hashOrSearch) {
  return /(error=)/i.test(hashOrSearch) || /(error_description)/i.test(hashOrSearch);
}
function isRedirectUri(uri, sdk) {
  var authParams = sdk.options;
  if (!uri || !authParams.redirectUri) {
    return false;
  }
  return uri.indexOf(authParams.redirectUri) === 0;
}
function isCodeFlow(options2) {
  return options2.pkce || options2.responseType === "code" || options2.responseMode === "query";
}
function getHashOrSearch(options2) {
  var codeFlow = isCodeFlow(options2);
  var useQuery = codeFlow && options2.responseMode !== "fragment";
  return useQuery ? window.location.search : window.location.hash;
}
function isLoginRedirect(sdk) {
  if (!isRedirectUri(window.location.href, sdk)) {
    return false;
  }
  var codeFlow = isCodeFlow(sdk.options);
  var hashOrSearch = getHashOrSearch(sdk.options);
  if (hasErrorInUrl(hashOrSearch)) {
    return true;
  }
  if (codeFlow) {
    var hasCode = hasAuthorizationCode(hashOrSearch) || hasInteractionCode(hashOrSearch);
    return hasCode;
  }
  return hasTokensInHash(window.location.hash);
}
function isInteractionRequired(sdk, hashOrSearch) {
  if (!hashOrSearch) {
    if (!isLoginRedirect(sdk)) {
      return false;
    }
    hashOrSearch = getHashOrSearch(sdk.options);
  }
  return /(error=interaction_required)/i.test(hashOrSearch);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/endpoints/well-known.js
function getWellKnown(sdk, issuer) {
  var authServerUri = issuer || sdk.options.issuer;
  return get(sdk, authServerUri + "/.well-known/openid-configuration", {
    cacheResponse: true
  });
}
function getKey(sdk, issuer, kid) {
  var httpCache = sdk.storageManager.getHttpCache(sdk.options.cookies);
  return getWellKnown(sdk, issuer).then(function(wellKnown) {
    var jwksUri = wellKnown["jwks_uri"];
    var cacheContents = httpCache.getStorage();
    var cachedResponse = cacheContents[jwksUri];
    if (cachedResponse && Date.now() / 1e3 < cachedResponse.expiresAt) {
      var cachedKey = find(cachedResponse.response.keys, {
        kid
      });
      if (cachedKey) {
        return cachedKey;
      }
    }
    httpCache.clearStorage(jwksUri);
    return get(sdk, jwksUri, {
      cacheResponse: true
    }).then(function(res) {
      var key = find(res.keys, {
        kid
      });
      if (key) {
        return key;
      }
      throw new AuthSdkError("The key id, " + kid + ", was not found in the server's keys");
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/defaultTokenParams.js
function getDefaultTokenParams(sdk) {
  const { pkce, clientId, redirectUri, responseType, responseMode, scopes, state, ignoreSignature } = sdk.options;
  const defaultRedirectUri = isBrowser() ? window.location.href : void 0;
  return removeNils({
    pkce,
    clientId,
    redirectUri: redirectUri || defaultRedirectUri,
    responseType: responseType || ["token", "id_token"],
    responseMode,
    state: state || generateState(),
    nonce: generateNonce(),
    scopes: scopes || ["openid", "email"],
    ignoreSignature
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/prepareTokenParams.js
function assertPKCESupport(sdk) {
  if (!sdk.features.isPKCESupported()) {
    var errorMessage = "PKCE requires a modern browser with encryption support running in a secure context.";
    if (!sdk.features.isHTTPS()) {
      errorMessage += "\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.";
    }
    if (!sdk.features.hasTextEncoder()) {
      errorMessage += '\n"TextEncoder" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';
    }
    throw new AuthSdkError(errorMessage);
  }
}
function validateCodeChallengeMethod(sdk, codeChallengeMethod) {
  return __async(this, null, function* () {
    codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;
    const wellKnownResponse = yield getWellKnown(sdk);
    var methods2 = wellKnownResponse["code_challenge_methods_supported"] || [];
    if (methods2.indexOf(codeChallengeMethod) === -1) {
      throw new AuthSdkError("Invalid code_challenge_method");
    }
    return codeChallengeMethod;
  });
}
function preparePKCE(sdk, tokenParams) {
  return __async(this, null, function* () {
    let { codeVerifier, codeChallenge, codeChallengeMethod } = tokenParams;
    codeChallenge = codeChallenge || sdk.options.codeChallenge;
    if (!codeChallenge) {
      assertPKCESupport(sdk);
      codeVerifier = codeVerifier || PKCE.generateVerifier();
      codeChallenge = yield PKCE.computeChallenge(codeVerifier);
    }
    codeChallengeMethod = yield validateCodeChallengeMethod(sdk, codeChallengeMethod);
    tokenParams = Object.assign(Object.assign({}, tokenParams), {
      responseType: "code",
      codeVerifier,
      codeChallenge,
      codeChallengeMethod
    });
    return tokenParams;
  });
}
function prepareTokenParams(_0) {
  return __async(this, arguments, function* (sdk, tokenParams = {}) {
    const defaults2 = getDefaultTokenParams(sdk);
    tokenParams = Object.assign(Object.assign({}, defaults2), tokenParams);
    if (tokenParams.pkce === false) {
      return tokenParams;
    }
    return preparePKCE(sdk, tokenParams);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/types/api.js
var IdxStatus;
(function(IdxStatus2) {
  IdxStatus2["SUCCESS"] = "SUCCESS";
  IdxStatus2["PENDING"] = "PENDING";
  IdxStatus2["FAILURE"] = "FAILURE";
  IdxStatus2["TERMINAL"] = "TERMINAL";
  IdxStatus2["CANCELED"] = "CANCELED";
})(IdxStatus || (IdxStatus = {}));
var AuthenticatorKey;
(function(AuthenticatorKey2) {
  AuthenticatorKey2["OKTA_PASSWORD"] = "okta_password";
  AuthenticatorKey2["OKTA_EMAIL"] = "okta_email";
  AuthenticatorKey2["PHONE_NUMBER"] = "phone_number";
  AuthenticatorKey2["GOOGLE_AUTHENTICATOR"] = "google_otp";
  AuthenticatorKey2["SECURITY_QUESTION"] = "security_question";
  AuthenticatorKey2["OKTA_VERIFY"] = "okta_verify";
  AuthenticatorKey2["WEBAUTHN"] = "webauthn";
})(AuthenticatorKey || (AuthenticatorKey = {}));
var IdxFeature;
(function(IdxFeature2) {
  IdxFeature2["PASSWORD_RECOVERY"] = "recover-password";
  IdxFeature2["REGISTRATION"] = "enroll-profile";
  IdxFeature2["SOCIAL_IDP"] = "redirect-idp";
  IdxFeature2["ACCOUNT_UNLOCK"] = "unlock-account";
})(IdxFeature || (IdxFeature = {}));
function isAuthenticator(obj) {
  return obj && (obj.key || obj.id);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/myaccount/types.js
var EmailRole;
(function(EmailRole2) {
  EmailRole2["PRIMARY"] = "PRIMARY";
  EmailRole2["SECONDARY"] = "SECONDARY";
})(EmailRole || (EmailRole = {}));
var Status;
(function(Status2) {
  Status2["VERIFIED"] = "VERIFIED";
  Status2["UNVERIFIED"] = "UNVERIFIED";
})(Status || (Status = {}));

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/decodeToken.js
function decodeToken(token) {
  var jwt = token.split(".");
  var decodedToken;
  try {
    decodedToken = {
      header: JSON.parse(base64UrlToString(jwt[0])),
      payload: JSON.parse(base64UrlToString(jwt[1])),
      signature: jwt[2]
    };
  } catch (e) {
    throw new AuthSdkError("Malformed token");
  }
  return decodedToken;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/revokeToken.js
function revokeToken(sdk, token) {
  return __async(this, null, function* () {
    let accessToken = "";
    let refreshToken = "";
    if (token) {
      accessToken = token.accessToken;
      refreshToken = token.refreshToken;
    }
    if (!accessToken && !refreshToken) {
      throw new AuthSdkError("A valid access or refresh token object is required");
    }
    var clientId = sdk.options.clientId;
    var clientSecret = sdk.options.clientSecret;
    if (!clientId) {
      throw new AuthSdkError("A clientId must be specified in the OktaAuth constructor to revoke a token");
    }
    var revokeUrl = getOAuthUrls(sdk).revokeUrl;
    var args = toQueryString({
      token_type_hint: refreshToken ? "refresh_token" : "access_token",
      token: refreshToken || accessToken
    }).slice(1);
    var creds = clientSecret ? b(`${clientId}:${clientSecret}`) : b(clientId);
    return post(sdk, revokeUrl, args, {
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic " + creds
      }
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/types/Token.js
function isAccessToken(obj) {
  return obj && obj.accessToken;
}
function isIDToken(obj) {
  return obj && obj.idToken;
}
function isRefreshToken(obj) {
  return obj && obj.refreshToken;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/browser.js
function addListener(eventTarget, name, fn11) {
  if (eventTarget.addEventListener) {
    eventTarget.addEventListener(name, fn11);
  } else {
    eventTarget.attachEvent("on" + name, fn11);
  }
}
function removeListener(eventTarget, name, fn11) {
  if (eventTarget.removeEventListener) {
    eventTarget.removeEventListener(name, fn11);
  } else {
    eventTarget.detachEvent("on" + name, fn11);
  }
}
function loadFrame(src) {
  var iframe = document.createElement("iframe");
  iframe.style.display = "none";
  iframe.src = src;
  return document.body.appendChild(iframe);
}
function loadPopup(src, options2) {
  var title = options2.popupTitle || "External Identity Provider User Authentication";
  var appearance = "toolbar=no, scrollbars=yes, resizable=yes, top=100, left=500, width=600, height=600";
  return window.open(src, title, appearance);
}
function addPostMessageListener(sdk, timeout, state) {
  var responseHandler;
  var timeoutId;
  var msgReceivedOrTimeout = new Promise(function(resolve, reject) {
    responseHandler = function responseHandler2(e) {
      if (!e.data || e.data.state !== state) {
        return;
      }
      if (e.origin !== sdk.getIssuerOrigin()) {
        return reject(new AuthSdkError("The request does not match client configuration"));
      }
      resolve(e.data);
    };
    addListener(window, "message", responseHandler);
    timeoutId = setTimeout(function() {
      reject(new AuthSdkError("OAuth flow timed out"));
    }, timeout || 12e4);
  });
  return msgReceivedOrTimeout.finally(function() {
    clearTimeout(timeoutId);
    removeListener(window, "message", responseHandler);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/endpoints/authorize.js
function convertTokenParamsToOAuthParams(tokenParams) {
  if (!tokenParams.clientId) {
    throw new AuthSdkError("A clientId must be specified in the OktaAuth constructor to get a token");
  }
  if (isString(tokenParams.responseType) && tokenParams.responseType.indexOf(" ") !== -1) {
    throw new AuthSdkError("Multiple OAuth responseTypes must be defined as an array");
  }
  var oauthParams = {
    "client_id": tokenParams.clientId,
    "code_challenge": tokenParams.codeChallenge,
    "code_challenge_method": tokenParams.codeChallengeMethod,
    "display": tokenParams.display,
    "idp": tokenParams.idp,
    "idp_scope": tokenParams.idpScope,
    "login_hint": tokenParams.loginHint,
    "max_age": tokenParams.maxAge,
    "nonce": tokenParams.nonce,
    "prompt": tokenParams.prompt,
    "redirect_uri": tokenParams.redirectUri,
    "response_mode": tokenParams.responseMode,
    "response_type": tokenParams.responseType,
    "sessionToken": tokenParams.sessionToken,
    "state": tokenParams.state
  };
  oauthParams = removeNils(oauthParams);
  ["idp_scope", "response_type"].forEach(function(mayBeArray) {
    if (Array.isArray(oauthParams[mayBeArray])) {
      oauthParams[mayBeArray] = oauthParams[mayBeArray].join(" ");
    }
  });
  if (tokenParams.responseType.indexOf("id_token") !== -1 && tokenParams.scopes.indexOf("openid") === -1) {
    throw new AuthSdkError("openid scope must be specified in the scopes argument when requesting an id_token");
  } else {
    oauthParams.scope = tokenParams.scopes.join(" ");
  }
  return oauthParams;
}
function buildAuthorizeParams(tokenParams) {
  var oauthQueryParams = convertTokenParamsToOAuthParams(tokenParams);
  return toQueryString(Object.assign(Object.assign({}, oauthQueryParams), tokenParams.extraParams && Object.assign({}, tokenParams.extraParams)));
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/validateClaims.js
function validateClaims(sdk, claims, validationParams) {
  var aud = validationParams.clientId;
  var iss = validationParams.issuer;
  var nonce = validationParams.nonce;
  if (!claims || !iss || !aud) {
    throw new AuthSdkError("The jwt, iss, and aud arguments are all required");
  }
  if (nonce && claims.nonce !== nonce) {
    throw new AuthSdkError("OAuth flow response nonce doesn't match request nonce");
  }
  var now = Math.floor(Date.now() / 1e3);
  if (claims.iss !== iss) {
    throw new AuthSdkError("The issuer [" + claims.iss + "] does not match [" + iss + "]");
  }
  if (claims.aud !== aud) {
    throw new AuthSdkError("The audience [" + claims.aud + "] does not match [" + aud + "]");
  }
  if (claims.iat > claims.exp) {
    throw new AuthSdkError("The JWT expired before it was issued");
  }
  if (!sdk.options.ignoreLifetime) {
    if (now - sdk.options.maxClockSkew > claims.exp) {
      throw new AuthSdkError("The JWT expired and is no longer valid");
    }
    if (claims.iat > now + sdk.options.maxClockSkew) {
      throw new AuthSdkError("The JWT was issued in the future");
    }
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/verifyToken.js
function verifyToken2(sdk, token, validationParams) {
  return __async(this, null, function* () {
    if (!token || !token.idToken) {
      throw new AuthSdkError("Only idTokens may be verified");
    }
    var jwt = decodeToken(token.idToken);
    const configuredIssuer = (validationParams === null || validationParams === void 0 ? void 0 : validationParams.issuer) || sdk.options.issuer;
    const { issuer } = yield getWellKnown(sdk, configuredIssuer);
    var validationOptions = Object.assign({
      clientId: sdk.options.clientId,
      ignoreSignature: sdk.options.ignoreSignature
    }, validationParams, {
      issuer
    });
    validateClaims(sdk, jwt.payload, validationOptions);
    if (validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported()) {
      return token;
    }
    const key = yield getKey(sdk, token.issuer, jwt.header.kid);
    const valid = yield verifyToken(token.idToken, key);
    if (!valid) {
      throw new AuthSdkError("The token signature is not valid");
    }
    if (validationParams && validationParams.accessToken && token.claims.at_hash) {
      const hash = yield getOidcHash(validationParams.accessToken);
      if (hash !== token.claims.at_hash) {
        throw new AuthSdkError("Token hash verification failed");
      }
    }
    return token;
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/handleOAuthResponse.js
function validateResponse(res, oauthParams) {
  if (res["error"] && res["error_description"]) {
    throw new OAuthError2(res["error"], res["error_description"]);
  }
  if (res.state !== oauthParams.state) {
    throw new AuthSdkError("OAuth flow response state doesn't match request state");
  }
}
function handleOAuthResponse(sdk, tokenParams, res, urls) {
  return __async(this, null, function* () {
    var pkce = sdk.options.pkce !== false;
    if (pkce && (res.code || res.interaction_code)) {
      return sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {
        authorizationCode: res.code,
        interactionCode: res.interaction_code
      }), urls);
    }
    tokenParams = tokenParams || getDefaultTokenParams(sdk);
    urls = urls || getOAuthUrls(sdk, tokenParams);
    var responseType = tokenParams.responseType || [];
    if (!Array.isArray(responseType)) {
      responseType = [responseType];
    }
    var scopes;
    if (res.scope) {
      scopes = res.scope.split(" ");
    } else {
      scopes = clone(tokenParams.scopes);
    }
    var clientId = tokenParams.clientId || sdk.options.clientId;
    validateResponse(res, tokenParams);
    var tokenDict = {};
    var expiresIn = res.expires_in;
    var tokenType = res.token_type;
    var accessToken = res.access_token;
    var idToken = res.id_token;
    var refreshToken = res.refresh_token;
    var now = Math.floor(Date.now() / 1e3);
    if (accessToken) {
      var accessJwt = sdk.token.decode(accessToken);
      tokenDict.accessToken = {
        accessToken,
        claims: accessJwt.payload,
        expiresAt: Number(expiresIn) + now,
        tokenType,
        scopes,
        authorizeUrl: urls.authorizeUrl,
        userinfoUrl: urls.userinfoUrl
      };
    }
    if (refreshToken) {
      tokenDict.refreshToken = {
        refreshToken,
        expiresAt: Number(expiresIn) + now,
        scopes,
        tokenUrl: urls.tokenUrl,
        authorizeUrl: urls.authorizeUrl,
        issuer: urls.issuer
      };
    }
    if (idToken) {
      var idJwt = sdk.token.decode(idToken);
      var idTokenObj = {
        idToken,
        claims: idJwt.payload,
        expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,
        scopes,
        authorizeUrl: urls.authorizeUrl,
        issuer: urls.issuer,
        clientId
      };
      var validationParams = {
        clientId,
        issuer: urls.issuer,
        nonce: tokenParams.nonce,
        accessToken
      };
      if (tokenParams.ignoreSignature !== void 0) {
        validationParams.ignoreSignature = tokenParams.ignoreSignature;
      }
      yield verifyToken2(sdk, idTokenObj, validationParams);
      tokenDict.idToken = idTokenObj;
    }
    if (responseType.indexOf("token") !== -1 && !tokenDict.accessToken) {
      throw new AuthSdkError('Unable to parse OAuth flow response: response type "token" was requested but "access_token" was not returned.');
    }
    if (responseType.indexOf("id_token") !== -1 && !tokenDict.idToken) {
      throw new AuthSdkError('Unable to parse OAuth flow response: response type "id_token" was requested but "id_token" was not returned.');
    }
    return {
      tokens: tokenDict,
      state: res.state,
      code: res.code
    };
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/getToken.js
function getToken(sdk, options2) {
  if (arguments.length > 2) {
    return Promise.reject(new AuthSdkError('As of version 3.0, "getToken" takes only a single set of options'));
  }
  options2 = options2 || {};
  const popupWindow = options2.popupWindow;
  options2.popupWindow = void 0;
  return prepareTokenParams(sdk, options2).then(function(tokenParams) {
    var sessionTokenOverrides = {
      prompt: "none",
      responseMode: "okta_post_message",
      display: null
    };
    var idpOverrides = {
      display: "popup"
    };
    if (options2.sessionToken) {
      Object.assign(tokenParams, sessionTokenOverrides);
    } else if (options2.idp) {
      Object.assign(tokenParams, idpOverrides);
    }
    var requestUrl, endpoint, urls;
    urls = getOAuthUrls(sdk, tokenParams);
    endpoint = options2.codeVerifier ? urls.tokenUrl : urls.authorizeUrl;
    requestUrl = endpoint + buildAuthorizeParams(tokenParams);
    var flowType;
    if (tokenParams.sessionToken || tokenParams.display === null) {
      flowType = "IFRAME";
    } else if (tokenParams.display === "popup") {
      flowType = "POPUP";
    } else {
      flowType = "IMPLICIT";
    }
    switch (flowType) {
      case "IFRAME":
        var iframePromise = addPostMessageListener(sdk, options2.timeout, tokenParams.state);
        var iframeEl = loadFrame(requestUrl);
        return iframePromise.then(function(res) {
          return handleOAuthResponse(sdk, tokenParams, res, urls);
        }).finally(function() {
          var _a;
          if (document.body.contains(iframeEl)) {
            (_a = iframeEl.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(iframeEl);
          }
        });
      case "POPUP":
        var oauthPromise;
        if (tokenParams.responseMode === "okta_post_message") {
          if (!sdk.features.isPopupPostMessageSupported()) {
            throw new AuthSdkError("This browser doesn't have full postMessage support");
          }
          oauthPromise = addPostMessageListener(sdk, options2.timeout, tokenParams.state);
        }
        if (popupWindow) {
          popupWindow.location.assign(requestUrl);
        }
        var popupPromise = new Promise(function(resolve, reject) {
          var closePoller = setInterval(function() {
            if (!popupWindow || popupWindow.closed) {
              clearInterval(closePoller);
              reject(new AuthSdkError("Unable to parse OAuth flow response"));
            }
          }, 100);
          oauthPromise.then(function(res) {
            clearInterval(closePoller);
            resolve(res);
          }).catch(function(err) {
            clearInterval(closePoller);
            reject(err);
          });
        });
        return popupPromise.then(function(res) {
          return handleOAuthResponse(sdk, tokenParams, res, urls);
        }).finally(function() {
          if (popupWindow && !popupWindow.closed) {
            popupWindow.close();
          }
        });
      default:
        throw new AuthSdkError("The full page redirect flow is not supported");
    }
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/getWithoutPrompt.js
function getWithoutPrompt(sdk, options2) {
  if (arguments.length > 2) {
    return Promise.reject(new AuthSdkError('As of version 3.0, "getWithoutPrompt" takes only a single set of options'));
  }
  options2 = clone(options2) || {};
  Object.assign(options2, {
    prompt: "none",
    responseMode: "okta_post_message",
    display: null
  });
  return getToken(sdk, options2);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/refreshToken.js
function isSameRefreshToken(a2, b2) {
  return a2.refreshToken === b2.refreshToken;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/endpoints/token.js
function validateOptions(options2) {
  if (!options2.clientId) {
    throw new AuthSdkError("A clientId must be specified in the OktaAuth constructor to get a token");
  }
  if (!options2.redirectUri) {
    throw new AuthSdkError("The redirectUri passed to /authorize must also be passed to /token");
  }
  if (!options2.authorizationCode && !options2.interactionCode) {
    throw new AuthSdkError("An authorization code (returned from /authorize) must be passed to /token");
  }
  if (!options2.codeVerifier) {
    throw new AuthSdkError('The "codeVerifier" (generated and saved by your app) must be passed to /token');
  }
}
function getPostData(sdk, options2) {
  var params = removeNils({
    "client_id": options2.clientId,
    "redirect_uri": options2.redirectUri,
    "grant_type": options2.interactionCode ? "interaction_code" : "authorization_code",
    "code_verifier": options2.codeVerifier
  });
  if (options2.interactionCode) {
    params["interaction_code"] = options2.interactionCode;
  } else if (options2.authorizationCode) {
    params.code = options2.authorizationCode;
  }
  const { clientSecret } = sdk.options;
  if (clientSecret) {
    params["client_secret"] = clientSecret;
  }
  return toQueryString(params).slice(1);
}
function postToTokenEndpoint(sdk, options2, urls) {
  validateOptions(options2);
  var data = getPostData(sdk, options2);
  const headers = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  return httpRequest(sdk, {
    url: urls.tokenUrl,
    method: "POST",
    args: data,
    headers
  });
}
function postRefreshToken(sdk, options2, refreshToken) {
  return httpRequest(sdk, {
    url: refreshToken.tokenUrl,
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    args: Object.entries({
      client_id: options2.clientId,
      grant_type: "refresh_token",
      scope: refreshToken.scopes.join(" "),
      refresh_token: refreshToken.refreshToken
    }).map(function([name, value]) {
      return name + "=" + encodeURIComponent(value);
    }).join("&")
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/renewTokensWithRefresh.js
function renewTokensWithRefresh(sdk, tokenParams, refreshTokenObject) {
  return __async(this, null, function* () {
    const { clientId } = sdk.options;
    if (!clientId) {
      throw new AuthSdkError("A clientId must be specified in the OktaAuth constructor to renew tokens");
    }
    try {
      const renewTokenParams = Object.assign({}, tokenParams, {
        clientId
      });
      const tokenResponse = yield postRefreshToken(sdk, renewTokenParams, refreshTokenObject);
      const urls = getOAuthUrls(sdk, tokenParams);
      const { tokens } = yield handleOAuthResponse(sdk, renewTokenParams, tokenResponse, urls);
      const { refreshToken } = tokens;
      if (refreshToken && !isSameRefreshToken(refreshToken, refreshTokenObject)) {
        sdk.tokenManager.updateRefreshToken(refreshToken);
      }
      return tokens;
    } catch (err) {
      if (isRefreshTokenInvalidError(err)) {
        sdk.tokenManager.removeRefreshToken();
      }
      throw err;
    }
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/renewToken.js
function throwInvalidTokenError() {
  throw new AuthSdkError("Renew must be passed a token with an array of scopes and an accessToken or idToken");
}
function getSingleToken(originalToken, tokens) {
  if (isIDToken(originalToken)) {
    return tokens.idToken;
  }
  if (isAccessToken(originalToken)) {
    return tokens.accessToken;
  }
  throwInvalidTokenError();
}
function renewToken(sdk, token) {
  return __async(this, null, function* () {
    if (!isIDToken(token) && !isAccessToken(token)) {
      throwInvalidTokenError();
    }
    let tokens = sdk.tokenManager.getTokensSync();
    if (tokens.refreshToken) {
      tokens = yield renewTokensWithRefresh(sdk, {
        scopes: token.scopes
      }, tokens.refreshToken);
      return getSingleToken(token, tokens);
    }
    var responseType;
    if (sdk.options.pkce) {
      responseType = "code";
    } else if (isAccessToken(token)) {
      responseType = "token";
    } else {
      responseType = "id_token";
    }
    const { scopes, authorizeUrl, userinfoUrl, issuer } = token;
    return getWithoutPrompt(sdk, {
      responseType,
      scopes,
      authorizeUrl,
      userinfoUrl,
      issuer
    }).then(function(res) {
      return getSingleToken(token, res.tokens);
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/renewTokens.js
function renewTokens(sdk, options2) {
  return __async(this, null, function* () {
    const tokens = sdk.tokenManager.getTokensSync();
    if (tokens.refreshToken) {
      return renewTokensWithRefresh(sdk, options2 || {}, tokens.refreshToken);
    }
    if (!tokens.accessToken && !tokens.idToken) {
      throw new AuthSdkError("renewTokens() was called but there is no existing token");
    }
    const accessToken = tokens.accessToken || {};
    const idToken = tokens.idToken || {};
    const scopes = accessToken.scopes || idToken.scopes;
    if (!scopes) {
      throw new AuthSdkError("renewTokens: invalid tokens: could not read scopes");
    }
    const authorizeUrl = accessToken.authorizeUrl || idToken.authorizeUrl;
    if (!authorizeUrl) {
      throw new AuthSdkError("renewTokens: invalid tokens: could not read authorizeUrl");
    }
    const userinfoUrl = accessToken.userinfoUrl || sdk.options.userinfoUrl;
    const issuer = idToken.issuer || sdk.options.issuer;
    options2 = Object.assign({
      scopes,
      authorizeUrl,
      userinfoUrl,
      issuer
    }, options2);
    if (sdk.options.pkce) {
      options2.responseType = "code";
    } else {
      const { responseType } = getDefaultTokenParams(sdk);
      options2.responseType = responseType;
    }
    return getWithoutPrompt(sdk, options2).then((res) => res.tokens);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/getUserInfo.js
function getUserInfo(sdk, accessTokenObject, idTokenObject) {
  return __async(this, null, function* () {
    if (!accessTokenObject) {
      accessTokenObject = (yield sdk.tokenManager.getTokens()).accessToken;
    }
    if (!idTokenObject) {
      idTokenObject = (yield sdk.tokenManager.getTokens()).idToken;
    }
    if (!accessTokenObject || !isAccessToken(accessTokenObject)) {
      return Promise.reject(new AuthSdkError("getUserInfo requires an access token object"));
    }
    if (!idTokenObject || !isIDToken(idTokenObject)) {
      return Promise.reject(new AuthSdkError("getUserInfo requires an ID token object"));
    }
    return httpRequest(sdk, {
      url: accessTokenObject.userinfoUrl,
      method: "GET",
      accessToken: accessTokenObject.accessToken
    }).then((userInfo) => {
      if (userInfo.sub === idTokenObject.claims.sub) {
        return userInfo;
      }
      return Promise.reject(new AuthSdkError("getUserInfo request was rejected due to token mismatch"));
    }).catch(function(err) {
      if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {
        var authenticateHeader;
        if (err.xhr.headers && isFunction3(err.xhr.headers.get) && err.xhr.headers.get("WWW-Authenticate")) {
          authenticateHeader = err.xhr.headers.get("WWW-Authenticate");
        } else if (isFunction3(err.xhr.getResponseHeader)) {
          authenticateHeader = err.xhr.getResponseHeader("WWW-Authenticate");
        }
        if (authenticateHeader) {
          var errorMatches = authenticateHeader.match(/error="(.*?)"/) || [];
          var errorDescriptionMatches = authenticateHeader.match(/error_description="(.*?)"/) || [];
          var error = errorMatches[1];
          var errorDescription = errorDescriptionMatches[1];
          if (error && errorDescription) {
            err = new OAuthError2(error, errorDescription);
          }
        }
      }
      throw err;
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/exchangeCodeForTokens.js
function exchangeCodeForTokens(sdk, tokenParams, urls) {
  urls = urls || getOAuthUrls(sdk, tokenParams);
  tokenParams = Object.assign({}, getDefaultTokenParams(sdk), clone(tokenParams));
  const { authorizationCode, interactionCode, codeVerifier, clientId, redirectUri, scopes, ignoreSignature, state } = tokenParams;
  var getTokenOptions = {
    clientId,
    redirectUri,
    authorizationCode,
    interactionCode,
    codeVerifier
  };
  return postToTokenEndpoint(sdk, getTokenOptions, urls).then((response) => {
    const responseType = ["token"];
    if (scopes.indexOf("openid") !== -1) {
      responseType.push("id_token");
    }
    const handleResponseOptions = {
      clientId,
      redirectUri,
      scopes,
      responseType,
      ignoreSignature
    };
    return handleOAuthResponse(sdk, handleResponseOptions, response, urls).then((response2) => {
      response2.code = authorizationCode;
      response2.state = state;
      return response2;
    });
  }).finally(() => {
    sdk.transactionManager.clear();
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/getWithPopup.js
function getWithPopup(sdk, options2) {
  if (arguments.length > 2) {
    return Promise.reject(new AuthSdkError('As of version 3.0, "getWithPopup" takes only a single set of options'));
  }
  const popupWindow = loadPopup("/", options2);
  options2 = clone(options2) || {};
  Object.assign(options2, {
    display: "popup",
    responseMode: "okta_post_message",
    popupWindow
  });
  return getToken(sdk, options2);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/oauthMeta.js
function createOAuthMeta(sdk, tokenParams) {
  const issuer = sdk.options.issuer;
  const urls = getOAuthUrls(sdk, tokenParams);
  const oauthMeta = {
    issuer,
    urls,
    clientId: tokenParams.clientId,
    redirectUri: tokenParams.redirectUri,
    responseType: tokenParams.responseType,
    responseMode: tokenParams.responseMode,
    scopes: tokenParams.scopes,
    state: tokenParams.state,
    nonce: tokenParams.nonce,
    ignoreSignature: tokenParams.ignoreSignature
  };
  if (tokenParams.pkce === false) {
    return oauthMeta;
  }
  const pkceMeta = Object.assign(Object.assign({}, oauthMeta), { codeVerifier: tokenParams.codeVerifier, codeChallengeMethod: tokenParams.codeChallengeMethod, codeChallenge: tokenParams.codeChallenge });
  return pkceMeta;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/getWithRedirect.js
function getWithRedirect(_0, _1) {
  return __async(this, arguments, function* (sdk, options2) {
    if (arguments.length > 2) {
      return Promise.reject(new AuthSdkError('As of version 3.0, "getWithRedirect" takes only a single set of options'));
    }
    options2 = clone(options2) || {};
    const tokenParams = yield prepareTokenParams(sdk, options2);
    const meta = createOAuthMeta(sdk, tokenParams);
    const requestUrl = meta.urls.authorizeUrl + buildAuthorizeParams(tokenParams);
    sdk.transactionManager.save(meta, { oauth: true });
    sdk.token.getWithRedirect._setLocation(requestUrl);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/urlParams.js
function urlParamsToObject(hashOrSearch) {
  var plus2space = /\+/g;
  var paramSplit = /([^&=]+)=?([^&]*)/g;
  var fragment = hashOrSearch || "";
  if (fragment.charAt(0) === "#" && fragment.charAt(1) === "/") {
    fragment = fragment.substring(2);
  }
  if (fragment.charAt(0) === "#" || fragment.charAt(0) === "?") {
    fragment = fragment.substring(1);
  }
  var obj = {};
  var param;
  while (true) {
    param = paramSplit.exec(fragment);
    if (!param) {
      break;
    }
    var key = param[1];
    var value = param[2];
    if (key === "id_token" || key === "access_token" || key === "code") {
      obj[key] = value;
    } else {
      obj[key] = decodeURIComponent(value.replace(plus2space, " "));
    }
  }
  return obj;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/parseFromUrl.js
function removeHash(sdk) {
  var nativeHistory = sdk.token.parseFromUrl._getHistory();
  var nativeDoc = sdk.token.parseFromUrl._getDocument();
  var nativeLoc = sdk.token.parseFromUrl._getLocation();
  if (nativeHistory && nativeHistory.replaceState) {
    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);
  } else {
    nativeLoc.hash = "";
  }
}
function removeSearch(sdk) {
  var nativeHistory = sdk.token.parseFromUrl._getHistory();
  var nativeDoc = sdk.token.parseFromUrl._getDocument();
  var nativeLoc = sdk.token.parseFromUrl._getLocation();
  if (nativeHistory && nativeHistory.replaceState) {
    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.hash);
  } else {
    nativeLoc.search = "";
  }
}
function getResponseMode(sdk) {
  var defaultResponseMode = sdk.options.pkce ? "query" : "fragment";
  var responseMode = sdk.options.responseMode || defaultResponseMode;
  return responseMode;
}
function parseOAuthResponseFromUrl(sdk, options2) {
  options2 = options2 || {};
  if (isString(options2)) {
    options2 = { url: options2 };
  } else {
    options2 = options2;
  }
  var url = options2.url;
  var responseMode = options2.responseMode || getResponseMode(sdk);
  var nativeLoc = sdk.token.parseFromUrl._getLocation();
  var paramStr;
  if (responseMode === "query") {
    paramStr = url ? url.substring(url.indexOf("?")) : nativeLoc.search;
  } else {
    paramStr = url ? url.substring(url.indexOf("#")) : nativeLoc.hash;
  }
  if (!paramStr) {
    throw new AuthSdkError("Unable to parse a token from the url");
  }
  return urlParamsToObject(paramStr);
}
function cleanOAuthResponseFromUrl(sdk, options2) {
  const responseMode = options2.responseMode || getResponseMode(sdk);
  responseMode === "query" ? removeSearch(sdk) : removeHash(sdk);
}
function parseFromUrl(sdk, options2) {
  return __async(this, null, function* () {
    options2 = options2 || {};
    if (isString(options2)) {
      options2 = { url: options2 };
    } else {
      options2 = options2;
    }
    const res = parseOAuthResponseFromUrl(sdk, options2);
    const state = res.state;
    const oauthParams = sdk.transactionManager.load({
      oauth: true,
      pkce: sdk.options.pkce,
      state
    });
    if (!oauthParams) {
      return Promise.reject(new AuthSdkError("Unable to retrieve OAuth redirect params from storage"));
    }
    const urls = oauthParams.urls;
    delete oauthParams.urls;
    if (!options2.url) {
      cleanOAuthResponseFromUrl(sdk, options2);
    }
    return handleOAuthResponse(sdk, oauthParams, res, urls).catch((err) => {
      if (!isInteractionRequiredError(err)) {
        sdk.transactionManager.clear({
          state
        });
      }
      throw err;
    }).then((res2) => {
      sdk.transactionManager.clear({
        state
      });
      return res2;
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/crypto/webauthn.js
var webauthn_exports = {};
__export(webauthn_exports, {
  buildCredentialCreationOptions: () => buildCredentialCreationOptions,
  buildCredentialRequestOptions: () => buildCredentialRequestOptions,
  getAssertion: () => getAssertion,
  getAttestation: () => getAttestation
});
var getEnrolledCredentials = (authenticatorEnrollments = []) => {
  const credentials = [];
  authenticatorEnrollments.forEach((enrollement) => {
    if (enrollement.key === "webauthn") {
      credentials.push({
        type: "public-key",
        id: base64UrlToBuffer(enrollement.credentialId)
      });
    }
  });
  return credentials;
};
var buildCredentialCreationOptions = (activationData, authenticatorEnrollments) => {
  return {
    publicKey: {
      rp: activationData.rp,
      user: {
        id: base64UrlToBuffer(activationData.user.id),
        name: activationData.user.name,
        displayName: activationData.user.displayName
      },
      challenge: base64UrlToBuffer(activationData.challenge),
      pubKeyCredParams: activationData.pubKeyCredParams,
      attestation: activationData.attestation,
      authenticatorSelection: activationData.authenticatorSelection,
      excludeCredentials: getEnrolledCredentials(authenticatorEnrollments)
    }
  };
};
var buildCredentialRequestOptions = (challengeData, authenticatorEnrollments) => {
  return {
    publicKey: {
      challenge: base64UrlToBuffer(challengeData.challenge),
      userVerification: challengeData.userVerification,
      allowCredentials: getEnrolledCredentials(authenticatorEnrollments)
    }
  };
};
var getAttestation = (credential) => {
  const response = credential.response;
  const id = credential.id;
  const clientData = bufferToBase64Url(response.clientDataJSON);
  const attestation = bufferToBase64Url(response.attestationObject);
  return {
    id,
    clientData,
    attestation
  };
};
var getAssertion = (credential) => {
  const response = credential.response;
  const id = credential.id;
  const clientData = bufferToBase64Url(response.clientDataJSON);
  const authenticatorData = bufferToBase64Url(response.authenticatorData);
  const signatureData = bufferToBase64Url(response.signature);
  return {
    id,
    clientData,
    authenticatorData,
    signatureData
  };
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/console.js
function getNativeConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  } else if (typeof console !== "undefined") {
    return console;
  } else {
    return void 0;
  }
}
function getConsole() {
  var nativeConsole = getNativeConsole();
  if (nativeConsole && nativeConsole.log) {
    return nativeConsole;
  }
  return {
    log: function() {
    },
    warn: function() {
    },
    group: function() {
    },
    groupEnd: function() {
    }
  };
}
function warn(text) {
  getConsole().warn("[okta-auth-sdk] WARN: " + text);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/browser/browserStorage.js
var storageUtil = {
  getHttpCache() {
    return null;
  },
  getPKCEStorage() {
    return null;
  },
  browserHasLocalStorage: function() {
    try {
      var storage = this.getLocalStorage();
      return this.testStorage(storage);
    } catch (e) {
      return false;
    }
  },
  browserHasSessionStorage: function() {
    try {
      var storage = this.getSessionStorage();
      return this.testStorage(storage);
    } catch (e) {
      return false;
    }
  },
  testStorageType: function(storageType) {
    var supported = false;
    switch (storageType) {
      case "sessionStorage":
        supported = this.browserHasSessionStorage();
        break;
      case "localStorage":
        supported = this.browserHasLocalStorage();
        break;
      case "cookie":
      case "memory":
        supported = true;
        break;
      default:
        supported = false;
        break;
    }
    return supported;
  },
  getStorageByType: function(storageType, options2) {
    let storageProvider;
    switch (storageType) {
      case "sessionStorage":
        storageProvider = this.getSessionStorage();
        break;
      case "localStorage":
        storageProvider = this.getLocalStorage();
        break;
      case "cookie":
        storageProvider = this.getCookieStorage(options2);
        break;
      case "memory":
        storageProvider = this.getInMemoryStorage();
        break;
      default:
        throw new AuthSdkError(`Unrecognized storage option: ${storageType}`);
    }
    return storageProvider;
  },
  findStorageType: function(types) {
    let curType;
    let nextType;
    types = types.slice();
    curType = types.shift();
    nextType = types.length ? types[0] : null;
    if (!nextType) {
      return curType;
    }
    if (this.testStorageType(curType)) {
      return curType;
    }
    warn(`This browser doesn't support ${curType}. Switching to ${nextType}.`);
    return this.findStorageType(types);
  },
  getLocalStorage: function() {
    if (isIE11OrLess() && !window.onstorage) {
      window.onstorage = function() {
      };
    }
    return localStorage;
  },
  getSessionStorage: function() {
    return sessionStorage;
  },
  getCookieStorage: function(options2) {
    const secure = options2.secure;
    const sameSite = options2.sameSite;
    const sessionCookie = options2.sessionCookie;
    if (typeof secure === "undefined" || typeof sameSite === "undefined") {
      throw new AuthSdkError('getCookieStorage: "secure" and "sameSite" options must be provided');
    }
    const storage = {
      getItem: this.storage.get,
      setItem: (key, value, expiresAt = "2200-01-01T00:00:00.000Z") => {
        expiresAt = sessionCookie ? null : expiresAt;
        this.storage.set(key, value, expiresAt, {
          secure,
          sameSite
        });
      },
      removeItem: (key) => {
        this.storage.delete(key);
      },
      isSharedStorage: () => true
    };
    if (!options2.useSeparateCookies) {
      return storage;
    }
    return {
      getItem: function(key) {
        var data = storage.getItem();
        var value = {};
        Object.keys(data).forEach((k) => {
          if (k.indexOf(key) === 0) {
            value[k.replace(`${key}_`, "")] = JSON.parse(data[k]);
          }
        });
        return JSON.stringify(value);
      },
      setItem: function(key, value) {
        var existingValues = JSON.parse(this.getItem(key));
        value = JSON.parse(value);
        Object.keys(value).forEach((k) => {
          var storageKey = key + "_" + k;
          var valueToStore = JSON.stringify(value[k]);
          storage.setItem(storageKey, valueToStore);
          delete existingValues[k];
        });
        Object.keys(existingValues).forEach((k) => {
          storage.removeItem(key + "_" + k);
        });
      },
      removeItem: function(key) {
        var existingValues = JSON.parse(this.getItem(key));
        Object.keys(existingValues).forEach((k) => {
          storage.removeItem(key + "_" + k);
        });
      },
      isSharedStorage: () => true
    };
  },
  inMemoryStore: {},
  getInMemoryStorage: function() {
    return {
      getItem: (key) => {
        return this.inMemoryStore[key];
      },
      setItem: (key, value) => {
        this.inMemoryStore[key] = value;
      },
      isSharedStorage: () => false
    };
  },
  testStorage: function(storage) {
    var key = "okta-test-storage";
    try {
      storage.setItem(key, key);
      storage.removeItem(key);
      return true;
    } catch (e) {
      return false;
    }
  },
  storage: {
    set: function(name, value, expiresAt, options2) {
      const { sameSite, secure } = options2;
      if (typeof secure === "undefined" || typeof sameSite === "undefined") {
        throw new AuthSdkError('storage.set: "secure" and "sameSite" options must be provided');
      }
      var cookieOptions = {
        path: options2.path || "/",
        secure,
        sameSite
      };
      if (!!Date.parse(expiresAt)) {
        cookieOptions.expires = new Date(expiresAt);
      }
      api.set(name, value, cookieOptions);
      return this.get(name);
    },
    get: function(name) {
      if (!arguments.length) {
        return api.get();
      }
      return api.get(name);
    },
    delete: function(name) {
      return api.remove(name, { path: "/" });
    }
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/validateToken.js
function validateToken(token, type) {
  if (!isIDToken(token) && !isAccessToken(token) && !isRefreshToken(token)) {
    throw new AuthSdkError("Token must be an Object with scopes, expiresAt, and one of: an idToken, accessToken, or refreshToken property");
  }
  if (type === "accessToken" && !isAccessToken(token)) {
    throw new AuthSdkError("invalid accessToken");
  }
  if (type === "idToken" && !isIDToken(token)) {
    throw new AuthSdkError("invalid idToken");
  }
  if (type === "refreshToken" && !isRefreshToken(token)) {
    throw new AuthSdkError("invalid refreshToken");
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/clock.js
var SdkClock = class _SdkClock {
  constructor(localOffset) {
    this.localOffset = parseInt(localOffset || 0);
  }
  static create() {
    var localOffset = 0;
    return new _SdkClock(localOffset);
  }
  now() {
    var now = (Date.now() + this.localOffset) / 1e3;
    return now;
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/types/TokenManager.js
var EVENT_EXPIRED = "expired";
var EVENT_RENEWED = "renewed";
var EVENT_ADDED = "added";
var EVENT_REMOVED = "removed";
var EVENT_ERROR = "error";
var EVENT_SET_STORAGE = "set_storage";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/TokenManager.js
var DEFAULT_OPTIONS = {
  autoRenew: true,
  autoRemove: true,
  syncStorage: true,
  clearPendingRemoveTokens: true,
  storage: void 0,
  expireEarlySeconds: 30,
  storageKey: TOKEN_STORAGE_NAME
};
function defaultState() {
  return {
    expireTimeouts: {},
    renewPromise: null
  };
}
var TokenManager = class {
  constructor(sdk, options2 = {}) {
    this.sdk = sdk;
    this.emitter = sdk.emitter;
    if (!this.emitter) {
      throw new AuthSdkError("Emitter should be initialized before TokenManager");
    }
    options2 = Object.assign({}, DEFAULT_OPTIONS, removeNils(options2));
    if (!isLocalhost()) {
      options2.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;
    }
    this.options = options2;
    const storageOptions = removeNils({
      storageKey: options2.storageKey,
      secure: options2.secure
    });
    if (typeof options2.storage === "object") {
      storageOptions.storageProvider = options2.storage;
    } else if (options2.storage) {
      storageOptions.storageType = options2.storage;
    }
    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), { useSeparateCookies: true }));
    this.clock = SdkClock.create();
    this.state = defaultState();
  }
  on(event, handler, context) {
    if (context) {
      this.emitter.on(event, handler, context);
    } else {
      this.emitter.on(event, handler);
    }
  }
  off(event, handler) {
    if (handler) {
      this.emitter.off(event, handler);
    } else {
      this.emitter.off(event);
    }
  }
  hasSharedStorage() {
    return this.storage.isSharedStorage();
  }
  start() {
    if (this.options.clearPendingRemoveTokens) {
      this.clearPendingRemoveTokens();
    }
    this.setExpireEventTimeoutAll();
  }
  stop() {
    this.clearExpireEventTimeoutAll();
  }
  getOptions() {
    return clone(this.options);
  }
  getExpireTime(token) {
    const expireEarlySeconds = this.options.expireEarlySeconds || 0;
    var expireTime = token.expiresAt - expireEarlySeconds;
    return expireTime;
  }
  hasExpired(token) {
    var expireTime = this.getExpireTime(token);
    return expireTime <= this.clock.now();
  }
  emitExpired(key, token) {
    this.emitter.emit(EVENT_EXPIRED, key, token);
  }
  emitRenewed(key, freshToken, oldToken) {
    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);
  }
  emitAdded(key, token) {
    this.emitter.emit(EVENT_ADDED, key, token);
  }
  emitRemoved(key, token) {
    this.emitter.emit(EVENT_REMOVED, key, token);
  }
  emitError(error) {
    this.emitter.emit(EVENT_ERROR, error);
  }
  clearExpireEventTimeout(key) {
    clearTimeout(this.state.expireTimeouts[key]);
    delete this.state.expireTimeouts[key];
    this.state.renewPromise = null;
  }
  clearExpireEventTimeoutAll() {
    var expireTimeouts = this.state.expireTimeouts;
    for (var key in expireTimeouts) {
      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {
        continue;
      }
      this.clearExpireEventTimeout(key);
    }
  }
  setExpireEventTimeout(key, token) {
    if (isRefreshToken(token)) {
      return;
    }
    var expireTime = this.getExpireTime(token);
    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1e3;
    this.clearExpireEventTimeout(key);
    var expireEventTimeout = setTimeout(() => {
      this.emitExpired(key, token);
    }, expireEventWait);
    this.state.expireTimeouts[key] = expireEventTimeout;
  }
  setExpireEventTimeoutAll() {
    var tokenStorage = this.storage.getStorage();
    for (var key in tokenStorage) {
      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {
        continue;
      }
      var token = tokenStorage[key];
      this.setExpireEventTimeout(key, token);
    }
  }
  resetExpireEventTimeoutAll() {
    this.clearExpireEventTimeoutAll();
    this.setExpireEventTimeoutAll();
  }
  add(key, token) {
    var tokenStorage = this.storage.getStorage();
    validateToken(token);
    tokenStorage[key] = token;
    this.storage.setStorage(tokenStorage);
    this.emitSetStorageEvent();
    this.emitAdded(key, token);
    this.setExpireEventTimeout(key, token);
  }
  getSync(key) {
    var tokenStorage = this.storage.getStorage();
    return tokenStorage[key];
  }
  get(key) {
    return __async(this, null, function* () {
      return this.getSync(key);
    });
  }
  getTokensSync() {
    const tokens = {};
    const tokenStorage = this.storage.getStorage();
    Object.keys(tokenStorage).forEach((key) => {
      const token = tokenStorage[key];
      if (isAccessToken(token)) {
        tokens.accessToken = token;
      } else if (isIDToken(token)) {
        tokens.idToken = token;
      } else if (isRefreshToken(token)) {
        tokens.refreshToken = token;
      }
    });
    return tokens;
  }
  getTokens() {
    return __async(this, null, function* () {
      return this.getTokensSync();
    });
  }
  getStorageKeyByType(type) {
    const tokenStorage = this.storage.getStorage();
    const key = Object.keys(tokenStorage).filter((key2) => {
      const token = tokenStorage[key2];
      return isAccessToken(token) && type === "accessToken" || isIDToken(token) && type === "idToken" || isRefreshToken(token) && type === "refreshToken";
    })[0];
    return key;
  }
  getTokenType(token) {
    if (isAccessToken(token)) {
      return "accessToken";
    }
    if (isIDToken(token)) {
      return "idToken";
    }
    if (isRefreshToken(token)) {
      return "refreshToken";
    }
    throw new AuthSdkError("Unknown token type");
  }
  emitSetStorageEvent() {
    if (isIE11OrLess()) {
      const storage = this.storage.getStorage();
      this.emitter.emit(EVENT_SET_STORAGE, storage);
    }
  }
  getStorage() {
    return this.storage;
  }
  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {
    const handleTokenCallback = (key, token) => {
      const type = this.getTokenType(token);
      if (type === "accessToken") {
        accessTokenCb && accessTokenCb(key, token);
      } else if (type === "idToken") {
        idTokenCb && idTokenCb(key, token);
      } else if (type === "refreshToken") {
        refreshTokenCb && refreshTokenCb(key, token);
      }
    };
    const handleAdded = (key, token) => {
      this.emitAdded(key, token);
      this.setExpireEventTimeout(key, token);
      handleTokenCallback(key, token);
    };
    const handleRenewed = (key, token, oldToken) => {
      this.emitRenewed(key, token, oldToken);
      this.clearExpireEventTimeout(key);
      this.setExpireEventTimeout(key, token);
      handleTokenCallback(key, token);
    };
    const handleRemoved = (key, token) => {
      this.clearExpireEventTimeout(key);
      this.emitRemoved(key, token);
      handleTokenCallback(key, token);
    };
    const types = ["idToken", "accessToken", "refreshToken"];
    const existingTokens = this.getTokensSync();
    types.forEach((type) => {
      const token = tokens[type];
      if (token) {
        validateToken(token, type);
      }
    });
    const storage = types.reduce((storage2, type) => {
      const token = tokens[type];
      if (token) {
        const storageKey = this.getStorageKeyByType(type) || type;
        storage2[storageKey] = token;
      }
      return storage2;
    }, {});
    this.storage.setStorage(storage);
    this.emitSetStorageEvent();
    types.forEach((type) => {
      const newToken = tokens[type];
      const existingToken = existingTokens[type];
      const storageKey = this.getStorageKeyByType(type) || type;
      if (newToken && existingToken) {
        handleRemoved(storageKey, existingToken);
        handleAdded(storageKey, newToken);
        handleRenewed(storageKey, newToken, existingToken);
      } else if (newToken) {
        handleAdded(storageKey, newToken);
      } else if (existingToken) {
        handleRemoved(storageKey, existingToken);
      }
    });
  }
  remove(key) {
    this.clearExpireEventTimeout(key);
    var tokenStorage = this.storage.getStorage();
    var removedToken = tokenStorage[key];
    delete tokenStorage[key];
    this.storage.setStorage(tokenStorage);
    this.emitSetStorageEvent();
    this.emitRemoved(key, removedToken);
  }
  renewToken(token) {
    return __async(this, null, function* () {
      var _a;
      return (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);
    });
  }
  validateToken(token) {
    return validateToken(token);
  }
  renew(key) {
    if (this.state.renewPromise) {
      return this.state.renewPromise;
    }
    try {
      var token = this.getSync(key);
      if (!token) {
        throw new AuthSdkError("The tokenManager has no token for the key: " + key);
      }
    } catch (e) {
      return Promise.reject(e);
    }
    this.clearExpireEventTimeout(key);
    this.state.renewPromise = this.sdk.token.renewTokens().then((tokens) => {
      this.setTokens(tokens);
      const tokenType = this.getTokenType(token);
      return tokens[tokenType];
    }).catch((err) => {
      this.remove(key);
      err.tokenKey = key;
      this.emitError(err);
      throw err;
    }).finally(() => {
      this.state.renewPromise = null;
    });
    return this.state.renewPromise;
  }
  clear() {
    const tokens = this.getTokensSync();
    this.clearExpireEventTimeoutAll();
    this.storage.clearStorage();
    this.emitSetStorageEvent();
    Object.keys(tokens).forEach((key) => {
      this.emitRemoved(key, tokens[key]);
    });
  }
  clearPendingRemoveTokens() {
    const tokenStorage = this.storage.getStorage();
    const removedTokens = {};
    Object.keys(tokenStorage).forEach((key) => {
      if (tokenStorage[key].pendingRemove) {
        removedTokens[key] = tokenStorage[key];
        delete tokenStorage[key];
      }
    });
    this.storage.setStorage(tokenStorage);
    this.emitSetStorageEvent();
    Object.keys(removedTokens).forEach((key) => {
      this.clearExpireEventTimeout(key);
      this.emitRemoved(key, removedTokens[key]);
    });
  }
  updateRefreshToken(token) {
    const key = this.getStorageKeyByType("refreshToken") || REFRESH_TOKEN_STORAGE_KEY;
    var tokenStorage = this.storage.getStorage();
    validateToken(token);
    tokenStorage[key] = token;
    this.storage.setStorage(tokenStorage);
    this.emitSetStorageEvent();
  }
  removeRefreshToken() {
    const key = this.getStorageKeyByType("refreshToken") || REFRESH_TOKEN_STORAGE_KEY;
    this.remove(key);
  }
  addPendingRemoveFlags() {
    const tokens = this.getTokensSync();
    Object.keys(tokens).forEach((key) => {
      tokens[key].pendingRemove = true;
    });
    this.setTokens(tokens);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/services/AutoRenewService.js
var AutoRenewService = class {
  constructor(tokenManager, options2 = {}) {
    this.started = false;
    this.tokenManager = tokenManager;
    this.options = options2;
    this.renewTimeQueue = [];
    this.onTokenExpiredHandler = this.onTokenExpiredHandler.bind(this);
  }
  shouldThrottleRenew() {
    let res = false;
    this.renewTimeQueue.push(Date.now());
    if (this.renewTimeQueue.length >= 10) {
      const firstTime = this.renewTimeQueue.shift();
      const lastTime = this.renewTimeQueue[this.renewTimeQueue.length - 1];
      res = lastTime - firstTime < 30 * 1e3;
    }
    return res;
  }
  requiresLeadership() {
    return !!this.options.syncStorage && isBrowser();
  }
  onTokenExpiredHandler(key) {
    if (this.options.autoRenew) {
      if (this.shouldThrottleRenew()) {
        const error = new AuthSdkError("Too many token renew requests");
        this.tokenManager.emitError(error);
      } else {
        this.tokenManager.renew(key).catch(() => {
        });
      }
    } else if (this.options.autoRemove) {
      this.tokenManager.remove(key);
    }
  }
  canStart() {
    return !!this.options.autoRenew || !!this.options.autoRemove;
  }
  start() {
    return __async(this, null, function* () {
      if (this.canStart()) {
        yield this.stop();
        this.tokenManager.on(EVENT_EXPIRED, this.onTokenExpiredHandler);
        this.started = true;
      }
    });
  }
  stop() {
    return __async(this, null, function* () {
      if (this.started) {
        this.tokenManager.off(EVENT_EXPIRED, this.onTokenExpiredHandler);
        this.renewTimeQueue = [];
        this.started = false;
      }
    });
  }
  isStarted() {
    return this.started;
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/services/SyncStorageService.js
var SyncStorageService = class {
  constructor(tokenManager, options2 = {}) {
    this.started = false;
    this.enablePostMessage = true;
    this.tokenManager = tokenManager;
    this.options = options2;
    this.onTokenAddedHandler = this.onTokenAddedHandler.bind(this);
    this.onTokenRemovedHandler = this.onTokenRemovedHandler.bind(this);
    this.onTokenRenewedHandler = this.onTokenRenewedHandler.bind(this);
    this.onSetStorageHandler = this.onSetStorageHandler.bind(this);
    this.onSyncMessageHandler = this.onSyncMessageHandler.bind(this);
  }
  requiresLeadership() {
    return false;
  }
  isStarted() {
    return this.started;
  }
  canStart() {
    return !!this.options.syncStorage && isBrowser() && this.tokenManager.hasSharedStorage();
  }
  start() {
    return __async(this, null, function* () {
      if (this.canStart()) {
        yield this.stop();
        const { syncChannelName } = this.options;
        this.channel = new BroadcastChannel(syncChannelName);
        this.tokenManager.on(EVENT_ADDED, this.onTokenAddedHandler);
        this.tokenManager.on(EVENT_REMOVED, this.onTokenRemovedHandler);
        this.tokenManager.on(EVENT_RENEWED, this.onTokenRenewedHandler);
        this.tokenManager.on(EVENT_SET_STORAGE, this.onSetStorageHandler);
        this.channel.addEventListener("message", this.onSyncMessageHandler);
        this.started = true;
      }
    });
  }
  stop() {
    return __async(this, null, function* () {
      var _a, _b;
      if (this.started) {
        this.tokenManager.off(EVENT_ADDED, this.onTokenAddedHandler);
        this.tokenManager.off(EVENT_REMOVED, this.onTokenRemovedHandler);
        this.tokenManager.off(EVENT_RENEWED, this.onTokenRenewedHandler);
        this.tokenManager.off(EVENT_SET_STORAGE, this.onSetStorageHandler);
        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.removeEventListener("message", this.onSyncMessageHandler);
        yield (_b = this.channel) === null || _b === void 0 ? void 0 : _b.close();
        this.channel = void 0;
        this.started = false;
      }
    });
  }
  onTokenAddedHandler(key, token) {
    var _a;
    if (!this.enablePostMessage) {
      return;
    }
    (_a = this.channel) === null || _a === void 0 ? void 0 : _a.postMessage({
      type: EVENT_ADDED,
      key,
      token
    });
  }
  onTokenRemovedHandler(key, token) {
    var _a;
    if (!this.enablePostMessage) {
      return;
    }
    (_a = this.channel) === null || _a === void 0 ? void 0 : _a.postMessage({
      type: EVENT_REMOVED,
      key,
      token
    });
  }
  onTokenRenewedHandler(key, token, oldToken) {
    var _a;
    if (!this.enablePostMessage) {
      return;
    }
    (_a = this.channel) === null || _a === void 0 ? void 0 : _a.postMessage({
      type: EVENT_RENEWED,
      key,
      token,
      oldToken
    });
  }
  onSetStorageHandler(storage) {
    var _a;
    (_a = this.channel) === null || _a === void 0 ? void 0 : _a.postMessage({
      type: EVENT_SET_STORAGE,
      storage
    });
  }
  onSyncMessageHandler(msg) {
    this.enablePostMessage = false;
    switch (msg.type) {
      case EVENT_SET_STORAGE:
        this.tokenManager.getStorage().setStorage(msg.storage);
        break;
      case EVENT_ADDED:
        this.tokenManager.emitAdded(msg.key, msg.token);
        this.tokenManager.setExpireEventTimeout(msg.key, msg.token);
        break;
      case EVENT_REMOVED:
        this.tokenManager.clearExpireEventTimeout(msg.key);
        this.tokenManager.emitRemoved(msg.key, msg.token);
        break;
      case EVENT_RENEWED:
        this.tokenManager.emitRenewed(msg.key, msg.token, msg.oldToken);
        break;
    }
    this.enablePostMessage = true;
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/services/LeaderElectionService.js
var LeaderElectionService = class {
  constructor(options2 = {}) {
    this.started = false;
    this.options = options2;
    this.onLeaderDuplicate = this.onLeaderDuplicate.bind(this);
    this.onLeader = this.onLeader.bind(this);
  }
  onLeaderDuplicate() {
  }
  onLeader() {
    return __async(this, null, function* () {
      var _a, _b;
      yield (_b = (_a = this.options).onLeader) === null || _b === void 0 ? void 0 : _b.call(_a);
    });
  }
  isLeader() {
    var _a;
    return !!((_a = this.elector) === null || _a === void 0 ? void 0 : _a.isLeader);
  }
  hasLeader() {
    var _a;
    return !!((_a = this.elector) === null || _a === void 0 ? void 0 : _a.hasLeader);
  }
  start() {
    return __async(this, null, function* () {
      yield this.stop();
      if (this.canStart()) {
        const { electionChannelName } = this.options;
        this.channel = new BroadcastChannel(electionChannelName);
        this.elector = createLeaderElection(this.channel);
        this.elector.onduplicate = this.onLeaderDuplicate;
        this.elector.awaitLeadership().then(this.onLeader);
        this.started = true;
      }
    });
  }
  stop() {
    return __async(this, null, function* () {
      if (this.started) {
        if (this.elector) {
          yield this.elector.die();
          this.elector = void 0;
        }
        if (this.channel) {
          this.channel.postInternal = () => Promise.resolve();
          yield this.channel.close();
          this.channel = void 0;
        }
        this.started = false;
      }
    });
  }
  requiresLeadership() {
    return false;
  }
  isStarted() {
    return this.started;
  }
  canStart() {
    return isBrowser();
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/ServiceManager.js
var AUTO_RENEW = "autoRenew";
var SYNC_STORAGE = "syncStorage";
var LEADER_ELECTION = "leaderElection";
var ServiceManager = class _ServiceManager {
  constructor(sdk, options2 = {}) {
    this.sdk = sdk;
    this.onLeader = this.onLeader.bind(this);
    const { autoRenew, autoRemove, syncStorage } = sdk.tokenManager.getOptions();
    options2.electionChannelName = options2.electionChannelName || options2.broadcastChannelName;
    this.options = Object.assign({}, _ServiceManager.defaultOptions, { autoRenew, autoRemove, syncStorage }, {
      electionChannelName: `${sdk.options.clientId}-election`,
      syncChannelName: `${sdk.options.clientId}-sync`
    }, removeNils(options2));
    this.started = false;
    this.services = /* @__PURE__ */ new Map();
    _ServiceManager.knownServices.forEach((name) => {
      const svc = this.createService(name);
      if (svc) {
        this.services.set(name, svc);
      }
    });
  }
  onLeader() {
    return __async(this, null, function* () {
      if (this.started) {
        yield this.startServices();
      }
    });
  }
  isLeader() {
    var _a;
    return (_a = this.getService(LEADER_ELECTION)) === null || _a === void 0 ? void 0 : _a.isLeader();
  }
  isLeaderRequired() {
    return [...this.services.values()].some((srv) => srv.canStart() && srv.requiresLeadership());
  }
  start() {
    return __async(this, null, function* () {
      if (this.started) {
        return;
      }
      yield this.startServices();
      this.started = true;
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.stopServices();
      this.started = false;
    });
  }
  getService(name) {
    return this.services.get(name);
  }
  startServices() {
    return __async(this, null, function* () {
      for (const [name, srv] of this.services.entries()) {
        if (this.canStartService(name, srv)) {
          yield srv.start();
        }
      }
    });
  }
  stopServices() {
    return __async(this, null, function* () {
      for (const srv of this.services.values()) {
        yield srv.stop();
      }
    });
  }
  canStartService(name, srv) {
    let canStart = srv.canStart() && !srv.isStarted();
    if (name === LEADER_ELECTION) {
      canStart && (canStart = this.isLeaderRequired());
    } else if (srv.requiresLeadership()) {
      canStart && (canStart = this.isLeader());
    }
    return canStart;
  }
  createService(name) {
    const tokenManager = this.sdk.tokenManager;
    let service;
    switch (name) {
      case LEADER_ELECTION:
        service = new LeaderElectionService(Object.assign(Object.assign({}, this.options), { onLeader: this.onLeader }));
        break;
      case AUTO_RENEW:
        service = new AutoRenewService(tokenManager, Object.assign({}, this.options));
        break;
      case SYNC_STORAGE:
        service = new SyncStorageService(tokenManager, Object.assign({}, this.options));
        break;
      default:
        throw new Error(`Unknown service ${name}`);
    }
    return service;
  }
};
ServiceManager.knownServices = [AUTO_RENEW, SYNC_STORAGE, LEADER_ELECTION];
ServiceManager.defaultOptions = {
  autoRenew: true,
  autoRemove: true,
  syncStorage: true
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/PromiseQueue.js
var PromiseQueue = class {
  constructor(options2 = { quiet: false }) {
    this.queue = [];
    this.running = false;
    this.options = options2;
  }
  push(method, thisObject, ...args) {
    return new Promise((resolve, reject) => {
      if (this.queue.length > 0) {
        if (this.options.quiet !== false) {
          warn("Async method is being called but another async method is already running. The new method will be delayed until the previous method completes.");
        }
      }
      this.queue.push({
        method,
        thisObject,
        args,
        resolve,
        reject
      });
      this.run();
    });
  }
  run() {
    if (this.running) {
      return;
    }
    if (this.queue.length === 0) {
      return;
    }
    this.running = true;
    var queueItem = this.queue.shift();
    var res = queueItem.method.apply(queueItem.thisObject, queueItem.args);
    if (isPromise(res)) {
      res.then(queueItem.resolve, queueItem.reject).finally(() => {
        this.running = false;
        this.run();
      });
    } else {
      queueItem.resolve(res);
      this.running = false;
      this.run();
    }
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/browser/fingerprint.js
function fingerprint(sdk, options2) {
  options2 = options2 || {};
  if (!isFingerprintSupported()) {
    return Promise.reject(new AuthSdkError("Fingerprinting is not supported on this device"));
  }
  var timeout;
  var iframe;
  var listener;
  var promise = new Promise(function(resolve, reject) {
    iframe = document.createElement("iframe");
    iframe.style.display = "none";
    listener = function listener2(e) {
      if (!e || !e.data || e.origin !== sdk.getIssuerOrigin()) {
        return;
      }
      try {
        var msg = JSON.parse(e.data);
      } catch (err) {
        return;
      }
      if (!msg) {
        return;
      }
      if (msg.type === "FingerprintAvailable") {
        return resolve(msg.fingerprint);
      }
      if (msg.type === "FingerprintServiceReady") {
        e.source.postMessage(JSON.stringify({
          type: "GetFingerprint"
        }), e.origin);
      }
    };
    addListener(window, "message", listener);
    iframe.src = sdk.getIssuerOrigin() + "/auth/services/devicefingerprint";
    document.body.appendChild(iframe);
    timeout = setTimeout(function() {
      reject(new AuthSdkError("Fingerprinting timed out"));
    }, (options2 === null || options2 === void 0 ? void 0 : options2.timeout) || 15e3);
  });
  return promise.finally(function() {
    clearTimeout(timeout);
    removeListener(window, "message", listener);
    if (document.body.contains(iframe)) {
      iframe.parentElement.removeChild(iframe);
    }
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/AuthStateManager.js
var import_p_cancelable = __toESM(require_p_cancelable(), 1);
var INITIAL_AUTH_STATE = null;
var DEFAULT_PENDING = {
  updateAuthStatePromise: null,
  canceledTimes: 0
};
var EVENT_AUTH_STATE_CHANGE = "authStateChange";
var MAX_PROMISE_CANCEL_TIMES = 10;
var isSameAuthState = (prevState, state) => {
  if (!prevState) {
    return false;
  }
  return prevState.isAuthenticated === state.isAuthenticated && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken) && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken) && prevState.error === state.error;
};
var AuthStateManager = class {
  constructor(sdk) {
    if (!sdk.emitter) {
      throw new AuthSdkError("Emitter should be initialized before AuthStateManager");
    }
    this._sdk = sdk;
    this._pending = Object.assign({}, DEFAULT_PENDING);
    this._authState = INITIAL_AUTH_STATE;
    this._logOptions = {};
    this._prevAuthState = null;
    this._transformQueue = new PromiseQueue({
      quiet: true
    });
    sdk.tokenManager.on(EVENT_ADDED, (key, token) => {
      this._setLogOptions({ event: EVENT_ADDED, key, token });
      this.updateAuthState();
    });
    sdk.tokenManager.on(EVENT_REMOVED, (key, token) => {
      this._setLogOptions({ event: EVENT_REMOVED, key, token });
      this.updateAuthState();
    });
  }
  _setLogOptions(options2) {
    this._logOptions = options2;
  }
  getAuthState() {
    return this._authState;
  }
  getPreviousAuthState() {
    return this._prevAuthState;
  }
  updateAuthState() {
    return __async(this, null, function* () {
      const { transformAuthState, devMode } = this._sdk.options;
      const log5 = (status) => {
        const { event, key, token } = this._logOptions;
        getConsole().group(`OKTA-AUTH-JS:updateAuthState: Event:${event} Status:${status}`);
        getConsole().log(key, token);
        getConsole().log("Current authState", this._authState);
        getConsole().groupEnd();
        this._logOptions = {};
      };
      const emitAuthStateChange = (authState) => {
        if (isSameAuthState(this._authState, authState)) {
          devMode && log5("unchanged");
          return;
        }
        this._prevAuthState = this._authState;
        this._authState = authState;
        this._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, Object.assign({}, authState));
        devMode && log5("emitted");
      };
      const finalPromise = (origPromise) => {
        return this._pending.updateAuthStatePromise.then(() => {
          const curPromise = this._pending.updateAuthStatePromise;
          if (curPromise && curPromise !== origPromise) {
            return finalPromise(curPromise);
          }
          return this.getAuthState();
        });
      };
      if (this._pending.updateAuthStatePromise) {
        if (this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES) {
          devMode && log5("terminated");
          return finalPromise(this._pending.updateAuthStatePromise);
        } else {
          this._pending.updateAuthStatePromise.cancel();
        }
      }
      const cancelablePromise = new import_p_cancelable.default((resolve, _2, onCancel) => {
        onCancel.shouldReject = false;
        onCancel(() => {
          this._pending.updateAuthStatePromise = null;
          this._pending.canceledTimes = this._pending.canceledTimes + 1;
          devMode && log5("canceled");
        });
        const emitAndResolve = (authState) => {
          if (cancelablePromise.isCanceled) {
            resolve();
            return;
          }
          emitAuthStateChange(authState);
          resolve();
          this._pending = Object.assign({}, DEFAULT_PENDING);
        };
        this._sdk.isAuthenticated().then(() => {
          if (cancelablePromise.isCanceled) {
            resolve();
            return;
          }
          const { accessToken, idToken, refreshToken } = this._sdk.tokenManager.getTokensSync();
          const authState = {
            accessToken,
            idToken,
            refreshToken,
            isAuthenticated: !!(accessToken && idToken)
          };
          const promise = transformAuthState ? this._transformQueue.push(transformAuthState, null, this._sdk, authState) : Promise.resolve(authState);
          promise.then((authState2) => emitAndResolve(authState2)).catch((error) => emitAndResolve({
            accessToken,
            idToken,
            refreshToken,
            isAuthenticated: false,
            error
          }));
        });
      });
      this._pending.updateAuthStatePromise = cancelablePromise;
      return finalPromise(cancelablePromise);
    });
  }
  subscribe(handler) {
    this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);
  }
  unsubscribe(handler) {
    this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/storage.js
function isLocalStorageAvailable() {
  const test = "test";
  try {
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (_a) {
    return false;
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/SavedObject.js
var SavedObject = class {
  constructor(storage, storageName) {
    if (!storage) {
      throw new AuthSdkError('"storage" is required');
    }
    if (typeof storageName !== "string" || !storageName.length) {
      throw new AuthSdkError('"storageName" is required');
    }
    this.storageName = storageName;
    this.storageProvider = storage;
  }
  getItem(key) {
    return this.getStorage()[key];
  }
  setItem(key, value) {
    return this.updateStorage(key, value);
  }
  removeItem(key) {
    return this.clearStorage(key);
  }
  isSharedStorage() {
    var _a, _b;
    return isLocalStorageAvailable() && this.storageProvider === localStorage || !!((_b = (_a = this.storageProvider).isSharedStorage) === null || _b === void 0 ? void 0 : _b.call(_a));
  }
  getStorage() {
    var storageString = this.storageProvider.getItem(this.storageName);
    storageString = storageString || "{}";
    try {
      return JSON.parse(storageString);
    } catch (e) {
      throw new AuthSdkError("Unable to parse storage string: " + this.storageName);
    }
  }
  setStorage(obj) {
    try {
      var storageString = obj ? JSON.stringify(obj) : "{}";
      this.storageProvider.setItem(this.storageName, storageString);
    } catch (e) {
      throw new AuthSdkError("Unable to set storage: " + this.storageName);
    }
  }
  clearStorage(key) {
    if (!key) {
      if (this.storageProvider.removeItem) {
        this.storageProvider.removeItem(this.storageName);
      } else {
        this.setStorage();
      }
      return;
    }
    var obj = this.getStorage();
    delete obj[key];
    this.setStorage(obj);
  }
  updateStorage(key, value) {
    var obj = this.getStorage();
    obj[key] = value;
    this.setStorage(obj);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/StorageManager.js
function logServerSideMemoryStorageWarning(options2) {
  if (!isBrowser() && !options2.storageProvider && !options2.storageProvider) {
    warn("Memory storage can only support simple single user use case on server side, please provide custom storageProvider or storageKey if advanced scenarios need to be supported.");
  }
}
var StorageManager = class {
  constructor(storageManagerOptions, cookieOptions, storageUtil2) {
    this.storageManagerOptions = storageManagerOptions;
    this.cookieOptions = cookieOptions;
    this.storageUtil = storageUtil2;
  }
  getOptionsForSection(sectionName, overrideOptions) {
    return Object.assign({}, this.storageManagerOptions[sectionName], overrideOptions);
  }
  getStorage(options2) {
    options2 = Object.assign({}, this.cookieOptions, options2);
    if (options2.storageProvider) {
      return options2.storageProvider;
    }
    let { storageType, storageTypes } = options2;
    if (storageType === "sessionStorage") {
      options2.sessionCookie = true;
    }
    if (storageType && storageTypes) {
      const idx = storageTypes.indexOf(storageType);
      if (idx >= 0) {
        storageTypes = storageTypes.slice(idx);
        storageType = void 0;
      }
    }
    if (!storageType) {
      storageType = this.storageUtil.findStorageType(storageTypes);
    }
    return this.storageUtil.getStorageByType(storageType, options2);
  }
  getTransactionStorage(options2) {
    options2 = this.getOptionsForSection("transaction", options2);
    logServerSideMemoryStorageWarning(options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || TRANSACTION_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getSharedTansactionStorage(options2) {
    options2 = this.getOptionsForSection("shared-transaction", options2);
    logServerSideMemoryStorageWarning(options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || SHARED_TRANSACTION_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getOriginalUriStorage(options2) {
    options2 = this.getOptionsForSection("original-uri", options2);
    logServerSideMemoryStorageWarning(options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || ORIGINAL_URI_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getIdxResponseStorage(options2) {
    let storage;
    if (isBrowser()) {
      try {
        storage = this.storageUtil.getStorageByType("memory", options2);
      } catch (e) {
        warn("No response storage found, you may want to provide custom implementation for intermediate idx responses to optimize the network traffic");
      }
    } else {
      const transactionStorage = this.getTransactionStorage(options2);
      if (transactionStorage) {
        storage = {
          getItem: (key) => {
            const transaction = transactionStorage.getStorage();
            if (transaction && transaction[key]) {
              return transaction[key];
            }
            return null;
          },
          setItem: (key, val) => {
            const transaction = transactionStorage.getStorage();
            if (!transaction) {
              throw new AuthSdkError("Transaction has been cleared, failed to save idxState");
            }
            transaction[key] = val;
            transactionStorage.setStorage(transaction);
          },
          removeItem: (key) => {
            const transaction = transactionStorage.getStorage();
            if (!transaction) {
              return;
            }
            delete transaction[key];
            transactionStorage.setStorage(transaction);
          }
        };
      }
    }
    if (!storage) {
      return null;
    }
    return new SavedObject(storage, IDX_RESPONSE_STORAGE_NAME);
  }
  getTokenStorage(options2) {
    options2 = this.getOptionsForSection("token", options2);
    logServerSideMemoryStorageWarning(options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || TOKEN_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getHttpCache(options2) {
    options2 = this.getOptionsForSection("cache", options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || CACHE_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getLegacyPKCEStorage(options2) {
    options2 = this.getOptionsForSection("legacy-pkce", options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || PKCE_STORAGE_NAME;
    return new SavedObject(storage, storageKey);
  }
  getLegacyOAuthParamsStorage(options2) {
    options2 = this.getOptionsForSection("legacy-oauth-params", options2);
    const storage = this.getStorage(options2);
    const storageKey = options2.storageKey || REDIRECT_OAUTH_PARAMS_NAME;
    return new SavedObject(storage, storageKey);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/types/Transaction.js
function isObjectWithProperties(obj) {
  if (!obj || typeof obj !== "object" || Object.values(obj).length === 0) {
    return false;
  }
  return true;
}
function isOAuthTransactionMeta(obj) {
  if (!isObjectWithProperties(obj)) {
    return false;
  }
  return !!obj.redirectUri || !!obj.responseType;
}
function isCustomAuthTransactionMeta(obj) {
  if (!isObjectWithProperties(obj)) {
    return false;
  }
  const isAllStringValues = Object.values(obj).find((value) => typeof value !== "string") === void 0;
  return isAllStringValues;
}
function isTransactionMeta(obj) {
  if (isOAuthTransactionMeta(obj) || isCustomAuthTransactionMeta(obj)) {
    return true;
  }
  return false;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/types/idx-js.js
function isRawIdxResponse(obj) {
  return obj && obj.version;
}
function isIdxResponse(obj) {
  return obj && isRawIdxResponse(obj.rawIdxState);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/util/sharedStorage.js
var MAX_ENTRY_LIFETIME = 30 * 60 * 1e3;
function pruneSharedStorage(storageManager) {
  const sharedStorage = storageManager.getSharedTansactionStorage();
  const entries = sharedStorage.getStorage();
  Object.keys(entries).forEach((state) => {
    const entry = entries[state];
    const age = Date.now() - entry.dateCreated;
    if (age > MAX_ENTRY_LIFETIME) {
      delete entries[state];
    }
  });
  sharedStorage.setStorage(entries);
}
function saveTransactionToSharedStorage(storageManager, state, meta) {
  const sharedStorage = storageManager.getSharedTansactionStorage();
  const entries = sharedStorage.getStorage();
  entries[state] = {
    dateCreated: Date.now(),
    transaction: meta
  };
  sharedStorage.setStorage(entries);
}
function loadTransactionFromSharedStorage(storageManager, state) {
  const sharedStorage = storageManager.getSharedTansactionStorage();
  const entries = sharedStorage.getStorage();
  const entry = entries[state];
  if (entry && entry.transaction && isTransactionMeta(entry.transaction)) {
    return entry.transaction;
  }
  return null;
}
function clearTransactionFromSharedStorage(storageManager, state) {
  const sharedStorage = storageManager.getSharedTansactionStorage();
  const entries = sharedStorage.getStorage();
  delete entries[state];
  sharedStorage.setStorage(entries);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/TransactionManager.js
var TransactionManager = class {
  constructor(options2) {
    this.storageManager = options2.storageManager;
    this.legacyWidgetSupport = options2.legacyWidgetSupport === false ? false : true;
    this.saveNonceCookie = options2.saveNonceCookie === false ? false : true;
    this.saveStateCookie = options2.saveStateCookie === false ? false : true;
    this.saveParamsCookie = options2.saveParamsCookie === false ? false : true;
    this.enableSharedStorage = options2.enableSharedStorage === false ? false : true;
    this.saveLastResponse = options2.saveLastResponse === false ? false : true;
    this.options = options2;
  }
  clear(options2 = {}) {
    const transactionStorage = this.storageManager.getTransactionStorage();
    const meta = transactionStorage.getStorage();
    transactionStorage.clearStorage();
    if (this.enableSharedStorage && options2.clearSharedStorage !== false) {
      const state = options2.state || (meta === null || meta === void 0 ? void 0 : meta.state);
      if (state) {
        clearTransactionFromSharedStorage(this.storageManager, state);
      }
    }
    if (options2.clearIdxResponse !== false) {
      this.clearIdxResponse();
    }
    if (!this.legacyWidgetSupport) {
      return;
    }
    if (options2.oauth) {
      this.clearLegacyOAuthParams();
    }
    if (options2.pkce) {
      this.clearLegacyPKCE();
    }
  }
  save(meta, options2 = {}) {
    let storage = this.storageManager.getTransactionStorage();
    const obj = storage.getStorage();
    if (isTransactionMeta(obj) && !options2.muteWarning) {
      warn("a saved auth transaction exists in storage. This may indicate another auth flow is already in progress.");
    }
    storage.setStorage(meta);
    if (this.enableSharedStorage && meta.state) {
      saveTransactionToSharedStorage(this.storageManager, meta.state, meta);
    }
    if (!options2.oauth) {
      return;
    }
    if (this.saveNonceCookie || this.saveStateCookie || this.saveParamsCookie) {
      const cookieStorage = this.storageManager.getStorage({ storageType: "cookie" });
      if (this.saveParamsCookie) {
        const { responseType, state, nonce, scopes, clientId, urls, ignoreSignature } = meta;
        const oauthParams = {
          responseType,
          state,
          nonce,
          scopes,
          clientId,
          urls,
          ignoreSignature
        };
        cookieStorage.setItem(REDIRECT_OAUTH_PARAMS_NAME, JSON.stringify(oauthParams), null);
      }
      if (this.saveNonceCookie && meta.nonce) {
        cookieStorage.setItem(REDIRECT_NONCE_COOKIE_NAME, meta.nonce, null);
      }
      if (this.saveStateCookie && meta.state) {
        cookieStorage.setItem(REDIRECT_STATE_COOKIE_NAME, meta.state, null);
      }
    }
  }
  exists(options2 = {}) {
    try {
      const meta = this.load(options2);
      return !!meta;
    } catch (_a) {
      return false;
    }
  }
  load(options2 = {}) {
    let meta;
    if (this.enableSharedStorage && options2.state) {
      pruneSharedStorage(this.storageManager);
      meta = loadTransactionFromSharedStorage(this.storageManager, options2.state);
      if (isTransactionMeta(meta)) {
        return meta;
      }
    }
    let storage = this.storageManager.getTransactionStorage();
    meta = storage.getStorage();
    if (isTransactionMeta(meta)) {
      return meta;
    }
    if (!this.legacyWidgetSupport) {
      return null;
    }
    if (options2.oauth) {
      try {
        const oauthParams = this.loadLegacyOAuthParams();
        Object.assign(meta, oauthParams);
      } finally {
        this.clearLegacyOAuthParams();
      }
    }
    if (options2.pkce) {
      try {
        const pkceMeta = this.loadLegacyPKCE();
        Object.assign(meta, pkceMeta);
      } finally {
        this.clearLegacyPKCE();
      }
    }
    if (isTransactionMeta(meta)) {
      return meta;
    }
    return null;
  }
  clearLegacyPKCE() {
    let storage;
    if (this.storageManager.storageUtil.testStorageType("localStorage")) {
      storage = this.storageManager.getLegacyPKCEStorage({ storageType: "localStorage" });
      storage.clearStorage();
    }
    if (this.storageManager.storageUtil.testStorageType("sessionStorage")) {
      storage = this.storageManager.getLegacyPKCEStorage({ storageType: "sessionStorage" });
      storage.clearStorage();
    }
  }
  loadLegacyPKCE() {
    let storage;
    let obj;
    if (this.storageManager.storageUtil.testStorageType("localStorage")) {
      storage = this.storageManager.getLegacyPKCEStorage({ storageType: "localStorage" });
      obj = storage.getStorage();
      if (obj && obj.codeVerifier) {
        return obj;
      }
    }
    if (this.storageManager.storageUtil.testStorageType("sessionStorage")) {
      storage = this.storageManager.getLegacyPKCEStorage({ storageType: "sessionStorage" });
      obj = storage.getStorage();
      if (obj && obj.codeVerifier) {
        return obj;
      }
    }
    throw new AuthSdkError("Could not load PKCE codeVerifier from storage. This may indicate the auth flow has already completed or multiple auth flows are executing concurrently.", void 0);
  }
  clearLegacyOAuthParams() {
    let storage;
    if (this.storageManager.storageUtil.testStorageType("sessionStorage")) {
      storage = this.storageManager.getLegacyOAuthParamsStorage({ storageType: "sessionStorage" });
      storage.clearStorage();
    }
    if (this.storageManager.storageUtil.testStorageType("cookie")) {
      storage = this.storageManager.getLegacyOAuthParamsStorage({ storageType: "cookie" });
      storage.clearStorage();
    }
  }
  loadLegacyOAuthParams() {
    let storage;
    let oauthParams;
    if (this.storageManager.storageUtil.testStorageType("sessionStorage")) {
      storage = this.storageManager.getLegacyOAuthParamsStorage({ storageType: "sessionStorage" });
      oauthParams = storage.getStorage();
    }
    if (isOAuthTransactionMeta(oauthParams)) {
      return oauthParams;
    }
    if (this.storageManager.storageUtil.testStorageType("cookie")) {
      storage = this.storageManager.getLegacyOAuthParamsStorage({ storageType: "cookie" });
      oauthParams = storage.getStorage();
    }
    if (isOAuthTransactionMeta(oauthParams)) {
      return oauthParams;
    }
    throw new AuthSdkError("Unable to retrieve OAuth redirect params from storage");
  }
  saveIdxResponse(data) {
    if (!this.saveLastResponse) {
      return;
    }
    const storage = this.storageManager.getIdxResponseStorage();
    if (!storage) {
      return;
    }
    storage.setStorage(data);
  }
  loadIdxResponse(options2) {
    if (!this.saveLastResponse) {
      return null;
    }
    const storage = this.storageManager.getIdxResponseStorage();
    if (!storage) {
      return null;
    }
    const storedValue = storage.getStorage();
    if (!storedValue || !isRawIdxResponse(storedValue.rawIdxResponse)) {
      return null;
    }
    if (options2) {
      const { stateHandle, interactionHandle } = options2;
      if (stateHandle && storedValue.stateHandle !== stateHandle) {
        return null;
      }
      if (interactionHandle && storedValue.interactionHandle !== interactionHandle) {
        return null;
      }
    }
    return storedValue;
  }
  clearIdxResponse() {
    if (!this.saveLastResponse) {
      return;
    }
    const storage = this.storageManager.getIdxResponseStorage();
    storage === null || storage === void 0 ? void 0 : storage.clearStorage();
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/builderUtil.js
function assertValidConfig(args) {
  args = args || {};
  var scopes = args.scopes;
  if (scopes && !Array.isArray(scopes)) {
    throw new AuthSdkError('scopes must be a array of strings. Required usage: new OktaAuth({scopes: ["openid", "email"]})');
  }
  var issuer = args.issuer;
  if (!issuer) {
    throw new AuthSdkError('No issuer passed to constructor. Required usage: new OktaAuth({issuer: "https://{yourOktaDomain}.com/oauth2/{authServerId}"})');
  }
  var isUrlRegex = new RegExp("^http?s?://.+");
  if (!isUrlRegex.test(issuer)) {
    throw new AuthSdkError('Issuer must be a valid URL. Required usage: new OktaAuth({issuer: "https://{yourOktaDomain}.com/oauth2/{authServerId}"})');
  }
  if (issuer.indexOf("-admin.") !== -1) {
    throw new AuthSdkError('Issuer URL passed to constructor contains "-admin" in subdomain. Required usage: new OktaAuth({issuer: "https://{yourOktaDomain}.com})');
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/fetch/fetchRequest.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill(), 1);
var appJsonContentTypeRegex = /application\/\w*\+?json/;
function readData(response) {
  if (response.headers.get("Content-Type") && response.headers.get("Content-Type").toLowerCase().indexOf("application/json") >= 0) {
    return response.json().catch((e) => {
      return {
        error: e,
        errorSummary: "Could not parse server response"
      };
    });
  } else {
    return response.text();
  }
}
function formatResult(status, data, response) {
  const isObject3 = typeof data === "object";
  const headers = {};
  for (const pair of response.headers.entries()) {
    headers[pair[0]] = pair[1];
  }
  const result = {
    responseText: isObject3 ? JSON.stringify(data) : data,
    status,
    headers
  };
  if (isObject3) {
    result.responseType = "json";
    result.responseJSON = data;
  }
  return result;
}
function fetchRequest(method, url, args) {
  var body = args.data;
  var headers = args.headers || {};
  var contentType = headers["Content-Type"] || headers["content-type"] || "";
  if (body && typeof body !== "string") {
    if (appJsonContentTypeRegex.test(contentType)) {
      body = JSON.stringify(body);
    } else if (contentType === "application/x-www-form-urlencoded") {
      body = Object.entries(body).map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join("&");
    }
  }
  var fetch2 = window.fetch || import_cross_fetch2.default;
  var fetchPromise = fetch2(url, {
    method,
    headers: args.headers,
    body,
    credentials: args.withCredentials ? "include" : "omit"
  });
  if (!fetchPromise.finally) {
    fetchPromise = Promise.resolve(fetchPromise);
  }
  return fetchPromise.then(function(response) {
    var error = !response.ok;
    var status = response.status;
    return readData(response).then((data) => {
      return formatResult(status, data, response);
    }).then((result) => {
      var _a;
      if (error || ((_a = result.responseJSON) === null || _a === void 0 ? void 0 : _a.error)) {
        throw result;
      }
      return result;
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/options/browser.js
function getStorage() {
  const storageUtil$1 = Object.assign({}, storageUtil, {
    inMemoryStore: {}
  });
  return storageUtil$1;
}
var STORAGE_MANAGER_OPTIONS = {
  token: {
    storageTypes: [
      "localStorage",
      "sessionStorage",
      "cookie"
    ]
  },
  cache: {
    storageTypes: [
      "localStorage",
      "sessionStorage",
      "cookie"
    ]
  },
  transaction: {
    storageTypes: [
      "sessionStorage",
      "localStorage",
      "cookie"
    ]
  },
  "shared-transaction": {
    storageTypes: [
      "localStorage"
    ]
  },
  "original-uri": {
    storageTypes: [
      "localStorage"
    ]
  }
};
var enableSharedStorage = true;
function getCookieSettings(args = {}, isHTTPS2) {
  var cookieSettings = args.cookies || {};
  if (typeof cookieSettings.secure === "undefined") {
    cookieSettings.secure = isHTTPS2;
  }
  if (typeof cookieSettings.sameSite === "undefined") {
    cookieSettings.sameSite = cookieSettings.secure ? "none" : "lax";
  }
  if (cookieSettings.secure && !isHTTPS2) {
    warn('The current page is not being served with the HTTPS protocol.\nFor security reasons, we strongly recommend using HTTPS.\nIf you cannot use HTTPS, set "cookies.secure" option to false.');
    cookieSettings.secure = false;
  }
  if (cookieSettings.sameSite === "none" && !cookieSettings.secure) {
    cookieSettings.sameSite = "lax";
  }
  return cookieSettings;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/options/index.js
function getDefaultOptions() {
  const options2 = {
    devMode: false,
    httpRequestClient: fetchRequest,
    storageUtil: getStorage(),
    storageManager: STORAGE_MANAGER_OPTIONS,
    transactionManager: {
      enableSharedStorage
    }
  };
  return options2;
}
function mergeOptions(options2, args) {
  return Object.assign({}, options2, removeNils(args), {
    storageManager: Object.assign({}, options2.storageManager, args.storageManager),
    transactionManager: Object.assign({}, options2.transactionManager, args.transactionManager)
  });
}
function buildOptions(args = {}) {
  var _a, _b;
  assertValidConfig(args);
  args = mergeOptions(getDefaultOptions(), args);
  return removeNils({
    issuer: removeTrailingSlash(args.issuer),
    tokenUrl: removeTrailingSlash(args.tokenUrl),
    authorizeUrl: removeTrailingSlash(args.authorizeUrl),
    userinfoUrl: removeTrailingSlash(args.userinfoUrl),
    revokeUrl: removeTrailingSlash(args.revokeUrl),
    logoutUrl: removeTrailingSlash(args.logoutUrl),
    clientId: args.clientId,
    redirectUri: args.redirectUri,
    state: args.state,
    scopes: args.scopes,
    postLogoutRedirectUri: args.postLogoutRedirectUri,
    responseMode: args.responseMode,
    responseType: args.responseType,
    pkce: args.pkce === false ? false : true,
    useInteractionCodeFlow: args.useInteractionCodeFlow,
    httpRequestClient: args.httpRequestClient,
    httpRequestInterceptors: args.httpRequestInterceptors,
    transformErrorXHR: args.transformErrorXHR,
    transformAuthState: args.transformAuthState,
    restoreOriginalUri: args.restoreOriginalUri,
    storageUtil: args.storageUtil,
    headers: args.headers,
    devMode: !!args.devMode,
    storageManager: args.storageManager,
    transactionManager: args.transactionManager,
    cookies: getCookieSettings(args, isHTTPS()),
    flow: args.flow,
    codeChallenge: args.codeChallenge,
    codeChallengeMethod: args.codeChallengeMethod,
    recoveryToken: args.recoveryToken,
    activationToken: args.activationToken,
    idx: {
      useGenericRemediator: !!((_a = args.idx) === null || _a === void 0 ? void 0 : _a.useGenericRemediator),
      exchangeCodeForTokens: ((_b = args.idx) === null || _b === void 0 ? void 0 : _b.exchangeCodeForTokens) !== false
    },
    ignoreSignature: !!args.ignoreSignature,
    clientSecret: args.clientSecret,
    setLocation: args.setLocation
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/transactionMeta.js
function createTransactionMeta(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    const tokenParams = yield authClient.token.prepareTokenParams(options2);
    const pkceMeta = createOAuthMeta(authClient, tokenParams);
    let { flow = "default", withCredentials = true, activationToken = void 0, recoveryToken = void 0, maxAge = void 0 } = Object.assign(Object.assign({}, authClient.options), options2);
    const meta = Object.assign(Object.assign({}, pkceMeta), {
      flow,
      withCredentials,
      activationToken,
      recoveryToken,
      maxAge
    });
    return meta;
  });
}
function hasSavedInteractionHandle(authClient, options2) {
  const savedMeta = getSavedTransactionMeta(authClient, options2);
  if (savedMeta === null || savedMeta === void 0 ? void 0 : savedMeta.interactionHandle) {
    return true;
  }
  return false;
}
function getSavedTransactionMeta(authClient, options2) {
  options2 = removeNils(options2);
  options2 = Object.assign(Object.assign({}, authClient.options), options2);
  let savedMeta;
  try {
    savedMeta = authClient.transactionManager.load(options2);
  } catch (e) {
  }
  if (!savedMeta) {
    return;
  }
  if (isTransactionMetaValid(savedMeta, options2)) {
    return savedMeta;
  }
  warn("Saved transaction meta does not match the current configuration. This may indicate that two apps are sharing a storage key.");
}
function getTransactionMeta(authClient, options2) {
  return __async(this, null, function* () {
    options2 = removeNils(options2);
    options2 = Object.assign(Object.assign({}, authClient.options), options2);
    const validExistingMeta = getSavedTransactionMeta(authClient, options2);
    if (validExistingMeta) {
      return validExistingMeta;
    }
    return createTransactionMeta(authClient, options2);
  });
}
function saveTransactionMeta(authClient, meta) {
  authClient.transactionManager.save(meta, { muteWarning: true });
}
function clearTransactionMeta(authClient) {
  authClient.transactionManager.clear();
}
function isTransactionMetaValid(meta, options2 = {}) {
  const keys = [
    "issuer",
    "clientId",
    "redirectUri",
    "state",
    "codeChallenge",
    "codeChallengeMethod",
    "activationToken",
    "recoveryToken"
  ];
  if (isTransactionMetaValidForOptions(meta, options2, keys) === false) {
    return false;
  }
  const { flow } = options2;
  if (isTransactionMetaValidForFlow(meta, flow) === false) {
    return false;
  }
  return true;
}
function isTransactionMetaValidForFlow(meta, flow) {
  const shouldValidateFlow = flow && flow !== "default" && flow !== "proceed";
  if (shouldValidateFlow) {
    if (flow !== meta.flow) {
      return false;
    }
  }
  return true;
}
function isTransactionMetaValidForOptions(meta, options2, keys) {
  const mismatch = keys.some((key) => {
    const value = options2[key];
    if (value && value !== meta[key]) {
      return true;
    }
  });
  return !mismatch;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/interact.js
function getResponse(meta) {
  return {
    meta,
    interactionHandle: meta.interactionHandle,
    state: meta.state
  };
}
function interact(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    options2 = removeNils(options2);
    let meta = getSavedTransactionMeta(authClient, options2);
    if (meta === null || meta === void 0 ? void 0 : meta.interactionHandle) {
      return getResponse(meta);
    }
    meta = yield createTransactionMeta(authClient, Object.assign(Object.assign({}, meta), options2));
    const baseUrl = getOAuthBaseUrl(authClient);
    let { clientId, redirectUri, state, scopes, withCredentials, codeChallenge, codeChallengeMethod, activationToken, recoveryToken, maxAge, nonce } = meta;
    const clientSecret = options2.clientSecret || authClient.options.clientSecret;
    withCredentials = withCredentials !== null && withCredentials !== void 0 ? withCredentials : true;
    const url = `${baseUrl}/v1/interact`;
    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ client_id: clientId, scope: scopes.join(" "), redirect_uri: redirectUri, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod, state }, activationToken && { activation_token: activationToken }), recoveryToken && { recovery_token: recoveryToken }), clientSecret && { client_secret: clientSecret }), maxAge && { max_age: maxAge }), nonce && { nonce });
    const headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    const resp = yield httpRequest(authClient, {
      method: "POST",
      url,
      headers,
      withCredentials,
      args: params
    });
    const interactionHandle = resp.interaction_handle;
    const newMeta = Object.assign(Object.assign({}, meta), {
      interactionHandle,
      withCredentials,
      state,
      scopes,
      recoveryToken,
      activationToken
    });
    saveTransactionMeta(authClient, newMeta);
    return getResponse(newMeta);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/actionParser.js
var isFieldMutable = function isFieldMutable2(field) {
  return field.mutable !== false;
};
var divideSingleActionParamsByMutability = function divideSingleActionParamsByMutability2(action2) {
  var _a, _b;
  const defaultParamsForAction = {};
  const neededParamsForAction = [];
  const immutableParamsForAction = {};
  if (!action2.value) {
    neededParamsForAction.push(action2);
    return { defaultParamsForAction, neededParamsForAction, immutableParamsForAction };
  }
  for (let field of action2.value) {
    if (isFieldMutable(field)) {
      neededParamsForAction.push(field);
      if ((_a = field.value) !== null && _a !== void 0 ? _a : false) {
        defaultParamsForAction[field.name] = field.value;
      }
    } else {
      immutableParamsForAction[field.name] = (_b = field.value) !== null && _b !== void 0 ? _b : "";
    }
  }
  return { defaultParamsForAction, neededParamsForAction, immutableParamsForAction };
};
var divideActionParamsByMutability = function divideActionParamsByMutability2(actionList) {
  actionList = Array.isArray(actionList) ? actionList : [actionList];
  const neededParams = [];
  const defaultParams = {};
  const immutableParams = {};
  for (let action2 of actionList) {
    const { defaultParamsForAction, neededParamsForAction, immutableParamsForAction } = divideSingleActionParamsByMutability(action2);
    neededParams.push(neededParamsForAction);
    defaultParams[action2.name] = defaultParamsForAction;
    immutableParams[action2.name] = immutableParamsForAction;
  }
  return { defaultParams, neededParams, immutableParams };
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/generateIdxAction.js
var generateDirectFetch = function generateDirectFetch2(authClient, { actionDefinition, defaultParamsForAction = {}, immutableParamsForAction = {}, toPersist = {} }) {
  const target = actionDefinition.href;
  return function() {
    return __async(this, arguments, function* (params = {}) {
      var _a;
      const headers = {
        "Content-Type": "application/json",
        "Accept": actionDefinition.accepts || "application/ion+json"
      };
      const body = JSON.stringify(Object.assign(Object.assign(Object.assign({}, defaultParamsForAction), params), immutableParamsForAction));
      try {
        const response = yield httpRequest(authClient, {
          url: target,
          method: actionDefinition.method,
          headers,
          args: body,
          withCredentials: (_a = toPersist === null || toPersist === void 0 ? void 0 : toPersist.withCredentials) !== null && _a !== void 0 ? _a : true
        });
        return authClient.idx.makeIdxResponse(Object.assign({}, response), toPersist, true);
      } catch (err) {
        if (!(err instanceof AuthApiError) || !(err === null || err === void 0 ? void 0 : err.xhr)) {
          throw err;
        }
        const response = err.xhr;
        const payload = response.responseJSON || JSON.parse(response.responseText);
        const wwwAuthHeader = response.headers["WWW-Authenticate"] || response.headers["www-authenticate"];
        const idxResponse = authClient.idx.makeIdxResponse(Object.assign({}, payload), toPersist, false);
        if (response.status === 401 && wwwAuthHeader === 'Oktadevicejwt realm="Okta Device"') {
          idxResponse.stepUp = true;
        }
        throw idxResponse;
      }
    });
  };
};
var generateIdxAction = function generateIdxAction2(authClient, actionDefinition, toPersist) {
  const generator = generateDirectFetch;
  const { defaultParams, neededParams, immutableParams } = divideActionParamsByMutability(actionDefinition);
  const action2 = generator(authClient, {
    actionDefinition,
    defaultParamsForAction: defaultParams[actionDefinition.name],
    immutableParamsForAction: immutableParams[actionDefinition.name],
    toPersist
  });
  action2.neededParams = neededParams;
  return action2;
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/remediationParser.js
var generateRemediationFunctions = function generateRemediationFunctions2(authClient, remediationValue, toPersist = {}) {
  return Object.fromEntries(remediationValue.map((remediation) => {
    return [
      remediation.name,
      generateIdxAction(authClient, remediation, toPersist)
    ];
  }));
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/idxResponseParser.js
var SKIP_FIELDS = Object.fromEntries([
  "remediation",
  "context"
].map((field) => [field, true]));
var parseNonRemediations = function parseNonRemediations2(authClient, idxResponse, toPersist = {}) {
  const actions = {};
  const context = {};
  Object.keys(idxResponse).filter((field) => !SKIP_FIELDS[field]).forEach((field) => {
    const fieldIsObject = typeof idxResponse[field] === "object" && !!idxResponse[field];
    if (!fieldIsObject) {
      context[field] = idxResponse[field];
      return;
    }
    if (idxResponse[field].rel) {
      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);
      return;
    }
    const _a = idxResponse[field], { value: fieldValue, type } = _a, info = __rest(_a, ["value", "type"]);
    context[field] = Object.assign({ type }, info);
    if (type !== "object") {
      context[field].value = fieldValue;
      return;
    }
    context[field].value = {};
    Object.entries(fieldValue).forEach(([subField, value]) => {
      if (value.rel) {
        actions[`${field}-${subField.name || subField}`] = generateIdxAction(authClient, value, toPersist);
      } else {
        context[field].value[subField] = value;
      }
    });
  });
  return { context, actions };
};
var expandRelatesTo = (idxResponse, value) => {
  Object.keys(value).forEach((k) => {
    if (k === "relatesTo") {
      const query = Array.isArray(value[k]) ? value[k][0] : value[k];
      if (typeof query === "string") {
        const result = JSONPath({ path: query, json: idxResponse })[0];
        if (result) {
          value[k] = result;
          return;
        }
      }
    }
    if (Array.isArray(value[k])) {
      value[k].forEach((innerValue) => expandRelatesTo(idxResponse, innerValue));
    }
  });
};
var convertRemediationAction = (authClient, remediation, toPersist) => {
  if (remediation.rel) {
    const remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);
    const actionFn = remediationActions[remediation.name];
    return Object.assign(Object.assign({}, remediation), { action: actionFn });
  }
  return remediation;
};
var parseIdxResponse = function parseIdxResponse2(authClient, idxResponse, toPersist = {}) {
  var _a;
  const remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];
  remediationData.forEach((remediation) => expandRelatesTo(idxResponse, remediation));
  const remediations = remediationData.map((remediation) => convertRemediationAction(authClient, remediation, toPersist));
  const { context, actions } = parseNonRemediations(authClient, idxResponse, toPersist);
  return {
    remediations,
    context,
    actions
  };
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/makeIdxState.js
function makeIdxState(authClient, idxResponse, toPersist, requestDidSucceed) {
  var _a, _b, _c;
  const rawIdxResponse = idxResponse;
  const { remediations, context, actions } = parseIdxResponse(authClient, idxResponse, toPersist);
  const neededToProceed = [...remediations];
  const proceed2 = function(_0) {
    return __async(this, arguments, function* (remediationChoice, paramsFromUser = {}) {
      const remediationChoiceObject = remediations.find((remediation) => remediation.name === remediationChoice);
      if (!remediationChoiceObject) {
        return Promise.reject(`Unknown remediation choice: [${remediationChoice}]`);
      }
      const actionFn = remediationChoiceObject.action;
      if (typeof actionFn !== "function") {
        return Promise.reject(`Current remediation cannot make form submit action: [${remediationChoice}]`);
      }
      return remediationChoiceObject.action(paramsFromUser);
    });
  };
  const findCode = (item) => item.name === "interaction_code";
  const interactionCode = (_c = (_b = (_a = rawIdxResponse.successWithInteractionCode) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.find(findCode)) === null || _c === void 0 ? void 0 : _c.value;
  return {
    proceed: proceed2,
    neededToProceed,
    actions,
    context,
    rawIdxState: rawIdxResponse,
    interactionCode,
    toPersist,
    requestDidSucceed
  };
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/v1/parsers.js
var v1 = {
  makeIdxState
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/idxState/index.js
var parsersForVersion = function parsersForVersion2(version2) {
  switch (version2) {
    case "1.0.0":
      return v1;
    case void 0:
    case null:
      throw new Error("Api version is required");
    default:
      throw new Error(`Unknown api version: ${version2}.  Use an exact semver version.`);
  }
};
function validateVersionConfig(version2) {
  if (!version2) {
    throw new Error("version is required");
  }
  const cleanVersion = (version2 !== null && version2 !== void 0 ? version2 : "").replace(/[^0-9a-zA-Z._-]/, "");
  if (cleanVersion !== version2 || !version2) {
    throw new Error("invalid version supplied - version is required and uses semver syntax");
  }
  parsersForVersion(version2);
}
function makeIdxState2(authClient, rawIdxResponse, toPersist, requestDidSucceed) {
  var _a;
  const version2 = (_a = rawIdxResponse === null || rawIdxResponse === void 0 ? void 0 : rawIdxResponse.version) !== null && _a !== void 0 ? _a : IDX_API_VERSION;
  validateVersionConfig(version2);
  const { makeIdxState: makeIdxState3 } = parsersForVersion(version2);
  return makeIdxState3(authClient, rawIdxResponse, toPersist, requestDidSucceed);
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/introspect.js
function introspect(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    var _a;
    let rawIdxResponse;
    let requestDidSucceed;
    const savedIdxResponse = authClient.transactionManager.loadIdxResponse(options2);
    if (savedIdxResponse) {
      rawIdxResponse = savedIdxResponse.rawIdxResponse;
      requestDidSucceed = savedIdxResponse.requestDidSucceed;
    }
    if (!rawIdxResponse) {
      const version2 = options2.version || IDX_API_VERSION;
      const domain = getOAuthDomain(authClient);
      const { interactionHandle, stateHandle } = options2;
      const withCredentials2 = (_a = options2.withCredentials) !== null && _a !== void 0 ? _a : true;
      try {
        requestDidSucceed = true;
        validateVersionConfig(version2);
        const url = `${domain}/idp/idx/introspect`;
        const body = stateHandle ? { stateToken: stateHandle } : { interactionHandle };
        const headers = {
          "Content-Type": `application/ion+json; okta-version=${version2}`,
          Accept: `application/ion+json; okta-version=${version2}`
        };
        rawIdxResponse = yield httpRequest(authClient, {
          method: "POST",
          url,
          headers,
          withCredentials: withCredentials2,
          args: body
        });
      } catch (err) {
        if (isAuthApiError(err) && err.xhr && isRawIdxResponse(err.xhr.responseJSON)) {
          rawIdxResponse = err.xhr.responseJSON;
          requestDidSucceed = false;
        } else {
          throw err;
        }
      }
    }
    const { withCredentials } = options2;
    return makeIdxState2(authClient, rawIdxResponse, { withCredentials }, requestDidSucceed);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/index.js
var remediators_exports = {};
__export(remediators_exports, {
  AuthenticatorEnrollmentData: () => AuthenticatorEnrollmentData,
  AuthenticatorVerificationData: () => AuthenticatorVerificationData,
  ChallengeAuthenticator: () => ChallengeAuthenticator,
  ChallengePoll: () => ChallengePoll,
  EnrollAuthenticator: () => EnrollAuthenticator,
  EnrollPoll: () => EnrollPoll,
  EnrollProfile: () => EnrollProfile,
  EnrollmentChannelData: () => EnrollmentChannelData,
  GenericRemediator: () => GenericRemediator,
  Identify: () => Identify,
  ReEnrollAuthenticator: () => ReEnrollAuthenticator,
  RedirectIdp: () => RedirectIdp,
  Remediator: () => Remediator,
  ResetAuthenticator: () => ResetAuthenticator,
  SelectAuthenticatorAuthenticate: () => SelectAuthenticatorAuthenticate,
  SelectAuthenticatorEnroll: () => SelectAuthenticatorEnroll,
  SelectAuthenticatorUnlockAccount: () => SelectAuthenticatorUnlockAccount,
  SelectEnrollProfile: () => SelectEnrollProfile,
  SelectEnrollmentChannel: () => SelectEnrollmentChannel,
  Skip: () => Skip
});

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/util.js
function getAllValues(idxRemediation) {
  var _a;
  return (_a = idxRemediation.value) === null || _a === void 0 ? void 0 : _a.map((r) => r.name);
}
function getRequiredValues(idxRemediation) {
  var _a;
  return (_a = idxRemediation.value) === null || _a === void 0 ? void 0 : _a.reduce((required, cur) => {
    if (cur.required) {
      required.push(cur.name);
    }
    return required;
  }, []);
}
function titleCase(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
}
function getAuthenticatorFromRemediation(remediation) {
  return remediation.value.find(({ name }) => name === "authenticator");
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/util.js
function formatAuthenticator(incoming) {
  let authenticator;
  if (isAuthenticator(incoming)) {
    authenticator = incoming;
  } else if (typeof incoming === "string") {
    authenticator = {
      key: incoming
    };
  } else {
    throw new Error("Invalid format for authenticator");
  }
  return authenticator;
}
function compareAuthenticators(auth1, auth2) {
  if (!auth1 || !auth2) {
    return false;
  }
  if (auth1.id && auth2.id) {
    return auth1.id === auth2.id;
  }
  if (auth1.key && auth2.key) {
    return auth1.key === auth2.key;
  }
  return false;
}
function findMatchedOption(authenticators, options2) {
  let option2;
  for (let authenticator of authenticators) {
    option2 = options2.find(({ relatesTo }) => relatesTo.key === authenticator.key);
    if (option2) {
      break;
    }
  }
  return option2;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Base/Remediator.js
var Remediator = class {
  constructor(remediation, values = {}, options2 = {}) {
    this.values = Object.assign({}, values);
    this.options = Object.assign({}, options2);
    this.formatAuthenticators();
    this.remediation = remediation;
  }
  formatAuthenticators() {
    this.values.authenticators = this.values.authenticators || [];
    this.values.authenticators = this.values.authenticators.map((authenticator) => {
      return formatAuthenticator(authenticator);
    });
    if (this.values.authenticator) {
      const authenticator = formatAuthenticator(this.values.authenticator);
      const hasAuthenticatorInList = this.values.authenticators.some((existing) => {
        return compareAuthenticators(authenticator, existing);
      });
      if (!hasAuthenticatorInList) {
        this.values.authenticators.push(authenticator);
      }
    }
    this.values.authenticatorsData = this.values.authenticators.reduce((acc, authenticator) => {
      if (typeof authenticator === "object" && Object.keys(authenticator).length > 1) {
        acc.push(authenticator);
      }
      return acc;
    }, this.values.authenticatorsData || []);
  }
  getName() {
    return this.remediation.name;
  }
  canRemediate() {
    const required = getRequiredValues(this.remediation);
    const needed = required.find((key) => !this.hasData(key));
    if (needed) {
      return false;
    }
    return true;
  }
  getData(key) {
    if (!key) {
      let allValues = getAllValues(this.remediation);
      let res = allValues.reduce((data, key2) => {
        data[key2] = this.getData(key2);
        return data;
      }, {});
      return res;
    }
    if (typeof this[`map${titleCase(key)}`] === "function") {
      const val = this[`map${titleCase(key)}`](this.remediation.value.find(({ name }) => name === key));
      if (val) {
        return val;
      }
    }
    if (this.map && this.map[key]) {
      const entry = this.map[key];
      for (let i = 0; i < entry.length; i++) {
        let val = this.values[entry[i]];
        if (val) {
          return val;
        }
      }
    }
    return this.values[key];
  }
  hasData(key) {
    return !!this.getData(key);
  }
  getNextStep(_authClient, _context) {
    const name = this.getName();
    const inputs = this.getInputs();
    const authenticator = this.getAuthenticator();
    const type = authenticator === null || authenticator === void 0 ? void 0 : authenticator.type;
    return Object.assign(Object.assign({
      name,
      inputs
    }, type && { type }), authenticator && { authenticator });
  }
  getInputs() {
    const inputs = [];
    const inputsFromRemediation = this.remediation.value || [];
    inputsFromRemediation.forEach((inputFromRemediation) => {
      let input;
      let { name, type, visible, messages } = inputFromRemediation;
      if (visible === false) {
        return;
      }
      if (typeof this[`getInput${titleCase(name)}`] === "function") {
        input = this[`getInput${titleCase(name)}`](inputFromRemediation);
      } else if (type !== "object") {
        let alias;
        const aliases = (this.map ? this.map[name] : null) || [];
        if (aliases.length === 1) {
          alias = aliases[0];
        } else {
          alias = aliases.find((name2) => Object.keys(this.values).includes(name2));
        }
        if (alias) {
          input = Object.assign(Object.assign({}, inputFromRemediation), { name: alias });
        }
      }
      if (!input) {
        input = inputFromRemediation;
      }
      if (Array.isArray(input)) {
        input.forEach((i) => inputs.push(i));
      } else {
        if (messages) {
          input.messages = messages;
        }
        inputs.push(input);
      }
    });
    return inputs;
  }
  static getMessages(remediation) {
    var _a, _b;
    if (!remediation.value) {
      return;
    }
    return (_b = (_a = remediation.value[0]) === null || _a === void 0 ? void 0 : _a.form) === null || _b === void 0 ? void 0 : _b.value.reduce((messages, field) => {
      if (field.messages) {
        messages = [...messages, ...field.messages.value];
      }
      return messages;
    }, []);
  }
  getValuesAfterProceed() {
    const inputsFromRemediation = this.remediation.value || [];
    const inputsFromRemediator = this.getInputs();
    const inputs = [
      ...inputsFromRemediation,
      ...inputsFromRemediator
    ];
    for (const input of inputs) {
      delete this.values[input.name];
    }
    return this.values;
  }
  getAuthenticator() {
    var _a, _b;
    const relatesTo = (_a = this.remediation.relatesTo) === null || _a === void 0 ? void 0 : _a.value;
    if (!relatesTo) {
      return;
    }
    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);
    if (!authenticatorFromRemediation) {
      return relatesTo;
    }
    const id = authenticatorFromRemediation.form.value.find(({ name }) => name === "id").value;
    const enrollmentId = (_b = authenticatorFromRemediation.form.value.find(({ name }) => name === "enrollmentId")) === null || _b === void 0 ? void 0 : _b.value;
    return Object.assign(Object.assign({}, relatesTo), {
      id,
      enrollmentId
    });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/Authenticator.js
var Authenticator = class {
  constructor(authenticator) {
    this.meta = authenticator;
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/VerificationCodeAuthenticator.js
var VerificationCodeAuthenticator = class extends Authenticator {
  canVerify(values) {
    return !!(values.credentials || values.verificationCode || values.otp);
  }
  mapCredentials(values) {
    const { credentials, verificationCode, otp } = values;
    if (!credentials && !verificationCode && !otp) {
      return;
    }
    return credentials || { passcode: verificationCode || otp };
  }
  getInputs(idxRemediationValue) {
    var _a;
    return Object.assign(Object.assign({}, (_a = idxRemediationValue.form) === null || _a === void 0 ? void 0 : _a.value[0]), { name: "verificationCode", type: "string", required: idxRemediationValue.required });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/OktaVerifyTotp.js
var OktaVerifyTotp = class extends VerificationCodeAuthenticator {
  mapCredentials(values) {
    const { verificationCode } = values;
    if (!verificationCode) {
      return;
    }
    return { totp: verificationCode };
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/OktaPassword.js
var OktaPassword = class extends Authenticator {
  canVerify(values) {
    return !!(values.credentials || values.password || values.passcode);
  }
  mapCredentials(values) {
    const { credentials, password, passcode } = values;
    if (!credentials && !password && !passcode) {
      return;
    }
    return credentials || { passcode: passcode || password };
  }
  getInputs(idxRemediationValue) {
    var _a;
    return Object.assign(Object.assign({}, (_a = idxRemediationValue.form) === null || _a === void 0 ? void 0 : _a.value[0]), { name: "password", type: "string", required: idxRemediationValue.required });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/SecurityQuestionEnrollment.js
var SecurityQuestionEnrollment = class extends Authenticator {
  canVerify(values) {
    const { credentials } = values;
    if (credentials && credentials.questionKey && credentials.answer) {
      return true;
    }
    const { questionKey, question, answer } = values;
    return !!(questionKey && answer) || !!(question && answer);
  }
  mapCredentials(values) {
    const { questionKey, question, answer } = values;
    if (!answer || !questionKey && !question) {
      return;
    }
    return {
      questionKey: question ? "custom" : questionKey,
      question,
      answer
    };
  }
  getInputs() {
    return [
      { name: "questionKey", type: "string", required: true },
      { name: "question", type: "string", label: "Create a security question" },
      { name: "answer", type: "string", label: "Answer", required: true }
    ];
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/SecurityQuestionVerification.js
var SecurityQuestionVerification = class extends Authenticator {
  canVerify(values) {
    const { credentials } = values;
    if (credentials && credentials.answer) {
      return true;
    }
    const { answer } = values;
    return !!answer;
  }
  mapCredentials(values) {
    const { answer } = values;
    if (!answer) {
      return;
    }
    return {
      questionKey: this.meta.contextualData.enrolledQuestion.questionKey,
      answer
    };
  }
  getInputs() {
    return [
      { name: "answer", type: "string", label: "Answer", required: true }
    ];
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/WebauthnEnrollment.js
var WebauthnEnrollment = class extends Authenticator {
  canVerify(values) {
    const { credentials } = values;
    const obj = credentials || values;
    const { clientData, attestation } = obj;
    return !!(clientData && attestation);
  }
  mapCredentials(values) {
    const { credentials, clientData, attestation } = values;
    if (!credentials && !clientData && !attestation) {
      return;
    }
    return credentials || {
      clientData,
      attestation
    };
  }
  getInputs() {
    return [
      { name: "clientData", type: "string", required: true, visible: false, label: "Client Data" },
      { name: "attestation", type: "string", required: true, visible: false, label: "Attestation" }
    ];
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/WebauthnVerification.js
var WebauthnVerification = class extends Authenticator {
  canVerify(values) {
    const { credentials } = values;
    const obj = credentials || values;
    const { clientData, authenticatorData, signatureData } = obj;
    return !!(clientData && authenticatorData && signatureData);
  }
  mapCredentials(values) {
    const { credentials, authenticatorData, clientData, signatureData } = values;
    if (!credentials && !authenticatorData && !clientData && !signatureData) {
      return;
    }
    return credentials || {
      authenticatorData,
      clientData,
      signatureData
    };
  }
  getInputs() {
    return [
      { name: "authenticatorData", type: "string", label: "Authenticator Data", required: true, visible: false },
      { name: "clientData", type: "string", label: "Client Data", required: true, visible: false },
      { name: "signatureData", type: "string", label: "Signature Data", required: true, visible: false }
    ];
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticator/getAuthenticator.js
function getAuthenticator(remediation) {
  var _a, _b;
  const relatesTo = remediation.relatesTo;
  const value = (relatesTo === null || relatesTo === void 0 ? void 0 : relatesTo.value) || {};
  switch (value.key) {
    case AuthenticatorKey.OKTA_PASSWORD:
      return new OktaPassword(value);
    case AuthenticatorKey.SECURITY_QUESTION:
      if ((_a = value.contextualData) === null || _a === void 0 ? void 0 : _a.enrolledQuestion) {
        return new SecurityQuestionVerification(value);
      } else {
        return new SecurityQuestionEnrollment(value);
      }
    case AuthenticatorKey.OKTA_VERIFY:
      return new OktaVerifyTotp(value);
    case AuthenticatorKey.WEBAUTHN:
      if ((_b = value.contextualData) === null || _b === void 0 ? void 0 : _b.challengeData) {
        return new WebauthnVerification(value);
      } else {
        return new WebauthnEnrollment(value);
      }
    default:
      return new VerificationCodeAuthenticator(value);
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Base/VerifyAuthenticator.js
var VerifyAuthenticator = class extends Remediator {
  constructor(remediation, values = {}) {
    super(remediation, values);
    this.authenticator = getAuthenticator(remediation);
  }
  getNextStep(authClient, context) {
    var _a;
    const nextStep = super.getNextStep(authClient, context);
    const authenticatorEnrollments = (_a = context === null || context === void 0 ? void 0 : context.authenticatorEnrollments) === null || _a === void 0 ? void 0 : _a.value;
    return Object.assign(Object.assign({}, nextStep), { authenticatorEnrollments });
  }
  canRemediate() {
    return this.authenticator.canVerify(this.values);
  }
  mapCredentials() {
    return this.authenticator.mapCredentials(this.values);
  }
  getInputCredentials(input) {
    return this.authenticator.getInputs(input);
  }
  getValuesAfterProceed() {
    this.values = super.getValuesAfterProceed();
    let trimmedValues = Object.keys(this.values).filter((valueKey) => valueKey !== "credentials");
    return trimmedValues.reduce((values, valueKey) => Object.assign(Object.assign({}, values), { [valueKey]: this.values[valueKey] }), {});
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/EnrollAuthenticator.js
var EnrollAuthenticator = class extends VerifyAuthenticator {
};
EnrollAuthenticator.remediationName = "enroll-authenticator";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/EnrollPoll.js
var EnrollPoll = class extends Remediator {
  canRemediate() {
    return !!this.values.startPolling || this.options.step === "enroll-poll";
  }
  getNextStep(authClient, context) {
    const common = super.getNextStep(authClient, context);
    let authenticator = this.getAuthenticator();
    if (!authenticator && (context === null || context === void 0 ? void 0 : context.currentAuthenticator)) {
      authenticator = context.currentAuthenticator.value;
    }
    return Object.assign(Object.assign({}, common), { authenticator, poll: {
      required: true,
      refresh: this.remediation.refresh
    } });
  }
  getValuesAfterProceed() {
    let trimmedValues = Object.keys(this.values).filter((valueKey) => valueKey !== "startPolling");
    return trimmedValues.reduce((values, valueKey) => Object.assign(Object.assign({}, values), { [valueKey]: this.values[valueKey] }), {});
  }
};
EnrollPoll.remediationName = "enroll-poll";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/SelectEnrollmentChannel.js
var SelectEnrollmentChannel = class extends Remediator {
  canRemediate() {
    if (this.values.channel) {
      return true;
    }
    if (this.values.authenticator) {
      const { id, channel } = this.values.authenticator;
      if (!!id && !!channel) {
        return true;
      }
    }
    return false;
  }
  getNextStep(authClient, context) {
    const common = super.getNextStep(authClient, context);
    const options2 = this.getChannels();
    const authenticator = context.currentAuthenticator.value;
    return Object.assign(Object.assign(Object.assign({}, common), options2 && { options: options2 }), { authenticator });
  }
  getChannels() {
    var _a;
    const authenticator = getAuthenticatorFromRemediation(this.remediation);
    const remediationValue = authenticator.value;
    return (_a = remediationValue.form.value.find(({ name }) => name === "channel")) === null || _a === void 0 ? void 0 : _a.options;
  }
  getData() {
    var _a;
    const remediationValue = this.remediation.value[0].value;
    return {
      authenticator: {
        id: remediationValue.form.value[0].value,
        channel: ((_a = this.values.authenticator) === null || _a === void 0 ? void 0 : _a.channel) || this.values.channel
      },
      stateHandle: this.values.stateHandle
    };
  }
  getValuesAfterProceed() {
    this.values = super.getValuesAfterProceed();
    delete this.values.authenticators;
    const filterKey = this.values.channel ? "channel" : "authenticator";
    let trimmedValues = Object.keys(this.values).filter((valueKey) => valueKey !== filterKey);
    return trimmedValues.reduce((values, valueKey) => Object.assign(Object.assign({}, values), { [valueKey]: this.values[valueKey] }), {});
  }
};
SelectEnrollmentChannel.remediationName = "select-enrollment-channel";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/EnrollmentChannelData.js
var EnrollmentChannelData = class extends Remediator {
  getInputEmail() {
    return [
      { name: "email", type: "string", required: true, label: "Email" }
    ];
  }
  getInputPhoneNumber() {
    return [
      { name: "phoneNumber", type: "string", required: true, label: "Phone Number" }
    ];
  }
  canRemediate() {
    return Boolean(this.values.email || this.values.phoneNumber);
  }
  getNextStep(authClient, context) {
    const common = super.getNextStep(authClient, context);
    const authenticator = context.currentAuthenticator.value;
    return Object.assign(Object.assign({}, common), { authenticator });
  }
  getData() {
    return {
      stateHandle: this.values.stateHandle,
      email: this.values.email,
      phoneNumber: this.values.phoneNumber
    };
  }
  getValuesAfterProceed() {
    let trimmedValues = Object.keys(this.values).filter((valueKey) => !["email", "phoneNumber"].includes(valueKey));
    return trimmedValues.reduce((values, valueKey) => Object.assign(Object.assign({}, values), { [valueKey]: this.values[valueKey] }), {});
  }
};
EnrollmentChannelData.remediationName = "enrollment-channel-data";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/ChallengeAuthenticator.js
var ChallengeAuthenticator = class extends VerifyAuthenticator {
};
ChallengeAuthenticator.remediationName = "challenge-authenticator";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/ChallengePoll.js
var ChallengePoll = class extends EnrollPoll {
  canRemediate() {
    return !!this.values.startPolling || this.options.step === "challenge-poll";
  }
};
ChallengePoll.remediationName = "challenge-poll";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/ResetAuthenticator.js
var ResetAuthenticator = class extends VerifyAuthenticator {
};
ResetAuthenticator.remediationName = "reset-authenticator";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/EnrollProfile.js
var EnrollProfile = class extends Remediator {
  constructor(remediation, values = {}, options2 = {}) {
    super(remediation, values, options2);
    this.authenticator = null;
    const credentials = this.getCredentialsFromRemediation();
    if (credentials) {
      this.authenticator = this.authenticator = new OktaPassword({});
    }
  }
  canRemediate() {
    if (this.authenticator && !this.authenticator.canVerify(this.values)) {
      return false;
    }
    const userProfileFromValues = this.getData().userProfile;
    if (!userProfileFromValues) {
      return false;
    }
    const userProfileFromRemediation = this.remediation.value.find(({ name }) => name === "userProfile");
    return userProfileFromRemediation.form.value.reduce((canRemediate, curr) => {
      if (curr.required) {
        canRemediate = canRemediate && !!userProfileFromValues[curr.name];
      }
      return canRemediate;
    }, true);
  }
  getCredentialsFromRemediation() {
    return this.remediation.value.find(({ name }) => name === "credentials");
  }
  mapUserProfile({ form: { value: profileAttributes } }) {
    const attributeNames = profileAttributes.map(({ name }) => name);
    const data = attributeNames.reduce((attributeValues, attributeName) => this.values[attributeName] ? Object.assign(Object.assign({}, attributeValues), { [attributeName]: this.values[attributeName] }) : attributeValues, {});
    if (Object.keys(data).length === 0) {
      return;
    }
    return data;
  }
  mapCredentials() {
    const val = this.authenticator && this.authenticator.mapCredentials(this.values);
    if (!val) {
      return;
    }
    return val;
  }
  getInputUserProfile(input) {
    return [...input.form.value];
  }
  getInputCredentials(input) {
    return [...input.form.value];
  }
  getErrorMessages(errorRemediation) {
    return errorRemediation.value[0].form.value.reduce((errors, field) => {
      if (field.messages) {
        errors.push(field.messages.value[0].message);
      }
      return errors;
    }, []);
  }
};
EnrollProfile.remediationName = "enroll-profile";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Identify.js
var Identify = class extends Remediator {
  constructor() {
    super(...arguments);
    this.map = {
      "identifier": ["username"]
    };
  }
  canRemediate() {
    const { identifier } = this.getData();
    return !!identifier;
  }
  mapCredentials() {
    const { credentials, password } = this.values;
    if (!credentials && !password) {
      return;
    }
    return credentials || { passcode: password };
  }
  getInputCredentials(input) {
    return Object.assign(Object.assign({}, input.form.value[0]), { name: "password", required: input.required });
  }
};
Identify.remediationName = "identify";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/ReEnrollAuthenticator.js
var ReEnrollAuthenticator = class extends Remediator {
  mapCredentials() {
    const { newPassword } = this.values;
    if (!newPassword) {
      return;
    }
    return {
      passcode: newPassword
    };
  }
  getInputCredentials(input) {
    const challengeType = this.getAuthenticator().type;
    const name = challengeType === "password" ? "newPassword" : "verificationCode";
    return Object.assign(Object.assign({}, input.form.value[0]), { name });
  }
};
ReEnrollAuthenticator.remediationName = "reenroll-authenticator";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/RedirectIdp.js
var RedirectIdp = class extends Remediator {
  canRemediate() {
    return false;
  }
  getNextStep() {
    const { name, type, idp, href } = this.remediation;
    return {
      name,
      type,
      idp,
      href
    };
  }
};
RedirectIdp.remediationName = "redirect-idp";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Base/SelectAuthenticator.js
var SelectAuthenticator = class extends Remediator {
  findMatchedOption(authenticators, options2) {
    let option2;
    for (let authenticator of authenticators) {
      option2 = options2.find(({ relatesTo }) => relatesTo.key === authenticator.key);
      if (option2) {
        break;
      }
    }
    return option2;
  }
  canRemediate() {
    const { authenticators, authenticator } = this.values;
    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);
    const { options: options2 } = authenticatorFromRemediation;
    if (!authenticators || !authenticators.length) {
      return false;
    }
    if (isAuthenticator(authenticator) && authenticator.id) {
      return true;
    }
    const matchedOption = this.findMatchedOption(authenticators, options2);
    if (matchedOption) {
      return true;
    }
    return false;
  }
  getNextStep(authClient) {
    const common = super.getNextStep(authClient);
    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);
    const options2 = authenticatorFromRemediation.options.map((option2) => {
      const { label, relatesTo } = option2;
      const key = relatesTo.key;
      return { label, value: key };
    });
    return Object.assign(Object.assign({}, common), { options: options2 });
  }
  mapAuthenticator(remediationValue) {
    const { authenticators, authenticator } = this.values;
    if (isAuthenticator(authenticator) && authenticator.id) {
      this.selectedAuthenticator = authenticator;
      return authenticator;
    }
    const { options: options2 } = remediationValue;
    const selectedOption = findMatchedOption(authenticators, options2);
    this.selectedAuthenticator = selectedOption.relatesTo;
    this.selectedOption = selectedOption;
    return {
      id: selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.value.form.value.find(({ name }) => name === "id").value
    };
  }
  getInputAuthenticator(remediation) {
    const options2 = remediation.options.map(({ label, relatesTo }) => {
      return {
        label,
        value: relatesTo.key
      };
    });
    return { name: "authenticator", type: "string", options: options2 };
  }
  getValuesAfterProceed() {
    this.values = super.getValuesAfterProceed();
    const authenticators = this.values.authenticators.filter((authenticator) => {
      return compareAuthenticators(authenticator, this.selectedAuthenticator) !== true;
    });
    return Object.assign(Object.assign({}, this.values), { authenticators });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorAuthenticate.js
var SelectAuthenticatorAuthenticate = class extends SelectAuthenticator {
  constructor(remediation, values = {}, options2 = {}) {
    var _a;
    super(remediation, values, options2);
    const isRecoveryFlow = this.options.flow === "recoverPassword";
    const hasPasswordInOptions = (_a = getAuthenticatorFromRemediation(remediation).options) === null || _a === void 0 ? void 0 : _a.some(({ relatesTo }) => (relatesTo === null || relatesTo === void 0 ? void 0 : relatesTo.key) === AuthenticatorKey.OKTA_PASSWORD);
    if (hasPasswordInOptions && (isRecoveryFlow || this.values.password)) {
      this.values.authenticators = [
        ...this.values.authenticators || [],
        { key: AuthenticatorKey.OKTA_PASSWORD }
      ];
    }
  }
};
SelectAuthenticatorAuthenticate.remediationName = "select-authenticator-authenticate";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorEnroll.js
var SelectAuthenticatorEnroll = class extends SelectAuthenticator {
};
SelectAuthenticatorEnroll.remediationName = "select-authenticator-enroll";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorUnlockAccount.js
var SelectAuthenticatorUnlockAccount = class extends SelectAuthenticator {
  constructor() {
    super(...arguments);
    this.map = {
      identifier: ["username"]
    };
  }
  canRemediate() {
    const identifier = this.getData("identifier");
    return !!identifier && super.canRemediate();
  }
  mapAuthenticator(remediationValue) {
    var _a, _b, _c;
    const authenticatorMap = super.mapAuthenticator(remediationValue);
    const methodTypeOption = (_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.value.form.value.find(({ name }) => name === "methodType");
    const methodTypeValue = this.values.methodType || (methodTypeOption === null || methodTypeOption === void 0 ? void 0 : methodTypeOption.value) || ((_c = (_b = methodTypeOption === null || methodTypeOption === void 0 ? void 0 : methodTypeOption.options) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.value);
    if (methodTypeValue) {
      return Object.assign(Object.assign({}, authenticatorMap), { methodType: methodTypeValue });
    }
    return authenticatorMap;
  }
  getInputUsername() {
    return { name: "username", type: "string" };
  }
};
SelectAuthenticatorUnlockAccount.remediationName = "select-authenticator-unlock-account";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/SelectEnrollProfile.js
var SelectEnrollProfile = class extends Remediator {
  canRemediate() {
    return true;
  }
};
SelectEnrollProfile.remediationName = "select-enroll-profile";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Base/AuthenticatorData.js
var AuthenticatorData = class extends Remediator {
  constructor(remediation, values = {}) {
    super(remediation, values);
    this.authenticator = this.getAuthenticator();
    this.formatAuthenticatorData();
  }
  formatAuthenticatorData() {
    const authenticatorData = this.getAuthenticatorData();
    if (authenticatorData) {
      this.values.authenticatorsData = this.values.authenticatorsData.map((data) => {
        if (compareAuthenticators(this.authenticator, data)) {
          return this.mapAuthenticatorDataFromValues(data);
        }
        return data;
      });
    } else {
      const data = this.mapAuthenticatorDataFromValues();
      if (data) {
        this.values.authenticatorsData.push(data);
      }
    }
  }
  getAuthenticatorData() {
    return this.values.authenticatorsData.find((data) => compareAuthenticators(this.authenticator, data));
  }
  canRemediate() {
    return this.values.authenticatorsData.some((data) => compareAuthenticators(this.authenticator, data));
  }
  getNextStep(authClient) {
    const common = super.getNextStep(authClient);
    const options2 = this.getMethodTypes();
    return Object.assign(Object.assign({}, common), options2 && { options: options2 });
  }
  mapAuthenticatorDataFromValues(authenticatorData) {
    let { methodType, authenticator } = this.values;
    if (!methodType && isAuthenticator(authenticator)) {
      methodType = authenticator === null || authenticator === void 0 ? void 0 : authenticator.methodType;
    }
    const { id, enrollmentId } = this.authenticator;
    const data = Object.assign(Object.assign({
      id,
      enrollmentId
    }, authenticatorData && authenticatorData), methodType && { methodType });
    return data.methodType ? data : null;
  }
  getAuthenticatorFromRemediation() {
    const authenticator = this.remediation.value.find(({ name }) => name === "authenticator");
    return authenticator;
  }
  getMethodTypes() {
    var _a;
    const authenticator = this.getAuthenticatorFromRemediation();
    return (_a = authenticator.form.value.find(({ name }) => name === "methodType")) === null || _a === void 0 ? void 0 : _a.options;
  }
  getValuesAfterProceed() {
    this.values = super.getValuesAfterProceed();
    const authenticatorsData = this.values.authenticatorsData.filter((data) => compareAuthenticators(this.authenticator, data) !== true);
    return Object.assign(Object.assign({}, this.values), { authenticatorsData });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/AuthenticatorVerificationData.js
var AuthenticatorVerificationData = class extends AuthenticatorData {
  constructor(remediation, values = {}, options2 = {}) {
    super(remediation, values);
    this.shouldProceedWithEmailAuthenticator = options2.shouldProceedWithEmailAuthenticator !== false && this.authenticator.methods.length === 1 && this.authenticator.methods[0].type === "email";
  }
  canRemediate() {
    if (this.shouldProceedWithEmailAuthenticator !== false) {
      return true;
    }
    return super.canRemediate();
  }
  mapAuthenticator() {
    var _a;
    if (this.shouldProceedWithEmailAuthenticator !== false) {
      const authenticatorFromRemediation = this.getAuthenticatorFromRemediation();
      return (_a = authenticatorFromRemediation.form) === null || _a === void 0 ? void 0 : _a.value.reduce((acc, curr) => {
        if (curr.value) {
          acc[curr.name] = curr.value;
        } else if (curr.options) {
          acc[curr.name] = curr.options[0].value;
        } else {
          throw new AuthSdkError(`Unsupported authenticator data type: ${curr}`);
        }
        return acc;
      }, {});
    }
    return this.getAuthenticatorData();
  }
  getInputAuthenticator() {
    const authenticator = this.getAuthenticatorFromRemediation();
    const methodType = authenticator.form.value.find(({ name }) => name === "methodType");
    if (methodType && methodType.options) {
      return {
        name: "methodType",
        type: "string",
        required: true,
        options: methodType.options
      };
    }
    const inputs = [...authenticator.form.value];
    return inputs;
  }
  getValuesAfterProceed() {
    this.values = super.getValuesAfterProceed();
    let trimmedValues = Object.keys(this.values).filter((valueKey) => valueKey !== "authenticator");
    return trimmedValues.reduce((values, valueKey) => Object.assign(Object.assign({}, values), { [valueKey]: this.values[valueKey] }), {});
  }
};
AuthenticatorVerificationData.remediationName = "authenticator-verification-data";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/AuthenticatorEnrollmentData.js
var AuthenticatorEnrollmentData = class extends AuthenticatorData {
  mapAuthenticator() {
    const authenticatorData = this.getAuthenticatorData();
    const authenticatorFromRemediation = getAuthenticatorFromRemediation(this.remediation);
    return {
      id: authenticatorFromRemediation.form.value.find(({ name }) => name === "id").value,
      methodType: authenticatorData.methodType,
      phoneNumber: authenticatorData.phoneNumber
    };
  }
  getInputAuthenticator(remediation) {
    return [
      { name: "methodType", type: "string" },
      { name: "phoneNumber", label: "Phone Number", type: "string" }
    ].map((item) => {
      const value = remediation.form.value.find((val) => val.name === item.name);
      return Object.assign(Object.assign({}, value), item);
    });
  }
  mapAuthenticatorDataFromValues(data) {
    data = super.mapAuthenticatorDataFromValues(data);
    const { phoneNumber } = this.values;
    if (!data && !phoneNumber) {
      return;
    }
    return Object.assign(Object.assign({}, data && data), phoneNumber && { phoneNumber });
  }
};
AuthenticatorEnrollmentData.remediationName = "authenticator-enrollment-data";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/Skip.js
var Skip = class extends Remediator {
  canRemediate() {
    return !!this.values.skip || this.options.step === "skip";
  }
};
Skip.remediationName = "skip";

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/GenericRemediator/util.js
function unwrapFormValue(remediation) {
  if (Array.isArray(remediation)) {
    return remediation.map((item) => {
      if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
        return item;
      }
      return unwrapFormValue(item);
    });
  }
  const res = {};
  for (const [key, value] of Object.entries(remediation)) {
    if (value === null || typeof value === "undefined") {
      continue;
    }
    if (typeof value === "object") {
      const formKeys = Object.keys(value);
      if (["value", "form"].includes(key) && formKeys.length === 1 && ["value", "form"].includes(formKeys[0])) {
        const unwrappedForm = unwrapFormValue(value);
        Object.entries(unwrappedForm).forEach(([key2, value2]) => {
          res[key2] = value2;
        });
      } else {
        res[key] = unwrapFormValue(value);
      }
    } else {
      res[key] = value;
    }
  }
  return res;
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediators/GenericRemediator/GenericRemediator.js
var GenericRemediator = class extends Remediator {
  canRemediate() {
    if (typeof this.remediation.action !== "function") {
      return false;
    }
    if (this.remediation.name === "poll" || this.remediation.name.endsWith("-poll")) {
      return true;
    }
    if (this.options.step) {
      return true;
    }
    return false;
  }
  getData() {
    const data = this.getInputs().reduce((acc, { name }) => {
      acc[name] = this.values[name];
      return acc;
    }, {});
    return data;
  }
  getNextStep(authClient, _context) {
    const name = this.getName();
    const inputs = this.getInputs();
    const _a = this.remediation, {
      href,
      method,
      rel,
      accepts,
      produces,
      value,
      action: action2
    } = _a, rest = __rest(_a, ["href", "method", "rel", "accepts", "produces", "value", "action"]);
    if (action2) {
      return Object.assign(Object.assign(Object.assign({}, rest), !!inputs.length && { inputs }), { action: (params) => __async(this, null, function* () {
        return authClient.idx.proceed(Object.assign({ step: name }, params));
      }) });
    }
    return Object.assign({}, this.remediation);
  }
  getInputs() {
    return (this.remediation.value || []).filter(({ name }) => name !== "stateHandle").map(unwrapFormValue).map((input) => {
      input.type = input.type || "string";
      return input;
    });
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/util.js
function isTerminalResponse(idxResponse) {
  const { neededToProceed, interactionCode } = idxResponse;
  return !neededToProceed.length && !interactionCode;
}
function canSkipFn(idxResponse) {
  return idxResponse.neededToProceed.some(({ name }) => name === "skip");
}
function canResendFn(idxResponse) {
  return Object.keys(idxResponse.actions).some((actionName) => actionName.includes("resend"));
}
function getMessagesFromIdxRemediationValue(value) {
  if (!value || !Array.isArray(value)) {
    return;
  }
  return value.reduce((messages, value2) => {
    if (value2.messages) {
      messages = [...messages, ...value2.messages.value];
    }
    if (value2.form) {
      const messagesFromForm = getMessagesFromIdxRemediationValue(value2.form.value) || [];
      messages = [...messages, ...messagesFromForm];
    }
    if (value2.options) {
      let optionValues = [];
      value2.options.forEach((option2) => {
        if (!option2.value || typeof option2.value === "string") {
          return;
        }
        optionValues = [...optionValues, option2.value];
      });
      const messagesFromOptions = getMessagesFromIdxRemediationValue(optionValues) || [];
      messages = [...messages, ...messagesFromOptions];
    }
    return messages;
  }, []);
}
function getMessagesFromResponse(idxResponse, options2) {
  var _a;
  let messages = [];
  const { rawIdxState, neededToProceed } = idxResponse;
  const globalMessages = (_a = rawIdxState.messages) === null || _a === void 0 ? void 0 : _a.value.map((message) => message);
  if (globalMessages) {
    messages = [...messages, ...globalMessages];
  }
  if (!options2.useGenericRemediator) {
    for (let remediation of neededToProceed) {
      const fieldMessages = getMessagesFromIdxRemediationValue(remediation.value);
      if (fieldMessages) {
        messages = [...messages, ...fieldMessages];
      }
    }
  }
  const seen = {};
  messages = messages.reduce((filtered, message) => {
    var _a2;
    const key = (_a2 = message.i18n) === null || _a2 === void 0 ? void 0 : _a2.key;
    if (key && seen[key]) {
      return filtered;
    }
    seen[key] = message;
    filtered = [...filtered, message];
    return filtered;
  }, []);
  return messages;
}
function getEnabledFeatures(idxResponse) {
  const res = [];
  const { actions, neededToProceed } = idxResponse;
  if (actions["currentAuthenticator-recover"]) {
    res.push(IdxFeature.PASSWORD_RECOVERY);
  }
  if (neededToProceed.some(({ name }) => name === "select-enroll-profile")) {
    res.push(IdxFeature.REGISTRATION);
  }
  if (neededToProceed.some(({ name }) => name === "redirect-idp")) {
    res.push(IdxFeature.SOCIAL_IDP);
  }
  if (neededToProceed.some(({ name }) => name === "unlock-account")) {
    res.push(IdxFeature.ACCOUNT_UNLOCK);
  }
  return res;
}
function getAvailableSteps(authClient, idxResponse, useGenericRemediator) {
  var _a;
  const res = [];
  const remediatorMap = Object.values(remediators_exports).reduce((map, remediatorClass) => {
    if (remediatorClass.remediationName) {
      map[remediatorClass.remediationName] = remediatorClass;
    }
    return map;
  }, {});
  for (let remediation of idxResponse.neededToProceed) {
    const T = getRemediatorClass(remediation, { useGenericRemediator, remediators: remediatorMap });
    if (T) {
      const remediator = new T(remediation);
      res.push(remediator.getNextStep(authClient, idxResponse.context));
    }
  }
  for (const [name] of Object.entries(idxResponse.actions || {})) {
    let stepObj = {
      name,
      action: (params) => __async(this, null, function* () {
        return authClient.idx.proceed({
          actions: [{ name, params }]
        });
      })
    };
    if (name.startsWith("currentAuthenticator")) {
      const [part1, part2] = split2(name, "-");
      const actionObj = idxResponse.rawIdxState[part1].value[part2];
      const rest = __rest(actionObj, ["href", "method", "rel", "accepts", "produces"]);
      const value = (_a = actionObj.value) === null || _a === void 0 ? void 0 : _a.filter((item) => item.name !== "stateHandle");
      stepObj = Object.assign(Object.assign(Object.assign({}, rest), value && { value }), stepObj);
    }
    res.push(stepObj);
  }
  return res;
}
function filterValuesForRemediation(idxResponse, remediationName, values) {
  const remediations = idxResponse.neededToProceed || [];
  const remediation = remediations.find((r) => r.name === remediationName);
  if (!remediation) {
    warn(`filterValuesForRemediation: "${remediationName}" did not match any remediations`);
    return values;
  }
  const valuesForRemediation = remediation.value.reduce((res, entry) => {
    const { name, value } = entry;
    if (name === "stateHandle") {
      res[name] = value;
    } else {
      res[name] = values[name];
    }
    return res;
  }, {});
  return valuesForRemediation;
}
function getRemediatorClass(remediation, options2) {
  const { useGenericRemediator, remediators } = options2;
  if (!remediation) {
    return void 0;
  }
  if (useGenericRemediator) {
    return GenericRemediator;
  }
  return remediators[remediation.name];
}
function getRemediator(idxRemediations, values, options2) {
  const remediators = options2.remediators;
  const useGenericRemediator = options2.useGenericRemediator;
  let remediator;
  if (options2.step) {
    const remediation = idxRemediations.find(({ name }) => name === options2.step);
    if (remediation) {
      const T = getRemediatorClass(remediation, options2);
      return T ? new T(remediation, values, options2) : void 0;
    } else {
      warn(`step "${options2.step}" did not match any remediations`);
      return;
    }
  }
  const remediatorCandidates = [];
  if (useGenericRemediator) {
    remediatorCandidates.push(new GenericRemediator(idxRemediations[0], values, options2));
  } else {
    for (let remediation of idxRemediations) {
      const isRemeditionInFlow = Object.keys(remediators).includes(remediation.name);
      if (!isRemeditionInFlow) {
        continue;
      }
      const T = getRemediatorClass(remediation, options2);
      remediator = new T(remediation, values, options2);
      if (remediator.canRemediate()) {
        return remediator;
      }
      remediatorCandidates.push(remediator);
    }
  }
  return remediatorCandidates[0];
}
function getNextStep(authClient, remediator, idxResponse) {
  const nextStep = remediator.getNextStep(authClient, idxResponse.context);
  const canSkip = canSkipFn(idxResponse);
  const canResend = canResendFn(idxResponse);
  return Object.assign(Object.assign(Object.assign({}, nextStep), canSkip && { canSkip }), canResend && { canResend });
}
function handleIdxError(authClient, e, options2 = {}) {
  let idxResponse = isIdxResponse(e) ? e : null;
  if (!idxResponse) {
    throw e;
  }
  idxResponse = Object.assign(Object.assign({}, idxResponse), { requestDidSucceed: false });
  const terminal = isTerminalResponse(idxResponse);
  const messages = getMessagesFromResponse(idxResponse, options2);
  if (terminal) {
    return { idxResponse, terminal, messages };
  } else {
    const remediator = getRemediator(idxResponse.neededToProceed, {}, options2);
    const nextStep = remediator && getNextStep(authClient, remediator, idxResponse);
    return Object.assign({
      idxResponse,
      messages
    }, nextStep && { nextStep });
  }
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/remediate.js
function getActionFromValues(values, idxResponse) {
  return Object.keys(idxResponse.actions).find((action2) => !!values.resend && action2.includes("-resend"));
}
function removeActionFromValues(values) {
  return Object.assign(Object.assign({}, values), { resend: void 0 });
}
function removeActionFromOptions(options2, actionName) {
  let actions = options2.actions || [];
  actions = actions.filter((entry) => {
    if (typeof entry === "string") {
      return entry !== actionName;
    }
    return entry.name !== actionName;
  });
  return Object.assign(Object.assign({}, options2), { actions });
}
function remediate(authClient, idxResponse, values, options2) {
  return __async(this, null, function* () {
    let { neededToProceed, interactionCode } = idxResponse;
    const { flow } = options2;
    if (interactionCode) {
      return { idxResponse };
    }
    const remediator = getRemediator(neededToProceed, values, options2);
    const actionFromValues = getActionFromValues(values, idxResponse);
    const actionFromOptions = options2.actions || [];
    const actions = [
      ...actionFromOptions,
      ...actionFromValues && [actionFromValues] || []
    ];
    if (actions) {
      for (let action2 of actions) {
        let params = {};
        if (typeof action2 !== "string") {
          params = action2.params || {};
          action2 = action2.name;
        }
        let valuesWithoutExecutedAction = removeActionFromValues(values);
        let optionsWithoutExecutedAction = removeActionFromOptions(options2, action2);
        if (typeof idxResponse.actions[action2] === "function") {
          try {
            idxResponse = yield idxResponse.actions[action2](params);
            idxResponse = Object.assign(Object.assign({}, idxResponse), { requestDidSucceed: true });
          } catch (e) {
            return handleIdxError(authClient, e, options2);
          }
          if (action2 === "cancel") {
            return { idxResponse, canceled: true };
          }
          return remediate(authClient, idxResponse, valuesWithoutExecutedAction, optionsWithoutExecutedAction);
        }
        const remediationAction = neededToProceed.find(({ name: name2 }) => name2 === action2);
        if (remediationAction) {
          try {
            idxResponse = yield idxResponse.proceed(action2, params);
            idxResponse = Object.assign(Object.assign({}, idxResponse), { requestDidSucceed: true });
          } catch (e) {
            return handleIdxError(authClient, e, options2);
          }
          return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction);
        }
      }
    }
    const terminal = isTerminalResponse(idxResponse);
    if (terminal) {
      return { idxResponse, terminal };
    }
    if (!remediator) {
      if (options2.step) {
        values = filterValuesForRemediation(idxResponse, options2.step, values);
        try {
          idxResponse = yield idxResponse.proceed(options2.step, values);
          idxResponse = Object.assign(Object.assign({}, idxResponse), { requestDidSucceed: true });
          return { idxResponse };
        } catch (e) {
          return handleIdxError(authClient, e, options2);
        }
      }
      if (flow === "default") {
        return { idxResponse };
      }
      throw new AuthSdkError(`
      No remediation can match current flow, check policy settings in your org.
      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + " ," + curr.name : curr.name, "")}]
    `);
    }
    if (!remediator.canRemediate()) {
      const nextStep = getNextStep(authClient, remediator, idxResponse);
      return {
        idxResponse,
        nextStep
      };
    }
    const name = remediator.getName();
    const data = remediator.getData();
    try {
      idxResponse = yield idxResponse.proceed(name, data);
      idxResponse = Object.assign(Object.assign({}, idxResponse), { requestDidSucceed: true });
      values = remediator.getValuesAfterProceed();
      options2 = Object.assign(Object.assign({}, options2), { step: void 0 });
      if (options2.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {
        const gr = getRemediator(idxResponse.neededToProceed, values, options2);
        const nextStep = getNextStep(authClient, gr, idxResponse);
        return {
          idxResponse,
          nextStep
        };
      }
      return remediate(authClient, idxResponse, values, options2);
    } catch (e) {
      return handleIdxError(authClient, e, options2);
    }
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/flow/AuthenticationFlow.js
var AuthenticationFlow = {
  "identify": Identify,
  "select-authenticator-authenticate": SelectAuthenticatorAuthenticate,
  "select-authenticator-enroll": SelectAuthenticatorEnroll,
  "authenticator-enrollment-data": AuthenticatorEnrollmentData,
  "authenticator-verification-data": AuthenticatorVerificationData,
  "enroll-authenticator": EnrollAuthenticator,
  "challenge-authenticator": ChallengeAuthenticator,
  "challenge-poll": ChallengePoll,
  "reenroll-authenticator": ReEnrollAuthenticator,
  "enroll-poll": EnrollPoll,
  "select-enrollment-channel": SelectEnrollmentChannel,
  "enrollment-channel-data": EnrollmentChannelData,
  "redirect-idp": RedirectIdp,
  "skip": Skip
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/flow/PasswordRecoveryFlow.js
var PasswordRecoveryFlow = {
  "identify": Identify,
  "identify-recovery": Identify,
  "select-authenticator-authenticate": SelectAuthenticatorAuthenticate,
  "select-authenticator-enroll": SelectAuthenticatorEnroll,
  "challenge-authenticator": ChallengeAuthenticator,
  "authenticator-verification-data": AuthenticatorVerificationData,
  "authenticator-enrollment-data": AuthenticatorEnrollmentData,
  "reset-authenticator": ResetAuthenticator,
  "reenroll-authenticator": ReEnrollAuthenticator,
  "enroll-poll": EnrollPoll
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/flow/RegistrationFlow.js
var RegistrationFlow = {
  "select-enroll-profile": SelectEnrollProfile,
  "enroll-profile": EnrollProfile,
  "authenticator-enrollment-data": AuthenticatorEnrollmentData,
  "select-authenticator-enroll": SelectAuthenticatorEnroll,
  "enroll-poll": EnrollPoll,
  "select-enrollment-channel": SelectEnrollmentChannel,
  "enrollment-channel-data": EnrollmentChannelData,
  "enroll-authenticator": EnrollAuthenticator,
  "skip": Skip
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/flow/AccountUnlockFlow.js
var AccountUnlockFlow = {
  "identify": Identify,
  "select-authenticator-unlock-account": SelectAuthenticatorUnlockAccount,
  "select-authenticator-authenticate": SelectAuthenticatorAuthenticate,
  "challenge-authenticator": ChallengeAuthenticator,
  "challenge-poll": ChallengePoll,
  "authenticator-verification-data": AuthenticatorVerificationData
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/flow/FlowSpecification.js
function getFlowSpecification(oktaAuth, flow = "default") {
  let remediators, actions, withCredentials = true;
  switch (flow) {
    case "register":
    case "signup":
    case "enrollProfile":
      remediators = RegistrationFlow;
      withCredentials = false;
      break;
    case "recoverPassword":
    case "resetPassword":
      remediators = PasswordRecoveryFlow;
      actions = [
        "currentAuthenticator-recover",
        "currentAuthenticatorEnrollment-recover"
      ];
      withCredentials = false;
      break;
    case "unlockAccount":
      remediators = AccountUnlockFlow;
      withCredentials = false;
      actions = [
        "unlock-account"
      ];
      break;
    case "authenticate":
    case "login":
    case "signin":
      remediators = AuthenticationFlow;
      break;
    default:
      remediators = AuthenticationFlow;
      break;
  }
  return { flow, remediators, actions, withCredentials };
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/run.js
function initializeValues(options2) {
  const knownOptions = [
    "flow",
    "remediators",
    "actions",
    "withCredentials",
    "step",
    "useGenericRemediator",
    "exchangeCodeForTokens",
    "shouldProceedWithEmailAuthenticator"
  ];
  const values = Object.assign({}, options2);
  knownOptions.forEach((option2) => {
    delete values[option2];
  });
  return values;
}
function initializeData(authClient, data) {
  let { options: options2 } = data;
  options2 = Object.assign(Object.assign({}, authClient.options.idx), options2);
  let { flow, withCredentials, remediators, actions } = options2;
  const status = IdxStatus.PENDING;
  flow = flow || authClient.idx.getFlow() || "default";
  if (flow) {
    authClient.idx.setFlow(flow);
    const flowSpec = getFlowSpecification(authClient, flow);
    withCredentials = typeof withCredentials !== "undefined" ? withCredentials : flowSpec.withCredentials;
    remediators = remediators || flowSpec.remediators;
    actions = actions || flowSpec.actions;
  }
  return Object.assign(Object.assign({}, data), { options: Object.assign(Object.assign({}, options2), {
    flow,
    withCredentials,
    remediators,
    actions
  }), status });
}
function getDataFromIntrospect(authClient, data) {
  return __async(this, null, function* () {
    const { options: options2 } = data;
    const { stateHandle, withCredentials, version: version2, state, scopes, recoveryToken, activationToken, maxAge, nonce } = options2;
    let idxResponse;
    let meta = getSavedTransactionMeta(authClient, { state, recoveryToken, activationToken });
    if (stateHandle) {
      idxResponse = yield introspect(authClient, { withCredentials, version: version2, stateHandle });
    } else {
      let interactionHandle = meta === null || meta === void 0 ? void 0 : meta.interactionHandle;
      if (!interactionHandle) {
        authClient.transactionManager.clear();
        const interactResponse = yield interact(authClient, {
          withCredentials,
          state,
          scopes,
          activationToken,
          recoveryToken,
          maxAge,
          nonce
        });
        interactionHandle = interactResponse.interactionHandle;
        meta = interactResponse.meta;
      }
      idxResponse = yield introspect(authClient, { withCredentials, version: version2, interactionHandle });
    }
    return Object.assign(Object.assign({}, data), { idxResponse, meta });
  });
}
function getDataFromRemediate(authClient, data) {
  return __async(this, null, function* () {
    let { idxResponse, options: options2, values } = data;
    const {
      autoRemediate,
      remediators,
      actions,
      flow,
      step,
      shouldProceedWithEmailAuthenticator,
      useGenericRemediator
    } = options2;
    const shouldRemediate = autoRemediate !== false && (remediators || actions || step);
    if (!shouldRemediate) {
      return data;
    }
    values = Object.assign(Object.assign({}, values), { stateHandle: idxResponse.rawIdxState.stateHandle });
    const { idxResponse: idxResponseFromRemediation, nextStep, canceled } = yield remediate(authClient, idxResponse, values, {
      remediators,
      actions,
      flow,
      step,
      shouldProceedWithEmailAuthenticator,
      useGenericRemediator
    });
    idxResponse = idxResponseFromRemediation;
    return Object.assign(Object.assign({}, data), { idxResponse, nextStep, canceled });
  });
}
function getTokens(authClient, data) {
  return __async(this, null, function* () {
    let { meta, idxResponse } = data;
    const { interactionCode } = idxResponse;
    const { clientId, codeVerifier, ignoreSignature, redirectUri, urls, scopes } = meta;
    const tokenResponse = yield authClient.token.exchangeCodeForTokens({
      interactionCode,
      clientId,
      codeVerifier,
      ignoreSignature,
      redirectUri,
      scopes
    }, urls);
    return tokenResponse.tokens;
  });
}
function finalizeData(authClient, data) {
  return __async(this, null, function* () {
    let { options: options2, idxResponse, canceled, status } = data;
    const { exchangeCodeForTokens: exchangeCodeForTokens2 } = options2;
    let shouldSaveResponse = false;
    let shouldClearTransaction = false;
    let clearSharedStorage = true;
    let interactionCode;
    let tokens;
    let enabledFeatures;
    let availableSteps;
    let messages;
    let terminal;
    if (idxResponse) {
      shouldSaveResponse = !!(idxResponse.requestDidSucceed || idxResponse.stepUp);
      enabledFeatures = getEnabledFeatures(idxResponse);
      availableSteps = getAvailableSteps(authClient, idxResponse, options2.useGenericRemediator);
      messages = getMessagesFromResponse(idxResponse, options2);
      terminal = isTerminalResponse(idxResponse);
    }
    if (terminal) {
      status = IdxStatus.TERMINAL;
      const hasActions = Object.keys(idxResponse.actions).length > 0;
      const hasErrors = !!messages.find((msg) => msg.class === "ERROR");
      const isTerminalSuccess = !hasActions && !hasErrors && idxResponse.requestDidSucceed === true;
      if (isTerminalSuccess) {
        shouldClearTransaction = true;
      } else {
        shouldSaveResponse = shouldSaveResponse && hasActions;
      }
      clearSharedStorage = false;
    } else if (canceled) {
      status = IdxStatus.CANCELED;
      shouldClearTransaction = true;
    } else if (idxResponse === null || idxResponse === void 0 ? void 0 : idxResponse.interactionCode) {
      interactionCode = idxResponse.interactionCode;
      if (exchangeCodeForTokens2 === false) {
        status = IdxStatus.SUCCESS;
        shouldClearTransaction = false;
      } else {
        tokens = yield getTokens(authClient, data);
        status = IdxStatus.SUCCESS;
        shouldClearTransaction = true;
      }
    }
    return Object.assign(Object.assign({}, data), {
      status,
      interactionCode,
      tokens,
      shouldSaveResponse,
      shouldClearTransaction,
      clearSharedStorage,
      enabledFeatures,
      availableSteps,
      messages,
      terminal
    });
  });
}
function handleError(err, data) {
  let { error, status, shouldClearTransaction } = data;
  if (isIdxResponse(err)) {
    error = err;
    status = IdxStatus.FAILURE;
    shouldClearTransaction = true;
  } else {
    throw err;
  }
  return Object.assign(Object.assign({}, data), { error, status, shouldClearTransaction });
}
function run(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    var _a;
    let data = {
      options: options2,
      values: initializeValues(options2)
    };
    data = initializeData(authClient, data);
    try {
      data = yield getDataFromIntrospect(authClient, data);
      data = yield getDataFromRemediate(authClient, data);
    } catch (err) {
      data = handleError(err, data);
    }
    data = yield finalizeData(authClient, data);
    const { idxResponse, meta, shouldSaveResponse, shouldClearTransaction, clearSharedStorage, status, enabledFeatures, availableSteps, tokens, nextStep, messages, error, interactionCode } = data;
    if (shouldClearTransaction) {
      authClient.transactionManager.clear({ clearSharedStorage });
    } else {
      saveTransactionMeta(authClient, Object.assign({}, meta));
      if (shouldSaveResponse) {
        const { rawIdxState: rawIdxResponse, requestDidSucceed: requestDidSucceed2 } = idxResponse;
        authClient.transactionManager.saveIdxResponse({
          rawIdxResponse,
          requestDidSucceed: requestDidSucceed2,
          stateHandle: (_a = idxResponse.context) === null || _a === void 0 ? void 0 : _a.stateHandle,
          interactionHandle: meta === null || meta === void 0 ? void 0 : meta.interactionHandle
        });
      }
    }
    const { actions, context, neededToProceed, proceed: proceed2, rawIdxState, requestDidSucceed, stepUp } = idxResponse || {};
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ status }, meta && { meta }), enabledFeatures && { enabledFeatures }), availableSteps && { availableSteps }), tokens && { tokens }), nextStep && { nextStep }), messages && messages.length && { messages }), error && { error }), stepUp && { stepUp }), {
      interactionCode,
      actions,
      context,
      neededToProceed,
      proceed: proceed2,
      rawIdxState,
      requestDidSucceed
    });
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/authenticate.js
function authenticate(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    if (options2.password && !options2.authenticator) {
      options2.authenticator = AuthenticatorKey.OKTA_PASSWORD;
    }
    return run(authClient, Object.assign(Object.assign({}, options2), { flow: "authenticate" }));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/cancel.js
function cancel(authClient, options2) {
  return __async(this, null, function* () {
    const meta = authClient.transactionManager.load();
    const flowSpec = getFlowSpecification(authClient, meta.flow);
    return run(authClient, Object.assign(Object.assign(Object.assign({}, options2), flowSpec), { actions: ["cancel"] }));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/emailVerify.js
var EmailVerifyCallbackError = class extends CustomError2 {
  constructor(state, otp) {
    super(`Enter the OTP code in the originating client: ${otp}`);
    this.name = "EmailVerifyCallbackError";
    this.state = state;
    this.otp = otp;
  }
};
function isEmailVerifyCallbackError(error) {
  return error.name === "EmailVerifyCallbackError";
}
function isEmailVerifyCallback(urlPath) {
  return /(otp=)/i.test(urlPath) && /(state=)/i.test(urlPath);
}
function parseEmailVerifyCallback(urlPath) {
  return urlParamsToObject(urlPath);
}
function handleEmailVerifyCallback(authClient, search) {
  return __async(this, null, function* () {
    if (isEmailVerifyCallback(search)) {
      const { state, otp } = parseEmailVerifyCallback(search);
      if (authClient.idx.canProceed({ state })) {
        return yield authClient.idx.proceed({ state, otp });
      } else {
        throw new EmailVerifyCallbackError(state, otp);
      }
    }
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/proceed.js
function canProceed(authClient, options2 = {}) {
  const meta = getSavedTransactionMeta(authClient, options2);
  return !!(meta || options2.stateHandle);
}
function proceed(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    if (!canProceed(authClient, options2)) {
      throw new AuthSdkError("Unable to proceed: saved transaction could not be loaded");
    }
    let { flow, state } = options2;
    if (!flow) {
      const meta = getSavedTransactionMeta(authClient, { state });
      flow = meta === null || meta === void 0 ? void 0 : meta.flow;
    }
    return run(authClient, Object.assign(Object.assign({}, options2), { flow }));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/poll.js
function poll(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    var _a;
    let transaction = yield proceed(authClient, {
      startPolling: true
    });
    const meta = getSavedTransactionMeta(authClient);
    let availablePollingRemeditaions = (_a = meta === null || meta === void 0 ? void 0 : meta.remediations) === null || _a === void 0 ? void 0 : _a.find((remediation) => remediation.includes("poll"));
    if (!(availablePollingRemeditaions === null || availablePollingRemeditaions === void 0 ? void 0 : availablePollingRemeditaions.length)) {
      warn("No polling remediations available at the current IDX flow stage");
    }
    if (Number.isInteger(options2.refresh)) {
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          return __async(this, null, function* () {
            var _a2, _b;
            try {
              const refresh = (_b = (_a2 = transaction.nextStep) === null || _a2 === void 0 ? void 0 : _a2.poll) === null || _b === void 0 ? void 0 : _b.refresh;
              if (refresh) {
                resolve(poll(authClient, {
                  refresh
                }));
              } else {
                resolve(transaction);
              }
            } catch (err) {
              reject(err);
            }
          });
        }, options2.refresh);
      });
    }
    return transaction;
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/startTransaction.js
function startTransaction(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    authClient.transactionManager.clear();
    return run(authClient, Object.assign({ exchangeCodeForTokens: false }, options2));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/register.js
function register(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    if (!hasSavedInteractionHandle(authClient)) {
      const { enabledFeatures, availableSteps } = yield startTransaction(authClient, Object.assign(Object.assign({}, options2), { flow: "register", autoRemediate: false }));
      if (!options2.activationToken && enabledFeatures && !enabledFeatures.includes(IdxFeature.REGISTRATION)) {
        const error = new AuthSdkError("Registration is not supported based on your current org configuration.");
        throw error;
      }
      if (options2.activationToken && (availableSteps === null || availableSteps === void 0 ? void 0 : availableSteps.some(({ name }) => name === "identify"))) {
        const error = new AuthSdkError("activationToken is not supported based on your current org configuration.");
        throw error;
      }
    }
    return run(authClient, Object.assign(Object.assign({}, options2), { flow: "register" }));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/recoverPassword.js
function recoverPassword(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    const flowSpec = getFlowSpecification(authClient, "recoverPassword");
    return run(authClient, Object.assign(Object.assign({}, options2), flowSpec));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/handleInteractionCodeRedirect.js
function handleInteractionCodeRedirect(authClient, url) {
  return __async(this, null, function* () {
    const meta = authClient.transactionManager.load();
    if (!meta) {
      throw new AuthSdkError("No transaction data was found in storage");
    }
    const { codeVerifier, state: savedState } = meta;
    const {
      searchParams
    } = new URL(url);
    const state = searchParams.get("state");
    const interactionCode = searchParams.get("interaction_code");
    const error = searchParams.get("error");
    if (error) {
      throw new OAuthError2(error, searchParams.get("error_description"));
    }
    if (state !== savedState) {
      throw new AuthSdkError("State in redirect uri does not match with transaction state");
    }
    if (!interactionCode) {
      throw new AuthSdkError("Unable to parse interaction_code from the url");
    }
    const { tokens } = yield authClient.token.exchangeCodeForTokens({ interactionCode, codeVerifier });
    authClient.tokenManager.setTokens(tokens);
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/idx/unlockAccount.js
function unlockAccount(_0) {
  return __async(this, arguments, function* (authClient, options2 = {}) {
    options2.flow = "unlockAccount";
    if (!hasSavedInteractionHandle(authClient)) {
      const { enabledFeatures } = yield startTransaction(authClient, Object.assign(Object.assign({}, options2), { autoRemediate: false }));
      if (enabledFeatures && !enabledFeatures.includes(IdxFeature.ACCOUNT_UNLOCK)) {
        throw new AuthSdkError("Self Service Account Unlock is not supported based on your current org configuration.");
      }
    }
    return run(authClient, Object.assign({}, options2));
  });
}

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/OktaUserAgent.js
var OktaUserAgent = class {
  constructor() {
    this.environments = [`okta-auth-js/${"6.9.0"}`];
  }
  addEnvironment(env) {
    this.environments.push(env);
  }
  getHttpHeader() {
    this.maybeAddNodeEnvironment();
    return { "X-Okta-User-Agent-Extended": this.environments.join(" ") };
  }
  getVersion() {
    return "6.9.0";
  }
  maybeAddNodeEnvironment() {
    if (isBrowser() || !process || !process.versions) {
      return;
    }
    const { node: version2 } = process.versions;
    this.environments.push(`nodejs/${version2}`);
  }
};

// node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/esm/browser/OktaAuth.js
var import_tiny_emitter = __toESM(require_tiny_emitter(), 1);
var OktaAuth = class {
  constructor(args) {
    this.features = features_exports;
    const options2 = this.options = buildOptions(args);
    this.storageManager = new StorageManager(options2.storageManager, options2.cookies, options2.storageUtil);
    this.transactionManager = new TransactionManager(Object.assign({
      storageManager: this.storageManager
    }, options2.transactionManager));
    this._oktaUserAgent = new OktaUserAgent();
    this.tx = {
      status: transactionStatus.bind(null, this),
      resume: resumeTransaction.bind(null, this),
      exists: Object.assign(transactionExists.bind(null, this), {
        _get: (name) => {
          const storage = options2.storageUtil.storage;
          return storage.get(name);
        }
      }),
      introspect: introspectAuthn.bind(null, this),
      createTransaction: (res) => {
        return new AuthTransaction(this, res);
      },
      postToTransaction: (url, args2, options3) => {
        return postToTransaction(this, url, args2, options3);
      }
    };
    this.pkce = {
      DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,
      generateVerifier: PKCE.generateVerifier,
      computeChallenge: PKCE.computeChallenge
    };
    Object.assign(this.options.storageUtil || {}, {
      getPKCEStorage: this.storageManager.getLegacyPKCEStorage.bind(this.storageManager),
      getHttpCache: this.storageManager.getHttpCache.bind(this.storageManager)
    });
    this._pending = { handleLogin: false };
    if (isBrowser()) {
      this.options = Object.assign(this.options, {
        redirectUri: toAbsoluteUrl(args.redirectUri, window.location.origin)
      });
    }
    if (!args.maxClockSkew && args.maxClockSkew !== 0) {
      this.options.maxClockSkew = DEFAULT_MAX_CLOCK_SKEW;
    } else {
      this.options.maxClockSkew = args.maxClockSkew;
    }
    this.options.ignoreLifetime = !!args.ignoreLifetime;
    this.session = {
      close: closeSession.bind(null, this),
      exists: sessionExists.bind(null, this),
      get: getSession.bind(null, this),
      refresh: refreshSession.bind(null, this),
      setCookieAndRedirect: setCookieAndRedirect.bind(null, this)
    };
    this._tokenQueue = new PromiseQueue();
    const useQueue = (method) => {
      return PromiseQueue.prototype.push.bind(this._tokenQueue, method, null);
    };
    const getWithRedirectFn = useQueue(getWithRedirect.bind(null, this));
    const getWithRedirectApi = Object.assign(getWithRedirectFn, {
      _setLocation: function(url) {
        if (options2.setLocation) {
          options2.setLocation(url);
        } else {
          window.location = url;
        }
      }
    });
    const parseFromUrlFn = useQueue(parseFromUrl.bind(null, this));
    const parseFromUrlApi = Object.assign(parseFromUrlFn, {
      _getHistory: function() {
        return window.history;
      },
      _getLocation: function() {
        return window.location;
      },
      _getDocument: function() {
        return window.document;
      }
    });
    this.token = {
      prepareTokenParams: prepareTokenParams.bind(null, this),
      exchangeCodeForTokens: exchangeCodeForTokens.bind(null, this),
      getWithoutPrompt: getWithoutPrompt.bind(null, this),
      getWithPopup: getWithPopup.bind(null, this),
      getWithRedirect: getWithRedirectApi,
      parseFromUrl: parseFromUrlApi,
      decode: decodeToken,
      revoke: revokeToken.bind(null, this),
      renew: renewToken.bind(null, this),
      renewTokensWithRefresh: renewTokensWithRefresh.bind(null, this),
      renewTokens: renewTokens.bind(null, this),
      getUserInfo: (accessTokenObject, idTokenObject) => {
        return getUserInfo(this, accessTokenObject, idTokenObject);
      },
      verify: verifyToken2.bind(null, this),
      isLoginRedirect: isLoginRedirect.bind(null, this)
    };
    const toWrap = [
      "getWithoutPrompt",
      "getWithPopup",
      "revoke",
      "renew",
      "renewTokensWithRefresh",
      "renewTokens"
    ];
    toWrap.forEach((key) => {
      this.token[key] = useQueue(this.token[key]);
    });
    const boundStartTransaction = startTransaction.bind(null, this);
    this.idx = {
      interact: interact.bind(null, this),
      introspect: introspect.bind(null, this),
      makeIdxResponse: makeIdxState2.bind(null, this),
      authenticate: authenticate.bind(null, this),
      register: register.bind(null, this),
      start: boundStartTransaction,
      startTransaction: boundStartTransaction,
      poll: poll.bind(null, this),
      proceed: proceed.bind(null, this),
      cancel: cancel.bind(null, this),
      recoverPassword: recoverPassword.bind(null, this),
      handleInteractionCodeRedirect: handleInteractionCodeRedirect.bind(null, this),
      isInteractionRequired: isInteractionRequired.bind(null, this),
      isInteractionRequiredError,
      handleEmailVerifyCallback: handleEmailVerifyCallback.bind(null, this),
      isEmailVerifyCallback,
      parseEmailVerifyCallback,
      isEmailVerifyCallbackError,
      getSavedTransactionMeta: getSavedTransactionMeta.bind(null, this),
      createTransactionMeta: createTransactionMeta.bind(null, this),
      getTransactionMeta: getTransactionMeta.bind(null, this),
      saveTransactionMeta: saveTransactionMeta.bind(null, this),
      clearTransactionMeta: clearTransactionMeta.bind(null, this),
      isTransactionMetaValid,
      setFlow: (flow) => {
        this.options.flow = flow;
      },
      getFlow: () => {
        return this.options.flow;
      },
      canProceed: canProceed.bind(null, this),
      unlockAccount: unlockAccount.bind(null, this)
    };
    this.http = {
      setRequestHeader: setRequestHeader.bind(null, this)
    };
    this.fingerprint = fingerprint.bind(null, this);
    this.emitter = new import_tiny_emitter.default();
    this.tokenManager = new TokenManager(this, args.tokenManager);
    this.authStateManager = new AuthStateManager(this);
    this.serviceManager = new ServiceManager(this, args.services);
  }
  start() {
    return __async(this, null, function* () {
      yield this.serviceManager.start();
      this.tokenManager.start();
      if (!this.token.isLoginRedirect()) {
        yield this.authStateManager.updateAuthState();
      }
    });
  }
  stop() {
    return __async(this, null, function* () {
      this.tokenManager.stop();
      yield this.serviceManager.stop();
    });
  }
  setHeaders(headers) {
    this.options.headers = Object.assign({}, this.options.headers, headers);
  }
  signIn(opts) {
    return __async(this, null, function* () {
      return this.signInWithCredentials(opts);
    });
  }
  signInWithCredentials(opts) {
    return __async(this, null, function* () {
      opts = clone(opts || {});
      const _postToTransaction = (options2) => {
        delete opts.sendFingerprint;
        return postToTransaction(this, "/api/v1/authn", opts, options2);
      };
      if (!opts.sendFingerprint) {
        return _postToTransaction();
      }
      return this.fingerprint().then(function(fingerprint2) {
        return _postToTransaction({
          headers: {
            "X-Device-Fingerprint": fingerprint2
          }
        });
      });
    });
  }
  signInWithRedirect() {
    return __async(this, arguments, function* (opts = {}) {
      const { originalUri } = opts, additionalParams = __rest(opts, ["originalUri"]);
      if (this._pending.handleLogin) {
        return;
      }
      this._pending.handleLogin = true;
      try {
        if (originalUri) {
          this.setOriginalUri(originalUri);
        }
        const params = Object.assign({
          scopes: this.options.scopes || ["openid", "email", "profile"]
        }, additionalParams);
        yield this.token.getWithRedirect(params);
      } finally {
        this._pending.handleLogin = false;
      }
    });
  }
  closeSession() {
    return this.session.close().then(() => __async(this, null, function* () {
      this.tokenManager.clear();
    })).catch(function(e) {
      if (e.name === "AuthApiError" && e.errorCode === "E0000007") {
        return null;
      }
      throw e;
    });
  }
  revokeAccessToken(accessToken) {
    return __async(this, null, function* () {
      if (!accessToken) {
        accessToken = (yield this.tokenManager.getTokens()).accessToken;
        const accessTokenKey = this.tokenManager.getStorageKeyByType("accessToken");
        this.tokenManager.remove(accessTokenKey);
      }
      if (!accessToken) {
        return Promise.resolve(null);
      }
      return this.token.revoke(accessToken);
    });
  }
  revokeRefreshToken(refreshToken) {
    return __async(this, null, function* () {
      if (!refreshToken) {
        refreshToken = (yield this.tokenManager.getTokens()).refreshToken;
        const refreshTokenKey = this.tokenManager.getStorageKeyByType("refreshToken");
        this.tokenManager.remove(refreshTokenKey);
      }
      if (!refreshToken) {
        return Promise.resolve(null);
      }
      return this.token.revoke(refreshToken);
    });
  }
  getSignOutRedirectUrl(options2 = {}) {
    let { idToken, postLogoutRedirectUri, state } = options2;
    if (!idToken) {
      idToken = this.tokenManager.getTokensSync().idToken;
    }
    if (!idToken) {
      return "";
    }
    if (!postLogoutRedirectUri) {
      postLogoutRedirectUri = this.options.postLogoutRedirectUri;
    }
    const logoutUrl = getOAuthUrls(this).logoutUrl;
    const idTokenHint = idToken.idToken;
    let logoutUri = logoutUrl + "?id_token_hint=" + encodeURIComponent(idTokenHint);
    if (postLogoutRedirectUri) {
      logoutUri += "&post_logout_redirect_uri=" + encodeURIComponent(postLogoutRedirectUri);
    }
    if (state) {
      logoutUri += "&state=" + encodeURIComponent(state);
    }
    return logoutUri;
  }
  signOut(options2) {
    return __async(this, null, function* () {
      options2 = Object.assign({}, options2);
      var defaultUri = window.location.origin;
      var currentUri = window.location.href;
      var postLogoutRedirectUri = options2.postLogoutRedirectUri || this.options.postLogoutRedirectUri || defaultUri;
      var accessToken = options2.accessToken;
      var refreshToken = options2.refreshToken;
      var revokeAccessToken = options2.revokeAccessToken !== false;
      var revokeRefreshToken = options2.revokeRefreshToken !== false;
      if (revokeRefreshToken && typeof refreshToken === "undefined") {
        refreshToken = this.tokenManager.getTokensSync().refreshToken;
      }
      if (revokeAccessToken && typeof accessToken === "undefined") {
        accessToken = this.tokenManager.getTokensSync().accessToken;
      }
      if (!options2.idToken) {
        options2.idToken = this.tokenManager.getTokensSync().idToken;
      }
      if (revokeRefreshToken && refreshToken) {
        yield this.revokeRefreshToken(refreshToken);
      }
      if (revokeAccessToken && accessToken) {
        yield this.revokeAccessToken(accessToken);
      }
      const logoutUri = this.getSignOutRedirectUrl(Object.assign(Object.assign({}, options2), { postLogoutRedirectUri }));
      if (!logoutUri) {
        return this.closeSession().then(function() {
          if (postLogoutRedirectUri === currentUri) {
            window.location.reload();
          } else {
            window.location.assign(postLogoutRedirectUri);
          }
        });
      } else {
        if (options2.clearTokensBeforeRedirect) {
          this.tokenManager.clear();
        } else {
          this.tokenManager.addPendingRemoveFlags();
        }
        window.location.assign(logoutUri);
      }
    });
  }
  webfinger(opts) {
    var url = "/.well-known/webfinger" + toQueryString(opts);
    var options2 = {
      headers: {
        "Accept": "application/jrd+json"
      }
    };
    return get(this, url, options2);
  }
  isAuthenticated() {
    return __async(this, arguments, function* (options2 = {}) {
      const { autoRenew, autoRemove } = this.tokenManager.getOptions();
      const shouldRenew = options2.onExpiredToken ? options2.onExpiredToken === "renew" : autoRenew;
      const shouldRemove = options2.onExpiredToken ? options2.onExpiredToken === "remove" : autoRemove;
      let { accessToken } = this.tokenManager.getTokensSync();
      if (accessToken && this.tokenManager.hasExpired(accessToken)) {
        accessToken = void 0;
        if (shouldRenew) {
          try {
            accessToken = yield this.tokenManager.renew("accessToken");
          } catch (_a) {
          }
        } else if (shouldRemove) {
          this.tokenManager.remove("accessToken");
        }
      }
      let { idToken } = this.tokenManager.getTokensSync();
      if (idToken && this.tokenManager.hasExpired(idToken)) {
        idToken = void 0;
        if (shouldRenew) {
          try {
            idToken = yield this.tokenManager.renew("idToken");
          } catch (_b) {
          }
        } else if (shouldRemove) {
          this.tokenManager.remove("idToken");
        }
      }
      return !!(accessToken && idToken);
    });
  }
  getUser() {
    return __async(this, null, function* () {
      const { idToken, accessToken } = this.tokenManager.getTokensSync();
      return this.token.getUserInfo(accessToken, idToken);
    });
  }
  getIdToken() {
    const { idToken } = this.tokenManager.getTokensSync();
    return idToken ? idToken.idToken : void 0;
  }
  getAccessToken() {
    const { accessToken } = this.tokenManager.getTokensSync();
    return accessToken ? accessToken.accessToken : void 0;
  }
  getRefreshToken() {
    const { refreshToken } = this.tokenManager.getTokensSync();
    return refreshToken ? refreshToken.refreshToken : void 0;
  }
  storeTokensFromRedirect() {
    return __async(this, null, function* () {
      const { tokens } = yield this.token.parseFromUrl();
      this.tokenManager.setTokens(tokens);
    });
  }
  setOriginalUri(originalUri, state) {
    const sessionStorage2 = storageUtil.getSessionStorage();
    sessionStorage2.setItem(REFERRER_PATH_STORAGE_KEY, originalUri);
    state = state || this.options.state;
    if (state) {
      const sharedStorage = this.storageManager.getOriginalUriStorage();
      sharedStorage.setItem(state, originalUri);
    }
  }
  getOriginalUri(state) {
    state = state || this.options.state;
    if (state) {
      const sharedStorage = this.storageManager.getOriginalUriStorage();
      const originalUri = sharedStorage.getItem(state);
      if (originalUri) {
        return originalUri;
      }
    }
    const storage = storageUtil.getSessionStorage();
    return storage ? storage.getItem(REFERRER_PATH_STORAGE_KEY) || void 0 : void 0;
  }
  removeOriginalUri(state) {
    const storage = storageUtil.getSessionStorage();
    storage.removeItem(REFERRER_PATH_STORAGE_KEY);
    state = state || this.options.state;
    if (state) {
      const sharedStorage = this.storageManager.getOriginalUriStorage();
      sharedStorage.removeItem && sharedStorage.removeItem(state);
    }
  }
  isLoginRedirect() {
    return isLoginRedirect(this);
  }
  handleLoginRedirect(tokens, originalUri) {
    return __async(this, null, function* () {
      let state = this.options.state;
      if (tokens) {
        this.tokenManager.setTokens(tokens);
        originalUri = originalUri || this.getOriginalUri(this.options.state);
      } else if (this.isLoginRedirect()) {
        try {
          const oAuthResponse = yield parseOAuthResponseFromUrl(this, {});
          state = oAuthResponse.state;
          originalUri = originalUri || this.getOriginalUri(state);
          yield this.storeTokensFromRedirect();
        } catch (e) {
          yield this.authStateManager.updateAuthState();
          throw e;
        }
      } else {
        return;
      }
      yield this.authStateManager.updateAuthState();
      this.removeOriginalUri(state);
      const { restoreOriginalUri } = this.options;
      if (restoreOriginalUri) {
        yield restoreOriginalUri(this, originalUri);
      } else if (originalUri) {
        window.location.replace(originalUri);
      }
    });
  }
  isPKCE() {
    return !!this.options.pkce;
  }
  hasResponseType(responseType) {
    let hasResponseType = false;
    if (Array.isArray(this.options.responseType) && this.options.responseType.length) {
      hasResponseType = this.options.responseType.indexOf(responseType) >= 0;
    } else {
      hasResponseType = this.options.responseType === responseType;
    }
    return hasResponseType;
  }
  isAuthorizationCodeFlow() {
    return this.hasResponseType("code");
  }
  getIssuerOrigin() {
    return this.options.issuer.split("/oauth2/")[0];
  }
  forgotPassword(opts) {
    return postToTransaction(this, "/api/v1/authn/recovery/password", opts);
  }
  unlockAccount(opts) {
    return postToTransaction(this, "/api/v1/authn/recovery/unlock", opts);
  }
  verifyRecoveryToken(opts) {
    return postToTransaction(this, "/api/v1/authn/recovery/token", opts);
  }
  invokeApiMethod(options2) {
    return __async(this, null, function* () {
      if (!options2.accessToken) {
        const accessToken = (yield this.tokenManager.getTokens()).accessToken;
        options2.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;
      }
      return httpRequest(this, options2);
    });
  }
};
OktaAuth.features = features_exports;
OktaAuth.crypto = crypto_exports;
OktaAuth.webauthn = webauthn_exports;
OktaAuth.features = OktaAuth.prototype.features = features_exports;
Object.assign(OktaAuth, {
  constants: constants_exports
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/widget/getAuthClient.js
function getAuthClient(options2 = {}) {
  let {
    authClient,
    authParams
  } = options2;
  if (!authClient) {
    const {
      issuer,
      clientId,
      redirectUri,
      state,
      scopes,
      flow,
      codeChallenge,
      codeChallengeMethod,
      recoveryToken
    } = options2;
    authParams = __spreadValues({
      issuer,
      clientId,
      redirectUri,
      state,
      scopes,
      flow,
      codeChallenge,
      codeChallengeMethod,
      transformErrorXHR: Util2.transformErrorXHR,
      recoveryToken
    }, authParams);
    if (!authParams.issuer) {
      authParams.issuer = options2.baseUrl + "/oauth2/default";
    }
    authClient = new OktaAuth(authParams);
  }
  if (!authClient._oktaUserAgent)
    ;
  else {
    authClient._oktaUserAgent.addEnvironment(`okta-signin-widget-${config.version}`);
  }
  return authClient;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/OAuthErrors.js
var InlineErrorType = class {
  constructor() {
    this.inline = true;
  }
};
var TerminalErrorType = class {
  constructor() {
    this.terminal = true;
  }
};
var TypedOAuthError = class extends OAuthError {
  constructor(originalError, errorTypeCtor) {
    super(originalError.message);
    this.errorType = void 0;
    this.orginalError = void 0;
    this.errorDetails = void 0;
    this.errorType = new errorTypeCtor();
    this.orginalError = originalError;
    this.errorDetails = {
      errorSummary: this.getErrorSummary(),
      errorCode: originalError.errorCode,
      errorCauses: originalError.errorCauses
    };
  }
  getErrorSummary() {
    return this.orginalError.errorSummary;
  }
  is(errorTrait) {
    var _Object$getOwnPropert;
    return Boolean((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(this.errorType, errorTrait)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.value);
  }
};
var RecoverableError = class extends TypedOAuthError {
};
var NonRecoverableError = class extends TypedOAuthError {
};
var ClockDriftError = class extends RecoverableError {
  constructor(error) {
    super(error, TerminalErrorType);
  }
  getErrorSummary() {
    return loc3("error.unsynced.clock", "login");
  }
};
var UserNotAssignedError = class extends RecoverableError {
  constructor(error) {
    super(error, InlineErrorType);
  }
};
var JITProfileProvisioningError = class extends RecoverableError {
  constructor(error) {
    super(error, InlineErrorType);
  }
  getErrorSummary() {
    return loc3("error.jit_failure", "login");
  }
};
var MfaRequiredError = class extends NonRecoverableError {
  constructor(error) {
    super(error, InlineErrorType);
  }
  getErrorSummary() {
    return loc3("error.mfa.required", "login");
  }
};
function getTypedOAuthError(error) {
  switch (error.errorCode) {
    case "access_denied":
      return new UserNotAssignedError(error);
    case "jit_failure_missing_fields":
    case "jit_failure_invalid_login_format":
    case "jit_failure_values_not_match_pattern":
    case "jit_failure_values_too_long":
    case "jit_failure_invalid_locale":
      return new JITProfileProvisioningError(error);
    case "login_required":
      const mfaRequiredMsg = "The client specified not to prompt, but the client app requires re-authentication or MFA.";
      if (error.message === mfaRequiredMsg) {
        return new MfaRequiredError(error);
      }
    case "INTERNAL":
      const clockDriftMsg = "The JWT was issued in the future";
      if (error.message === clockDriftMsg) {
        return new ClockDriftError(error);
      }
    default:
      return new RecoverableError(error, Object);
  }
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/OAuth2Util.js
var util = {};
var AUTH_PARAMS = ["responseType", "scopes", "state", "nonce", "idp", "idpScope", "display", "prompt", "maxAge", "loginHint"];
util.AUTH_PARAMS = AUTH_PARAMS;
util.getTokens = function(settings, params, controller) {
  function success(result) {
    settings.callGlobalSuccess(Enums.SUCCESS, result);
  }
  function error(error2) {
    const typedError = getTypedOAuthError(error2);
    if (typedError.is("terminal")) {
      controller.model.appState.set("flashError", typedError);
      controller.model.appState.trigger("navigate", "signin/error");
    } else if (typedError.is("inline")) {
      controller.model.trigger("error", controller.model, {
        responseJSON: {
          errorSummary: typedError.errorDetails.errorSummary
        }
      });
      controller.model.appState.trigger("removeLoading");
    }
    if (!typedError.is("terminal")) {
      Util2.triggerAfterError(controller, typedError, settings);
    }
    if (typedError instanceof NonRecoverableError) {
      settings.callGlobalError(typedError);
    }
  }
  const authClient = settings.getAuthClient();
  const isAuthorizationCodeFlow = authClient.isAuthorizationCodeFlow() && !authClient.isPKCE();
  const options2 = settings.toJSON({
    verbose: true
  });
  const getTokenOptions = {};
  oktaUnderscore.extend(getTokenOptions, oktaUnderscore.pick(options2, "clientId", "redirectUri"), oktaUnderscore.pick(options2.authParams, AUTH_PARAMS), params);
  getTokenOptions.popupTitle = loc3("socialauth.popup.title", "login");
  getTokenOptions.timeout = options2.oAuthTimeout;
  if (options2.redirect === "always" || isAuthorizationCodeFlow) {
    authClient.token.getWithRedirect(getTokenOptions).catch(error);
  } else if (getTokenOptions.sessionToken) {
    authClient.token.getWithoutPrompt(getTokenOptions).then(success).catch(error);
  } else {
    authClient.token.getWithPopup(getTokenOptions).then(success).catch(error);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/widget/buildRenderOptions.js
function buildRenderOptions(widgetOptions = {}, options2 = {}) {
  const authParams = oktaJQueryStatic.extend(true, {}, widgetOptions.authParams, oktaUnderscore.pick(options2, util.AUTH_PARAMS));
  const {
    el,
    clientId,
    redirectUri
  } = Object.assign({}, widgetOptions, options2);
  const renderOptions = Object.assign({}, {
    el,
    clientId,
    redirectUri,
    authParams
  });
  if (!renderOptions.el) {
    throw new ConfigError('"el" is required');
  }
  if (!renderOptions.clientId) {
    throw new ConfigError('"clientId" is required');
  }
  if (!renderOptions.redirectUri) {
    throw new ConfigError('"redirectUri" is required');
  }
  return renderOptions;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/widget/createRouter.js
function createRouter(Router2, widgetOptions, renderOptions, authClient, successFn, errorFn, hooks) {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  const routerOptions = oktaJQueryStatic.extend(true, {}, widgetOptions, renderOptions, {
    authClient,
    hooks,
    globalSuccessFn: (res) => {
      successFn && successFn(res);
      if (res && res.status === Enums.SUCCESS) {
        resolve(res);
      }
    },
    globalErrorFn: (error) => {
      errorFn && errorFn(error);
      reject(error);
    }
  });
  const router = new Router2(routerOptions);
  router.start();
  return {
    router,
    routerOptions,
    promise
  };
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/BaseLoginModel.js
var import_q2 = __toESM(require_q());
var KNOWN_ERRORS = ["OAuthError", "AuthSdkError", "AuthPollStopError", "AuthApiError"];
var BaseLoginModel = Model2.extend({
  // May return either a "standard" promise or a Q promise
  doTransaction: function(fn11, rethrow) {
    const self2 = this;
    return fn11.call(this, this.appState.get("transaction")).then(function(trans) {
      self2.trigger("setTransaction", trans);
      return trans;
    }).catch(function(err) {
      if (err.name === "AuthPollStopError" || err.name === Enums.AUTH_STOP_POLL_INITIATION_ERROR || err.name === Enums.WEBAUTHN_ABORT_ERROR) {
        return;
      }
      self2.trigger("error", self2, err.xhr);
      self2.trigger("setTransactionError", err);
      if (rethrow || oktaUnderscore.indexOf(KNOWN_ERRORS, err.name) === -1) {
        throw err;
      }
    });
  },
  manageTransaction: function(fn11) {
    const self2 = this;
    const res = fn11.call(this, this.appState.get("transaction"), oktaUnderscore.bind(this.setTransaction, this));
    if (import_q2.default.isPromiseAlike(res)) {
      return res.catch(function(err) {
        if (err.name === "AuthPollStopError" || err.name === Enums.AUTH_STOP_POLL_INITIATION_ERROR || err.name === Enums.WEBAUTHN_ABORT_ERROR) {
          return;
        }
        self2.trigger("error", self2, err.xhr);
        self2.trigger("setTransactionError", err);
      });
    }
    return import_q2.default.resolve(res);
  },
  startTransaction: function(fn11) {
    const self2 = this;
    const res = fn11.call(this, this.settings.getAuthClient());
    if (import_q2.default.isPromiseAlike(res)) {
      return res.then(function(trans) {
        self2.trigger("setTransaction", trans);
        return trans;
      }).catch(function(err) {
        self2.trigger("error", self2, err.xhr);
        self2.trigger("setTransactionError", err);
        throw err;
      });
    }
    return import_q2.default.resolve(res);
  },
  setTransaction: function(trans) {
    this.appState.set("transaction", trans);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/BaseLoginController.js
var import_q3 = __toESM(require_q());
function getForm(controller) {
  return oktaUnderscore.find(controller.getChildren(), function(item) {
    return item instanceof Form;
  });
}
var BaseLoginController = Controller.extend({
  // Ideally we should be attaching the listeners in the constructor, but because of the way
  // we construct the FormController (this.model is generated after the BaseLoginController's
  // constructor is called), this.model is undefined in when try to attach the events and
  // therefore we don't listen to events for such forms. And changing the order in which we call
  // the constructor doesn't help either (JS errors etc.). This at least guarantees that we
  // are listening to the model events.
  // Note - Figure out a way to call the constructor in the right order.
  addListeners: function() {
    this.listenTo(this.model, "save", function() {
      const form2 = getForm(this);
      const disableSubmitButton = form2.disableSubmitButton;
      if (disableSubmitButton && !form2.disableSubmitButton()) {
        return;
      }
      this.toggleButtonState(true);
    });
    this.listenTo(this.model, "error", function() {
      this.toggleButtonState(false);
    });
    this.addModelListeners(this.model);
  },
  addModelListeners: function(model) {
    const setTransactionHandler = (transaction) => {
      this.options.appState.set("transaction", transaction);
    };
    const transactionErrorHandler = (err) => {
      this.options.appState.set("transactionError", err);
    };
    this.listenTo(model, "setTransaction", setTransactionHandler);
    this.listenTo(model, "setTransactionError", transactionErrorHandler);
    const totpModel = model.get("backupFactor");
    if (totpModel) {
      this.listenTo(totpModel, "setTransaction", setTransactionHandler);
      this.listenTo(totpModel, "setTransactionError", transactionErrorHandler);
    }
  },
  // Override this method to delay switching to this screen until return
  // promise is resolved. This is useful for cases like enrolling a security
  // question, which requires an additional request to fetch the question
  // list.
  fetchInitialData: function() {
    return (0, import_q3.default)();
  },
  // Override this method to prevent route navigation. This is useful for
  // intermediate status changes that do not trigger a full refresh of the
  // page, like MFA_ENROLL_ACTIVATE and MFA_CHALLENGE.
  trapAuthResponse: function() {
    return false;
  },
  toJSON: function() {
    const data = Controller.prototype.toJSON.apply(this, arguments);
    return oktaUnderscore.extend(oktaUnderscore.pick(this.options, "appState"), data);
  },
  toggleButtonState: function(state) {
    const button = this.$el.find(".button");
    button.toggleClass("link-button-disabled", state).prop("disabled", state);
  },
  postRenderAnimation: function() {
    this.trigger("pageRendered", {
      page: this.className
    });
    this.trigger("afterRender", {
      controller: this.className
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/FormType.js
var INPUT = "INPUT";
var BUTTON = "BUTTON";
var DIVIDER = "DIVIDER";
var TOOLBAR = "TOOLBAR";
var VIEW = "VIEW";
function wrap(type) {
  return function(viewOptions, addOptions) {
    return {
      type,
      viewOptions,
      addOptions
    };
  };
}
var FormType = {
  Input: wrap(INPUT),
  Button: wrap(BUTTON),
  Divider: wrap(DIVIDER),
  Toolbar: wrap(TOOLBAR),
  View: wrap(VIEW),
  INPUT,
  BUTTON,
  DIVIDER,
  TOOLBAR,
  VIEW
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/FormController.js
var {
  Toolbar: Toolbar2
} = internal.views.forms.components;
var {
  FormUtil: FormUtil2
} = internal.views.forms.helpers;
var FormControllerSimpleForm = Form.extend({
  layout: "o-form-theme",
  noCancelButton: true,
  constructor: function(options2) {
    Form.call(this, options2);
    oktaUnderscore.each(oktaUnderscore.result(this, "formChildren") || [], function(child) {
      switch (child.type) {
        case FormType.INPUT:
          this.addInput(oktaUnderscore.extend({
            label: false,
            "label-top": true
          }, child.viewOptions));
          break;
        case FormType.BUTTON:
          this.add(createButton2(oktaUnderscore.extend({
            model: this.model
          }, child.viewOptions)), child.addOptions);
          FormUtil2.applyShowWhen(this.last(), child.viewOptions && child.viewOptions.showWhen);
          break;
        case FormType.DIVIDER:
          this.addDivider(child.viewOptions);
          break;
        case FormType.TOOLBAR:
          this.add(Toolbar2, {
            options: child.viewOptions
          });
          FormUtil2.applyShowWhen(this.last(), child.viewOptions && child.viewOptions.showWhen);
          break;
        case FormType.VIEW:
          this.add(child.viewOptions.View, child.addOptions);
          FormUtil2.applyShowWhen(this.last(), child.viewOptions.showWhen);
          break;
        default:
          throw new Error("Unrecognized child type: " + child.type);
      }
    }, this);
  }
});
var FormController = BaseLoginController.extend({
  constructor: function() {
    const initialize2 = this.initialize;
    this.initialize = function() {
    };
    BaseLoginController.apply(this, arguments);
    if (this.Model && this.Form) {
      const Model5 = BaseLoginModel.extend(oktaUnderscore.extend({
        parse: function(attributes2) {
          this.settings = attributes2.settings;
          this.appState = attributes2.appState;
          return oktaUnderscore.omit(attributes2, ["settings", "appState"]);
        }
      }, oktaUnderscore.result(this, "Model")));
      this.model = new Model5({
        settings: this.settings,
        appState: this.options.appState
      }, {
        parse: true
      });
      const Form4 = FormControllerSimpleForm.extend(oktaUnderscore.result(this, "Form", this));
      this.form = new Form4(this.toJSON());
      this.add(this.form);
    }
    if (this.Footer) {
      this.addFooter(this.Footer);
    }
    this.addListeners();
    initialize2.apply(this, arguments);
  },
  addFooter: function(Footer13, args) {
    this.footer = new Footer13(oktaUnderscore.extend(this.toJSON(), args || {}));
    this.add(this.footer);
  },
  toJSON: function() {
    const data = BaseLoginController.prototype.toJSON.apply(this, arguments);
    return oktaUnderscore.extend(oktaUnderscore.pick(this.options, "appState"), data);
  },
  back: function() {
    if (this.footer && this.footer.back) {
      this.footer.back();
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/AccountUnlockedController.js
var AccountUnlockedController = FormController.extend({
  className: "account-unlocked",
  Model: function() {
    return {
      local: {
        userFullName: ["string", false, this.options.appState.get("userFullName")]
      }
    };
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "account.unlock.unlocked.title", "login"),
    subtitle: oktaUnderscore.partial(loc3, "account.unlock.unlocked.desc", "login"),
    noButtonBar: true,
    attributes: {
      "data-se": "account-unlocked"
    },
    formChildren: function() {
      return [FormType.Button({
        title: loc3("goback", "login"),
        className: "button button-primary button-wide",
        attributes: {
          "data-se": "back-button"
        },
        click: function() {
          this.state.set("navigateDir", Enums.DIRECTION_BACK);
          this.options.appState.trigger("navigate", "");
        }
      })];
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/TimeUtil.js
var import_to_milliseconds = __toESM(require_to_milliseconds());
var import_parse_ms = __toESM(require_parse_ms());
var MOMENT_UNIT = {
  MILLISECOND: "milliseconds",
  SECOND: "seconds",
  MINUTE: "minutes",
  HOUR: "hours",
  DAY: "days"
};
var MOMENT_UNIT_KEYS = Object.keys(MOMENT_UNIT);
var convertMomentUnits = function(momentUnit) {
  const entry = MOMENT_UNIT_KEYS.filter((k) => MOMENT_UNIT[k] === momentUnit);
  return entry.length === 1 ? entry[0] : momentUnit;
};
var TimeUtil = {
  /**
   * @method getTimeInHighestRelevantUnit
   * Will return a number in the units of the highest relevant time unit.
   * Only checks milliseconds, seconds, minutes, hours, and days.
   * E.g.
   *   15 MINUTE  -> 15 MINUTE
   *   15 minutes -> 15 MINUTE
   *   60 minutes ->  1 HOUR
   *   90 minutes -> 90 MINUTE
   *   24 HOUR    ->  1 DAY
   *   24 hours   ->  1 DAY
   *   30 DAY     -> 30 DAY
   *
   * @typedef { "MILLISECOND" | "SECOND" | "MINUTE" | "HOUR" | "DAY" } TimeUnit
   *
   * @typedef { "MILLISECOND" | "SECOND" | "MINUTE" | "HOUR" | "DAY" |
   *            "milliseconds" | "seconds" | "minutes" | "hours" | "days"
   *          } FlexibleTimeUnit
   *
   * @typedef TimeAndUnit
   * @property {number} time the consolidated time
   * @property {TimeUnit} unit the unit of the time
   *
   * @param {FlexibleTimeUnit} unit The time unit
   * @return {TimeAndUnit} An object containing the amount of time and the unit
   */
  getTimeInHighestRelevantUnit: function(val, unit) {
    const defaultTimeObj = {
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    };
    const normalizedUnit = MOMENT_UNIT[unit] || unit;
    let timeObj;
    try {
      const ms = (0, import_to_milliseconds.default)(Object.assign(defaultTimeObj, {
        [normalizedUnit]: val
      }));
      timeObj = (0, import_parse_ms.default)(ms);
    } catch (error) {
      timeObj = {};
    }
    const duration = Object.keys(timeObj).reduce((init, k) => {
      if (timeObj[k] !== 0) {
        init[k] = timeObj[k];
      }
      return init;
    }, {});
    let highestUnit;
    let time;
    if (Object.keys(duration).length === 1) {
      Object.keys(duration).forEach((k) => {
        time = duration[k];
        highestUnit = k;
      });
    } else {
      time = val;
      highestUnit = normalizedUnit;
    }
    return {
      time,
      unit: convertMomentUnits(highestUnit)
    };
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/FactorUtil.js
var fn2 = {};
var factorData = {
  OKTA_VERIFY: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.totpSoft.oktaVerify",
    description: "factor.totpSoft.description",
    iconClassName: "mfa-okta-verify",
    sortOrder: 1
  },
  OKTA_VERIFY_PUSH: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.oktaVerifyPush",
    description: "factor.push.description",
    iconClassName: "mfa-okta-verify",
    sortOrder: 1
  },
  U2F: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.u2f",
    description: (brandName) => {
      return brandName ? "factor.u2f.description.specific" : "factor.u2f.description.generic";
    },
    iconClassName: "mfa-u2f",
    sortOrder: 2
  },
  WEBAUTHN: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.webauthn.biometric",
    description: "factor.webauthn.biometric.description",
    iconClassName: "mfa-webauthn",
    sortOrder: 2
  },
  WINDOWS_HELLO: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.windowsHello",
    description: (brandName) => {
      return brandName ? "factor.windowsHello.signin.description.specific" : "factor.windowsHello.signin.description.generic";
    },
    iconClassName: "mfa-windows-hello",
    sortOrder: 3
  },
  YUBIKEY: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.totpHard.yubikey",
    description: "factor.totpHard.yubikey.description",
    iconClassName: "mfa-yubikey",
    sortOrder: 4
  },
  GOOGLE_AUTH: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.totpSoft.googleAuthenticator",
    description: "factor.totpSoft.description",
    iconClassName: "mfa-google-auth",
    sortOrder: 5
  },
  CUSTOM_HOTP: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "",
    description: "factor.hotp.description",
    iconClassName: "mfa-hotp",
    sortOrder: 6
  },
  SMS: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.sms",
    description: "factor.sms.description",
    iconClassName: "mfa-okta-sms",
    sortOrder: 7
  },
  CALL: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.call",
    description: "factor.call.description",
    iconClassName: "mfa-okta-call",
    sortOrder: 8
  },
  EMAIL: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.email",
    description: "factor.email.description",
    iconClassName: "mfa-okta-email",
    sortOrder: 9
  },
  QUESTION: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.securityQuestion",
    description: "factor.securityQuestion.description",
    iconClassName: "mfa-okta-security-question",
    sortOrder: 10
  },
  DUO: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.duo",
    description: "factor.duo.description",
    iconClassName: "mfa-duo",
    sortOrder: 11
  },
  SYMANTEC_VIP: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.totpHard.symantecVip",
    description: "factor.totpHard.description",
    iconClassName: "mfa-symantec",
    sortOrder: 12
  },
  RSA_SECURID: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.totpHard.rsaSecurId",
    description: "factor.totpHard.description",
    iconClassName: "mfa-rsa",
    sortOrder: 13
  },
  ON_PREM: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "",
    description: "factor.totpHard.description",
    iconClassName: "mfa-onprem",
    sortOrder: 14
  },
  PASSWORD: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "factor.password",
    description: "",
    iconClassName: "mfa-okta-password",
    sortOrder: 15
  },
  CUSTOM_CLAIMS: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "",
    description: "factor.customFactor.description",
    iconClassName: "mfa-custom-factor",
    sortOrder: 16
  },
  GENERIC_SAML: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "",
    description: (brandName) => {
      return brandName ? "factor.customFactor.description.specific" : "factor.customFactor.description.generic";
    },
    iconClassName: "mfa-custom-factor",
    sortOrder: 17
  },
  GENERIC_OIDC: {
    /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
    label: "",
    description: (brandName) => {
      return brandName ? "factor.customFactor.description.specific" : "factor.customFactor.description.generic";
    },
    iconClassName: "mfa-custom-factor",
    sortOrder: 18
  }
};
var getPasswordComplexityRequirementsAsArray = function(policy, i18nKeys) {
  const setExcludeAttributes = function(policyComplexity) {
    const excludeAttributes = policyComplexity.excludeAttributes;
    policyComplexity.excludeFirstName = oktaUnderscore.contains(excludeAttributes, "firstName");
    policyComplexity.excludeLastName = oktaUnderscore.contains(excludeAttributes, "lastName");
    return oktaUnderscore.omit(policyComplexity, "excludeAttributes");
  };
  if (policy.complexity) {
    const complexityFields = i18nKeys.complexity;
    const policyComplexity = setExcludeAttributes(policy.complexity);
    const requirements = oktaUnderscore.map(policyComplexity, function(complexityValue, complexityType) {
      if (complexityValue <= 0) {
        return;
      }
      const params = complexityFields[complexityType];
      return params.args ? loc3(params.i18n, "login", [complexityValue]) : loc3(params.i18n, "login");
    });
    return oktaUnderscore.compact(requirements);
  }
  return [];
};
var getPasswordHistoryRequirementDescription = function(policy, i18nKeys) {
  if (policy.age && policy.age.historyCount > 0) {
    return loc3(i18nKeys.history.i18n, "login", [policy.age.historyCount]);
  }
  return null;
};
var getPasswordAgeRequirementDescription = function(policy, i18nKeys) {
  const getPasswordAgeRequirement = function(displayableTime) {
    let propertiesString;
    switch (displayableTime.unit) {
      case "DAY":
        propertiesString = i18nKeys.age.days.i18n;
        break;
      case "HOUR":
        propertiesString = i18nKeys.age.hours.i18n;
        break;
      case "MINUTE":
        propertiesString = i18nKeys.age.minutes.i18n;
    }
    return loc3(propertiesString, "login", [displayableTime.time]);
  };
  if (policy.age && policy.age.minAgeMinutes > 0) {
    const displayableTime = TimeUtil.getTimeInHighestRelevantUnit(policy.age.minAgeMinutes, "MINUTE");
    return getPasswordAgeRequirement(displayableTime);
  }
  return null;
};
var getPasswordRequirements = function(policy, i18nKeys) {
  const passwordRequirements = {
    complexity: [],
    history: [],
    age: []
  };
  passwordRequirements.complexity = getPasswordComplexityRequirementsAsArray(policy, i18nKeys);
  const historyRequirement = getPasswordHistoryRequirementDescription(policy, i18nKeys);
  if (historyRequirement) {
    passwordRequirements.history.push(historyRequirement);
  }
  const ageRequirement = getPasswordAgeRequirementDescription(policy, i18nKeys);
  if (ageRequirement) {
    passwordRequirements.age.push(ageRequirement);
  }
  return passwordRequirements;
};
fn2.getFactorName = function(provider, factorType) {
  if (provider === "OKTA" && factorType === "token:software:totp") {
    return "OKTA_VERIFY";
  }
  if (provider === "OKTA" && factorType === "push") {
    return "OKTA_VERIFY_PUSH";
  }
  if (provider === "GOOGLE") {
    return "GOOGLE_AUTH";
  }
  if (provider === "SYMANTEC" && factorType === "token") {
    return "SYMANTEC_VIP";
  }
  if (provider === "RSA" && factorType === "token") {
    return "RSA_SECURID";
  }
  if (provider === "DEL_OATH" && factorType === "token") {
    return "ON_PREM";
  }
  if (provider === "DUO" && factorType === "web") {
    return "DUO";
  }
  if (provider === "YUBICO" && factorType === "token:hardware") {
    return "YUBIKEY";
  }
  if (provider === "OKTA" && factorType === "sms") {
    return "SMS";
  }
  if (provider === "OKTA" && factorType === "call") {
    return "CALL";
  }
  if (provider === "OKTA" && factorType === "question") {
    return "QUESTION";
  }
  if (provider === "OKTA" && factorType === "email") {
    return "EMAIL";
  }
  if (provider === "OKTA" && factorType === "password") {
    return "PASSWORD";
  }
  if (provider === "GENERIC_SAML" && factorType === "assertion:saml2") {
    return "GENERIC_SAML";
  }
  if (provider === "GENERIC_OIDC" && factorType === "assertion:oidc") {
    return "GENERIC_OIDC";
  }
  return fn2.getFactorNameForFactorType.call(this, factorType);
};
fn2.getFactorNameForFactorType = function(factorType) {
  if (factorType === "u2f") {
    return "U2F";
  }
  if (factorType === "token:software:totp") {
    return "OKTA_VERIFY";
  }
  if (factorType === "webauthn") {
    if (this.settings.get("features.webauthn")) {
      return "WEBAUTHN";
    } else {
      return "WINDOWS_HELLO";
    }
  }
  if (factorType === "token:hotp") {
    return "CUSTOM_HOTP";
  }
  if (factorType === "claims_provider") {
    return "CUSTOM_CLAIMS";
  }
};
fn2.isOktaVerify = function(provider, factorType) {
  return provider === "OKTA" && (factorType === "token:software:totp" || factorType === "push");
};
fn2.getFactorLabel = function(provider, factorType) {
  const key = factorData[fn2.getFactorName.apply(this, [provider, factorType])].label;
  return loc3(key, "login");
};
fn2.getFactorDescription = function(provider, factorType) {
  const descriptionKey = factorData[fn2.getFactorName.apply(this, [provider, factorType])].description;
  if (oktaUnderscore.isFunction(descriptionKey)) {
    const brandName = this.settings.get("brandName");
    const key = descriptionKey(brandName);
    return brandName ? loc3(key, "login", [brandName]) : loc3(key, "login");
  } else {
    return loc3(descriptionKey, "login");
  }
};
fn2.getFactorIconClassName = function(provider, factorType) {
  return factorData[fn2.getFactorName.apply(this, [provider, factorType])].iconClassName;
};
fn2.getFactorSortOrder = function(provider, factorType) {
  return factorData[fn2.getFactorName.apply(this, [provider, factorType])].sortOrder;
};
fn2.getRememberDeviceValue = function(appState) {
  return appState && appState.get("rememberDeviceByDefault");
};
fn2.getSecurityQuestionLabel = function(questionObj) {
  const localizedQuestion = loc3("security." + questionObj.question);
  return localizedQuestion.indexOf("L10N_ERROR") < 0 ? localizedQuestion : questionObj.questionText;
};
fn2.removeRequirementsFromError = function(responseJSON, policy) {
  const passwordRequirementsAsString = this.getPasswordComplexityDescription(policy);
  if (responseJSON.errorCauses && responseJSON.errorCauses.length > 0 && oktaUnderscore.isString(responseJSON.errorCauses[0].errorSummary)) {
    responseJSON.errorCauses[0].errorSummary = responseJSON.errorCauses[0].errorSummary.replace(passwordRequirementsAsString, "").trim();
  }
  return responseJSON;
};
fn2.getPasswordComplexityDescriptionForHtmlList = function(policy) {
  const passwordRequirementHtmlI18nKeys = {
    complexity: {
      minLength: {
        i18n: "password.complexity.length.description",
        args: true
      },
      minLowerCase: {
        i18n: "password.complexity.lowercase.description"
      },
      minUpperCase: {
        i18n: "password.complexity.uppercase.description"
      },
      minNumber: {
        i18n: "password.complexity.number.description"
      },
      minSymbol: {
        i18n: "password.complexity.symbol.description"
      },
      excludeUsername: {
        i18n: "password.complexity.no_username.description"
      },
      excludeFirstName: {
        i18n: "password.complexity.no_first_name.description"
      },
      excludeLastName: {
        i18n: "password.complexity.no_last_name.description"
      }
    },
    history: {
      i18n: "password.complexity.history.description"
    },
    age: {
      minutes: {
        i18n: "password.complexity.minAgeMinutes.description"
      },
      hours: {
        i18n: "password.complexity.minAgeHours.description"
      },
      days: {
        i18n: "password.complexity.minAgeDays.description"
      }
    }
  };
  const passwordRequirements = getPasswordRequirements(policy, passwordRequirementHtmlI18nKeys);
  return oktaUnderscore.union(passwordRequirements.complexity, passwordRequirements.history, passwordRequirements.age);
};
fn2.getPasswordComplexityDescription = function(policy) {
  const passwordRequirementI18nKeys = {
    complexity: {
      minLength: {
        i18n: "password.complexity.length",
        args: true
      },
      minLowerCase: {
        i18n: "password.complexity.lowercase"
      },
      minUpperCase: {
        i18n: "password.complexity.uppercase"
      },
      minNumber: {
        i18n: "password.complexity.number"
      },
      minSymbol: {
        i18n: "password.complexity.symbol"
      },
      excludeUsername: {
        i18n: "password.complexity.no_username"
      },
      excludeFirstName: {
        i18n: "password.complexity.no_first_name"
      },
      excludeLastName: {
        i18n: "password.complexity.no_last_name"
      }
    },
    history: {
      i18n: "password.complexity.history"
    },
    age: {
      minutes: {
        i18n: "password.complexity.minAgeMinutes"
      },
      hours: {
        i18n: "password.complexity.minAgeHours"
      },
      days: {
        i18n: "password.complexity.minAgeDays"
      }
    }
  };
  const result = [];
  const passwordRequirements = getPasswordRequirements(policy, passwordRequirementI18nKeys);
  let requirements = passwordRequirements.complexity;
  if (requirements.length > 0) {
    requirements = oktaUnderscore.reduce(requirements, function(result2, requirement) {
      return result2 ? result2 + loc3("password.complexity.list.element", "login", [requirement]) : requirement;
    });
    result.push(loc3("password.complexity.requirements", "login", [requirements]));
  }
  result.push(passwordRequirements.history[0]);
  result.push(passwordRequirements.age[0]);
  return oktaUnderscore.compact(result).join(" ");
};
fn2.getCardinalityText = function(enrolled, required, cardinality) {
  if (cardinality) {
    if (enrolled) {
      return cardinality.enrolled === 1 ? "" : loc3("enroll.choices.cardinality.setup", "login", [cardinality.enrolled]);
    } else if (required && cardinality.maximum > 1) {
      return loc3("enroll.choices.cardinality.setup.remaining", "login", [cardinality.enrolled, cardinality.minimum]);
    }
  }
  return "";
};
fn2.findFactorInFactorsArray = function(factors, provider, factorType) {
  let factor = factors.findWhere({
    provider,
    factorType
  });
  if (factor === void 0) {
    factor = factors.findWhere({
      factorType
    });
  }
  return factor;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/TextBox.js
var {
  TextBox: TextBox2
} = internal.views.forms.inputs;
var TextBox$1 = TextBox2.extend({
  postRender: function() {
    if (this.options.type === "number") {
      const input = this.$("input");
      input.attr({
        pattern: "[0-9]*",
        inputmode: "numeric"
      });
    }
    TextBox2.prototype.postRender.apply(this, arguments);
  },
  // Override the focus() to ignore focus in IE. IE (8-11) has a known bug where
  // the placeholder text disappears when the input field is focused.
  focus: function() {
    if (fn.isIE()) {
      return;
    }
    return TextBox2.prototype.focus.apply(this, arguments);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/EnterPasscodeForm.js
var form = {
  title: function() {
    const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
    return loc3("enroll.totp.title", "login", [factorName]);
  },
  subtitle: oktaUnderscore.partial(loc3, "enroll.totp.enterCode", "login"),
  autoSave: true,
  noButtonBar: true,
  attributes: {
    "data-se": "step-sendcode"
  },
  formChildren: function() {
    return [FormType.Input({
      label: loc3("mfa.challenge.enterCode.placeholder", "login"),
      "label-top": true,
      explain: Util2.createInputExplain("mfa.challenge.enterCode.tooltip", "mfa.challenge.enterCode.placeholder", "login"),
      "explain-top": true,
      name: "passCode",
      input: TextBox$1,
      type: "tel"
    }), FormType.Toolbar({
      noCancelButton: true,
      save: loc3("oform.verify", "login")
      // TODO: deprecated by mfa.challenge.verify
    })];
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/Footer.js
var Footer = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.backToFactors"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 106
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.options.appState.trigger("backToFactors");
      this.back();
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    if (this.options.appState.get("prevLink")) {
      this.model.doTransaction(function(transaction) {
        return transaction.prev();
      });
    } else {
      this.options.appState.trigger("navigate", "signin/enroll");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ActivateTotpController.js
var ActivateTotpController = FormController.extend({
  className: "activate-totp",
  Model: function() {
    return {
      props: {
        factorId: ["string", true, this.options.appState.get("activatedFactorId")],
        passCode: ["string", true]
      },
      local: {
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      },
      save: function() {
        return this.doTransaction(function(transaction) {
          return transaction.activate({
            passCode: this.get("passCode")
          });
        });
      }
    };
  },
  Form: form,
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/admin-consent/ScopeItem.js
var ScopeItem = View2.extend({
  className: "scope-item",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      return '<span class="scope-item-tooltip icon form-help-16" />';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="scope-item-text no-translate">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 48
          }
        }
      }) : helper)) + "</p>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "description") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 52
          },
          "end": {
            "line": 1,
            "column": 131
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  postRender: function() {
    this.$(".scope-item-tooltip").qtip({
      content: {
        text: oktaUnderscore.escape(this.options.description)
      },
      style: {
        classes: "okta-tooltip qtip-custom qtip-shadow"
      },
      position: {
        my: "bottom left",
        target: "mouse"
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/admin-consent/ScopeList.js
var SCOPE_N_GROUP_CONFIG = {
  groups: "user",
  myAccount: "user",
  users: "user",
  apps: "resource",
  authenticators: "resource",
  authorizationServers: "resource",
  clients: "resource",
  domains: "resource",
  factors: "resource",
  idps: "resource",
  linkedObjects: "resource",
  policies: "resource",
  templates: "resource",
  eventHooks: "hook",
  inlineHooks: "hook",
  events: "system",
  logs: "system",
  orgs: "system",
  roles: "system",
  schemas: "system",
  sessions: "system",
  trustedOrigins: "system"
};
var DEFAULT_GROUP = "system";
var findScopeGroupKey = ({
  name = ""
}) => {
  const xs = name.split(".");
  const groupType = xs[1];
  return SCOPE_N_GROUP_CONFIG[groupType] || DEFAULT_GROUP;
};
var ScopeGroupHeaderView = View2.extend({
  className: "scope-group",
  events: {
    "click": "expandScopes"
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="scope-group--header"><h3>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "groupName") || (depth0 != null ? lookupProperty(depth0, "groupName") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "groupName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 37
          },
          "end": {
            "line": 1,
            "column": 50
          }
        }
      }) : helper)) + '</h3><span class="scope-group--toggle"><svg class="caret" width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path class="path" fill-rule="evenodd" clip-rule="evenodd" d="M5.99967 4.66663L10.2663 8.66663L11.333 7.66663L5.99967 2.66663L0.666342 7.73636L1.73301 8.66663L5.99967 4.66663Z" fill="#A0A7AC"></path></svg></span></div>';
    },
    "useData": true
  }),
  expandScopes: function() {
    this.$el.toggleClass("scope-group--is-expanded");
    this.$(".caret").toggleClass("caret--is-rotated");
  },
  preRender: function() {
    oktaUnderscore.chain(this.options.scopes).sortBy(({
      name
    }) => name).each(({
      name,
      displayName,
      description
    }) => {
      this.add(ScopeItem, {
        options: {
          name: displayName || name,
          description
        }
      });
    });
  }
});
var AdminScopeList = View2.extend({
  className: "scope-list detail-row",
  postRender: function() {
    const allScopes = this.model.get("scopes");
    const scopesWithGroup = oktaUnderscore.groupBy(allScopes, findScopeGroupKey);
    const SCOPE_GROUP_NAMES_CONFIG = {
      "user": loc3("admin.consent.group.user.group", "login"),
      "resource": loc3("admin.consent.group.resource.policy", "login"),
      "hook": loc3("admin.consent.group.hook", "login"),
      "system": loc3("admin.consent.group.system", "login")
    };
    oktaUnderscore.each(SCOPE_GROUP_NAMES_CONFIG, (groupName, groupKey) => {
      const scopes = scopesWithGroup[groupKey];
      if (!Array.isArray(scopes)) {
        return;
      }
      this.add(ScopeGroupHeaderView, {
        options: {
          groupName,
          scopes
        }
      });
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/templates/consentLogoHeaderTemplate.js
var consentLogoHeaderTemplate = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<a href="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "clientURI") || (depth0 != null ? lookupProperty(depth0, "clientURI") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "clientURI",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 26
        },
        "end": {
          "line": 1,
          "column": 39
        }
      }
    }) : helper)) + '" class="client-logo-link" target="_blank">';
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<img class="client-logo custom-logo" src="' + alias3((helper = (helper = lookupProperty(helpers2, "customLogo") || (depth0 != null ? lookupProperty(depth0, "customLogo") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
      "name": "customLogo",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 149
        },
        "end": {
          "line": 1,
          "column": 163
        }
      }
    }) : helper)) + '" alt="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
      "name": "i18n",
      "hash": {
        "bundle": "login",
        "code": "common.logo.alt"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 170
        },
        "end": {
          "line": 1,
          "column": 216
        }
      }
    })) + '" aria-hidden="true" />';
  },
  "5": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<img class="client-logo default-logo" src="' + alias3((helper = (helper = lookupProperty(helpers2, "defaultLogo") || (depth0 != null ? lookupProperty(depth0, "defaultLogo") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
      "name": "defaultLogo",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 290
        },
        "end": {
          "line": 1,
          "column": 305
        }
      }
    }) : helper)) + '" alt="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
      "name": "i18n",
      "hash": {
        "bundle": "login",
        "code": "common.logo.alt"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 312
        },
        "end": {
          "line": 1,
          "column": 358
        }
      }
    })) + '" aria-hidden="true" />';
  },
  "7": function(container, depth0, helpers2, partials, data) {
    return "</a>";
  },
  "9": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="issuer"><span>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "issuer") || (depth0 != null ? lookupProperty(depth0, "issuer") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "issuer",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 566
        },
        "end": {
          "line": 1,
          "column": 576
        }
      }
    }) : helper)) + "</span></div>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 89
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "customLogo") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.program(5, data, 0),
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 89
        },
        "end": {
          "line": 1,
          "column": 388
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(7, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 388
        },
        "end": {
          "line": 1,
          "column": 416
        }
      }
    })) != null ? stack1 : "") + '<h1><span class="title-text">' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
      "name": "i18n",
      "hash": {
        "arguments": "appName",
        "bundle": "login",
        "code": "consent.required.text"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 445
        },
        "end": {
          "line": 1,
          "column": 519
        }
      }
    })) != null ? stack1 : "") + "</span>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "issuer") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(9, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 526
        },
        "end": {
          "line": 1,
          "column": 596
        }
      }
    })) != null ? stack1 : "") + "</h1>";
  },
  "useData": true
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/AdminConsentRequiredController.js
var ConsentModel = {
  props: {
    scopes: ["array", true]
  },
  save: function() {
    return this.doTransaction(function(transaction) {
      return transaction.consent({
        consent: {
          scopes: oktaUnderscore.pluck(this.get("scopes"), "name")
        }
      });
    });
  },
  cancel: function() {
    var self2 = this;
    return this.doTransaction(function(transaction) {
      return transaction.cancel();
    }).then(function() {
      var consentCancelFn = self2.settings.get("consent.cancel");
      if (oktaUnderscore.isFunction(consentCancelFn)) {
        consentCancelFn();
      }
    });
  }
};
var ConsentHeader = View2.extend({
  className: "consent-title detail-row",
  template: consentLogoHeaderTemplate,
  getTemplateData: function() {
    var appState = this.options.appState;
    return {
      appName: appState.escape("targetLabel"),
      customLogo: appState.get("targetLogo") && appState.get("targetLogo").href,
      defaultLogo: appState.get("defaultAppLogo"),
      clientURI: appState.get("targetClientURI") && appState.get("targetClientURI").href,
      issuer: appState.get("issuer")
    };
  }
});
var ConsentForm = {
  noCancelButton: false,
  buttonOrder: ["cancel", "save"],
  autoSave: true,
  save: oktaUnderscore.partial(loc3, "consent.required.consentButton", "login"),
  cancel: oktaUnderscore.partial(loc3, "consent.required.cancelButton", "login"),
  formChildren: [FormType.View({
    View: ConsentHeader
  }), FormType.View({
    View: AdminScopeList
  })]
};
var AdminConsentRequiredController = FormController.extend({
  Model: ConsentModel,
  Form: ConsentForm,
  className: "admin-consent-required",
  initialize: function() {
    this.model.set("scopes", this.options.appState.get("scopes"));
    this.listenTo(this.form, "cancel", () => {
      this.model.cancel();
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/ErrorCodes.js
var ErrorCodes = {
  INVALID_TOKEN_EXCEPTION: "E0000011"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/RouterUtil.js
var fn3 = {};
var verifyUrlTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/verify/" + alias4((helper = (helper = lookupProperty(helpers2, "provider") || (depth0 != null ? lookupProperty(depth0, "provider") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "provider",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 14
        },
        "end": {
          "line": 1,
          "column": 26
        }
      }
    }) : helper)) + "/" + alias4((helper = (helper = lookupProperty(helpers2, "factorType") || (depth0 != null ? lookupProperty(depth0, "factorType") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorType",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 27
        },
        "end": {
          "line": 1,
          "column": 41
        }
      }
    }) : helper));
  },
  "useData": true
});
var verifyUrlMultipleTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/verify/" + alias4((helper = (helper = lookupProperty(helpers2, "provider") || (depth0 != null ? lookupProperty(depth0, "provider") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "provider",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 14
        },
        "end": {
          "line": 1,
          "column": 26
        }
      }
    }) : helper)) + "/" + alias4((helper = (helper = lookupProperty(helpers2, "factorType") || (depth0 != null ? lookupProperty(depth0, "factorType") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorType",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 27
        },
        "end": {
          "line": 1,
          "column": 41
        }
      }
    }) : helper)) + "/" + alias4((helper = (helper = lookupProperty(helpers2, "factorIndex") || (depth0 != null ? lookupProperty(depth0, "factorIndex") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorIndex",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 42
        },
        "end": {
          "line": 1,
          "column": 57
        }
      }
    }) : helper));
  },
  "useData": true
});
var verifyUrlNoProviderTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/verify/" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "factorType") || (depth0 != null ? lookupProperty(depth0, "factorType") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "factorType",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 14
        },
        "end": {
          "line": 1,
          "column": 28
        }
      }
    }) : helper));
  },
  "useData": true
});
var enrollFactorUrlTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/enroll/" + alias4((helper = (helper = lookupProperty(helpers2, "provider") || (depth0 != null ? lookupProperty(depth0, "provider") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "provider",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 14
        },
        "end": {
          "line": 1,
          "column": 26
        }
      }
    }) : helper)) + "/" + alias4((helper = (helper = lookupProperty(helpers2, "factorType") || (depth0 != null ? lookupProperty(depth0, "factorType") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorType",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 27
        },
        "end": {
          "line": 1,
          "column": 41
        }
      }
    }) : helper));
  },
  "useData": true
});
var activateFactorUrlTpl = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "/" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "step") || (depth0 != null ? lookupProperty(depth0, "step") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "step",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 63
        },
        "end": {
          "line": 1,
          "column": 71
        }
      }
    }) : helper));
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/enroll-activate/" + alias4((helper = (helper = lookupProperty(helpers2, "provider") || (depth0 != null ? lookupProperty(depth0, "provider") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "provider",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 23
        },
        "end": {
          "line": 1,
          "column": 35
        }
      }
    }) : helper)) + "/" + alias4((helper = (helper = lookupProperty(helpers2, "factorType") || (depth0 != null ? lookupProperty(depth0, "factorType") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorType",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 36
        },
        "end": {
          "line": 1,
          "column": 50
        }
      }
    }) : helper)) + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "step") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 50
        },
        "end": {
          "line": 1,
          "column": 78
        }
      }
    })) != null ? stack1 : "");
  },
  "useData": true
});
var recoveryUrlTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/recovery/" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "recoveryToken") || (depth0 != null ? lookupProperty(depth0, "recoveryToken") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "recoveryToken",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 16
        },
        "end": {
          "line": 1,
          "column": 33
        }
      }
    }) : helper));
  },
  "useData": true
});
var refreshUrlTpl = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "/" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "token") || (depth0 != null ? lookupProperty(depth0, "token") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "token",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 39
        },
        "end": {
          "line": 1,
          "column": 48
        }
      }
    }) : helper));
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "signin/refresh-auth-state" + ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "token") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 25
        },
        "end": {
          "line": 1,
          "column": 55
        }
      }
    })) != null ? stack1 : "");
  },
  "useData": true
});
var sessionCookieRedirectTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "baseUrl") || (depth0 != null ? lookupProperty(depth0, "baseUrl") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "baseUrl",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 11
        }
      }
    }) : helper)) + "/login/sessionCookieRedirect?checkAccountSetupComplete=true&token=" + ((stack1 = (helper = (helper = lookupProperty(helpers2, "token") || (depth0 != null ? lookupProperty(depth0, "token") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "token",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 77
        },
        "end": {
          "line": 1,
          "column": 88
        }
      }
    }) : helper)) != null ? stack1 : "") + "&redirectUrl=" + ((stack1 = (helper = (helper = lookupProperty(helpers2, "redirectUrl") || (depth0 != null ? lookupProperty(depth0, "redirectUrl") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "redirectUrl",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 101
        },
        "end": {
          "line": 1,
          "column": 118
        }
      }
    }) : helper)) != null ? stack1 : "");
  },
  "useData": true
});
var deviceActivationStatuses = ["DEVICE_ACTIVATED", "DEVICE_NOT_ACTIVATED_CONSENT_DENIED", "DEVICE_NOT_ACTIVATED"];
fn3.isHostBackgroundChromeTab = function() {
  if (navigator.userAgent.match(/Android/) && navigator.userAgent.match(/Chrome/) && document.hidden) {
    return true;
  } else {
    return false;
  }
};
fn3.isDocumentVisible = function() {
  return document.visibilityState === "visible";
};
fn3.createVerifyUrl = function(provider, factorType, factorIndex) {
  if (provider && factorIndex) {
    return verifyUrlMultipleTpl({
      provider: encodeURIComponent(provider.toLowerCase()),
      factorType: encodeURIComponent(factorType),
      factorIndex: encodeURIComponent(factorIndex)
    });
  } else if (provider) {
    return verifyUrlTpl({
      provider: encodeURIComponent(provider.toLowerCase()),
      factorType: encodeURIComponent(factorType)
    });
  } else {
    return verifyUrlNoProviderTpl({
      factorType: encodeURIComponent(factorType)
    });
  }
};
fn3.createEnrollFactorUrl = function(provider, factorType) {
  return enrollFactorUrlTpl({
    provider: encodeURIComponent(provider.toLowerCase()),
    factorType: encodeURIComponent(factorType)
  });
};
fn3.createActivateFactorUrl = function(provider, factorType, step) {
  return activateFactorUrlTpl({
    provider: encodeURIComponent(provider.toLowerCase()),
    factorType: encodeURIComponent(factorType),
    step: step ? encodeURIComponent(step) : false
  });
};
fn3.createRecoveryUrl = function(recoveryToken) {
  return recoveryUrlTpl({
    recoveryToken: encodeURIComponent(recoveryToken)
  });
};
fn3.createRefreshUrl = function(stateToken) {
  const token = stateToken ? encodeURIComponent(stateToken) : null;
  return refreshUrlTpl({
    token
  });
};
fn3.routeAfterAuthStatusChangeError = function(router, err) {
  if (!err) {
    return;
  }
  if (err.xhr && fn.corsIsNotEnabled(err.xhr)) {
    router.settings.callGlobalError(new UnsupportedBrowserError(loc3("error.enabled.cors")));
    return;
  }
  if (err.errorCode === ErrorCodes.INVALID_TOKEN_EXCEPTION) {
    router.appState.set("flashError", err);
    router.controller.state.set("navigateDir", Enums.DIRECTION_BACK);
    if (router.settings.get("features.mfaOnlyFlow")) {
      router.navigate("signin/error", {
        trigger: true
      });
    } else {
      router.navigate("", {
        trigger: true
      });
    }
    return;
  }
  Util2.triggerAfterError(router.controller, err);
};
fn3.routeAfterAuthStatusChange = function(router, res) {
  if (!res || !res.status) {
    router.appState.clearLastAuthResponse();
    return;
  }
  router.appState.setAuthResponse(res);
  if (router.controller && router.controller.trapAuthResponse(res)) {
    return;
  }
  fn3.handleResponseStatus(router, res);
};
fn3.handleResponseStatus = function(router, res) {
  switch (res.status) {
    case "SUCCESS": {
      handleSuccessResponseStatus(router, res);
      return;
    }
    case "ADMIN_CONSENT_REQUIRED":
      router.navigate("signin/admin-consent", {
        trigger: true
      });
      return;
    case "CONSENT_REQUIRED":
      router.navigate("signin/consent", {
        trigger: true
      });
      return;
    case "DEVICE_ACTIVATE":
      router.navigate("signin/device-activate", {
        trigger: true
      });
      return;
    case "FACTOR_REQUIRED":
    case "FACTOR_CHALLENGE":
    case "MFA_REQUIRED": {
      const lastFailedChallengeFactorData = router.appState.get("lastFailedChallengeFactorData");
      if (lastFailedChallengeFactorData && lastFailedChallengeFactorData.factor) {
        router.appState.get("factors").lastUsedFactor = lastFailedChallengeFactorData.factor;
      }
      const factor = router.appState.get("factors").getDefaultFactor();
      const url = fn3.createVerifyUrl(factor.get("provider"), factor.get("factorType"));
      router.navigate(url, {
        trigger: true
      });
      router.appState.clearLastFailedChallengeFactorData();
      return;
    }
    case "POLL": {
      const pollUrl = "signin/poll";
      router.navigate(pollUrl, {
        trigger: true
      });
      return;
    }
    case "MFA_CHALLENGE":
      if (router.appState.get("isFactorResultFailed")) {
        router.appState.setLastFailedChallengeFactorData();
      }
      router.appState.get("transaction").prev().then(function(trans) {
        router.appState.set("transaction", trans);
      });
      return;
    case "MFA_ENROLL":
    case "FACTOR_ENROLL":
      router.navigate("signin/enroll", {
        trigger: true
      });
      return;
    case "MFA_ENROLL_ACTIVATE":
    case "FACTOR_ENROLL_ACTIVATE": {
      const activateUrl = fn3.createActivateFactorUrl(router.appState.get("activatedFactorProvider"), router.appState.get("activatedFactorType"));
      router.navigate(activateUrl, {
        trigger: true
      });
      return;
    }
    case "PASSWORD_WARN":
    case "PASSWORD_EXPIRED":
      if (router.settings.get("features.customExpiredPassword") && !router.appState.get("isPwdManagedByOkta")) {
        router.navigate("signin/custom-password-expired", {
          trigger: true
        });
      } else {
        router.navigate("signin/password-expired", {
          trigger: true
        });
      }
      return;
    case "RECOVERY_CHALLENGE": {
      const fromEmail = res.factorType.toLowerCase() === Enums.RECOVERY_FACTOR_TYPE_EMAIL.toLowerCase();
      const isForgotPassword = res.recoveryType === Enums.RECOVERY_TYPE_PASSWORD;
      const isUnlock = res.recoveryType === Enums.RECOVERY_TYPE_UNLOCK;
      if (isForgotPassword && fromEmail) {
        router.navigate("signin/recovery-emailed", {
          trigger: true
        });
      } else if (isUnlock && fromEmail) {
        router.navigate("signin/unlock-emailed", {
          trigger: true
        });
      } else {
        router.navigate("signin/recovery-challenge", {
          trigger: true
        });
      }
      return;
    }
    case "RECOVERY":
      router.navigate("signin/recovery-question", {
        trigger: true
      });
      return;
    case "PASSWORD_RESET":
      router.navigate("signin/password-reset", {
        trigger: true
      });
      return;
    case "LOCKED_OUT": {
      if (router.settings.get("features.selfServiceUnlock")) {
        router.navigate("signin/unlock", {
          trigger: true
        });
      } else {
        const errorMessage = loc3("error.auth.lockedOut", "login");
        const resError = {
          responseJSON: {
            errorCauses: [],
            errorSummary: errorMessage,
            errorCode: "E0000119"
          }
        };
        const err = {
          name: "AuthApiError",
          message: errorMessage,
          xhr: resError
        };
        router.controller.model.appState.trigger("removeLoading");
        router.controller.model.trigger("error", router.controller.model, resError);
        Util2.triggerAfterError(router.controller, err);
      }
      return;
    }
    case "PROFILE_REQUIRED":
      router.navigate("signin/enroll-user", {
        trigger: true
      });
      return;
    case "UNAUTHENTICATED":
      if (router.appState.get("promptForFactorInUnauthenticated")) {
        const defaultFactor = router.appState.get("factors").getDefaultFactor();
        const factorURL = fn3.createVerifyUrl(defaultFactor.get("provider"), defaultFactor.get("factorType"));
        router.navigate(factorURL, {
          trigger: true
        });
        return;
      }
      if (router.appState.get("usingDeviceFlow")) {
        router.navigate("signin/idp-discovery-check", {
          trigger: true
        });
        return;
      }
      router.navigate("", {
        trigger: true
      });
      return;
    default:
      throw new Error("Unknown status: " + res.status);
  }
};
function handleSuccessResponseStatus(router, res) {
  var _res$_embedded, _res$_links, _res$_links$original, _res$_links2, _res$_links2$next;
  if (res.recoveryType === Enums.RECOVERY_TYPE_UNLOCK) {
    router.navigate("signin/account-unlocked", {
      trigger: true
    });
    return;
  }
  if (oktaUnderscore.contains(deviceActivationStatuses, (_res$_embedded = res._embedded) === null || _res$_embedded === void 0 ? void 0 : _res$_embedded.deviceActivationStatus)) {
    router.navigate("signin/device-activate-complete", {
      trigger: true
    });
    return;
  }
  if (router.settings.get("oauth2Enabled")) {
    util.getTokens(router.settings, {
      sessionToken: res.sessionToken
    }, router.controller);
    return;
  }
  const successData = {
    user: res._embedded.user,
    type: res.type || Enums.SESSION_SSO
  };
  if (res.relayState) {
    successData.relayState = res.relayState;
  }
  const redirectFn = router.settings.get("redirectUtilFn");
  const nextUrl = (res === null || res === void 0 ? void 0 : (_res$_links = res._links) === null || _res$_links === void 0 ? void 0 : (_res$_links$original = _res$_links.original) === null || _res$_links$original === void 0 ? void 0 : _res$_links$original.href) || (res === null || res === void 0 ? void 0 : (_res$_links2 = res._links) === null || _res$_links2 === void 0 ? void 0 : (_res$_links2$next = _res$_links2.next) === null || _res$_links2$next === void 0 ? void 0 : _res$_links2$next.href);
  if (res.type === Enums.SESSION_STEP_UP) {
    var _res$_links3, _res$_links3$next;
    const targetUrl = res === null || res === void 0 ? void 0 : (_res$_links3 = res._links) === null || _res$_links3 === void 0 ? void 0 : (_res$_links3$next = _res$_links3.next) === null || _res$_links3$next === void 0 ? void 0 : _res$_links3$next.href;
    successData.stepUp = {
      url: targetUrl,
      finish: function() {
        redirectFn(targetUrl);
      }
    };
  } else {
    if (nextUrl) {
      successData.next = function() {
        redirectFn(nextUrl);
      };
    } else {
      successData.type = Enums.SESSION_SSO;
    }
    if (res.sessionToken) {
      successData.session = {
        token: res.sessionToken,
        setCookieAndRedirect: function(redirectUri) {
          if (redirectUri) {
            Util2.debugMessage(`
              Passing a "redirectUri" to "setCookieAndRedirect" is strongly discouraged.
              It is recommended to set a "redirectUri" option in the config object passed to the widget constructor.
            `);
          }
          redirectUri = redirectUri || router.settings.get("redirectUri");
          if (!redirectUri) {
            throw new ConfigError('"redirectUri" is required');
          }
          redirectFn(sessionCookieRedirectTpl({
            baseUrl: router.settings.get("baseUrl"),
            token: encodeURIComponent(res.sessionToken),
            redirectUrl: encodeURIComponent(redirectUri)
          }));
        }
      };
    }
  }
  if (fn3.isHostBackgroundChromeTab()) {
    document.addEventListener("visibilitychange", function checkVisibilityAndCallSuccess() {
      if (fn3.isDocumentVisible()) {
        document.removeEventListener("visibilitychange", checkVisibilityAndCallSuccess);
        router.settings.callGlobalSuccess(Enums.SUCCESS, successData);
      }
    });
  } else {
    router.settings.callGlobalSuccess(Enums.SUCCESS, successData);
  }
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/BarcodeView.js
var BarcodeView = View2.extend({
  className: "scan-instructions clearfix",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="scan-instructions-details-wrapper"><div class="scan-instructions-details"><p>' + alias4((helper = (helper = lookupProperty(helpers2, "instructions") || (depth0 != null ? lookupProperty(depth0, "instructions") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "instructions",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 89
          },
          "end": {
            "line": 1,
            "column": 105
          }
        }
      }) : helper)) + '</p></div></div><div class="scan-instructions-qrcode-wrapper"><div class="qrcode-wrap"><img data-se="qrcode" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "altQRCode") || (depth0 != null ? lookupProperty(depth0, "altQRCode") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "altQRCode",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 219
          },
          "end": {
            "line": 1,
            "column": 232
          }
        }
      }) : helper)) + '" class="qrcode-image" src="' + alias4((helper = (helper = lookupProperty(helpers2, "qrcode") || (depth0 != null ? lookupProperty(depth0, "qrcode") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "qrcode",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 260
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      }) : helper)) + '"><div data-se="qrcode-success" class="qrcode-success"></div><div data-se="qrcode-error" class="qrcode-error"></div></div><a href="#" data-type="manual-setup" data-se="manual-setup" class="link manual-setup" aria-label="' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.totp.aria.cannotScan"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 490
          },
          "end": {
            "line": 1,
            "column": 549
          }
        }
      })) + '">' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.totp.cannotScan"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 551
          },
          "end": {
            "line": 1,
            "column": 604
          }
        }
      })) + '</a><a href="#" data-type="refresh-qrcode" data-se="refresh-qrcode" class="link refresh-qrcode">' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.totp.refreshBarcode"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 700
          },
          "end": {
            "line": 1,
            "column": 757
          }
        }
      })) + "</a></div>";
    },
    "useData": true
  }),
  events: {
    'click [data-type="manual-setup"]': function(e) {
      e.preventDefault();
      const url = fn3.createActivateFactorUrl(this.model.get("__provider__"), this.model.get("__factorType__"), "manual");
      if (this.model.get("__factorType__") === "push") {
        this.model.doTransaction(function(transaction) {
          return transaction.prev().then(function(trans) {
            const factor = oktaUnderscore.findWhere(trans.factors, {
              factorType: "push",
              provider: "OKTA"
            });
            return factor.enroll();
          });
        }).then(() => {
          this.options.appState.trigger("navigate", url);
        });
      } else {
        this.options.appState.trigger("navigate", url);
      }
    },
    'click [data-type="refresh-qrcode"]': function(e) {
      e.preventDefault();
      this.model.trigger("errors:clear");
      const self2 = this;
      this.model.doTransaction(function(transaction) {
        if (this.appState.get("isWaitingForActivation")) {
          return transaction.poll();
        } else {
          return transaction.activate();
        }
      }).then(function(trans) {
        const res = trans.data;
        if ((res.status === "MFA_ENROLL_ACTIVATE" || res.status === "FACTOR_ENROLL_ACTIVATE") && res.factorResult === "WAITING") {
          oktaUnderscore.defer(oktaUnderscore.bind(self2.render, self2));
        }
      });
    }
  },
  initialize: function() {
    this.listenTo(this.options.appState, "change:lastAuthResponse", function() {
      if (this.options.appState.get("isMfaEnrollActivate")) {
        this.$el.toggleClass("qrcode-expired", !this.options.appState.get("isWaitingForActivation"));
      } else if (this.options.appState.get("isSuccessResponse")) {
        this.$el.addClass("qrcode-success");
      }
    });
    this.listenTo(this.model, "error", function() {
      if (this.options.appState.get("isMfaEnrollActivate")) {
        this.$el.toggleClass("qrcode-expired", true);
      }
    });
  },
  getTemplateData: function() {
    const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
    let instructions;
    if (this.model.get("__provider__") === "GOOGLE") {
      instructions = loc3("enroll.totp.setupGoogleAuthApp", "login", [factorName]);
    } else {
      instructions = loc3("enroll.totp.setupApp", "login", [factorName]);
    }
    return {
      instructions,
      qrcode: this.options.appState.get("qrcode"),
      altQRCode: loc3("mfa.altQrCode", "login")
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/BarcodePushController.js
var PUSH_INTERVAL = 6e3;
var BarcodePushController = FormController.extend({
  className: "barcode-push",
  Model: function() {
    return {
      local: {
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      }
    };
  },
  Form: {
    title: function() {
      const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
      return loc3("enroll.totp.title", "login", [factorName]);
    },
    noButtonBar: true,
    attributes: {
      "data-se": "step-scan"
    },
    className: "barcode-scan",
    initialize: function() {
      this.listenTo(this.model, "error errors:clear", function() {
        this.clearErrors();
      });
    },
    formChildren: [FormType.View({
      View: BarcodeView
    })]
  },
  Footer,
  initialize: function() {
    this.pollForEnrollment().catch(() => {
    });
  },
  pollForEnrollment: function() {
    return this.model.doTransaction(function(transaction) {
      return transaction.poll(PUSH_INTERVAL);
    });
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/BarcodeTotpController.js
var BarcodeTotpController = FormController.extend({
  className: "barcode-totp",
  Model: function() {
    return {
      local: {
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      }
    };
  },
  Form: {
    title: function() {
      const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
      return loc3("enroll.totp.title", "login", [factorName]);
    },
    save: oktaUnderscore.partial(loc3, "oform.next", "login"),
    noCancelButton: true,
    attributes: {
      "data-se": "step-scan"
    },
    className: "barcode-scan",
    formChildren: [FormType.View({
      View: BarcodeView
    })]
  },
  Footer,
  initialize: function() {
    this.listenTo(this.form, "save", function() {
      const url = fn3.createActivateFactorUrl(this.model.get("__provider__"), this.model.get("__factorType__"), "activate");
      this.options.appState.trigger("navigate", url);
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/consent/ScopeItem.js
var ScopeItem2 = View2.extend({
  className: "scope-item",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      return '<span class="scope-item-tooltip icon form-help-16"></span>';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="' + alias4((helper = (helper = lookupProperty(helpers2, "classNames") || (depth0 != null ? lookupProperty(depth0, "classNames") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "classNames",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 12
          },
          "end": {
            "line": 1,
            "column": 26
          }
        }
      }) : helper)) + '"><p>' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 31
          },
          "end": {
            "line": 1,
            "column": 39
          }
        }
      }) : helper)) + "</p></div>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "description") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 49
          },
          "end": {
            "line": 1,
            "column": 133
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    const {
      name,
      description,
      isCustomized
    } = this.options;
    const baseClass = "scope-item-text";
    const classNames = name === "openid" || isCustomized ? `${baseClass} no-translate` : baseClass;
    return {
      classNames,
      name,
      description
    };
  },
  postRender: function() {
    this.$(".scope-item-tooltip").qtip({
      content: {
        text: oktaUnderscore.escape(this.options.description)
      },
      style: {
        classes: "okta-tooltip qtip-custom qtip-shadow"
      },
      position: {
        my: "bottom right",
        target: "mouse"
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/consent/ScopeList.js
var EnduserScopeList = View2.extend({
  className: "scope-list detail-row",
  postRender: function() {
    this.model.get("scopes").forEach((scope) => {
      this.add(ScopeItem2, {
        options: {
          name: scope.displayName || scope.name,
          description: scope.description,
          isCustomized: scope.isCustomized
        }
      });
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/consent/ScopeCheckBox.js
var CheckBox2 = internal.views.forms.inputs.CheckBox;
var ScopeCheckBox = CheckBox2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<input type="checkbox" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 29
          },
          "end": {
            "line": 1,
            "column": 37
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 54
          }
        }
      }) : helper)) + '"/><label for="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 69
          },
          "end": {
            "line": 1,
            "column": 80
          }
        }
      }) : helper)) + '" data-se-for-name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 100
          },
          "end": {
            "line": 1,
            "column": 108
          }
        }
      }) : helper)) + '"><b>' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 113
          },
          "end": {
            "line": 1,
            "column": 128
          }
        }
      }) : helper)) + "</b><p>" + alias4((helper = (helper = lookupProperty(helpers2, "desc") || (depth0 != null ? lookupProperty(depth0, "desc") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "desc",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 135
          },
          "end": {
            "line": 1,
            "column": 143
          }
        }
      }) : helper)) + "</p></label>";
    },
    "useData": true
  }),
  /**
     * @Override
     */
  enable: function() {
    if (this.options.options.optional) {
      this.$(":input").prop("disabled", false);
    }
  },
  /**
     * @Override
     */
  editMode: function() {
    this.$el.html(this.template(oktaUnderscore.extend(oktaUnderscore.omit(this.options, "placeholder"), {
      placeholder: this.options.placeholder || this.options.name,
      desc: this.options.options.description
    })));
    this.$(":checkbox").prop("checked", this.getModelValue() || false);
    this.$("input").customInput();
    this.model.trigger("form:resize");
    if (!this.options.options.optional) {
      const input = this.$("input").get(0);
      this.$(input.parentElement).addClass("o-form-read-mode");
      this.$(":checkbox").prop("disabled", true);
    }
    if (this.options.name === "openid" || this.options.options.isCustomized) {
      this.$("label > b").addClass("no-translate");
      if (this.options.options.isCustomized) {
        this.$("label > p").addClass("no-translate");
      }
    }
    return this;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/SkipLink.js
var SkipLink = View2.extend({
  tagName: "a",
  className: "skip-to-content-link",
  attributes: {
    href: `#${Enums.WIDGET_CONTAINER_ID}`
  },
  initialize: function initialize() {
    this.$el.append(loc3("skip.to.main.content", "login"));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ConsentRequiredController.js
var granularConsentHeaderTemplate = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<a href="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "clientURI") || (depth0 != null ? lookupProperty(depth0, "clientURI") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "clientURI",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 26
        },
        "end": {
          "line": 1,
          "column": 39
        }
      }
    }) : helper)) + '" class="client-logo-link" target="_blank">';
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<img class="client-logo custom-logo" src="' + alias3((helper = (helper = lookupProperty(helpers2, "customLogo") || (depth0 != null ? lookupProperty(depth0, "customLogo") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
      "name": "customLogo",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 149
        },
        "end": {
          "line": 1,
          "column": 163
        }
      }
    }) : helper)) + '" alt="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
      "name": "i18n",
      "hash": {
        "bundle": "login",
        "code": "common.logo.alt"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 170
        },
        "end": {
          "line": 1,
          "column": 216
        }
      }
    })) + '" aria-hidden="true" />';
  },
  "5": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<img class="client-logo default-logo" src="' + alias3((helper = (helper = lookupProperty(helpers2, "defaultLogo") || (depth0 != null ? lookupProperty(depth0, "defaultLogo") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
      "name": "defaultLogo",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 290
        },
        "end": {
          "line": 1,
          "column": 305
        }
      }
    }) : helper)) + '" alt="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
      "name": "i18n",
      "hash": {
        "bundle": "login",
        "code": "common.logo.alt"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 312
        },
        "end": {
          "line": 1,
          "column": 358
        }
      }
    })) + '" aria-hidden="true" />';
  },
  "7": function(container, depth0, helpers2, partials, data) {
    return "</a>";
  },
  "9": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="issuer"><span>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "issuer") || (depth0 != null ? lookupProperty(depth0, "issuer") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "issuer",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 624
        },
        "end": {
          "line": 1,
          "column": 634
        }
      }
    }) : helper)) + "</span></div>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 89
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "customLogo") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.program(5, data, 0),
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 89
        },
        "end": {
          "line": 1,
          "column": 388
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(7, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 388
        },
        "end": {
          "line": 1,
          "column": 416
        }
      }
    })) != null ? stack1 : "") + '<h1><span class="title-text">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
      "name": "i18n",
      "hash": {
        "$2": "<p>$2</p>",
        "$1": "<b class='no-translate'>$1</b>",
        "arguments": "appName",
        "bundle": "login",
        "code": "granular.consent.scopes.title"
      },
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 445
        },
        "end": {
          "line": 1,
          "column": 577
        }
      }
    })) + "</span>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "issuer") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(9, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 584
        },
        "end": {
          "line": 1,
          "column": 654
        }
      }
    })) != null ? stack1 : "") + "</h1>";
  },
  "useData": true
});
var getConsentHeader = (template8) => FormType.View({
  View: View2.extend({
    className: "consent-title detail-row",
    template: template8,
    getTemplateData: function() {
      const appState = this.options.appState;
      return {
        appName: appState.escape("targetLabel"),
        customLogo: appState.get("targetLogo") && appState.get("targetLogo").href,
        defaultLogo: appState.get("defaultAppLogo"),
        clientURI: appState.get("targetClientURI") && appState.get("targetClientURI").href
      };
    }
  })
});
var consentRequiredDescription = FormType.View({
  View: View2.extend({
    className: "consent-description detail-row",
    template: _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "consent.required.description"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 3
            },
            "end": {
              "line": 1,
              "column": 62
            }
          }
        })) + "</p>";
      },
      "useData": true
    })
  })
});
var granularConsentDescription = FormType.View({
  View: View2.extend({
    className: "consent-description",
    template: _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "granular.consent.scopes.description"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 3
            },
            "end": {
              "line": 1,
              "column": 69
            }
          }
        })) + "</p>";
      },
      "useData": true
    })
  })
});
var getScopeCheckBoxes = (scopes) => {
  const sortedScopes = scopes.slice().sort((scope1, scope2) => scope2.optional - scope1.optional);
  return oktaUnderscore.map(sortedScopes, ({
    name,
    displayName,
    description,
    optional,
    isCustomized
  }) => FormType.Input({
    name,
    input: ScopeCheckBox,
    placeholder: displayName,
    label: false,
    modelType: "boolean",
    required: true,
    options: {
      description,
      optional,
      isCustomized
    }
  }));
};
var isGranularConsent = (appState) => {
  return "optional" in appState.get("scopes")[0];
};
var ConsentRequiredController = FormController.extend({
  className: "consent-required",
  initialize: function() {
    this.model.set("expiresAt", this.options.appState.get("expiresAt"));
    this.model.set("scopes", this.options.appState.get("scopes"));
    this.listenTo(this.form, "cancel", oktaUnderscore.bind(this.model.cancel, this.model));
    const skipLink = new SkipLink();
    oktaJQueryStatic(`#${Enums.WIDGET_LOGIN_CONTAINER_ID}`).prepend(skipLink.render().$el);
    if (isGranularConsent(this.options.appState)) {
      this.$el.addClass("granular-consent").removeClass("consent-required");
      this.form.cancel = oktaUnderscore.partial(loc3, "oform.cancel", "login");
      oktaUnderscore.forEach(this.options.appState.get("scopes"), (scope) => {
        this.model.set(scope.name, true);
      });
    }
  },
  postRender: function() {
    FormController.prototype.postRender.apply(this, arguments);
    this.$(".o-form-button-bar .button-primary").removeClass("button-primary");
  },
  Model: {
    props: {
      expiresAt: ["string", true],
      scopes: ["array", true]
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        let scopeNames = oktaUnderscore.pluck(this.get("scopes"), "name");
        let consent = {
          expiresAt: this.get("expiresAt")
        };
        if (isGranularConsent(this)) {
          consent["optedScopes"] = oktaUnderscore.reduce(scopeNames, (optedScopes, scope) => {
            optedScopes[scope] = this.get(scope);
            return optedScopes;
          }, {});
        } else {
          consent["scopes"] = scopeNames;
        }
        return transaction.consent({
          consent
        });
      });
    },
    cancel: function() {
      const self2 = this;
      return this.doTransaction(function(transaction) {
        return transaction.cancel();
      }).then(function() {
        const consentCancelFn = self2.settings.get("consent.cancel");
        if (oktaUnderscore.isFunction(consentCancelFn)) {
          consentCancelFn();
        }
      });
    }
  },
  Form: {
    noCancelButton: false,
    buttonOrder: ["cancel", "save"],
    autoSave: true,
    save: oktaUnderscore.partial(loc3, "consent.required.consentButton", "login"),
    cancel: oktaUnderscore.partial(loc3, "consent.required.cancelButton", "login"),
    formChildren: function() {
      if (isGranularConsent(this.options.appState)) {
        return [getConsentHeader(granularConsentHeaderTemplate), granularConsentDescription].concat(getScopeCheckBoxes(this.options.appState.get("scopes")));
      } else {
        return [getConsentHeader(consentLogoHeaderTemplate), FormType.View({
          View: new EnduserScopeList({
            model: this.model
          })
        }), consentRequiredDescription];
      }
    }
  },
  Footer: View2.extend({
    className: "consent-footer",
    template: _Handlebars2.template({
      "1": function(container, depth0, helpers2, partials, data) {
        var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<a class="terms-of-service" href="' + alias3((helper = (helper = lookupProperty(helpers2, "termsOfService") || (depth0 != null ? lookupProperty(depth0, "termsOfService") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
          "name": "termsOfService",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 56
            },
            "end": {
              "line": 1,
              "column": 74
            }
          }
        }) : helper)) + '" target="_blank">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "consent.required.termsOfService"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 92
            },
            "end": {
              "line": 1,
              "column": 154
            }
          }
        })) + "</a>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(2, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 158
            },
            "end": {
              "line": 1,
              "column": 194
            }
          }
        })) != null ? stack1 : "");
      },
      "2": function(container, depth0, helpers2, partials, data) {
        return " &#8226 ";
      },
      "4": function(container, depth0, helpers2, partials, data) {
        var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<a class="privacy-policy" href="' + alias3((helper = (helper = lookupProperty(helpers2, "privacyPolicy") || (depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
          "name": "privacyPolicy",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 254
            },
            "end": {
              "line": 1,
              "column": 271
            }
          }
        }) : helper)) + '" target="_blank">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "consent.required.privacyPolicy"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 289
            },
            "end": {
              "line": 1,
              "column": 350
            }
          }
        })) + "</a>";
      },
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "termsOfService") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(1, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 0
            },
            "end": {
              "line": 1,
              "column": 201
            }
          }
        })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(4, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 201
            },
            "end": {
              "line": 1,
              "column": 361
            }
          }
        })) != null ? stack1 : "");
      },
      "useData": true
    }),
    getTemplateData: function() {
      const appState = this.options.appState;
      return {
        termsOfService: appState.get("targetTermsOfService") && appState.get("targetTermsOfService").href,
        privacyPolicy: appState.get("targetPrivacyPolicy") && appState.get("targetPrivacyPolicy").href
      };
    }
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/expired-password/Footer.js
var {
  Util: Util3
} = internal.util;
var Footer2 = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-skip" data-se="skip-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "password.expiring.later"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 78
          },
          "end": {
            "line": 1,
            "column": 132
          }
        }
      })) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "passwordWarn") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 143
          }
        }
      })) != null ? stack1 : "") + '<a href="#" class="link help goto js-signout" data-se="signout-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "signout"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 212
          },
          "end": {
            "line": 1,
            "column": 250
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer clearfix",
  events: {
    "click .js-signout": function(e) {
      e.preventDefault();
      const self2 = this;
      const authClient = self2.settings.authClient;
      this.model.doTransaction(function(transaction) {
        return transaction.cancel();
      }).then(function() {
        return authClient.session.exists();
      }).then(function(sessionExists2) {
        if (sessionExists2) {
          return authClient.closeSession().catch(() => {
          });
        }
      }).then(function() {
        if (self2.settings.get("backToSignInUri")) {
          Util3.redirect(self2.settings.get("backToSignInUri"));
        } else {
          self2.state.set("navigateDir", Enums.DIRECTION_BACK);
          self2.options.appState.trigger("navigate", "");
        }
      });
    },
    "click .js-skip": function(e) {
      e.preventDefault();
      this.model.doTransaction(function(transaction) {
        return transaction.skip();
      });
    }
  },
  getTemplateData: function() {
    return {
      passwordWarn: this.options.appState.get("isPwdExpiringSoon")
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/CustomPasswordExpiredController.js
var {
  Util: Util4
} = internal.util;
var CustomPasswordExpiredController = FormController.extend({
  className: "custom-password-expired",
  Model: {},
  Form: {
    noButtonBar: true,
    title: function() {
      const expiringSoon = this.options.appState.get("isPwdExpiringSoon");
      const numDays = this.options.appState.get("passwordExpireDays");
      if (expiringSoon && numDays > 0) {
        return loc3("password.expiring.title", "login", [numDays]);
      } else if (expiringSoon && numDays === 0) {
        return loc3("password.expiring.today", "login");
      } else if (expiringSoon) {
        return loc3("password.expiring.soon", "login");
      } else {
        return this.settings.get("brandName") ? loc3("password.expired.title.specific", "login", [this.settings.get("brandName")]) : loc3("password.expired.title.generic", "login");
      }
    },
    subtitle: function() {
      if (this.options.appState.get("isPwdExpiringSoon")) {
        const subtitle = this.settings.get("brandName") ? loc3("password.expiring.subtitle.specific", "login", [this.settings.get("brandName")]) : loc3("password.expiring.subtitle.generic", "login");
        return subtitle + " " + loc3("password.expired.custom.subtitle", "login");
      }
      return loc3("password.expired.custom.subtitle", "login");
    },
    formChildren: function() {
      return [FormType.Button({
        title: oktaUnderscore.partial(loc3, "password.expired.custom.submit", "login", [this.options.appState.get("passwordExpiredWebsiteName")]),
        className: "button button-primary button-wide",
        attributes: {
          "data-se": "custom-button"
        },
        click: function() {
          Util4.redirect(this.options.appState.get("passwordExpiredLinkUrl"));
        }
      })];
    }
  },
  Footer: Footer2
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/DeviceActivateController.js
var InvalidUserCodeErrorView = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-infobox-error infobox infobox-error" role="alert"><span class="icon error-16"></span><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "api.authn.error.PASSCODE_INVALID"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 110
          },
          "end": {
            "line": 1,
            "column": 173
          }
        }
      })) + "</p></div>";
    },
    "useData": true
  })
});
var DeviceActivateController = FormController.extend({
  className: "device-code-activate",
  Model: function() {
    var _this$options, _this$options$appStat;
    return {
      props: {
        userCode: ["string", true, (_this$options = this.options) === null || _this$options === void 0 ? void 0 : (_this$options$appStat = _this$options.appState) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.get("userCode")],
        stateToken: "string"
      },
      save: function() {
        const self2 = this;
        return this.doTransaction(function(transaction) {
          return transaction.deviceActivate({
            userCode: self2.get("userCode")
          });
        });
      }
    };
  },
  Form: {
    noCancelButton: true,
    autoSave: true,
    save: function() {
      return loc3("oform.next", "login");
    },
    title: function() {
      return loc3("device.code.activate.title", "login");
    },
    subtitle: function() {
      return loc3("device.code.activate.subtitle", "login");
    },
    formChildren: function() {
      if (this.options.appState.get("deviceActivationStatus") === "INVALID_USER_CODE") {
        this.add(InvalidUserCodeErrorView, ".o-form-error-container");
      }
      return [FormType.Input({
        label: loc3("device.code.activate.label", "login"),
        "label-top": true,
        name: "userCode",
        input: TextBox$1,
        inputId: "user-code",
        type: "text",
        inlineValidation: false
      })];
    },
    events: {
      'keyup input[name="userCode"]': function(e) {
        e.preventDefault();
        this.addHyphen(e);
      }
    },
    addHyphen: function(evt) {
      const currentVal = evt.target.value;
      if (currentVal && currentVal.length === 4 && !["Backspace", "Delete", "-"].includes(evt.key)) {
        evt.target.value = currentVal.concat("-");
      }
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/DeviceActivateTerminalController.js
var DEVICE_ACTIVATED = "DEVICE_ACTIVATED";
var DEVICE_NOT_ACTIVATED_CONSENT_DENIED = "DEVICE_NOT_ACTIVATED_CONSENT_DENIED";
var DEVICE_NOT_ACTIVATED = "DEVICE_NOT_ACTIVATED";
var DEVICE_CODE_ERROR_KEYS = [DEVICE_NOT_ACTIVATED_CONSENT_DENIED, DEVICE_NOT_ACTIVATED];
var DeviceActivateTerminalController = FormController.extend({
  className: "device-code-terminal",
  postRender: function() {
    FormController.prototype.postRender.apply(this, arguments);
    const iconClass = this.options.appState.get("deviceActivationStatus") === DEVICE_ACTIVATED ? "success-24-green" : "error-24-red";
    this.$(".o-form-head").before('<div class="device-code-terminal--icon-container"><span class="device-code-terminal--icon ' + iconClass + '"></span></div>');
  },
  Model: {},
  Form: {
    noCancelButton: true,
    noButtonBar: true,
    title: function() {
      const deviceActivationStatus = this.options.appState.get("deviceActivationStatus");
      if (deviceActivationStatus === DEVICE_ACTIVATED) {
        return loc3("device.code.activated.success.title", "login");
      }
      if (oktaUnderscore.contains(DEVICE_CODE_ERROR_KEYS, deviceActivationStatus)) {
        return loc3("device.code.activated.error.title", "login");
      }
    },
    subtitle: function() {
      const deviceActivationStatus = this.options.appState.get("deviceActivationStatus");
      if (deviceActivationStatus === DEVICE_ACTIVATED) {
        return loc3("idx.device.activated", "login");
      }
      if (deviceActivationStatus === DEVICE_NOT_ACTIVATED_CONSENT_DENIED) {
        return loc3("idx.device.not.activated.consent.denied", "login");
      }
      if (deviceActivationStatus === DEVICE_NOT_ACTIVATED) {
        return loc3("idx.device.not.activated.internal.error", "login");
      }
    },
    formChildren: function() {
      return [FormType.View({
        View: View2.extend({
          template: _Handlebars2.template({
            "1": function(container, depth0, helpers2, partials, data) {
              var lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return '<a href="/activate" class="button button-primary text-align-c retry-button" data-se="try-again">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                "name": "i18n",
                "hash": {
                  "bundle": "login",
                  "code": "oie.try.again"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 121
                  },
                  "end": {
                    "line": 1,
                    "column": 165
                  }
                }
              })) + "</a>";
            },
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "isDeviceCodeError") : depth0, {
                "name": "if",
                "hash": {},
                "fn": container.program(1, data, 0),
                "inverse": container.noop,
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 0
                  },
                  "end": {
                    "line": 1,
                    "column": 176
                  }
                }
              })) != null ? stack1 : "";
            },
            "useData": true
          }),
          getTemplateData: function() {
            return {
              isDeviceCodeError: oktaUnderscore.contains(DEVICE_CODE_ERROR_KEYS, this.options.appState.get("deviceActivationStatus"))
            };
          }
        })
      })];
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollCustomFactorController.js
var {
  Util: Util5
} = internal.util;
var EnrollCustomFactorController = FormController.extend({
  className: "enroll-custom-factor",
  Model: {
    local: {
      provider: "string",
      factorType: "string"
    },
    save: function() {
      return this.manageTransaction((transaction, setTransaction) => {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          provider: this.get("provider"),
          factorType: this.get("factorType")
        });
        return factor.enroll().then((trans) => {
          setTransaction(trans);
          const url = this.appState.get("enrollCustomFactorRedirectUrl");
          if (url !== null) {
            Util5.redirect(url);
          }
        }).catch(function(err) {
          throw err;
        });
      });
    }
  },
  Form: function() {
    const factors = this.options.appState.get("factors");
    const factor = factors.findWhere({
      provider: this.options.provider,
      factorType: this.options.factorType
    });
    const vendorName = factor.get("vendorName");
    const subtitle = loc3("enroll.customFactor.subtitle", "login", [vendorName]);
    const saveText = loc3("enroll.customFactor.save", "login");
    return {
      autoSave: true,
      title: vendorName,
      subtitle,
      save: saveText
    };
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      return true;
    }
  },
  initialize: function() {
    this.model.set("provider", this.options.provider);
    this.model.set("factorType", this.options.factorType);
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/Factor.js
var import_q4 = __toESM(require_q());
var PUSH_INTERVAL2 = 4e3;
var FactorFactor = BaseLoginModel.extend({
  extraProperties: true,
  flat: false,
  props: {
    id: "string",
    factorType: {
      type: "string",
      values: ["sms", "call", "email", "token", "token:software:totp", "token:hotp", "token:hardware", "question", "push", "u2f", "password", "assertion:saml2", "assertion:oidc", "claims_provider", "webauthn"]
    },
    provider: {
      type: "string",
      values: ["OKTA", "RSA", "DEL_OATH", "SYMANTEC", "GOOGLE", "YUBICO", "FIDO", "CUSTOM", "GENERIC_SAML", "GENERIC_OIDC"]
    },
    enrollment: {
      type: "string",
      values: ["OPTIONAL", "REQUIRED"]
    },
    status: {
      type: "string",
      values: ["NOT_SETUP", "ACTIVE"]
    },
    profile: ["object"],
    vendorName: "string",
    policy: ["object"],
    profiles: ["object"]
  },
  local: {
    answer: "string",
    password: "string",
    backupFactor: "object",
    showAnswer: "boolean",
    rememberDevice: "boolean",
    autoPush: ["boolean", true, false]
  },
  derived: {
    isOktaFactor: {
      deps: ["provider"],
      fn: function(provider) {
        return provider === "OKTA";
      }
    },
    factorName: {
      deps: ["provider", "factorType"],
      fn: fn2.getFactorName
    },
    factorLabel: {
      deps: ["provider", "factorType", "vendorName"],
      fn: function(provider, factorType, vendorName) {
        if (oktaUnderscore.contains(["DEL_OATH", "GENERIC_SAML", "GENERIC_OIDC", "CUSTOM"], provider)) {
          return vendorName;
        }
        return fn2.getFactorLabel.apply(this, [provider, factorType]);
      }
    },
    factorDescription: {
      deps: ["provider", "factorType"],
      fn: fn2.getFactorDescription
    },
    sortOrder: {
      deps: ["provider", "factorType"],
      fn: fn2.getFactorSortOrder
    },
    iconClassName: {
      deps: ["provider", "factorType"],
      fn: fn2.getFactorIconClassName
    },
    securityQuestion: {
      deps: ["profile", "factorType"],
      fn: function(profile, factorType) {
        if (factorType !== "question") {
          return null;
        }
        return profile && fn2.getSecurityQuestionLabel(profile);
      }
    },
    phoneNumber: {
      deps: ["profile", "factorType"],
      fn: function(profile, factorType) {
        if (oktaUnderscore.contains(["sms", "call"], factorType)) {
          return profile && profile.phoneNumber;
        }
        return null;
      }
    },
    email: {
      deps: ["profile", "factorType"],
      fn: function(profile, factorType) {
        if (factorType === "email") {
          return profile && profile.email;
        }
        return null;
      }
    },
    deviceName: {
      deps: ["profile", "factorType"],
      fn: function(profile, factorType) {
        if (factorType !== "push") {
          return null;
        }
        return profile && profile.name;
      }
    },
    enrolled: {
      deps: ["status"],
      fn: function(status) {
        return status === "ACTIVE";
      }
    },
    cardinality: {
      deps: ["policy", "profiles"],
      fn: function(policy, profiles) {
        if (profiles && profiles.length > 0) {
          const profile = profiles[0];
          const enrolled = profile._embedded.enrolledFactors.length;
          const adoption = oktaUnderscore.findWhere(profile._embedded.features, {
            type: "adoption"
          });
          if (adoption && adoption.cardinality) {
            return {
              enrolled,
              minimum: adoption.cardinality.min,
              maximum: adoption.cardinality.max
            };
          }
          return false;
        } else if (policy && policy.enrollment) {
          return policy.enrollment;
        } else {
          return false;
        }
      }
    },
    additionalEnrollment: {
      deps: ["cardinality"],
      fn: function(cardinality) {
        if (cardinality) {
          return cardinality.enrolled !== 0 && cardinality.enrolled < cardinality.maximum;
        } else {
          return false;
        }
      }
    },
    required: {
      deps: ["enrollment"],
      fn: function(enrollment) {
        return enrollment === "REQUIRED";
      }
    },
    canUseResend: {
      deps: ["provider", "factorType"],
      fn: function(provider, factorType) {
        return provider === "OKTA" && oktaUnderscore.contains(["push", "sms", "call", "email"], factorType);
      }
    },
    isAnswerRequired: {
      deps: ["factorType"],
      fn: function(factorType) {
        return oktaUnderscore.contains(["sms", "call", "email", "token", "token:software:totp", "question"], factorType);
      }
    },
    isFactorTypeVerification: {
      deps: ["provider", "id"],
      fn: function(provider, id) {
        return provider === void 0 && id === void 0;
      }
    }
  },
  parse: function(attributes2) {
    this.settings = attributes2.settings;
    this.appState = attributes2.appState;
    attributes2.rememberDevice = fn2.getRememberDeviceValue(this.appState);
    this.setCustomHotpVendorName(attributes2);
    return oktaUnderscore.omit(attributes2, ["settings", "appState"]);
  },
  validate: function() {
    if (this.get("isAnswerRequired") && !this.get("answer")) {
      return {
        answer: loc3("model.validation.field.blank")
      };
    } else if (this.get("factorType") === "password" && !this.get("password")) {
      return {
        password: loc3("error.password.required")
      };
    }
  },
  needsPasscode: function() {
    return !(this.options.appState.get("isIdxStateToken") && this.get("factorType") === "email");
  },
  resend: function() {
    this.trigger("form:clear-errors");
    return this.manageTransaction(function(transaction) {
      const firstLink = transaction.data._links.resend[0];
      return transaction.resend(firstLink.name);
    });
  },
  save: function() {
    const rememberDevice2 = !!this.get("rememberDevice");
    const self2 = this;
    return this.manageTransaction(function(transaction, setTransaction) {
      const data = {
        rememberDevice: rememberDevice2
      };
      if (this.get("factorType") === "question") {
        data.answer = this.get("answer");
      } else if (this.get("factorType") === "password") {
        data.password = this.get("password");
      } else if (this.needsPasscode()) {
        data.passCode = this.get("answer");
      }
      if (this.pushFactorHasAutoPush()) {
        data.autoPush = this.get("autoPush");
      }
      let promise;
      if (transaction.status === "MFA_REQUIRED" || transaction.status === "FACTOR_REQUIRED" || this.appState.get("promptForFactorInUnauthenticated")) {
        const factor = this._findFactor(transaction);
        promise = factor.verify(data);
      } else if (this.get("canUseResend") && !this.get("answer") && transaction.resend) {
        const firstLink = transaction.data._links.resend[0];
        promise = transaction.resend(firstLink.name);
      } else {
        promise = transaction.verify(data);
      }
      this.trigger("save");
      return promise.then(function(trans) {
        const options2 = {
          delay: PUSH_INTERVAL2,
          transactionCallBack: (transaction2) => {
            self2.options.appState.set("lastAuthResponse", transaction2);
          }
        };
        setTransaction(trans);
        if (trans.status === "MFA_CHALLENGE" && trans.poll || trans.status === "FACTOR_CHALLENGE" && trans.poll) {
          const deferred = import_q4.default.defer();
          const initiatePollTimout = Util2.callAfterTimeout(deferred.resolve, PUSH_INTERVAL2);
          self2.listenToOnce(self2.options.appState, "factorSwitched", () => {
            clearTimeout(initiatePollTimout);
            deferred.reject(new AuthStopPollInitiationError());
          });
          return deferred.promise.then(function() {
            self2.stopListening(self2.options.appState, "factorSwitched");
            if (self2.pushFactorHasAutoPush()) {
              options2.autoPush = function() {
                return self2.get("autoPush");
              };
              options2.rememberDevice = function() {
                return self2.get("rememberDevice");
              };
            }
            return trans.poll(options2).then(function(trans2) {
              self2.options.appState.set("lastAuthResponse", trans2.data);
              setTransaction(trans2);
            });
          });
        }
      });
    });
  },
  _findFactor: function(transaction) {
    let factor;
    if (transaction.factorTypes) {
      factor = oktaUnderscore.findWhere(transaction.factorTypes, {
        factorType: this.get("factorType")
      });
    }
    if (!factor) {
      factor = oktaUnderscore.findWhere(transaction.factors, {
        id: this.get("id")
      });
    }
    return factor;
  },
  pushFactorHasAutoPush: function() {
    return this.settings.get("features.autoPush") && this.get("factorType") === "push";
  },
  setCustomHotpVendorName: function(attributes2) {
    if (attributes2.factorType === "token:hotp" && attributes2.profiles) {
      if (attributes2.status === "NOT_SETUP") {
        attributes2.vendorName = attributes2.profiles[0].name;
      } else if (attributes2.status === "ACTIVE") {
        const enrolledProfiles = attributes2.profiles.filter((profile) => {
          return profile._embedded.enrolledFactors.length > 0;
        });
        attributes2.vendorName = enrolledProfiles[0].name;
      }
    }
    return attributes2;
  }
});
var FactorFactors = Collection2.extend({
  model: FactorFactor,
  comparator: "sortOrder",
  // One override necessary here - When Okta Verify OTP and Push are in the list,
  // they are presented in the view as one factor - in the beacon menu,
  // there's only one option (Okta Verify), and we show a form with Push
  // with an inline totp option. What we need to do is to add totp
  // as a "backupFactor" for push
  parse: function(factors) {
    this.lastUsedFactor = factors[0];
    const oktaPushFactor = oktaUnderscore.findWhere(factors, {
      provider: "OKTA",
      factorType: "push"
    });
    let totpFactor;
    if (oktaUnderscore.where(factors, {
      factorType: "push"
    }).length > 1) {
      totpFactor = oktaUnderscore.findWhere(factors, {
        factorType: "token:software:totp"
      });
    } else {
      totpFactor = oktaUnderscore.findWhere(factors, {
        provider: "OKTA",
        factorType: "token:software:totp"
      });
    }
    if (!oktaPushFactor || !totpFactor) {
      return factors;
    }
    const isTotpFirst = totpFactor === factors[0];
    const parsedFactors = oktaUnderscore.reduce(factors, function(memo, factor) {
      const isOkta = factor.provider === "OKTA";
      const isOktaTotp = isOkta && factor.factorType === "token:software:totp";
      const isOktaPush = isOkta && factor.factorType === "push";
      const notEnrolled = factor.status !== "ACTIVE";
      const hideOktaTotp = isOktaTotp && (notEnrolled || oktaPushFactor.status === "ACTIVE");
      const hideOktaPush = isOktaPush && notEnrolled && totpFactor.status === "ACTIVE";
      if (hideOktaTotp || hideOktaPush) {
        return memo;
      }
      if (isOktaPush) {
        factor.backupFactor = new FactorFactor(totpFactor, {
          parse: true
        });
      }
      memo.push(factor);
      return memo;
    }, []);
    if (isTotpFirst) {
      this.lastUsedFactor = oktaPushFactor;
    }
    return parsedFactors;
  },
  // Will need to update this to use HAL link to get last used factor:
  // https://oktainc.atlassian.net/browse/OKTA-58380
  // However, current code returns last used factor as first factor in list.
  // Also, will need to add priority - i.e. if they do not have a last used
  // factor, should try Okta Verify, then Okta SMS, etc.
  getDefaultFactor: function() {
    const factor = oktaUnderscore.pick(this.lastUsedFactor, "factorType", "provider");
    return this.findWhere(factor);
  },
  getFirstUnenrolledRequiredFactor: function() {
    return this.findWhere({
      required: true,
      enrolled: false
    });
  },
  _getFactorsOfType: function(factorType) {
    return this.where({
      factorType
    });
  },
  getFactorIndex: function(factorType, factorId) {
    return this._getFactorsOfType(factorType).findIndex(function(factor) {
      return factor.get("id") === factorId;
    });
  },
  hasMultipleFactorsOfSameType: function(factorType) {
    return this._getFactorsOfType(factorType).length > 1;
  },
  getFactorByTypeAndIndex: function(factorType, factorIndex) {
    return this._getFactorsOfType(factorType)[factorIndex];
  }
});
var Factor = {
  Model: FactorFactor,
  Collection: FactorFactors
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/HtmlErrorMessageView.js
var template6 = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<span class="icon error-24"></span><h4><strong>' + ((stack1 = (helper = (helper = lookupProperty(helpers2, "message") || (depth0 != null ? lookupProperty(depth0, "message") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "message",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 47
        },
        "end": {
          "line": 1,
          "column": 60
        }
      }
    }) : helper)) != null ? stack1 : "") + "</strong></h4>";
  },
  "useData": true
});
var HtmlErrorMessageView = View2.extend({
  template: template6,
  className: "okta-infobox-error infobox infobox-error infobox-md margin-btm-25",
  attributes: {
    "data-se": "o-form-error-html"
  },
  message: "",
  initialize: function(options2) {
    if (options2 && options2.message) {
      this.message = options2.message;
    }
  },
  getTemplateData: function() {
    return {
      message: this.message
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollActivateCustomFactorController.js
var {
  Util: Util6
} = internal.util;
var EnrollActivateCustomFactorController = EnrollCustomFactorController.extend({
  Model: {
    local: {
      provider: "string",
      factorType: "string"
    },
    save: function() {
      return this.manageTransaction(() => {
        const url = this.appState.get("enrollCustomFactorRedirectUrl");
        if (url !== null) {
          Util6.redirect(url);
        }
      });
    }
  },
  Form: function() {
    const factor = new Factor.Model(this.options.appState.get("factor"), this.toJSON());
    const vendorName = factor.get("vendorName");
    const subtitle = loc3("enroll.customFactor.subtitle", "login", [vendorName]);
    const saveText = loc3("enroll.customFactor.save", "login");
    return {
      autoSave: true,
      title: vendorName,
      subtitle,
      save: saveText,
      formChildren: function() {
        const result = [];
        if (this.options.appState.get("isFactorResultFailed")) {
          result.push(FormType.View({
            View: new HtmlErrorMessageView({
              message: this.options.appState.get("factorResultErrorMessage")
            })
          }, {
            selector: ".o-form-error-container"
          }));
        }
        return result;
      }
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/ResendEmailView.js
var ResendEmailView = View2.extend({
  className: "hide resend-email-infobox",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="infobox infobox-warning" aria-live="polite"><span class="icon warning-16"></span><p><span>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "email.code.not.received"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 102
          },
          "end": {
            "line": 1,
            "column": 156
          }
        }
      })) + '</span><a href="#" class="resend-email-btn">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "email.button.resend"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 200
          },
          "end": {
            "line": 1,
            "column": 250
          }
        }
      })) + "</a></p></div>";
    },
    "useData": true
  }),
  events: {
    "click .resend-email-btn": "resendEmail"
  },
  postRender: function() {
    this.showResendCallout();
  },
  showResendCallout: function() {
    oktaUnderscore.delay(() => {
      this.$el.removeClass("hide");
    }, Enums.API_RATE_LIMIT);
  },
  hideResendCallout: function() {
    this.$el.addClass("hide");
  },
  resendEmail: function(e) {
    e.preventDefault();
    this.hideResendCallout();
    this.model.resend().finally(this.showResendCallout.bind(this));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollActivateEmailController.js
var Model3 = {
  props: {
    passCode: "string"
  },
  resend: function() {
    this.trigger("form:clear-errors");
    return this.doTransaction(function(transaction) {
      return transaction.resend("email");
    });
  },
  save: function() {
    this.trigger("save");
    const formData = this.toJSON();
    return this.doTransaction(function(transaction) {
      return transaction.activate(formData);
    });
  }
};
var Form2 = function() {
  return {
    title: oktaUnderscore.partial(loc3, "email.enroll.title", "login"),
    noButtonBar: false,
    autoSave: true,
    save: oktaUnderscore.partial(loc3, "oform.verify", "login"),
    // TODO: deprecated by mfa.challenge.verify
    formChildren: [
      // message
      FormType.View({
        View: View2.extend({
          className: "enroll-activate-email-content",
          attributes: {
            "data-se": "enroll-activate-email-content"
          },
          // Why use `{{{` for the description?
          // - factorEmail is actually an HTML fragment which
          //   is created via another handlebar template and used for bold the email address.
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                "name": "i18n",
                "hash": {
                  "arguments": "factorEmail",
                  "bundle": "login",
                  "code": "email.mfa.email.sent.description"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 0
                  },
                  "end": {
                    "line": 1,
                    "column": 89
                  }
                }
              })) != null ? stack1 : "";
            },
            "useData": true
          }),
          getTemplateData: function() {
            const factor = this.options.appState.get("factor");
            const factorEmailVal = factor && factor.profile ? factor.profile.email : "";
            const factorEmail = _Handlebars2.template({
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<span class="mask-email">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "email") || (depth0 != null ? lookupProperty(depth0, "email") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
                  "name": "email",
                  "hash": {},
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 25
                    },
                    "end": {
                      "line": 1,
                      "column": 34
                    }
                  }
                }) : helper)) + "</span>";
              },
              "useData": true
            })({
              email: factorEmailVal
            });
            return {
              factorEmail
            };
          }
        })
      }),
      // send again callout message and link button
      FormType.View({
        View: ResendEmailView
      }),
      // passcode input
      FormType.Input({
        label: loc3("email.code.label", "login"),
        "label-top": true,
        name: "passCode",
        type: "text",
        wide: true
      })
    ]
  };
};
var EnrollActivateEmailController = FormController.extend({
  className: "enroll-activate-email",
  Model: Model3,
  Form: Form2,
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/countryCallingCodes.js
var countryCallingCodes = {
  US: "1",
  AG: "1",
  AI: "1",
  AS: "1",
  BB: "1",
  BM: "1",
  BS: "1",
  CA: "1",
  DM: "1",
  DO: "1",
  GD: "1",
  GU: "1",
  JM: "1",
  KN: "1",
  KY: "1",
  LC: "1",
  MP: "1",
  MS: "1",
  PR: "1",
  SX: "1",
  TC: "1",
  TT: "1",
  VC: "1",
  VG: "1",
  VI: "1",
  RU: "7",
  KZ: "7",
  EG: "20",
  ZA: "27",
  GR: "30",
  NL: "31",
  BE: "32",
  FR: "33",
  ES: "34",
  HU: "36",
  IT: "39",
  VA: "39",
  RO: "40",
  CH: "41",
  AT: "43",
  GB: "44",
  GG: "44",
  IM: "44",
  JE: "44",
  DK: "45",
  SE: "46",
  NO: "47",
  SJ: "47",
  PL: "48",
  DE: "49",
  PE: "51",
  MX: "52",
  CU: "53",
  AR: "54",
  BR: "55",
  CL: "56",
  CO: "57",
  VE: "58",
  MY: "60",
  AU: "61",
  CC: "61",
  CX: "61",
  ID: "62",
  PH: "63",
  NZ: "64",
  SG: "65",
  TH: "66",
  JP: "81",
  KR: "82",
  VN: "84",
  CN: "86",
  TR: "90",
  IN: "91",
  PK: "92",
  AF: "93",
  LK: "94",
  MM: "95",
  IR: "98",
  SS: "211",
  MA: "212",
  EH: "212",
  DZ: "213",
  TN: "216",
  LY: "218",
  GM: "220",
  SN: "221",
  MR: "222",
  ML: "223",
  GN: "224",
  CI: "225",
  BF: "226",
  NE: "227",
  TG: "228",
  BJ: "229",
  MU: "230",
  LR: "231",
  SL: "232",
  GH: "233",
  NG: "234",
  TD: "235",
  CF: "236",
  CM: "237",
  CV: "238",
  ST: "239",
  GQ: "240",
  GA: "241",
  CG: "242",
  CD: "243",
  AO: "244",
  GW: "245",
  IO: "246",
  AC: "247",
  SC: "248",
  SD: "249",
  RW: "250",
  ET: "251",
  SO: "252",
  DJ: "253",
  KE: "254",
  TZ: "255",
  UG: "256",
  BI: "257",
  MZ: "258",
  ZM: "260",
  MG: "261",
  RE: "262",
  YT: "262",
  ZW: "263",
  NA: "264",
  MW: "265",
  LS: "266",
  BW: "267",
  SZ: "268",
  KM: "269",
  SH: "290",
  TA: "290",
  ER: "291",
  AW: "297",
  FO: "298",
  GL: "299",
  GI: "350",
  PT: "351",
  LU: "352",
  IE: "353",
  IS: "354",
  AL: "355",
  MT: "356",
  CY: "357",
  FI: "358",
  AX: "358",
  BG: "359",
  LT: "370",
  LV: "371",
  EE: "372",
  MD: "373",
  AM: "374",
  BY: "375",
  AD: "376",
  MC: "377",
  SM: "378",
  UA: "380",
  RS: "381",
  ME: "382",
  XK: "383",
  HR: "385",
  SI: "386",
  BA: "387",
  MK: "389",
  CZ: "420",
  SK: "421",
  LI: "423",
  FK: "500",
  BZ: "501",
  GT: "502",
  SV: "503",
  HN: "504",
  NI: "505",
  CR: "506",
  PA: "507",
  PM: "508",
  HT: "509",
  GP: "590",
  BL: "590",
  MF: "590",
  BO: "591",
  GY: "592",
  EC: "593",
  GF: "594",
  PY: "595",
  MQ: "596",
  SR: "597",
  UY: "598",
  CW: "599",
  BQ: "599",
  TL: "670",
  NF: "672",
  BN: "673",
  NR: "674",
  PG: "675",
  TO: "676",
  SB: "677",
  VU: "678",
  FJ: "679",
  PW: "680",
  WF: "681",
  CK: "682",
  NU: "683",
  WS: "685",
  KI: "686",
  NC: "687",
  TV: "688",
  PF: "689",
  TK: "690",
  FM: "691",
  MH: "692",
  "001": "979",
  KP: "850",
  HK: "852",
  MO: "853",
  KH: "855",
  LA: "856",
  BD: "880",
  TW: "886",
  MV: "960",
  LB: "961",
  JO: "962",
  SY: "963",
  IQ: "964",
  KW: "965",
  SA: "966",
  YE: "967",
  OM: "968",
  PS: "970",
  AE: "971",
  IL: "972",
  BH: "973",
  QA: "974",
  BT: "975",
  MN: "976",
  NP: "977",
  TJ: "992",
  TM: "993",
  AZ: "994",
  GE: "995",
  KG: "996",
  UZ: "998",
  GS: "500",
  PN: "64",
  AQ: "672",
  UM: "1",
  AN: "599"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/CountryUtil.js
var fn4 = {};
fn4.getCountries = function() {
  const countries = oktaUnderscore.omit(Bundles.country, "HM", "BV", "TF");
  let collection = oktaUnderscore.map(countries, function(name, code) {
    return {
      name,
      code
    };
  });
  collection = oktaUnderscore.sortBy(collection, "name");
  const sorted = {};
  oktaUnderscore.each(collection, function(country2) {
    sorted[country2.code] = country2.name;
  });
  return sorted;
};
fn4.getCountryCode = function() {
  const countries = oktaUnderscore.omit(Bundles.country, "HM", "BV", "TF");
  let collection = oktaUnderscore.map(countries, function(name, code) {
    return {
      name,
      code
    };
  });
  collection = oktaUnderscore.sortBy(collection, "name");
  const sorted = {};
  oktaUnderscore.each(collection, function(country2) {
    sorted[country2.code] = loc3("country.option.label", "login", [country2.name, country2.code]);
  });
  return sorted;
};
fn4.getCallingCodeForCountry = function(countryCode) {
  return countryCallingCodes[countryCode];
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/PhoneTextBox.js
var {
  TextBox: TextBox3
} = internal.views.forms.inputs;
var PhoneTextBox = TextBox3.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="okta-form-label-inline o-form-label-inline">' + alias4((helper = (helper = lookupProperty(helpers2, "countryCallingCode") || (depth0 != null ? lookupProperty(depth0, "countryCallingCode") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "countryCallingCode",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 57
          },
          "end": {
            "line": 1,
            "column": 79
          }
        }
      }) : helper)) + '</span><span class="okta-form-input-field input-fix o-form-control"><input type="' + alias4((helper = (helper = lookupProperty(helpers2, "type") || (depth0 != null ? lookupProperty(depth0, "type") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "type",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 160
          },
          "end": {
            "line": 1,
            "column": 168
          }
        }
      }) : helper)) + '" placeholder="' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 183
          },
          "end": {
            "line": 1,
            "column": 198
          }
        }
      }) : helper)) + '" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 206
          },
          "end": {
            "line": 1,
            "column": 214
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 220
          },
          "end": {
            "line": 1,
            "column": 231
          }
        }
      }) : helper)) + '" value="' + alias4((helper = (helper = lookupProperty(helpers2, "value") || (depth0 != null ? lookupProperty(depth0, "value") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "value",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 240
          },
          "end": {
            "line": 1,
            "column": 249
          }
        }
      }) : helper)) + '" autocomplete="tel"></span>';
    },
    "useData": true
  }),
  initialize: function() {
    this.listenTo(this.model, "change:countryCallingCode", function() {
      this.$(".o-form-label-inline").text(this.model.get("countryCallingCode"));
    });
  },
  preRender: function() {
    this.options.countryCallingCode = this.model.get("countryCallingCode");
  },
  postRender: function() {
    this.$el.removeClass("input-fix o-form-control");
    oktaUnderscore.defer(() => {
      this.$el.parent().addClass("o-form-input-group");
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollCallAndSmsController.js
var {
  Keys: Keys2
} = internal.util;
var EnrollCallAndSmsControllerwarningTemplate = View2.extend({
  className: "okta-form-infobox-warning infobox infobox-warning login-timeout-warning",
  attributes: {
    "aria-live": "polite"
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon warning-16"></span><p>' + ((stack1 = (helper = (helper = lookupProperty(helpers2, "warning") || (depth0 != null ? lookupProperty(depth0, "warning") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "warning",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 53
          }
        }
      }) : helper)) != null ? stack1 : "") + "</p>";
    },
    "useData": true
  })
});
var factorIdIsDefined = {
  factorId: function(val) {
    return !oktaUnderscore.isUndefined(val);
  }
};
function isCallFactor(factorType) {
  return factorType === "call";
}
function getClassName(factorType) {
  return isCallFactor(factorType) ? "enroll-call" : "enroll-sms";
}
function sendCode(e) {
  if (Keys2.isEnter(e)) {
    e.stopPropagation();
    e.preventDefault();
    if (e.type === "keyup" && e.data && e.data.model) {
      e.data.model.sendCode();
    }
  }
}
var EnrollCallAndSmsController = FormController.extend({
  className: function() {
    return getClassName(this.options.factorType);
  },
  Model: function() {
    return {
      props: {
        phoneNumber: ["string", true],
        phoneExtension: ["string", false],
        lastEnrolledPhoneNumber: "string",
        passCode: ["string", true],
        factorId: "string"
      },
      local: {
        countryCode: ["string", false, this.options.appState.get("userCountryCode")],
        hasExistingPhones: "boolean",
        trapEnrollment: "boolean",
        ableToResend: "boolean",
        factorType: "string",
        skipPhoneValidation: "boolean"
      },
      derived: {
        countryCallingCode: {
          deps: ["countryCode"],
          fn: function(countryCode) {
            return "+" + fn4.getCallingCodeForCountry(countryCode);
          }
        },
        fullPhoneNumber: {
          deps: ["countryCallingCode", "phoneNumber"],
          fn: function(countryCallingCode, phoneNumber) {
            return phoneNumber ? countryCallingCode + phoneNumber : "";
          }
        },
        enrolled: {
          deps: ["lastEnrolledPhoneNumber", "fullPhoneNumber"],
          fn: function(lastEnrolled, current) {
            return lastEnrolled === current;
          }
        }
      },
      limitResending: function() {
        this.set({
          ableToResend: false
        });
        oktaUnderscore.delay(oktaUnderscore.bind(this.set, this), Enums.API_RATE_LIMIT, {
          ableToResend: true
        });
      },
      sendCode: function() {
        const self2 = this;
        const phoneNumber = this.get("fullPhoneNumber");
        const phoneExtension = this.get("phoneExtension");
        self2.trigger("errors:clear");
        if (!phoneNumber.length) {
          self2.trigger("invalid", self2, {
            phoneNumber: "model.validation.field.blank"
          });
          return;
        }
        return this.doTransaction(function(transaction) {
          const isMfaEnroll = transaction.status === "MFA_ENROLL" || transaction.status === "FACTOR_ENROLL";
          const profileData = {
            phoneNumber,
            updatePhone: isMfaEnroll ? self2.get("hasExistingPhones") : true
          };
          if (isCallFactor(self2.get("factorType"))) {
            profileData["phoneExtension"] = phoneExtension;
          }
          if (self2.get("skipPhoneValidation")) {
            profileData["validatePhone"] = false;
          }
          const doEnroll = function(trans) {
            const factor = oktaUnderscore.findWhere(trans.factors, {
              factorType: self2.get("factorType"),
              provider: "OKTA"
            });
            return factor.enroll({
              profile: profileData
            }).catch(function(error) {
              if (error.errorCode === "E0000098") {
                self2.set("skipPhoneValidation", true);
                error.xhr.responseJSON.errorSummary = loc3("enroll.sms.try_again", "login");
              }
              throw error;
            });
          };
          if (isMfaEnroll) {
            return doEnroll(transaction);
          } else {
            self2.set("trapEnrollment", true);
            return transaction.prev().then(doEnroll).then(function(trans) {
              self2.set("trapEnrollment", false);
              return trans;
            });
          }
        }, true).then(function() {
          self2.set("lastEnrolledPhoneNumber", phoneNumber);
          self2.limitResending();
        }).catch(function() {
          self2.set("trapEnrollment", false);
        });
      },
      resendCode: function() {
        this.trigger("errors:clear");
        this.limitResending();
        return this.doTransaction(function(transaction) {
          return transaction.resend(this.get("factorType"));
        });
      },
      save: function() {
        return this.doTransaction(function(transaction) {
          return transaction.activate({
            passCode: this.get("passCode")
          });
        });
      }
    };
  },
  Form: function() {
    const factorType = this.options.factorType;
    const isCall = isCallFactor(factorType);
    const formTitle = loc3(isCall ? "enroll.call.setup" : "enroll.sms.setup", "login");
    const formSubmit = loc3(isCall ? "mfa.call" : "mfa.sendCode", "login");
    const formRetry = loc3(isCall ? "mfa.redial" : "mfa.resendCode", "login");
    const formSubmitted = loc3(isCall ? "mfa.calling" : "mfa.sent", "login");
    const numberFieldClassName = isCall ? "enroll-call-phone" : "enroll-sms-phone";
    const buttonClassName = isCall ? "call-request-button" : "sms-request-button";
    const formChildren = [FormType.Input({
      name: "countryCode",
      type: "select",
      wide: true,
      options: fn4.getCountries()
    }), FormType.Input({
      label: loc3("mfa.phoneNumber.placeholder", "login"),
      "label-top": true,
      className: numberFieldClassName,
      name: "phoneNumber",
      input: PhoneTextBox,
      type: "text",
      render: function() {
        this.$('input[name="phoneNumber"]').off("keydown keyup", sendCode).keydown(sendCode).keyup({
          model: this.model
        }, sendCode);
      }
    })];
    if (isCall) {
      formChildren.push(FormType.Input({
        label: loc3("mfa.phoneNumber.ext.placeholder", "login"),
        "label-top": true,
        className: "enroll-call-extension",
        name: "phoneExtension",
        input: TextBox$1,
        type: "text"
      }));
    }
    formChildren.push(FormType.Button({
      title: formSubmit,
      attributes: {
        "data-se": buttonClassName
      },
      className: "button button-primary js-enroll-phone margin-top-30 " + buttonClassName,
      click: function() {
        this.model.sendCode();
      }
    }), FormType.Button({
      title: formRetry,
      attributes: {
        "data-se": buttonClassName
      },
      className: "button js-enroll-phone margin-top-30 " + buttonClassName,
      click: function() {
        this.model.resendCode();
      },
      initialize: function() {
        this.$el.css({
          display: "none"
        });
        this.listenTo(this.model, "change:ableToResend", function(model, ableToResend) {
          if (ableToResend) {
            this.options.title = formRetry;
            this.enable();
          } else {
            this.options.title = formSubmitted;
            this.disable();
          }
          this.render();
        });
      }
    }), FormType.Divider({
      showWhen: factorIdIsDefined
    }), FormType.Input({
      label: loc3("mfa.challenge.enterCode.placeholder", "login"),
      "label-top": true,
      explain: Util2.createInputExplain("mfa.challenge.enterCode.tooltip", "mfa.challenge.enterCode.placeholder", "login"),
      "explain-top": true,
      name: "passCode",
      input: TextBox$1,
      type: "tel",
      showWhen: factorIdIsDefined
    }), FormType.Toolbar({
      noCancelButton: true,
      save: loc3("mfa.challenge.verify", "login"),
      showWhen: factorIdIsDefined
    }));
    return {
      title: formTitle,
      noButtonBar: true,
      autoSave: true,
      className: getClassName(factorType),
      showWarning: function(msg) {
        this.clearWarnings();
        this.add(EnrollCallAndSmsControllerwarningTemplate, ".o-form-error-container", {
          options: {
            warning: msg
          }
        });
      },
      clearWarnings: function() {
        this.$(".okta-form-infobox-warning").remove();
      },
      initialize: function() {
        this.listenTo(this.model, "change:ableToResend", function(model, ableToResend) {
          if (ableToResend) {
            this.showWarning(loc3(isCall ? "factor.call.time.warning" : "factor.sms.time.warning", "login"));
          } else {
            this.clearWarnings();
          }
        });
        this.listenTo(this.model, "error errors:clear", function() {
          this.clearWarnings();
          this.clearErrors();
        });
        this.listenTo(this.model, "change:enrolled", function() {
          this.$(".js-enroll-phone").toggle();
        });
      },
      formChildren
    };
  },
  Footer,
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      this.model.set("factorId", this.options.appState.get("activatedFactorId"));
      return true;
    }
    if (this.options.appState.get("isMfaEnroll") && this.model.get("trapEnrollment")) {
      return true;
    }
  },
  initialize: function() {
    if (isCallFactor(this.options.factorType)) {
      this.model.set("hasExistingPhones", this.options.appState.get("hasExistingPhonesForCall"));
    } else {
      this.model.set("hasExistingPhones", this.options.appState.get("hasExistingPhones"));
    }
    this.model.set("factorType", this.options.factorType);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-choices/FactorList.js
var cardinalityTextTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<span class="factor-cardinality">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "cardinalityText") || (depth0 != null ? lookupProperty(depth0, "cardinalityText") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "cardinalityText",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 33
        },
        "end": {
          "line": 1,
          "column": 52
        }
      }
    }) : helper)) + "</span>";
  },
  "useData": true
});
var FactorListFactorRow = View2.extend({
  tagName: "li",
  className: "enroll-factor-row clearfix",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "factorDescription") || (depth0 != null ? lookupProperty(depth0, "factorDescription") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "factorDescription",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 235
          },
          "end": {
            "line": 1,
            "column": 256
          }
        }
      }) : helper)) + "</p>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="enroll-factor-icon-container"><div class="factor-icon enroll-factor-icon ' + alias4((helper = (helper = lookupProperty(helpers2, "iconClassName") || (depth0 != null ? lookupProperty(depth0, "iconClassName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "iconClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 85
          },
          "end": {
            "line": 1,
            "column": 102
          }
        }
      }) : helper)) + '"></div></div><div class="enroll-factor-description"><h3 class="enroll-factor-label">' + alias4((helper = (helper = lookupProperty(helpers2, "factorLabel") || (depth0 != null ? lookupProperty(depth0, "factorLabel") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "factorLabel",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 187
          },
          "end": {
            "line": 1,
            "column": 202
          }
        }
      }) : helper)) + "</h3>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "factorDescription") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 207
          },
          "end": {
            "line": 1,
            "column": 267
          }
        }
      })) != null ? stack1 : "") + '<div class="enroll-factor-button"></div></div>';
    },
    "useData": true
  }),
  attributes: function() {
    return {
      "data-se": this.model.get("factorName")
    };
  },
  children: function() {
    const children = [];
    const enrolled = this.model.get("enrolled");
    const required = this.model.get("required");
    const cardinality = this.model.get("cardinality");
    if (this.options.showInlineSetupButton) {
      return [[createButton2({
        className: "button",
        title: this.getSetupButtonText(),
        click: function() {
          this.options.appState.trigger("navigate", fn3.createEnrollFactorUrl(this.model.get("provider"), this.model.get("factorType")));
        }
      }), ".enroll-factor-button"]];
    } else if (enrolled) {
      children.push(['<span class="icon success-16-green"></span>', ".enroll-factor-label"]);
    } else if (required) {
      children.push(['<span class="icon success-16-gray"></span>', ".enroll-factor-label"]);
    }
    const cardinalityText = fn2.getCardinalityText(enrolled, required, cardinality);
    if (cardinalityText) {
      children.push([cardinalityTextTpl({
        cardinalityText
      }), ".enroll-factor-description"]);
    }
    return children;
  },
  minimize: function() {
    this.$el.addClass("enroll-factor-row-min");
  },
  maximize: function() {
    this.$el.removeClass("enroll-factor-row-min");
  },
  getSetupButtonText: function() {
    return this.model.get("additionalEnrollment") ? loc3("enroll.choices.setup.another", "login") : loc3("enroll.choices.setup", "login");
  }
});
var FactorList = Backbone_ListView.extend({
  className: "enroll-factor-list",
  item: FactorListFactorRow,
  itemSelector: ".list-content",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<h3 class="list-title">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "listTitle") || (depth0 != null ? lookupProperty(depth0, "listTitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "listTitle",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 53
          }
        }
      }) : helper)) + "</h3>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "listTitle") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 65
          }
        }
      })) != null ? stack1 : "") + '<ul class="list-content"></ul>';
    },
    "useData": true
  }),
  getTemplateData: function() {
    const json = Backbone_ListView.prototype.getTemplateData.call(this);
    oktaUnderscore.extend(json, this);
    return json;
  },
  postRender: function() {
    if (this.options.minimize) {
      this.invoke("minimize");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-choices/Footer.js
var Footer3 = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link goto js-skip" data-se="skip-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.choices.setup.skip"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 114
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer clearfix",
  events: {
    "click .js-skip": function(e) {
      e.preventDefault();
      this.model.doTransaction(function(transaction) {
        return transaction.skip();
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-choices/RequiredFactorList.js
var RequiredFactorList = FactorList.extend({
  listTitle: oktaUnderscore.partial(loc3, "enroll.choices.list.setup", "login"),
  className: function() {
    return FactorList.prototype.className + " enroll-required-factor-list";
  },
  postRender: function() {
    let currentModel;
    let currentRow;
    FactorList.prototype.postRender.apply(this, arguments);
    currentModel = this.options.appState.get("factors").getFirstUnenrolledRequiredFactor();
    currentRow = this.find(function(view) {
      return view.model === currentModel;
    });
    currentRow.maximize();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollChoicesController.js
var subtitleTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "<span>" + ((stack1 = (helper = (helper = lookupProperty(helpers2, "subtitle") || (depth0 != null ? lookupProperty(depth0, "subtitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "subtitle",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 6
        },
        "end": {
          "line": 1,
          "column": 20
        }
      }
    }) : helper)) != null ? stack1 : "") + "</span>";
  },
  "useData": true
});
var EnrollChoicesController = FormController.extend({
  className: "enroll-choices",
  state: {
    pageType: null
  },
  Model: {},
  Form: {
    noCancelButton: true,
    title: oktaUnderscore.partial(loc3, "enroll.choices.title", "login"),
    noButtonBar: function() {
      return this.state.get("pageType") === Enums.ALL_OPTIONAL_NONE_ENROLLED;
    },
    subtitle: " ",
    getSubtitle: function() {
      switch (this.state.get("pageType")) {
        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
          return loc3("enroll.choices.optional", "login");
        case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED: {
          const remainingDays = this.options.appState.get("gracePeriodRemainingDays");
          return Number.isInteger(remainingDays) && remainingDays >= 0 ? this.getGracePeriodSubtitle(remainingDays) : this.getDefaultSubtitle();
        }
        default:
          return this.getDefaultSubtitle();
      }
    },
    getDefaultSubtitle: function() {
      return this.settings.get("brandName") ? loc3("enroll.choices.description.specific", "login", [this.settings.get("brandName")]) : loc3("enroll.choices.description.generic", "login");
    },
    getGracePeriodSubtitle: function(remainingDays) {
      return remainingDays >= 1 ? loc3("enroll.choices.description.gracePeriod.bold", "login", [remainingDays]) : loc3("enroll.choices.description.gracePeriod.oneDay.bold", "login");
    },
    save: function() {
      switch (this.state.get("pageType")) {
        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
          return loc3("enroll.choices.submit.finish", "login");
        case Enums.HAS_REQUIRED_NONE_ENROLLED:
          return loc3("enroll.choices.submit.configure", "login");
        case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
          return loc3("enroll.choices.submit.next", "login");
        default:
          return "";
      }
    },
    initialize: function(options2) {
      this.listenTo(this, "save", function() {
        let current;
        switch (this.state.get("pageType")) {
          case Enums.HAS_REQUIRED_NONE_ENROLLED:
          case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
            current = options2.appState.get("factors").getFirstUnenrolledRequiredFactor();
            options2.appState.trigger("navigate", fn3.createEnrollFactorUrl(current.get("provider"), current.get("factorType")));
            break;
          default:
            return this.model.doTransaction(function(transaction) {
              return transaction.skip();
            });
        }
      });
    },
    preRender: function() {
      this.add(subtitleTpl({
        subtitle: this.getSubtitle()
      }), "p.okta-form-subtitle");
      const factors = this.options.appState.get("factors");
      switch (this.state.get("pageType")) {
        case Enums.HAS_REQUIRED_NONE_ENROLLED:
        case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
          this.add(new RequiredFactorList({
            minimize: true,
            collection: new Collection2(factors.where({
              required: true
            })),
            appState: this.options.appState
          }));
          break;
        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
        case Enums.ALL_OPTIONAL_NONE_ENROLLED: {
          const enrolled = factors.where({
            enrolled: true
          });
          const notEnrolled = factors.filter(function(factor) {
            return !factor.get("enrolled") || factor.get("additionalEnrollment");
          });
          let notEnrolledListTitle;
          if (enrolled.length > 0) {
            notEnrolledListTitle = loc3("enroll.choices.list.optional", "login");
            this.add(new FactorList({
              listTitle: loc3("enroll.choices.list.enrolled", "login"),
              minimize: true,
              collection: new Collection2(enrolled),
              appState: this.options.appState
            }));
          }
          this.add(new FactorList({
            listTitle: notEnrolledListTitle,
            collection: new Collection2(notEnrolled),
            appState: this.options.appState,
            showInlineSetupButton: true
          }));
          break;
        }
      }
    }
  },
  initialize: function(options2) {
    let numRequiredEnrolled = 0;
    let numRequiredNotEnrolled = 0;
    let numOptionalEnrolled = 0;
    let numOptionalNotEnrolled = 0;
    let hasRequired;
    let pageType;
    options2.appState.get("factors").each(function(factor) {
      const required = factor.get("required");
      const enrolled = factor.get("enrolled");
      const additionalEnrollment = factor.get("additionalEnrollment");
      if (required && enrolled) {
        numRequiredEnrolled++;
      } else if (required && !enrolled) {
        numRequiredNotEnrolled++;
      } else if (!required && enrolled) {
        numOptionalEnrolled++;
      } else if (!required && !enrolled) {
        numOptionalNotEnrolled++;
      }
      if (enrolled && additionalEnrollment) {
        numOptionalNotEnrolled++;
      }
    });
    hasRequired = numRequiredEnrolled > 0 || numRequiredNotEnrolled > 0;
    if (hasRequired && numRequiredEnrolled === 0) {
      pageType = Enums.HAS_REQUIRED_NONE_ENROLLED;
    } else if (hasRequired && numRequiredNotEnrolled > 0) {
      pageType = Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED;
    } else if (hasRequired && numOptionalNotEnrolled > 0) {
      pageType = Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED;
    } else if (numOptionalEnrolled === 0 && numOptionalNotEnrolled > 0) {
      pageType = Enums.ALL_OPTIONAL_NONE_ENROLLED;
    } else if (numOptionalNotEnrolled > 0) {
      pageType = Enums.ALL_OPTIONAL_SOME_ENROLLED;
    } else {
      this.model.doTransaction(function(transaction) {
        return transaction.skip();
      });
    }
    this.state.set("pageType", pageType);
    if (this.options.appState.get("skipLink") && pageType === Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED) {
      this.add(new Footer3(this.toJSON()));
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/_virtual/_commonjsHelpers.js
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

// node_modules/@okta/okta-signin-widget/dist/esm/_virtual/index.js
var duo_web_sdk = { exports: {} };

// node_modules/@okta/okta-signin-widget/dist/esm/packages/vendor/duo_web_sdk/index.js
(function(root, factory) {
  duo_web_sdk.exports = factory();
})(commonjsGlobal2, function() {
  var DUO_MESSAGE_FORMAT = /^(?:AUTH|ENROLL)+\|[A-Za-z0-9\+\/=]+\|[A-Za-z0-9\+\/=]+$/;
  var DUO_ERROR_FORMAT = /^ERR\|[\w\s\.\(\)]+$/;
  var DUO_OPEN_WINDOW_FORMAT = /^DUO_OPEN_WINDOW\|/;
  var VALID_OPEN_WINDOW_DOMAINS = ["duo.com", "duosecurity.com", "duomobile.s3-us-west-1.amazonaws.com"];
  var postAction, postArgument, host, duoSig, appSig, iframe;
  initializeStatefulVariables();
  function initializeStatefulVariables() {
    postAction = "";
    postArgument = "sig_response";
    host = void 0;
    duoSig = void 0;
    appSig = void 0;
    iframe = void 0;
  }
  function throwError(message, givenUrl) {
    var url = givenUrl || "https://www.duosecurity.com/docs/duoweb#3.-show-the-iframe";
    throw new Error("Duo Web SDK error: " + message + (url ? "\nSee " + url + " for more information" : ""));
  }
  function hyphenize(str) {
    return str.replace(/([a-z])([A-Z])/, "$1-$2").toLowerCase();
  }
  function getDataAttribute(element, name) {
    if ("dataset" in element) {
      return element.dataset[name];
    } else {
      return element.getAttribute("data-" + hyphenize(name));
    }
  }
  function on(context, event, fallbackEvent, callback) {
    if ("addEventListener" in window) {
      context.addEventListener(event, callback, false);
    } else {
      context.attachEvent(fallbackEvent, callback);
    }
  }
  function off(context, event, fallbackEvent, callback) {
    if ("removeEventListener" in window) {
      context.removeEventListener(event, callback, false);
    } else {
      context.detachEvent(fallbackEvent, callback);
    }
  }
  function onReady(callback) {
    on(document, "DOMContentLoaded", "onreadystatechange", callback);
  }
  function offReady(callback) {
    off(document, "DOMContentLoaded", "onreadystatechange", callback);
  }
  function onMessage(callback) {
    on(window, "message", "onmessage", callback);
  }
  function offMessage(callback) {
    off(window, "message", "onmessage", callback);
  }
  function parseSigRequest(sig) {
    if (!sig) {
      return;
    }
    if (sig.indexOf("ERR|") === 0) {
      throwError(sig.split("|")[1]);
    }
    if (sig.indexOf(":") === -1 || sig.split(":").length !== 2) {
      throwError("Duo was given a bad token.  This might indicate a configuration problem with one of Duo's client libraries.");
    }
    var sigParts = sig.split(":");
    duoSig = sigParts[0];
    appSig = sigParts[1];
    return {
      sigRequest: sig,
      duoSig: sigParts[0],
      appSig: sigParts[1]
    };
  }
  function isDuoMessage(event) {
    return Boolean(event.origin === "https://" + host && typeof event.data === "string" && (event.data.match(DUO_MESSAGE_FORMAT) || event.data.match(DUO_ERROR_FORMAT) || event.data.match(DUO_OPEN_WINDOW_FORMAT)));
  }
  function init(options2) {
    initializeStatefulVariables();
    if (options2) {
      if (options2.host) {
        host = options2.host;
      }
      if (options2.sig_request) {
        parseSigRequest(options2.sig_request);
      }
      if (options2.post_action) {
        postAction = options2.post_action;
      }
      if (options2.post_argument) {
        postArgument = options2.post_argument;
      }
      if (typeof options2.submit_callback === "function")
        ;
    }
    var promptElement = getPromptElement(options2);
    if (promptElement) {
      ready(promptElement, options2.iframeAttributes || {});
    } else {
      asyncReady(options2);
    }
    offReady(init);
  }
  function getPromptElement(options2) {
    var result;
    if (options2.iframe && options2.iframeContainer) {
      throwError("Passing both `iframe` and `iframeContainer` arguments at the same time is not allowed.");
    } else if (options2.iframe) {
      result = getUserDefinedElement(options2.iframe);
      validateIframe(result);
    } else if (options2.iframeContainer) {
      result = getUserDefinedElement(options2.iframeContainer);
      validateIframeContainer(result);
    } else {
      result = document.getElementById("duo_iframe");
    }
    return result;
  }
  function getUserDefinedElement(object) {
    if (object.tagName) {
      return object;
    } else if (typeof object == "string") {
      return document.getElementById(object);
    }
    return null;
  }
  function isIframe(element) {
    return element && element.tagName && element.tagName.toLowerCase() === "iframe";
  }
  function validateIframe(element) {
    if (element && !isIframe(element)) {
      throwError("`iframe` only accepts an iframe element or the id of an iframe. To use a non-iframe element, use the `iframeContainer` argument.");
    }
  }
  function validateIframeContainer(element) {
    if (element && isIframe(element)) {
      throwError("`iframeContainer` only accepts a non-iframe element or the id of a non-iframe. To use a non-iframe element, use the `iframeContainer` argument on Duo.init().");
    }
  }
  function generateIframeSrc() {
    return ["https://", host, "/frame/web/v1/auth?tx=", duoSig, "&parent=", encodeURIComponent(document.location.href), "&v=2.8"].join("");
  }
  function onReceivedMessage(event) {
    if (isDuoMessage(event)) {
      if (event.data.match(DUO_OPEN_WINDOW_FORMAT)) {
        var url = event.data.substring("DUO_OPEN_WINDOW|".length);
        if (isValidUrlToOpen(url)) {
          window.open(url, "_self");
        }
      } else {
        doPostBack(event.data);
        offMessage(onReceivedMessage);
      }
    }
  }
  function isValidUrlToOpen(url) {
    if (!url) {
      return false;
    }
    var parser = document.createElement("a");
    parser.href = url;
    if (parser.protocol === "duotrustedendpoints:") {
      return true;
    } else if (parser.protocol !== "https:") {
      return false;
    }
    for (var i = 0; i < VALID_OPEN_WINDOW_DOMAINS.length; i++) {
      if (parser.hostname.endsWith("." + VALID_OPEN_WINDOW_DOMAINS[i]) || parser.hostname === VALID_OPEN_WINDOW_DOMAINS[i]) {
        return true;
      }
    }
    return false;
  }
  function asyncReady(options2) {
    var callback = function() {
      var promptElement = getPromptElement(options2);
      if (!promptElement) {
        throwError('This page does not contain an iframe for Duo to use. Add an element like <iframe id="duo_iframe"></iframe> to this page.');
      }
      ready(promptElement, options2.iframeAttributes || {});
      offReady(callback);
    };
    onReady(callback);
  }
  function ready(promptElement, iframeAttributes) {
    if (!host) {
      host = getDataAttribute(promptElement, "host");
      if (!host) {
        throwError("No API hostname is given for Duo to use.  Be sure to pass a `host` parameter to Duo.init, or through the `data-host` attribute on the iframe element.");
      }
    }
    if (!duoSig || !appSig) {
      parseSigRequest(getDataAttribute(promptElement, "sigRequest"));
      if (!duoSig || !appSig) {
        throwError("No valid signed request is given.  Be sure to give the `sig_request` parameter to Duo.init, or use the `data-sig-request` attribute on the iframe element.");
      }
    }
    if (postAction === "") {
      postAction = getDataAttribute(promptElement, "postAction") || postAction;
    }
    if (postArgument === "sig_response") {
      postArgument = getDataAttribute(promptElement, "postArgument") || postArgument;
    }
    if (isIframe(promptElement)) {
      iframe = promptElement;
      iframe.src = generateIframeSrc();
    } else {
      while (promptElement.firstChild) {
        promptElement.removeChild(promptElement.firstChild);
      }
      iframe = document.createElement("iframe");
      iframeAttributes["src"] = generateIframeSrc();
      for (var name in iframeAttributes) {
        iframe.setAttribute(name, iframeAttributes[name]);
      }
      promptElement.appendChild(iframe);
    }
    onMessage(onReceivedMessage);
  }
  function doPostBack(response) {
    postAction(response + ":" + appSig);
  }
  return {
    init,
    _onReady: onReady,
    _parseSigRequest: parseSigRequest,
    _isDuoMessage: isDuoMessage,
    _doPostBack: doPostBack
  };
});
var Duo = duo_web_sdk.exports;

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollDuoController.js
var import_q5 = __toESM(require_q());
var EnrollDuoController = FormController.extend({
  className: "enroll-duo duo-form",
  Model: {
    props: {
      host: "string",
      signature: "string",
      postAction: "string",
      factorId: "string",
      stateToken: "string"
    },
    getInitOptions: function() {
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "web",
          provider: "DUO"
        });
        return factor.enroll();
      });
    },
    activate: function(signedResponse) {
      const url = this.get("postAction");
      const factorId = this.get("factorId");
      const self2 = this;
      const data = {
        id: factorId,
        stateToken: this.get("stateToken"),
        sig_response: signedResponse
      };
      return (0, import_q5.default)(oktaJQueryStatic.post(url, data)).then(function() {
        return self2.doTransaction(function(transaction) {
          return transaction.poll();
        });
      }).catch(function(err) {
        self2.trigger("error", self2, err.xhr);
      });
    }
  },
  Form: {
    autoSave: true,
    noButtonBar: true,
    title: oktaUnderscore.partial(loc3, "enroll.duo.title", "login"),
    postRender: function() {
      this.add('<iframe frameborder="0" title="' + this.title() + '"></iframe>');
      Duo.init({
        host: this.model.get("host"),
        sig_request: this.model.get("signature"),
        iframe: this.$("iframe").get(0),
        post_action: oktaUnderscore.bind(this.model.activate, this.model)
      });
    }
  },
  Footer,
  fetchInitialData: function() {
    const self2 = this;
    return this.model.getInitOptions(this.options.appState).then(function(trans) {
      const res = trans.data;
      if (!res || !res._embedded || !res._embedded.factor || !res._embedded.factor._embedded || !res._embedded.factor._embedded.activation) {
        throw new Error("Response does not have duo activation options");
      }
      const factor = res._embedded.factor;
      const activation = factor._embedded.activation;
      self2.model.set({
        host: activation.host,
        signature: activation.signature,
        postAction: activation._links.complete.href,
        factorId: factor.id,
        stateToken: res.stateToken
      });
    });
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollEmailController.js
var Model4 = {
  local: {
    factorType: "string",
    provider: "string"
  },
  save: function() {
    this.trigger("save");
    const factorOpt = this.pick("factorType", "provider");
    return this.doTransaction(function(transaction) {
      const factor = oktaUnderscore.findWhere(transaction.factors, factorOpt);
      return factor.enroll();
    });
  }
};
var Form3 = function() {
  return {
    title: oktaUnderscore.partial(loc3, "email.enroll.title", "login"),
    noButtonBar: false,
    autoSave: true,
    save: oktaUnderscore.partial(loc3, "email.button.send", "login"),
    formChildren: [FormType.View({
      View: View2.extend({
        attributes: {
          "data-se": "enroll-email-content"
        },
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "email.enroll.description"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 0
                },
                "end": {
                  "line": 1,
                  "column": 55
                }
              }
            }));
          },
          "useData": true
        })
      })
    })]
  };
};
var EnrollEmailController = FormController.extend({
  className: "enroll-email",
  Model: Model4,
  Form: Form3,
  Footer,
  initialize: function() {
    this.model.set(oktaUnderscore.pick(this.options, "factorType", "provider"));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollHotpController.js
var EnrollHotpController = FormController.extend({
  className: "enroll-hotp",
  Model: function() {
    return {
      local: {
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      }
    };
  },
  Form: {
    title: function() {
      const factors = this.options.appState.get("factors");
      const hotpFactor = factors.findWhere({
        provider: this.model.get("__provider__"),
        factorType: this.model.get("__factorType__")
      });
      return loc3("enroll.totp.title", "login", [hotpFactor.get("factorLabel")]);
    },
    noButtonBar: true,
    attributes: {
      "data-se": "restrict-enroll"
    },
    formChildren: function() {
      const children = [FormType.View({
        View: new HtmlErrorMessageView({
          message: loc3("enroll.hotp.restricted", "login")
        })
      })];
      return children;
    }
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollOnPremController.js
function isRSA(provider) {
  return provider === "RSA";
}
function getClassName2(provider) {
  return isRSA(provider) ? "enroll-rsa" : "enroll-onprem";
}
var EnrollOnPremController = FormController.extend({
  className: function() {
    return getClassName2(this.options.provider);
  },
  Model: function() {
    const provider = this.options.provider;
    const factors = this.options.appState.get("factors");
    const factor = factors.findWhere(oktaUnderscore.pick(this.options, "provider", "factorType"));
    const profile = factor.get("profile");
    const credentialId = profile && profile.credentialId ? profile.credentialId : "";
    return {
      props: {
        credentialId: ["string", true, credentialId],
        passCode: ["string", true],
        factorId: "string"
      },
      save: function() {
        return this.doTransaction(function(transaction) {
          const factor2 = oktaUnderscore.findWhere(transaction.factors, {
            factorType: "token",
            provider
          });
          return factor2.enroll({
            passCode: this.get("passCode"),
            profile: {
              credentialId: this.get("credentialId")
            }
          });
        });
      }
    };
  },
  Form: function() {
    const provider = this.options.provider;
    const factors = this.options.appState.get("factors");
    const factor = factors.findWhere(oktaUnderscore.pick(this.options, "provider", "factorType"));
    const vendorName = factor.get("vendorName");
    const title = isRSA(provider) ? loc3("factor.totpHard.rsaSecurId", "login") : vendorName;
    return {
      title,
      noButtonBar: true,
      autoSave: true,
      className: getClassName2(provider),
      initialize: function() {
        this.listenTo(this.model, "error", (source, error) => {
          if (error && error.status === 409) {
            this.$(".o-form-input-name-passCode input").val("");
            this.$(".o-form-input-name-passCode input").trigger("change");
            this.$(".o-form-input-name-passCode input").focus();
          }
        });
      },
      formChildren: [FormType.Input({
        label: loc3("enroll.onprem.username.placeholder", "login", [vendorName]),
        "label-top": true,
        explain: Util2.createInputExplain("enroll.onprem.username.tooltip", "enroll.onprem.username.placeholder", "login", [vendorName], [vendorName]),
        "explain-top": true,
        name: "credentialId",
        input: TextBox$1,
        type: "text"
      }), FormType.Input({
        label: loc3("enroll.onprem.passcode.placeholder", "login", [vendorName]),
        "label-top": true,
        explain: Util2.createInputExplain("enroll.onprem.passcode.tooltip", "enroll.onprem.passcode.placeholder", "login", [vendorName], [vendorName]),
        "explain-top": true,
        name: "passCode",
        input: TextBox$1,
        type: "password"
      }), FormType.Toolbar({
        noCancelButton: true,
        save: loc3("mfa.challenge.verify", "login")
      })]
    };
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/ValidationUtil.js
var fn5 = {};
fn5.validateUsername = function(model) {
  const username = model.get("username");
  if (username && username.length > 256) {
    return {
      username: loc3("model.validation.field.username", "login")
    };
  }
};
fn5.validateFieldsMatch = function(model, field1, field2, message) {
  if (model.get(field1) !== model.get(field2)) {
    const ret = {};
    ret[field2] = message;
    return ret;
  }
};
fn5.validatePasswordMatch = function(model) {
  return fn5.validateFieldsMatch(model, "newPassword", "confirmPassword", loc3("password.error.match", "login"));
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollPasswordController.js
var EnrollPasswordController = FormController.extend({
  className: "enroll-password",
  Model: {
    props: {
      password: ["string", true],
      confirmPassword: ["string", true]
    },
    validate: function() {
      return fn5.validateFieldsMatch(this, "password", "confirmPassword", loc3("password.enroll.error.match", "login"));
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "password",
          provider: "OKTA"
        });
        return factor.enroll({
          profile: {
            password: this.get("password")
          }
        });
      });
    }
  },
  Form: {
    autoSave: true,
    title: oktaUnderscore.partial(loc3, "enroll.password.setup", "login"),
    inputs: function() {
      return [{
        label: loc3("mfa.challenge.password.placeholder", "login"),
        "label-top": true,
        className: "o-form-fieldset o-form-label-top auth-passcode",
        name: "password",
        input: TextBox$1,
        type: "password"
      }, {
        label: loc3("password.confirmPassword.placeholder", "login"),
        "label-top": true,
        className: "o-form-fieldset o-form-label-top auth-passcode",
        name: "confirmPassword",
        input: TextBox$1,
        type: "password"
      }];
    }
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollQuestionController.js
var EnrollQuestionController = FormController.extend({
  className: "enroll-question",
  Model: {
    props: {
      question: "string",
      answer: ["string", true]
    },
    local: {
      securityQuestions: "object"
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "question",
          provider: "OKTA"
        });
        return factor.enroll({
          profile: {
            question: this.get("question"),
            answer: this.get("answer")
          }
        });
      });
    }
  },
  Form: {
    autoSave: true,
    title: oktaUnderscore.partial(loc3, "enroll.securityQuestion.setup", "login"),
    inputs: function() {
      return [{
        label: false,
        "label-top": true,
        name: "question",
        type: "select",
        wide: true,
        options: function() {
          return this.model.get("securityQuestions");
        },
        params: {
          searchThreshold: 25
        }
      }, {
        label: loc3("mfa.challenge.answer.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("mfa.challenge.answer.tooltip", "mfa.challenge.answer.placeholder", "login"),
        "explain-top": true,
        className: "o-form-fieldset o-form-label-top auth-passcode",
        name: "answer",
        input: TextBox$1,
        type: "text"
      }];
    }
  },
  Footer,
  fetchInitialData: function() {
    const self2 = this;
    return this.model.manageTransaction(function(transaction) {
      const factor = oktaUnderscore.findWhere(transaction.factors, {
        factorType: "question",
        provider: "OKTA"
      });
      return factor.questions();
    }).then(function(questionsRes) {
      const questions = {};
      oktaUnderscore.each(questionsRes, function(question) {
        questions[question.question] = fn2.getSecurityQuestionLabel(question);
      });
      self2.model.set("securityQuestions", questions);
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollSymantecVipController.js
var EnrollSymantecVipController = FormController.extend({
  className: "enroll-symantec",
  Model: {
    props: {
      credentialId: ["string", true],
      passCode: ["string", true],
      nextPassCode: ["string", true],
      factorId: "string"
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "token",
          provider: "SYMANTEC"
        });
        return factor.enroll({
          passCode: this.get("passCode"),
          nextPassCode: this.get("nextPassCode"),
          profile: {
            credentialId: this.get("credentialId")
          }
        });
      });
    }
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "factor.totpHard.symantecVip", "login"),
    subtitle: oktaUnderscore.partial(loc3, "enroll.symantecVip.subtitle", "login"),
    noButtonBar: true,
    autoSave: true,
    className: "enroll-symantec",
    formChildren: function() {
      return [FormType.Input({
        label: loc3("enroll.symantecVip.credentialId.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("enroll.symantecVip.credentialId.tooltip", "enroll.symantecVip.credentialId.placeholder", "login"),
        "explain-top": true,
        name: "credentialId",
        input: TextBox$1,
        type: "text"
      }), FormType.Input({
        label: loc3("enroll.symantecVip.passcode1.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("enroll.symantecVip.passcode1.tooltip", "enroll.symantecVip.passcode1.placeholder", "login"),
        "explain-top": true,
        name: "passCode",
        input: TextBox$1,
        type: "text"
      }), FormType.Input({
        label: loc3("enroll.symantecVip.passcode2.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("enroll.symantecVip.passcode2.tooltip", "enroll.symantecVip.passcode2.placeholder", "login"),
        "explain-top": true,
        name: "nextPassCode",
        input: TextBox$1,
        type: "text"
      }), FormType.Toolbar({
        noCancelButton: true,
        save: loc3("mfa.challenge.verify", "login")
      })];
    }
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/StoreLinks.js
var StoreLinks = {
  OKTA: {
    APPLE: "https://itunes.apple.com/us/app/okta-verify/id490179405",
    ANDROID: "https://play.google.com/store/apps/details?id=com.okta.android.auth"
  },
  GOOGLE: {
    APPLE: "https://itunes.apple.com/us/app/google-authenticator/id388497605",
    ANDROID: "https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2"
  },
  STORE: {
    APPLE: "App Store",
    ANDROID: "Google Play Store"
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollTotpController.js
var showWhenDeviceTypeSelected = {
  __deviceType__: function(val) {
    return val !== void 0;
  }
};
var EnrollTotpControllerAppDownloadInstructionsView = View2.extend({
  attributes: {
    "data-se": "app-download-instructions"
  },
  className: "app-download-instructions",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="app-logo ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "appIcon") || (depth0 != null ? lookupProperty(depth0, "appIcon") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "appIcon",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 22
          },
          "end": {
            "line": 1,
            "column": 33
          }
        }
      }) : helper)) + '"></span><p class="instructions">' + ((stack1 = (helper = (helper = lookupProperty(helpers2, "appStoreLinkText") || (depth0 != null ? lookupProperty(depth0, "appStoreLinkText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "appStoreLinkText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 66
          },
          "end": {
            "line": 1,
            "column": 88
          }
        }
      }) : helper)) != null ? stack1 : "") + "</p>";
    },
    "useData": true
  }),
  initialize: function() {
    this.listenTo(this.model, "change:__deviceType__", this.render);
  },
  postRender: function() {
    const link = this.$el.find(".instructions a");
    if (link.length) {
      link[0].setAttribute("target", "_blank");
      link[0].setAttribute("rel", "noreferer noopener");
    }
  },
  getTemplateData: function() {
    let appStoreLink;
    let appIcon;
    let appStoreName;
    const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
    appStoreName = StoreLinks.STORE[this.model.get("__deviceType__")];
    if (this.model.get("__provider__") === "GOOGLE") {
      appStoreLink = StoreLinks.GOOGLE[this.model.get("__deviceType__")];
      appIcon = "google-auth-38";
    } else {
      appStoreLink = StoreLinks.OKTA[this.model.get("__deviceType__")];
      appIcon = "okta-verify-download-icon";
    }
    return {
      appStoreLinkText: loc3("enroll.totp.downloadApp", "login", [appStoreLink, factorName, appStoreName]),
      appIcon
    };
  }
});
var EnrollTotpControllerEnrollTotpController = FormController.extend({
  className: "enroll-totp",
  Model: function() {
    return {
      local: {
        __deviceType__: "string",
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      },
      save: function() {
        return this.doTransaction(function(transaction) {
          const factor = oktaUnderscore.findWhere(transaction.factors, {
            factorType: this.get("__factorType__"),
            provider: this.get("__provider__")
          });
          return factor.enroll();
        });
      }
    };
  },
  Form: {
    title: function() {
      const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
      return loc3("enroll.totp.title", "login", [factorName]);
    },
    noButtonBar: true,
    attributes: {
      "data-se": "step-device-type"
    },
    formChildren: function() {
      const inputOptions = {
        APPLE: loc3("iphone", "login"),
        ANDROID: loc3("android", "login")
      };
      const children = [FormType.Input({
        name: "__deviceType__",
        type: "radio",
        options: inputOptions,
        group: true,
        label: oktaUnderscore.partial(loc3, "enroll.totp.selectDevice", "login")
      }), FormType.Divider({
        showWhen: showWhenDeviceTypeSelected
      }), FormType.View({
        View: EnrollTotpControllerAppDownloadInstructionsView,
        showWhen: showWhenDeviceTypeSelected
      }), FormType.Button({
        title: loc3("oform.next", "login"),
        attributes: {
          "data-type": "save"
        },
        className: "button button-primary default-custom-button",
        click: function() {
          this.model.save();
        },
        showWhen: showWhenDeviceTypeSelected
      })];
      return children;
    }
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollU2FController.js
var import_q6 = __toESM(require_q());

// node_modules/u2f-api-polyfill/u2f-api-polyfill.js
(function() {
  var isChrome = "chrome" in window && window.navigator.userAgent.indexOf("Edge") < 0;
  if ("u2f" in window || !isChrome) {
    return;
  }
  var u2f2 = window.u2f = {};
  var js_api_version;
  u2f2.EXTENSION_ID = "kmendfapggjehodndflmmgagdbamhnfd";
  u2f2.MessageTypes = {
    "U2F_REGISTER_REQUEST": "u2f_register_request",
    "U2F_REGISTER_RESPONSE": "u2f_register_response",
    "U2F_SIGN_REQUEST": "u2f_sign_request",
    "U2F_SIGN_RESPONSE": "u2f_sign_response",
    "U2F_GET_API_VERSION_REQUEST": "u2f_get_api_version_request",
    "U2F_GET_API_VERSION_RESPONSE": "u2f_get_api_version_response"
  };
  u2f2.ErrorCodes = {
    "OK": 0,
    "OTHER_ERROR": 1,
    "BAD_REQUEST": 2,
    "CONFIGURATION_UNSUPPORTED": 3,
    "DEVICE_INELIGIBLE": 4,
    "TIMEOUT": 5
  };
  u2f2.U2fRequest;
  u2f2.U2fResponse;
  u2f2.Error;
  u2f2.Transport;
  u2f2.Transports;
  u2f2.SignRequest;
  u2f2.SignResponse;
  u2f2.RegisterRequest;
  u2f2.RegisterResponse;
  u2f2.RegisteredKey;
  u2f2.GetJsApiVersionResponse;
  u2f2.getMessagePort = function(callback) {
    if (typeof chrome != "undefined" && chrome.runtime) {
      var msg = {
        type: u2f2.MessageTypes.U2F_SIGN_REQUEST,
        signRequests: []
      };
      chrome.runtime.sendMessage(u2f2.EXTENSION_ID, msg, function() {
        if (!chrome.runtime.lastError) {
          u2f2.getChromeRuntimePort_(callback);
        } else {
          u2f2.getIframePort_(callback);
        }
      });
    } else if (u2f2.isAndroidChrome_()) {
      u2f2.getAuthenticatorPort_(callback);
    } else if (u2f2.isIosChrome_()) {
      u2f2.getIosPort_(callback);
    } else {
      u2f2.getIframePort_(callback);
    }
  };
  u2f2.isAndroidChrome_ = function() {
    var userAgent = navigator.userAgent;
    return userAgent.indexOf("Chrome") != -1 && userAgent.indexOf("Android") != -1;
  };
  u2f2.isIosChrome_ = function() {
    return ["iPhone", "iPad", "iPod"].indexOf(navigator.platform) > -1;
  };
  u2f2.getChromeRuntimePort_ = function(callback) {
    var port = chrome.runtime.connect(
      u2f2.EXTENSION_ID,
      { "includeTlsChannelId": true }
    );
    setTimeout(function() {
      callback(new u2f2.WrappedChromeRuntimePort_(port));
    }, 0);
  };
  u2f2.getAuthenticatorPort_ = function(callback) {
    setTimeout(function() {
      callback(new u2f2.WrappedAuthenticatorPort_());
    }, 0);
  };
  u2f2.getIosPort_ = function(callback) {
    setTimeout(function() {
      callback(new u2f2.WrappedIosPort_());
    }, 0);
  };
  u2f2.WrappedChromeRuntimePort_ = function(port) {
    this.port_ = port;
  };
  u2f2.formatSignRequest_ = function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {
    if (js_api_version === void 0 || js_api_version < 1.1) {
      var signRequests = [];
      for (var i = 0; i < registeredKeys.length; i++) {
        signRequests[i] = {
          version: registeredKeys[i].version,
          challenge,
          keyHandle: registeredKeys[i].keyHandle,
          appId
        };
      }
      return {
        type: u2f2.MessageTypes.U2F_SIGN_REQUEST,
        signRequests,
        timeoutSeconds,
        requestId: reqId
      };
    }
    return {
      type: u2f2.MessageTypes.U2F_SIGN_REQUEST,
      appId,
      challenge,
      registeredKeys,
      timeoutSeconds,
      requestId: reqId
    };
  };
  u2f2.formatRegisterRequest_ = function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {
    if (js_api_version === void 0 || js_api_version < 1.1) {
      for (var i = 0; i < registerRequests.length; i++) {
        registerRequests[i].appId = appId;
      }
      var signRequests = [];
      for (var i = 0; i < registeredKeys.length; i++) {
        signRequests[i] = {
          version: registeredKeys[i].version,
          challenge: registerRequests[0],
          keyHandle: registeredKeys[i].keyHandle,
          appId
        };
      }
      return {
        type: u2f2.MessageTypes.U2F_REGISTER_REQUEST,
        signRequests,
        registerRequests,
        timeoutSeconds,
        requestId: reqId
      };
    }
    return {
      type: u2f2.MessageTypes.U2F_REGISTER_REQUEST,
      appId,
      registerRequests,
      registeredKeys,
      timeoutSeconds,
      requestId: reqId
    };
  };
  u2f2.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
    this.port_.postMessage(message);
  };
  u2f2.WrappedChromeRuntimePort_.prototype.addEventListener = function(eventName, handler) {
    var name = eventName.toLowerCase();
    if (name == "message" || name == "onmessage") {
      this.port_.onMessage.addListener(function(message) {
        handler({ "data": message });
      });
    } else {
      console.error("WrappedChromeRuntimePort only supports onMessage");
    }
  };
  u2f2.WrappedAuthenticatorPort_ = function() {
    this.requestId_ = -1;
    this.requestObject_ = null;
  };
  u2f2.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {
    var intentUrl = u2f2.WrappedAuthenticatorPort_.INTENT_URL_BASE_ + ";S.request=" + encodeURIComponent(JSON.stringify(message)) + ";end";
    document.location = intentUrl;
  };
  u2f2.WrappedAuthenticatorPort_.prototype.getPortType = function() {
    return "WrappedAuthenticatorPort_";
  };
  u2f2.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {
    var name = eventName.toLowerCase();
    if (name == "message") {
      var self2 = this;
      window.addEventListener(
        "message",
        self2.onRequestUpdate_.bind(self2, handler),
        false
      );
    } else {
      console.error("WrappedAuthenticatorPort only supports message");
    }
  };
  u2f2.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ = function(callback, message) {
    var messageObject = JSON.parse(message.data);
    var intentUrl = messageObject["intentURL"];
    var errorCode = messageObject["errorCode"];
    var responseObject = null;
    if (messageObject.hasOwnProperty("data")) {
      responseObject = /** @type {Object} */
      JSON.parse(messageObject["data"]);
    }
    callback({ "data": responseObject });
  };
  u2f2.WrappedAuthenticatorPort_.INTENT_URL_BASE_ = "intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE";
  u2f2.WrappedIosPort_ = function() {
  };
  u2f2.WrappedIosPort_.prototype.postMessage = function(message) {
    var str = JSON.stringify(message);
    var url = "u2f://auth?" + encodeURI(str);
    location.replace(url);
  };
  u2f2.WrappedIosPort_.prototype.getPortType = function() {
    return "WrappedIosPort_";
  };
  u2f2.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {
    var name = eventName.toLowerCase();
    if (name !== "message") {
      console.error("WrappedIosPort only supports message");
    }
  };
  u2f2.getIframePort_ = function(callback) {
    var iframeOrigin = "chrome-extension://" + u2f2.EXTENSION_ID;
    var iframe = document.createElement("iframe");
    iframe.src = iframeOrigin + "/u2f-comms.html";
    iframe.setAttribute("style", "display:none");
    document.body.appendChild(iframe);
    var channel = new MessageChannel();
    var ready = function(message) {
      if (message.data == "ready") {
        channel.port1.removeEventListener("message", ready);
        callback(channel.port1);
      } else {
        console.error('First event on iframe port was not "ready"');
      }
    };
    channel.port1.addEventListener("message", ready);
    channel.port1.start();
    iframe.addEventListener("load", function() {
      iframe.contentWindow.postMessage("init", iframeOrigin, [channel.port2]);
    });
  };
  u2f2.EXTENSION_TIMEOUT_SEC = 30;
  u2f2.port_ = null;
  u2f2.waitingForPort_ = [];
  u2f2.reqCounter_ = 0;
  u2f2.callbackMap_ = {};
  u2f2.getPortSingleton_ = function(callback) {
    if (u2f2.port_) {
      callback(u2f2.port_);
    } else {
      if (u2f2.waitingForPort_.length == 0) {
        u2f2.getMessagePort(function(port) {
          u2f2.port_ = port;
          u2f2.port_.addEventListener(
            "message",
            /** @type {function(Event)} */
            u2f2.responseHandler_
          );
          while (u2f2.waitingForPort_.length)
            u2f2.waitingForPort_.shift()(u2f2.port_);
        });
      }
      u2f2.waitingForPort_.push(callback);
    }
  };
  u2f2.responseHandler_ = function(message) {
    var response = message.data;
    var reqId = response["requestId"];
    if (!reqId || !u2f2.callbackMap_[reqId]) {
      console.error("Unknown or missing requestId in response.");
      return;
    }
    var cb = u2f2.callbackMap_[reqId];
    delete u2f2.callbackMap_[reqId];
    cb(response["responseData"]);
  };
  u2f2.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
    if (js_api_version === void 0) {
      u2f2.getApiVersion(
        function(response) {
          js_api_version = response["js_api_version"] === void 0 ? 0 : response["js_api_version"];
          console.log("Extension JS API Version: ", js_api_version);
          u2f2.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
        }
      );
    } else {
      u2f2.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
    }
  };
  u2f2.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
    u2f2.getPortSingleton_(function(port) {
      var reqId = ++u2f2.reqCounter_;
      u2f2.callbackMap_[reqId] = callback;
      var timeoutSeconds = typeof opt_timeoutSeconds !== "undefined" ? opt_timeoutSeconds : u2f2.EXTENSION_TIMEOUT_SEC;
      var req = u2f2.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);
      port.postMessage(req);
    });
  };
  u2f2.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
    if (js_api_version === void 0) {
      u2f2.getApiVersion(
        function(response) {
          js_api_version = response["js_api_version"] === void 0 ? 0 : response["js_api_version"];
          console.log("Extension JS API Version: ", js_api_version);
          u2f2.sendRegisterRequest(
            appId,
            registerRequests,
            registeredKeys,
            callback,
            opt_timeoutSeconds
          );
        }
      );
    } else {
      u2f2.sendRegisterRequest(
        appId,
        registerRequests,
        registeredKeys,
        callback,
        opt_timeoutSeconds
      );
    }
  };
  u2f2.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
    u2f2.getPortSingleton_(function(port) {
      var reqId = ++u2f2.reqCounter_;
      u2f2.callbackMap_[reqId] = callback;
      var timeoutSeconds = typeof opt_timeoutSeconds !== "undefined" ? opt_timeoutSeconds : u2f2.EXTENSION_TIMEOUT_SEC;
      var req = u2f2.formatRegisterRequest_(
        appId,
        registeredKeys,
        registerRequests,
        timeoutSeconds,
        reqId
      );
      port.postMessage(req);
    });
  };
  u2f2.getApiVersion = function(callback, opt_timeoutSeconds) {
    u2f2.getPortSingleton_(function(port) {
      if (port.getPortType) {
        var apiVersion;
        switch (port.getPortType()) {
          case "WrappedIosPort_":
          case "WrappedAuthenticatorPort_":
            apiVersion = 1.1;
            break;
          default:
            apiVersion = 0;
            break;
        }
        callback({ "js_api_version": apiVersion });
        return;
      }
      var reqId = ++u2f2.reqCounter_;
      u2f2.callbackMap_[reqId] = callback;
      var req = {
        type: u2f2.MessageTypes.U2F_GET_API_VERSION_REQUEST,
        timeoutSeconds: typeof opt_timeoutSeconds !== "undefined" ? opt_timeoutSeconds : u2f2.EXTENSION_TIMEOUT_SEC,
        requestId: reqId
      };
      port.postMessage(req);
    });
  };
})();

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/FidoUtil.js
var fn6 = {};
fn6.getU2fEnrollErrorMessageKeyByCode = function(errorCode) {
  switch (errorCode) {
    default:
    case 1:
      return "u2f.error.other";
    case 2:
    case 3:
      return "u2f.error.badRequest";
    case 4:
      return "u2f.error.unsupported";
    case 5:
      return "u2f.error.timeout";
  }
};
fn6.getU2fVerifyErrorMessageKeyByCode = function(errorCode, isOneFactor) {
  switch (errorCode) {
    case 1:
      return isOneFactor ? "u2f.error.other.oneFactor" : "u2f.error.other";
    case 2:
    case 3:
      return isOneFactor ? "u2f.error.badRequest.oneFactor" : "u2f.error.badRequest";
    case 4:
      return isOneFactor ? "u2f.error.unsupported.oneFactor" : "u2f.error.unsupported";
    case 5:
      return "u2f.error.timeout";
  }
};
fn6.getU2fEnrollErrorMessageByCode = function(errorCode) {
  return loc3(fn6.getU2fEnrollErrorMessageKeyByCode(errorCode), "login");
};
fn6.getU2fVerifyErrorMessageByCode = function(errorCode, isOneFactor) {
  return loc3(fn6.getU2fVerifyErrorMessageKeyByCode(errorCode, isOneFactor), "login");
};
fn6.getU2fVersion = function() {
  return "U2F_V2";
};
fn6.isU2fAvailable = function() {
  return Object.prototype.hasOwnProperty.call(window, "u2f");
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollU2FController.js
var EnrollU2FController = FormController.extend({
  className: "enroll-u2f",
  Model: {
    local: {
      __enrolled__: "boolean"
    },
    save: function() {
      this.trigger("request");
      if (this.get("__enrolled__")) {
        return this.activate();
      }
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "u2f",
          provider: "FIDO"
        });
        return factor.enroll();
      });
    },
    activate: function() {
      this.set("__enrolled__", true);
      this.trigger("errors:clear");
      return this.doTransaction(function(transaction) {
        const activation = transaction.factor.activation;
        const appId = activation.appId;
        const registerRequests = [{
          version: fn6.getU2fVersion(),
          challenge: activation.nonce
        }];
        const self2 = this;
        const deferred = import_q6.default.defer();
        u2f.register(appId, registerRequests, [], function(data) {
          self2.trigger("errors:clear");
          if (data.errorCode && data.errorCode !== 0) {
            deferred.reject(new U2FError({
              xhr: {
                responseJSON: {
                  errorSummary: fn6.getU2fEnrollErrorMessageByCode(data.errorCode)
                }
              }
            }));
          } else {
            deferred.resolve(transaction.activate({
              registrationData: data.registrationData,
              version: data.version,
              challenge: data.challenge,
              clientData: data.clientData
            }));
          }
        });
        return deferred.promise;
      });
    }
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "enroll.u2f.title", "login"),
    save: oktaUnderscore.partial(loc3, "enroll.u2f.save", "login"),
    noCancelButton: true,
    hasSavingState: false,
    autoSave: true,
    className: "enroll-u2f-form",
    noButtonBar: function() {
      return !fn6.isU2fAvailable();
    },
    modelEvents: {
      request: "_startEnrollment",
      error: "_stopEnrollment"
    },
    formChildren: function() {
      const result = [];
      if (!fn6.isU2fAvailable()) {
        let errorMessageKey = "u2f.error.factorNotSupported";
        if (this.options.appState.get("factors").length === 1) {
          errorMessageKey = "u2f.error.factorNotSupported.oneFactor";
        }
        result.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3(errorMessageKey, "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      } else {
        result.push(FormType.View({
          View: View2.extend({
            template: _Handlebars2.template({
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="u2f-instructions"><ol><li>' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.u2f.general2"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 38
                    },
                    "end": {
                      "line": 1,
                      "column": 90
                    }
                  }
                })) != null ? stack1 : "") + "</li><li>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.u2f.general3"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 99
                    },
                    "end": {
                      "line": 1,
                      "column": 149
                    }
                  }
                })) + "</li></ol></div>";
              },
              "useData": true
            })
          })
        }));
        result.push(FormType.View({
          View: View2.extend({
            template: _Handlebars2.template({
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="u2f-enroll-text hide"><p>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.u2f.instructions"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 37
                    },
                    "end": {
                      "line": 1,
                      "column": 91
                    }
                  }
                })) + "</p><p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.u2f.instructionsBluetooth"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 98
                    },
                    "end": {
                      "line": 1,
                      "column": 161
                    }
                  }
                })) + '</p><div data-se="u2f-devices" class="u2f-devices-images"><div class="u2f-usb"></div><div class="u2f-bluetooth"></div></div><div data-se="u2f-waiting" class="okta-waiting-spinner"></div></div>';
              },
              "useData": true
            })
          })
        }));
      }
      return result;
    },
    _startEnrollment: function() {
      this.$(".u2f-instructions").addClass("hide");
      this.$(".u2f-enroll-text").removeClass("hide");
      this.$(".o-form-button-bar").hide();
    },
    _stopEnrollment: function() {
      this.$(".u2f-instructions").removeClass("hide");
      this.$(".u2f-enroll-text").addClass("hide");
      this.$(".o-form-button-bar").show();
    }
  },
  Footer,
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      this.model.activate();
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/EnrollUser.js
var EnrollUser = BaseLoginModel.extend({
  initialize: function(options2) {
    this.options = options2 || {};
    this.appState = this.options.appState;
  },
  constructPostData: function(profileAttributes) {
    const postData = {
      registration: {
        profile: profileAttributes
      }
    };
    if (this.appState.get("policy").registration.createNewAccount) {
      postData.registration["createNewAccount"] = true;
    }
    return postData;
  },
  getEnrollFormData: function() {
    return this.manageTransaction(function(transaction, setTransaction) {
      return transaction.enroll().then(function(trans) {
        setTransaction(trans);
      });
    });
  },
  save: function() {
    let data = BaseLoginModel.prototype.toJSON.apply(this, arguments);
    data = oktaUnderscore.omit(data, ["appState", "settings", "createNewAccount"]);
    if (oktaUnderscore.isEmpty(data)) {
      const error = {
        errorSummary: loc3("oform.errorbanner.title", "login")
      };
      this.trigger("error", this, {
        responseJSON: error
      });
    } else {
      return this.manageTransaction(function(transaction, setTransaction) {
        transaction.enroll(this.constructPostData(data)).then(function(trans) {
          setTransaction(trans);
        });
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/ProfileSchema.js
var {
  BaseSchema: BaseSchema2
} = internal.models;
var ProfileSchema = BaseSchema2.Model.extend({
  expand: ["schema"],
  setFieldPlaceholder: function(formFields) {
    oktaUnderscore.each(formFields, function(formField) {
      formField.title = formField.label;
    });
    return formFields;
  },
  initialize: function(options2) {
    let profileAttributes = options2.profileSchemaAttributes;
    profileAttributes = this.setFieldPlaceholder(profileAttributes);
    if (profileAttributes) {
      const userProfileSchema = {
        properties: {}
      };
      for (var i = 0; i < profileAttributes.length; i++) {
        const profileAttributeObject = profileAttributes[i];
        userProfileSchema.properties[profileAttributeObject.name] = profileAttributeObject;
      }
      this.parse.apply(this, [{
        schema: userProfileSchema
      }]);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/RegistrationFormFactory.js
var {
  SchemaFormFactory: SchemaFormFactory2
} = internal.views.forms.helpers;
var getParts = function(username) {
  const usernameArr = username.split("");
  const minPartsLength = 3;
  const userNameParts = [];
  const delimiters = [",", ".", "-", "_", "#", "@"];
  let userNamePart = "";
  oktaUnderscore.each(usernameArr, function(part) {
    if (delimiters.indexOf(part) === -1) {
      userNamePart += part;
    } else {
      if (userNamePart.length >= minPartsLength) {
        userNameParts.push(oktaUnderscore.clone(userNamePart));
      }
      userNamePart = "";
    }
  });
  if (userNamePart.length >= minPartsLength) {
    userNameParts.push(oktaUnderscore.clone(userNamePart));
  }
  return userNameParts.filter(Boolean);
};
var passwordContainsFormField = function(formField, password) {
  if (!formField) {
    return false;
  }
  formField = formField.toLowerCase();
  password = password.toLowerCase();
  const formFieldArr = getParts(formField);
  for (var i = 0; i < formFieldArr.length; i++) {
    const formFieldPart = formFieldArr[i];
    if (password.indexOf(formFieldPart) !== -1) {
      return true;
    }
  }
  return false;
};
var checkSubSchema = function(subSchema, value, model) {
  const minLength = subSchema.get("minLength");
  const maxLength = subSchema.get("maxLength");
  const regex = subSchema.get("format");
  if (oktaUnderscore.isNumber(minLength)) {
    if (value.length < minLength) {
      return false;
    }
  }
  if (oktaUnderscore.isNumber(maxLength)) {
    if (value.length > maxLength) {
      return false;
    }
  }
  const password = value;
  if (oktaUnderscore.isString(regex)) {
    if (regex === "^[#/userName]" || regex === "^[#/firstName]" || regex === "^[#/lastName]") {
      const fieldName = regex.split("^[#/")[1].split("]")[0];
      let fieldValue = model.get(fieldName);
      if (fieldName === "userName") {
        fieldValue = model.has("userName") ? model.get("userName") : model.get("email");
      }
      return !passwordContainsFormField(fieldValue, password);
    } else {
      if (!new RegExp(regex).test(value)) {
        return false;
      }
    }
  }
  return true;
};
var checkSubSchemas = function(fieldName, model, subSchemas, showError) {
  const value = model.get(fieldName);
  if (!oktaUnderscore.isString(value)) {
    return;
  }
  subSchemas.each(function(subSchema, index) {
    const ele = oktaJQueryStatic("#subschemas-" + fieldName + " .subschema-" + index);
    if (value) {
      ele.children("p").removeClass("default-schema");
    } else {
      ele.children("p").addClass("default-schema");
    }
    ele.children("p").removeAttr("role").removeAttr("aria-live");
    ele.removeClass("subschema-satisfied subschema-unsatisfied subschema-error");
    if (checkSubSchema(subSchema, value, model)) {
      ele.addClass("subschema-satisfied");
      ele.find("p span").removeClass("error error-16-small");
      ele.find("p span").addClass("confirm-16");
    } else {
      if (showError) {
        ele.find("p span").removeClass("confirm-16");
        ele.find("p span").addClass("error error-16-small");
        ele.addClass("subschema-error subschema-unsatisfied");
        ele.find("p").attr("role", "alert").attr("aria-live", "polite");
      }
    }
  });
};
var fnCreateInputOptions = function(schemaProperty) {
  let inputOptions = SchemaFormFactory2.createInputOptions(schemaProperty);
  if (inputOptions.type === "select") {
    inputOptions = oktaUnderscore.extend(inputOptions, {
      label: schemaProperty.get("title")
    });
  } else {
    let placeholder = schemaProperty.get("title");
    if (schemaProperty.get("required")) {
      placeholder += " *";
    }
    inputOptions = oktaUnderscore.extend(inputOptions, {
      label: false,
      "label-top": true,
      placeholder
    });
  }
  const fieldName = schemaProperty.get("name");
  switch (fieldName) {
    case "userName":
      inputOptions.input = TextBox$1;
      inputOptions.params = {
        icon: "person-16-gray"
      };
      break;
    case "password":
      inputOptions.type = "password";
      inputOptions.input = TextBox$1;
      inputOptions.params = {
        icon: "remote-lock-16"
      };
  }
  const subSchemas = schemaProperty.get("subSchemas");
  if (subSchemas) {
    inputOptions.events = {
      input: function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      },
      focusout: function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      },
      "change:userName": function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      },
      "change:firstName": function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      },
      "change:lastName": function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      },
      "change:email": function() {
        checkSubSchemas(fieldName, this.model, subSchemas, true);
      }
    };
  }
  return inputOptions;
};
var RegistrationFormFactory = {
  createInputOptions: fnCreateInputOptions,
  getUsernameParts: getParts,
  passwordContainsFormField
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enrollUser/EnrollUserForm.js
var EnrollUserForm = Form.extend({
  layout: "o-form-theme",
  autoSave: true,
  noCancelButton: true,
  title: function() {
    return loc3("registration.form.title", "login");
  },
  save: function() {
    return loc3("registration.form.submit", "login");
  },
  initialize: function(options2) {
    this.options = options2 || {};
    this.schema = new ProfileSchema({
      profileSchemaAttributes: this.options.appState.get("policy").registration.profile
    });
    this.schema.properties.each((schemaProperty) => {
      const inputOptions = RegistrationFormFactory.createInputOptions(schemaProperty);
      this.addInput(inputOptions);
    });
    const requiredFieldsLabel = _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<span class="required-fields-label">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "label",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 36
            },
            "end": {
              "line": 1,
              "column": 45
            }
          }
        }) : helper)) + "</span>";
      },
      "useData": true
    })({
      label: loc3("registration.required.fields.label", "login")
    });
    this.add(requiredFieldsLabel);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FooterWithBackLink.js
var FooterWithBackLink = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "goback"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 50
          },
          "end": {
            "line": 1,
            "column": 87
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .help": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollUserController.js
var EnrollUserController = BaseLoginController.extend({
  className: "enroll-user",
  initialize: function(options2) {
    this.options = options2 || {};
    this.model = new EnrollUser(this.options);
  },
  fetchInitialData: function() {
    if (this.options.appState.get("isUnauthenticated")) {
      return this.model.getEnrollFormData();
    } else {
      return BaseLoginController.prototype.fetchInitialData.call();
    }
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isProfileRequired")) {
      return true;
    }
  },
  postRender: function() {
    const form2 = new EnrollUserForm(this.toJSON());
    this.add(form2);
    this.add(new FooterWithBackLink(this.toJSON()));
    this.addListeners();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollWebauthnController.js
var import_q8 = __toESM(require_q());

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/CryptoUtil.js
var fn7 = {};
fn7.getStringHash = function(str) {
  let hash = 5381;
  let i = str.length;
  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }
  return hash >>> 0;
};
fn7.base64UrlSafeToBase64 = function(str) {
  return str.replace(new RegExp("_", "g"), "/").replace(new RegExp("-", "g"), "+");
};
fn7.binToStr = function(bin) {
  return btoa(new Uint8Array(bin).reduce((s, byte) => s + String.fromCharCode(byte), ""));
};
fn7.strToBin = function(str) {
  return Uint8Array.from(atob(this.base64UrlSafeToBase64(str)), (c2) => c2.charCodeAt(0));
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/webauthn.js
var import_q7 = __toESM(require_q());
function adaptToOkta(promise) {
  return new import_q7.default(promise);
}
function makeCredential(accountInfo, cryptoParams, challenge) {
  cryptoParams = cryptoParams.map(function(param) {
    return {
      type: "FIDO_2_0",
      algorithm: param.algorithm
    };
  });
  const promise = window.msCredentials.makeCredential(accountInfo, cryptoParams, challenge).then(function(cred) {
    return Object.freeze({
      credential: {
        id: cred.id
      },
      publicKey: JSON.parse(cred.publicKey),
      attestation: cred.attestation
    });
  });
  return adaptToOkta(promise);
}
function getAssertion2(challenge, allowList) {
  const accept = allowList.map(function(item) {
    return {
      type: "FIDO_2_0",
      id: item.id
    };
  });
  const filters = {
    accept
  };
  const promise = window.msCredentials.getAssertion(challenge, filters).then(function(attestation) {
    const signature = attestation.signature;
    return Object.freeze({
      credential: {
        id: attestation.id
      },
      clientData: signature.clientData,
      authenticatorData: signature.authnrData,
      signature: signature.signature
    });
  });
  return adaptToOkta(promise);
}
var webauthn = {
  makeCredential,
  getAssertion: getAssertion2,
  isAvailable: function() {
    return Object.prototype.hasOwnProperty.call(window, "msCredentials");
  },
  isNewApiAvailable: function() {
    return navigator && navigator.credentials && navigator.credentials.create;
  },
  isWebauthnOrU2fAvailable: function() {
    return this.isNewApiAvailable() || fn6.isU2fAvailable();
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollWebauthnController.js
function getExcludeCredentials(credentials) {
  const excludeCredentials = [];
  oktaUnderscore.each(credentials, function(credential) {
    excludeCredentials.push({
      type: "public-key",
      id: fn7.strToBin(credential.id)
    });
  });
  return excludeCredentials;
}
var EnrollWebauthnController = FormController.extend({
  className: "enroll-webauthn",
  Model: {
    local: {
      __enrolled__: "boolean"
    },
    save: function() {
      this.trigger("request");
      if (this.get("__enrolled__")) {
        return this.activate();
      }
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "webauthn",
          provider: "FIDO"
        });
        return factor.enroll();
      });
    },
    activate: function() {
      this.set("__enrolled__", true);
      this.trigger("errors:clear");
      this.appState.on("backToFactors", () => {
        if (this.webauthnAbortController) {
          this.webauthnAbortController.abort();
          this.webauthnAbortController = null;
        }
      });
      return this.doTransaction(function(transaction) {
        const activation = transaction.factor.activation;
        const self2 = this;
        if (webauthn.isNewApiAvailable()) {
          const options2 = oktaUnderscore.extend({}, activation, {
            challenge: fn7.strToBin(activation.challenge),
            user: {
              id: fn7.strToBin(activation.user.id),
              name: activation.user.name,
              displayName: activation.user.displayName
            },
            excludeCredentials: getExcludeCredentials(activation.excludeCredentials)
          });
          if (typeof AbortController !== "undefined") {
            self2.webauthnAbortController = new AbortController();
          }
          return new import_q8.default(navigator.credentials.create({
            publicKey: options2,
            signal: self2.webauthnAbortController && self2.webauthnAbortController.signal
          })).then(function(newCredential) {
            return transaction.activate({
              attestation: fn7.binToStr(newCredential.response.attestationObject),
              clientData: fn7.binToStr(newCredential.response.clientDataJSON)
            });
          }).catch(function(error) {
            self2.trigger("errors:clear");
            if (!self2.webauthnAbortController) {
              throw new WebauthnAbortError();
            } else {
              throw new WebAuthnError({
                xhr: {
                  responseJSON: {
                    errorSummary: error.message
                  }
                }
              });
            }
          }).finally(function() {
            self2.webauthnAbortController = null;
          });
        }
      });
    }
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "enroll.webauthn.biometric.title", "login"),
    save: oktaUnderscore.partial(loc3, "enroll.webauthn.save", "login"),
    noCancelButton: true,
    hasSavingState: false,
    autoSave: true,
    className: "enroll-webauthn-form",
    noButtonBar: function() {
      return !webauthn.isNewApiAvailable();
    },
    modelEvents: {
      request: "_startEnrollment",
      error: "_stopEnrollment"
    },
    formChildren: function() {
      const children = [];
      if (webauthn.isNewApiAvailable()) {
        children.push(FormType.View({
          View: View2.extend({
            className: "webauthn-enroll-text",
            template: _Handlebars2.template({
              "1": function(container, depth0, helpers2, partials, data) {
                var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="webauthn-edge-text"><p>' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.webauthn.biometric.instructions.edge"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 173
                    },
                    "end": {
                      "line": 1,
                      "column": 249
                    }
                  }
                })) != null ? stack1 : "") + "</p></div>";
              },
              "3": function(container, depth0, helpers2, partials, data) {
                var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="webauthn-restrictions-text"><p>' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.webauthn.instructions.noSupportForBiometric"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 340
                    },
                    "end": {
                      "line": 1,
                      "column": 423
                    }
                  }
                })) != null ? stack1 : "") + "</p></div>";
              },
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="webauthn-enroll-instructions"><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "enroll.webauthn.biometric.instructions"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 45
                    },
                    "end": {
                      "line": 1,
                      "column": 114
                    }
                  }
                })) + "</p></div>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isEdge") : depth0, {
                  "name": "if",
                  "hash": {},
                  "fn": container.program(1, data, 0),
                  "inverse": container.noop,
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 124
                    },
                    "end": {
                      "line": 1,
                      "column": 266
                    }
                  }
                })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "onlySupportsSecurityKey") : depth0, {
                  "name": "if",
                  "hash": {},
                  "fn": container.program(3, data, 0),
                  "inverse": container.noop,
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 266
                    },
                    "end": {
                      "line": 1,
                      "column": 440
                    }
                  }
                })) != null ? stack1 : "") + '<div data-se="webauthn-waiting" class="okta-waiting-spinner hide"></div>';
              },
              "useData": true
            }),
            getTemplateData: function() {
              return {
                isEdge: fn.isEdge(),
                onlySupportsSecurityKey: (fn.isFirefox() || fn.isSafari()) && fn.isMac()
              };
            }
          })
        }));
      } else {
        let errorMessageKey = "webauthn.biometric.error.factorNotSupported";
        if (this.options.appState.get("factors").length === 1) {
          errorMessageKey = "webauthn.biometric.error.factorNotSupported.oneFactor";
        }
        children.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3(errorMessageKey, "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      }
      return children;
    },
    _startEnrollment: function() {
      this.$(".okta-waiting-spinner").show();
      this.$(".o-form-button-bar").hide();
    },
    _stopEnrollment: function() {
      this.$(".okta-waiting-spinner").hide();
      this.$(".o-form-button-bar").show();
    }
  },
  Footer,
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      this.model.activate();
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/Spinner.js
var Spinner = View2.extend({
  className: "okta-waiting-spinner",
  attributes: {
    "data-se": "o-form-okta-waiting-spinner"
  },
  modelEvents: {
    "spinner:show": "show",
    "spinner:hide": "hide"
  },
  initialize: function(options2) {
    if (options2 && options2.visible === false) {
      this.hide();
    }
  },
  show: function() {
    this.$el.removeClass("hide");
  },
  hide: function() {
    this.$el.addClass("hide");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollWindowsHelloController.js
var EnrollWindowsHelloController = FormController.extend({
  className: "enroll-windows-hello",
  Model: {
    local: {
      __isEnrolled__: "boolean"
    },
    save: function() {
      if (!webauthn.isAvailable()) {
        return;
      }
      this.trigger("request");
      if (this.get("__isEnrolled__")) {
        return this.activate();
      }
      return this.doTransaction(function(transaction) {
        return this._enroll(transaction);
      });
    },
    _enroll: function(transaction) {
      const factor = oktaUnderscore.findWhere(transaction.factors, {
        factorType: "webauthn",
        provider: "FIDO"
      });
      return factor.enroll();
    },
    activate: function() {
      this.set("__isEnrolled__", true);
      return this.doTransaction(function(transaction) {
        const activation = transaction.factor.activation;
        const user = transaction.user;
        const model = this;
        const accountInfo = {
          rpDisplayName: activation.rpDisplayName,
          userDisplayName: user.profile.displayName,
          accountName: user.profile.login,
          userId: user.id
        };
        const cryptoParams = [{
          algorithm: activation.algorithm
        }];
        const challenge = activation.nonce;
        return webauthn.makeCredential(accountInfo, cryptoParams, challenge).then(function(creds) {
          return transaction.activate({
            credentialId: creds.credential.id,
            publicKey: creds.publicKey,
            attestation: null
          });
        }).catch(function(error) {
          switch (error.message) {
            case "AbortError":
            case "NotFoundError":
            case "NotSupportedError":
              model.trigger("abort", error.message);
              return transaction;
          }
          throw error;
        });
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: oktaUnderscore.partial(loc3, "enroll.windowsHello.title", "login"),
    subtitle: function() {
      return webauthn.isAvailable() ? loc3("enroll.windowsHello.subtitle", "login") : "";
    },
    save: oktaUnderscore.partial(loc3, "enroll.windowsHello.save", "login"),
    customSavingState: {
      stop: "abort"
    },
    modelEvents: function() {
      if (!webauthn.isAvailable()) {
        return {};
      }
      return {
        request: "_startEnrollment",
        error: "_stopEnrollment",
        abort: "_stopEnrollment"
      };
    },
    noButtonBar: function() {
      return !webauthn.isAvailable();
    },
    formChildren: function() {
      const result = [];
      if (!webauthn.isAvailable()) {
        result.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3("enroll.windowsHello.error.notWindows", "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      }
      result.push(FormType.View({
        View: new Spinner({
          model: this.model,
          visible: false
        })
      }));
      return result;
    },
    _startEnrollment: function() {
      this.subtitle = loc3("enroll.windowsHello.subtitle.loading", "login");
      this.model.trigger("spinner:show");
      this._resetErrorMessage();
      this.render();
      this.$(".o-form-button-bar").addClass("hide");
    },
    _stopEnrollment: function(errorMessage) {
      this.subtitle = loc3("enroll.windowsHello.subtitle", "login");
      this.model.trigger("spinner:hide");
      let message;
      switch (errorMessage) {
        case "NotSupportedError":
          message = loc3("enroll.windowsHello.error.notConfiguredHtml", "login");
          break;
      }
      this._resetErrorMessage();
      if (message) {
        const messageView = new HtmlErrorMessageView({
          message
        });
        this.$(".o-form-error-container").addClass("o-form-has-errors");
        this.add(messageView, {
          selector: ".o-form-error-container"
        });
        this._errorMessageView = this.last();
      }
      this.render();
      this.$(".o-form-button-bar").removeClass("hide");
    },
    _resetErrorMessage: function() {
      this._errorMessageView && this._errorMessageView.remove();
      this._errorMessageView = void 0;
      this.clearErrors();
    }
  },
  Footer,
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate")) {
      this.model.activate();
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollYubikeyController.js
var EnrollYubikeyController = FormController.extend({
  className: "enroll-yubikey",
  Model: {
    props: {
      passCode: ["string", true],
      factorId: "string"
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "token:hardware",
          provider: "YUBICO"
        });
        return factor.enroll({
          passCode: this.get("passCode")
        });
      });
    }
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "enroll.yubikey.title", "login"),
    subtitle: oktaUnderscore.partial(loc3, "enroll.yubikey.subtitle", "login"),
    noCancelButton: true,
    save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
    autoSave: true,
    className: "enroll-yubikey",
    formChildren: [FormType.View({
      View: '<div class="yubikey-demo" data-type="yubikey-example"></div>'
    }), FormType.Input({
      name: "passCode",
      input: TextBox$1,
      type: "password"
    })]
  },
  Footer
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollmentLinkSentController.js
var PUSH_INTERVAL3 = 6e3;
var EnrollmentLinkSentControllerFooter = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oform.back"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 99
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    const url = fn3.createActivateFactorUrl(this.options.appState.get("activatedFactorProvider"), this.options.appState.get("activatedFactorType"), "manual");
    this.options.appState.trigger("navigate", url);
  }
});
var emailSentForm = {
  title: oktaUnderscore.partial(loc3, "enroll.totp.enrollViaEmail.title", "login"),
  noButtonBar: true,
  attributes: {
    "data-se": "sent-email-activation-link"
  },
  formChildren: [FormType.View({
    View: View2.extend({
      template: _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return "<p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
            "name": "i18n",
            "hash": {
              "bundle": "login",
              "code": "enroll.totp.enrollViaEmail.msg"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 3
              },
              "end": {
                "line": 1,
                "column": 64
              }
            }
          })) + '</p><p class="email-address">' + alias3((helper = (helper = lookupProperty(helpers2, "email") || (depth0 != null ? lookupProperty(depth0, "email") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
            "name": "email",
            "hash": {},
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 93
              },
              "end": {
                "line": 1,
                "column": 102
              }
            }
          }) : helper)) + "</p>";
        },
        "useData": true
      }),
      getTemplateData: function() {
        return {
          email: this.options.appState.get("userEmail")
        };
      }
    })
  })]
};
var smsSentForm = {
  title: oktaUnderscore.partial(loc3, "enroll.totp.enrollViaSms.title", "login"),
  noButtonBar: true,
  attributes: {
    "data-se": "sent-sms-activation-link"
  },
  formChildren: [FormType.View({
    View: View2.extend({
      template: _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return "<p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
            "name": "i18n",
            "hash": {
              "bundle": "login",
              "code": "enroll.totp.enrollViaSms.msg"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 3
              },
              "end": {
                "line": 1,
                "column": 62
              }
            }
          })) + '</p><p class="phone-number">' + alias3((helper = (helper = lookupProperty(helpers2, "phoneNumber") || (depth0 != null ? lookupProperty(depth0, "phoneNumber") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
            "name": "phoneNumber",
            "hash": {},
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 90
              },
              "end": {
                "line": 1,
                "column": 105
              }
            }
          }) : helper)) + "</p>";
        },
        "useData": true
      }),
      getTemplateData: function() {
        return {
          phoneNumber: this.model.get("fullPhoneNumber")
        };
      }
    })
  })]
};
var EnrollmentLinkSentController = FormController.extend({
  className: "enroll-activation-link-sent",
  Model: function() {
    return {
      local: {
        countryCode: ["string", false, this.options.appState.get("userCountryCode")],
        phoneNumber: ["string", false, this.options.appState.get("userPhoneNumber")],
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      },
      derived: {
        countryCallingCode: {
          deps: ["countryCode"],
          fn: function(countryCode) {
            return "+" + fn4.getCallingCodeForCountry(countryCode);
          }
        },
        fullPhoneNumber: {
          deps: ["countryCallingCode", "phoneNumber"],
          fn: function(countryCallingCode, phoneNumber) {
            return countryCallingCode + phoneNumber;
          }
        }
      }
    };
  },
  Form: function() {
    const activationType = this.options.appState.get("factorActivationType");
    switch (activationType) {
      case "SMS":
        return smsSentForm;
      case "EMAIL":
        return emailSentForm;
      default:
        throw new Error("Unknown activation option: " + activationType);
    }
  },
  Footer: EnrollmentLinkSentControllerFooter,
  initialize: function() {
    this.pollForEnrollment();
  },
  remove: function() {
    return FormController.prototype.remove.apply(this, arguments);
  },
  pollForEnrollment: function() {
    return this.model.doTransaction(function(transaction) {
      return transaction.poll(PUSH_INTERVAL3);
    });
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isWaitingForActivation")) {
      this.pollForEnrollment();
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnterPasscodePushFlowController.js
var EnterPasscodePushFlowControllerFooter = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oform.back"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 99
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    const url = fn3.createActivateFactorUrl(this.options.appState.get("activatedFactorProvider"), "push", "manual");
    this.options.appState.trigger("navigate", url);
  }
});
var EnterPasscodePushFlowController = FormController.extend({
  className: "activate-push",
  Model: function() {
    return {
      props: {
        factorId: ["string", true, this.options.appState.get("activatedFactorId")],
        passCode: ["string", true]
      },
      local: {
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      },
      save: function() {
        return this.doTransaction(function(transaction) {
          return transaction.activate({
            passCode: this.get("passCode")
          });
        });
      }
    };
  },
  Form: form,
  Footer: EnterPasscodePushFlowControllerFooter
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/ContactSupport.js
var ContactSupport = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="infobox"><span class="icon info-16"></span><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "arguments": "helpSupportNumber",
          "bundle": "login",
          "code": "contact.support"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 134
          }
        }
      })) + "</p></div>";
    },
    "useData": true
  }),
  className: "contact-support",
  getTemplateData: function() {
    return this.settings.pick("helpSupportNumber");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ForgotPasswordController.js
var ForgotPasswordControllernoFactorsError = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-infobox-error infobox infobox-error" role="alert"><span class="icon error-16"></span><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "password.forgot.noFactorsEnabled"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 110
          },
          "end": {
            "line": 1,
            "column": 173
          }
        }
      })) + "</p></div>";
    },
    "useData": true
  })
});
var ForgotPasswordControllerFooter = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "goback"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 94
          },
          "end": {
            "line": 1,
            "column": 131
          }
        }
      })) + "</a>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link goto js-contact-support">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.noAccessToEmail"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 220
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      })) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "unless").call(alias1, depth0 != null ? lookupProperty(depth0, "hideBackToSignInForReset") : depth0, {
        "name": "unless",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 146
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "helpSupportNumber") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 146
          },
          "end": {
            "line": 1,
            "column": 281
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    },
    "click .js-contact-support": function(e) {
      e.preventDefault();
      this.state.trigger("contactSupport");
      this.$(".js-contact-support").hide();
    }
  },
  getTemplateData: function() {
    return {
      hideBackToSignInForReset: this.settings.get("features.hideBackToSignInForReset"),
      helpSupportNumber: this.settings.get("helpSupportNumber")
    };
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  }
});
var ForgotPasswordController = FormController.extend({
  className: "forgot-password",
  Model: {
    props: {
      username: ["string", true],
      factorType: ["string", true]
    },
    validate: function() {
      return fn5.validateUsername(this);
    },
    save: function() {
      const self2 = this;
      const relayState = this.settings.get("relayState");
      this.startTransaction(function(authClient) {
        return authClient.forgotPassword({
          username: self2.settings.transformUsername(self2.get("username"), Enums.FORGOT_PASSWORD),
          factorType: self2.get("factorType"),
          relayState
        });
      }).catch(function() {
      });
    }
  },
  Form: {
    noButtonBar: true,
    title: oktaUnderscore.partial(loc3, "password.reset", "login"),
    formChildren: function() {
      const smsEnabled = this.settings.get("features.smsRecovery");
      const callEnabled = this.settings.get("features.callRecovery");
      const emailEnabled = this.settings.get("features.emailRecovery");
      const noFactorsEnabled = !(smsEnabled || callEnabled || emailEnabled);
      const formChildren = [];
      if (noFactorsEnabled) {
        this.add(ForgotPasswordControllernoFactorsError, ".o-form-error-container");
      } else {
        formChildren.push(FormType.Input({
          label: loc3("password.forgot.email.or.username.placeholder", "login"),
          "label-top": true,
          explain: Util2.createInputExplain("password.forgot.email.or.username.tooltip", "password.forgot.email.or.username.placeholder", "login"),
          "explain-top": true,
          name: "username",
          input: TextBox$1,
          inputId: "account-recovery-username",
          autoComplete: "username",
          type: "text",
          inlineValidation: false
        }));
        if (smsEnabled || callEnabled) {
          formChildren.push(FormType.View({
            View: View2.extend({
              template: _Handlebars2.template({
                "compiler": [8, ">= 4.3.0"],
                "main": function(container, depth0, helpers2, partials, data) {
                  var lookupProperty = container.lookupProperty || function(parent, propertyName) {
                    if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                      return parent[propertyName];
                    }
                    return void 0;
                  };
                  return '<p class="mobile-recovery-hint">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                    "name": "i18n",
                    "hash": {
                      "arguments": "mobileFactors",
                      "bundle": "login",
                      "code": "recovery.mobile.hint"
                    },
                    "data": data,
                    "loc": {
                      "start": {
                        "line": 1,
                        "column": 32
                      },
                      "end": {
                        "line": 1,
                        "column": 109
                      }
                    }
                  })) + "</p>";
                },
                "useData": true
              }),
              getTemplateData: function() {
                let mobileFactors;
                if (smsEnabled && callEnabled) {
                  mobileFactors = loc3("recovery.smsOrCall");
                } else if (callEnabled) {
                  mobileFactors = loc3("recovery.call");
                } else {
                  mobileFactors = loc3("recovery.sms");
                }
                return {
                  mobileFactors
                };
              }
            })
          }));
        }
        if (smsEnabled) {
          this.$el.addClass("forgot-password-sms-enabled");
          formChildren.push(this.createRecoveryFactorButton("sms-button", "password.forgot.sendText", Enums.RECOVERY_FACTOR_TYPE_SMS, this));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_SMS);
        }
        if (callEnabled) {
          this.$el.addClass("forgot-password-call-enabled");
          formChildren.push(this.createRecoveryFactorButton("call-button", "password.forgot.call", Enums.RECOVERY_FACTOR_TYPE_CALL, this));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_CALL);
        }
        if (emailEnabled) {
          this.$el.addClass("forgot-password-email-enabled");
          formChildren.push(this.createRecoveryFactorButton("email-button", "password.forgot.sendEmail", Enums.RECOVERY_FACTOR_TYPE_EMAIL, this));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_EMAIL);
        }
      }
      return formChildren;
    },
    initialize: function() {
      this.listenTo(this.state, "contactSupport", function() {
        this.add(ContactSupport, ".o-form-error-container");
      });
      this.listenTo(this, "save", function() {
        this.options.appState.set("username", this.model.get("username"));
        this.model.save();
      });
    },
    setDefaultFactorType: function(factorType) {
      if (oktaUnderscore.isEmpty(this.model.get("factorType"))) {
        this.model.set("factorType", factorType);
      }
    },
    createRecoveryFactorButton: function(className2, labelCode, factorType, form2) {
      return FormType.Button({
        attributes: {
          "data-se": className2
        },
        className: "button button-primary button-wide " + className2,
        title: loc3(labelCode, "login"),
        click: function() {
          form2.clearErrors();
          if (this.model.isValid()) {
            this.model.set("factorType", factorType);
            form2.trigger("save", this.model);
          }
        }
      });
    }
  },
  Footer: ForgotPasswordControllerFooter,
  initialize: function() {
    this.options.appState.unset("username");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/CookieUtil.js
var Cookie3 = internal.util.Cookie;
var LAST_USERNAME_COOKIE_NAME = "ln";
var DAYS_SAVE_REMEMBER = 365;
var fn8 = {};
fn8.getCookieUsername = function() {
  return Cookie3.getCookie(LAST_USERNAME_COOKIE_NAME);
};
fn8.setUsernameCookie = function(username) {
  Cookie3.setCookie(LAST_USERNAME_COOKIE_NAME, username, {
    expires: DAYS_SAVE_REMEMBER,
    path: "/"
  });
};
fn8.removeUsernameCookie = function() {
  Cookie3.removeCookie(LAST_USERNAME_COOKIE_NAME, {
    path: "/"
  });
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/PrimaryAuth.js
var PrimaryAuthModel = BaseLoginModel.extend({
  props: function() {
    const cookieUsername = fn8.getCookieUsername();
    const properties = this.getUsernameAndRemember(cookieUsername);
    const props6 = {
      username: {
        type: "string",
        validate: function(value) {
          if (oktaUnderscore.isEmpty(value)) {
            return loc3("error.username.required", "login");
          }
        },
        value: properties.username
      },
      lastUsername: ["string", false, cookieUsername],
      context: ["object", false],
      remember: ["boolean", true, properties.remember],
      multiOptionalFactorEnroll: ["boolean", true]
    };
    if (!(this.settings && this.settings.get("features.passwordlessAuth"))) {
      props6.password = {
        type: "string",
        validate: function(value) {
          if (oktaUnderscore.isEmpty(value)) {
            return loc3("error.password.required", "login");
          }
        }
      };
    }
    return props6;
  },
  getUsernameAndRemember: function(cookieUsername) {
    const settingsUsername = this.settings && this.settings.get("username");
    const rememberMeEnabled = this.settings && this.settings.get("features.rememberMe");
    let remember2 = false;
    let username;
    if (settingsUsername) {
      username = settingsUsername;
      remember2 = rememberMeEnabled && username === cookieUsername;
    } else if (rememberMeEnabled && cookieUsername) {
      username = cookieUsername;
      remember2 = true;
    }
    return {
      username,
      remember: remember2
    };
  },
  constructor: function(options2) {
    this.settings = options2 && options2.settings;
    this.appState = options2 && options2.appState;
    Model2.apply(this, arguments);
    this.listenTo(this, "change:username", function(model, username) {
      this.set({
        remember: username === this.get("lastUsername")
      });
    });
  },
  parse: function(options2) {
    return oktaUnderscore.omit(options2, ["settings", "appState"]);
  },
  save: function() {
    const username = this.settings.transformUsername(this.get("username"), Enums.PRIMARY_AUTH);
    const remember2 = this.get("remember");
    const lastUsername = this.get("lastUsername");
    this.setUsernameCookie(username, remember2, lastUsername);
    this.trigger("save");
    this.appState.trigger("loading", true);
    const signInArgs = this.getSignInArgs(username);
    let primaryAuthPromise;
    if (this.appState.get("isUnauthenticated")) {
      const authClient = this.appState.settings.authClient;
      if (this.appState.get("isIdxStateToken")) {
        primaryAuthPromise = this.doTransaction(function(transaction) {
          return this.doPrimaryAuth(authClient, signInArgs, transaction.login);
        });
      } else {
        primaryAuthPromise = this.doTransaction(function(transaction) {
          return this.doPrimaryAuth(authClient, signInArgs, transaction.authenticate);
        }, true);
      }
    } else {
      primaryAuthPromise = this.startTransaction(function(authClient) {
        return this.doPrimaryAuth(authClient, signInArgs, oktaUnderscore.bind(authClient.signInWithCredentials, authClient));
      });
    }
    return primaryAuthPromise.catch(() => {
      this.appState.trigger("removeLoading");
      fn8.removeUsernameCookie();
    }).finally(() => {
      this.appState.trigger("loading", false);
    });
  },
  getSignInArgs: function(username) {
    const multiOptionalFactorEnroll = this.get("multiOptionalFactorEnroll");
    const signInArgs = {};
    if (!this.settings.get("features.passwordlessAuth")) {
      signInArgs.password = this.get("password");
    }
    if (this.appState.get("isIdxStateToken")) {
      signInArgs.identifier = username;
    } else {
      signInArgs.username = username;
      signInArgs.options = {
        warnBeforePasswordExpired: true,
        multiOptionalFactorEnroll
      };
    }
    return signInArgs;
  },
  setUsernameCookie: function(username, remember2, lastUsername) {
    if (this.settings.get("features.rememberMe")) {
      if (!remember2 && lastUsername === username) {
        fn8.removeUsernameCookie();
      } else if (remember2) {
        fn8.setUsernameCookie(username);
      }
    }
  },
  doPrimaryAuth: function(authClient, signInArgs, func) {
    const deviceFingerprintEnabled = this.settings.get("features.deviceFingerprinting");
    const typingPatternEnabled = this.settings.get("features.trackTypingPattern");
    if (deviceFingerprintEnabled && this.appState.get("deviceFingerprint")) {
      authClient.http.setRequestHeader("X-Device-Fingerprint", this.appState.get("deviceFingerprint"));
    }
    if (typingPatternEnabled && this.appState.get("typingPattern")) {
      authClient.http.setRequestHeader("X-Typing-Pattern", this.appState.get("typingPattern"));
    }
    const self2 = this;
    return func(signInArgs).finally(function() {
      if (deviceFingerprintEnabled) {
        authClient.http.setRequestHeader("X-Device-Fingerprint", void 0);
        self2.appState.unset("deviceFingerprint");
      }
      if (typingPatternEnabled) {
        authClient.http.setRequestHeader("X-Typing-Pattern", void 0);
        self2.appState.unset("typingPattern");
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/DeviceFingerprint.js
var import_q9 = __toESM(require_q());
var DeviceFingerprint = {
  getUserAgent: function() {
    return navigator.userAgent;
  },
  isMessageFromCorrectSource: function($iframe, event) {
    return event.source === $iframe[0].contentWindow;
  },
  generateDeviceFingerprint: function(oktaDomainUrl, element) {
    const userAgent = this.getUserAgent();
    if (!userAgent) {
      return import_q9.default.reject("user agent is not defined");
    } else if (isWindowsPhone3(userAgent)) {
      return import_q9.default.reject("device fingerprint is not supported on Windows phones");
    }
    const deferred = import_q9.default.defer();
    const self2 = this;
    let $iframe;
    let iFrameTimeout;
    function isWindowsPhone3(userAgent2) {
      return userAgent2.match(/windows phone|iemobile|wpdesktop/i);
    }
    function removeIframe() {
      $iframe.off();
      $iframe.remove();
      window.removeEventListener("message", onMessageReceivedFromOkta, false);
    }
    function handleError2(reason) {
      removeIframe();
      deferred.reject(reason);
    }
    function onMessageReceivedFromOkta(event) {
      if (!self2.isMessageFromCorrectSource($iframe, event)) {
        return;
      }
      clearTimeout(iFrameTimeout);
      if (!event || !event.data || event.origin !== oktaDomainUrl) {
        handleError2("no data");
        return;
      }
      try {
        const message = JSON.parse(event.data);
        if (message && message.type === "FingerprintServiceReady") {
          sendMessageToOkta({
            type: "GetFingerprint"
          });
        } else if (message && message.type === "FingerprintAvailable") {
          removeIframe();
          deferred.resolve(message.fingerprint);
        } else {
          handleError2("no data");
        }
      } catch (error) {
      }
    }
    function sendMessageToOkta(message) {
      const win = $iframe[0].contentWindow;
      if (win) {
        win.postMessage(JSON.stringify(message), oktaDomainUrl);
      }
    }
    window.addEventListener("message", onMessageReceivedFromOkta, false);
    $iframe = oktaJQueryStatic("<iframe>", {
      style: "display: none;",
      src: oktaDomainUrl + "/auth/services/devicefingerprint"
    });
    element.append($iframe);
    iFrameTimeout = setTimeout(() => {
      handleError2("service not available");
    }, 2e3);
    return deferred.promise;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/primary-auth/CustomButtons.js
var SharedUtil = internal.util.Util;
var dividerTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="auth-divider"><span class="auth-divider-text">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "text",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 58
        },
        "end": {
          "line": 1,
          "column": 66
        }
      }
    }) : helper)) + "</span></div>";
  },
  "useData": true
});
var formTitleTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<h2 data-se="o-form-head" class="okta-form-title o-form-head">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "title",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 62
        },
        "end": {
          "line": 1,
          "column": 71
        }
      }
    }) : helper)) + "</h2>";
  },
  "useData": true
});
var CustomButtons = View2.extend({
  className: "primary-auth-container",
  children: function() {
    const children = [];
    const socialIdpButtons = this.settings.get("configuredSocialIdps");
    const pivButton = this.settings.get("piv");
    const customButtons = this.settings.get("customButtons");
    const divider = dividerTpl({
      text: loc3("socialauth.divider.text", "login")
    });
    if (this.settings.get("hasPivCard")) {
      children.push(this._createPivButton(pivButton));
    }
    oktaUnderscore.each(socialIdpButtons, function(button) {
      children.push(this._createSocialIdpButton(button));
    }, this);
    oktaUnderscore.each(customButtons, function(button) {
      children.push(this._createCustomButton(button));
    }, this);
    if (this.settings.get("socialAuthPositionTop")) {
      children.unshift(formTitleTpl({
        title: loc3("primaryauth.title", "login")
      }));
      children.push(divider);
    } else {
      children.unshift(divider);
    }
    return children;
  },
  _createSocialIdpButton: function(options2) {
    return createButton2({
      attributes: {
        "data-se": options2.dataAttr
      },
      className: options2.className,
      title: function() {
        return options2.text || loc3(options2.i18nKey);
      },
      click: function(e) {
        e.preventDefault();
        if (this.settings.get("oauth2Enabled")) {
          util.getTokens(this.settings, {
            idp: options2.id
          }, this.options.currentController);
        } else {
          const baseUrl = this.settings.get("baseUrl");
          let params;
          const lastAuthResponse = this.options.appState.get("lastAuthResponse");
          if (this.options.appState.get("usingDeviceFlow")) {
            params = oktaJQueryStatic.param({
              stateToken: lastAuthResponse === null || lastAuthResponse === void 0 ? void 0 : lastAuthResponse.stateToken
            });
          } else {
            params = oktaJQueryStatic.param({
              fromURI: this.settings.get("relayState")
            });
          }
          const targetUri = `${baseUrl}/sso/idps/${options2.id}?${params}`;
          SharedUtil.redirect(targetUri);
        }
      }
    });
  },
  _createPivButton: function(options2) {
    let className2 = options2.className || "";
    return createButton2({
      attributes: {
        "data-se": "piv-card-button"
      },
      className: className2 + " piv-button",
      title: options2.text || loc3("piv.cac.card", "login"),
      click: function(e) {
        e.preventDefault();
        this.options.appState.trigger("navigate", "signin/verify/piv");
      }
    });
  },
  _createCustomButton: function(options2) {
    return createButton2({
      attributes: {
        "data-se": options2.dataAttr
      },
      className: options2.className + " default-custom-button",
      title: function() {
        return options2.title || loc3(options2.i18nKey);
      },
      click: options2.click
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/packages/vendor/TypingDnaRecorder-JavaScript/typingdna.js
var typingdna = function TypingDNA() {
  if (TypingDNA.initialized != true) {
    TypingDNA.prototype.start = function() {
      return TypingDNA.start.apply(this, arguments);
    };
    TypingDNA.prototype.stop = function() {
      return TypingDNA.stop.apply(this, arguments);
    };
    TypingDNA.prototype.reset = function() {
      return TypingDNA.reset.apply(this, arguments);
    };
    TypingDNA.prototype.addTarget = function() {
      return TypingDNA.addTarget.apply(this, arguments);
    };
    TypingDNA.prototype.removeTarget = function() {
      return TypingDNA.removeTarget.apply(this, arguments);
    };
    TypingDNA.prototype.getTypingPattern = function() {
      return TypingDNA.getTypingPattern.apply(this, arguments);
    };
    TypingDNA.prototype.get = function() {
      return TypingDNA.get.apply(this, arguments);
    };
    TypingDNA.prototype.startDiagram = function() {
    };
    TypingDNA.prototype.stopDiagram = function() {
    };
    TypingDNA.prototype.getDiagram = function() {
      return TypingDNA.getDiagram.apply(this, arguments);
    };
    TypingDNA.prototype.getExtendedDiagram = function() {
      return TypingDNA.getExtendedDiagram.apply(this, arguments);
    };
    TypingDNA.prototype.getMouseDiagram = function() {
      return TypingDNA.getMouseDiagram.apply(this, arguments);
    };
    TypingDNA.prototype.startMouse = function() {
      return TypingDNA.startMouse.apply(this, arguments);
    };
    TypingDNA.prototype.stopMouse = function() {
      return TypingDNA.stopMouse.apply(this, arguments);
    };
    TypingDNA.prototype.getQuality = function() {
      return TypingDNA.getQuality.apply(this, arguments);
    };
    TypingDNA.prototype.getLength = function() {
      return TypingDNA.getLength.apply(this, arguments);
    };
    TypingDNA.prototype.isMobile = function() {
      return TypingDNA.isMobile.apply(this, arguments);
    };
    TypingDNA.prototype.getTextId = function() {
      return TypingDNA.getTextId.apply(this, arguments);
    };
    TypingDNA.initialized = true;
    TypingDNA.prototype.maxHistoryLength = TypingDNA.maxHistoryLength;
    TypingDNA.prototype.defaultHistoryLength = TypingDNA.defaultHistoryLength;
    TypingDNA.prototype.maxSeekTime = TypingDNA.maxSeekTime;
    TypingDNA.prototype.maxPressTime = TypingDNA.maxPressTime;
    TypingDNA.version = 2.15;
    TypingDNA.flags = 0;
    TypingDNA.instance = this;
    TypingDNA.document = document;
    TypingDNA.maxHistoryLength = 2e3;
    TypingDNA.maxSeekTime = 1500;
    TypingDNA.maxPressTime = 300;
    TypingDNA.defaultHistoryLength = 160;
    TypingDNA.spKeyCodes = [8, 13, 32];
    TypingDNA.spKeyCodesObj = {
      8: 1,
      13: 1,
      32: 1
    };
    TypingDNA.keyCodes = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 32, 222, 188, 190, 186, 187, 189, 191, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57];
    TypingDNA.keyCodesObj = {};
    for (var i in TypingDNA.keyCodes) {
      TypingDNA.keyCodesObj[TypingDNA.keyCodes[i]] = 1;
    }
    TypingDNA.pt1 = TypingDNA.ut1 = (/* @__PURE__ */ new Date()).getTime();
    TypingDNA.wfk = [];
    TypingDNA.sti = [];
    TypingDNA.skt = [];
    TypingDNA.recording = true;
    TypingDNA.mouseRecording = true;
    TypingDNA.mouseMoveRecording = false;
    TypingDNA.spKeyRecording = true;
    TypingDNA.diagramRecording = true;
    TypingDNA.dwfk = [];
    TypingDNA.dsti = [];
    TypingDNA.dskt = [];
    TypingDNA.drkc = [];
    TypingDNA.prevKeyCode = 0;
    TypingDNA.maxMoveDeltaTime = 600;
    TypingDNA.maxScrollDeltaTime = 800;
    TypingDNA.maxStopTime = 1500;
    TypingDNA.maxClickTime = 600;
    TypingDNA.maxMouseHistoryLength = 500;
    TypingDNA.lastMouseMoveTime = TypingDNA.lastMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
    TypingDNA.stopTimes = [];
    TypingDNA.clickTimes = [];
    TypingDNA.lastMouseStop = true;
    TypingDNA.zl = 1e-7;
    TypingDNA.isAndroidChrome = false;
    TypingDNA.ACLastTime = (/* @__PURE__ */ new Date()).getTime();
    TypingDNA.ACSeekTime = 0;
    TypingDNA.ACPressTime = 0;
    TypingDNA.ACLastCharCode = 0;
    TypingDNA.ACLastKeyCode = 0;
    TypingDNA.ACInputLengths = {
      inputs: [],
      lastLength: []
    };
    TypingDNA.ACPreviousKeyCode = 0;
    TypingDNA.targetIds = [];
    TypingDNA.lastTarget = "";
    TypingDNA.lastTargetFound = false;
    TypingDNA.replaceMissingKeys = true;
    TypingDNA.replaceMissingKeysPerc = 7;
    TypingDNA.keyDown = function(e) {
      if (!TypingDNA.recording && !TypingDNA.diagramRecording) {
        return;
      }
      if (!TypingDNA.isTarget(e.target.id)) {
        return;
      }
      var keyCode = e.keyCode;
      if (TypingDNA.wfk[keyCode] == 1 || TypingDNA.dwfk[keyCode] == 1)
        ;
      if (keyCode == 229 && TypingDNA.isMobile() && !TypingDNA.isAndroidChrome) {
        TypingDNA.isAndroidChrome = true;
        TypingDNA.ACSeekTime = (/* @__PURE__ */ new Date()).getTime() - TypingDNA.ACLastTime;
        TypingDNA.ACLastTime = (/* @__PURE__ */ new Date()).getTime();
        TypingDNA.document.removeEventListener("keydown", TypingDNA.keyDown);
        TypingDNA.document.removeEventListener("keyup", TypingDNA.keyUp);
        TypingDNA.document.removeEventListener("keypress", TypingDNA.keyPress);
        TypingDNA.document.addEventListener("keydown", TypingDNA.ACKeyDown);
        TypingDNA.document.addEventListener("keyup", TypingDNA.ACKeyUp);
      } else {
        var t0 = TypingDNA.pt1;
        TypingDNA.pt1 = (/* @__PURE__ */ new Date()).getTime();
        var seekTotal = TypingDNA.pt1 - t0;
        var startTime = TypingDNA.pt1;
        if (TypingDNA.recording == true || TypingDNA.spKeyCodesObj[keyCode] && TypingDNA.spKeyRecording == true) {
          if (!e.shiftKey || TypingDNA.isMobile()) {
            TypingDNA.wfk[keyCode] = 1;
            TypingDNA.skt[keyCode] = seekTotal;
            TypingDNA.sti[keyCode] = startTime;
          }
        }
        if (TypingDNA.diagramRecording == true) {
          TypingDNA.dwfk[keyCode] = 1;
          TypingDNA.dskt[keyCode] = seekTotal;
          TypingDNA.dsti[keyCode] = startTime;
          TypingDNA.dlastDownKey = keyCode;
        }
      }
    };
    TypingDNA.keyPress = function(e) {
      if (!TypingDNA.recording && !TypingDNA.diagramRecording) {
        return;
      }
      if (!TypingDNA.isTarget(e.target.id)) {
        return;
      }
      if (TypingDNA.diagramRecording == true) {
        var keyCode = TypingDNA.dlastDownKey;
        TypingDNA.drkc[keyCode] = e.charCode;
      }
    };
    TypingDNA.keyUp = function(e) {
      if (!TypingDNA.recording && !TypingDNA.diagramRecording) {
        return;
      }
      if (!TypingDNA.isTarget(e.target.id)) {
        return;
      }
      var ut = (/* @__PURE__ */ new Date()).getTime();
      var keyCode = e.keyCode;
      if (TypingDNA.recording == true || TypingDNA.spKeyCodesObj[keyCode] && TypingDNA.spKeyRecording == true) {
        if (!e.shiftKey || TypingDNA.isMobile()) {
          if (TypingDNA.wfk[keyCode] == 1) {
            var pressTime = ut - TypingDNA.sti[keyCode];
            var seekTime = TypingDNA.skt[keyCode];
            var arr = [keyCode, seekTime, pressTime, TypingDNA.prevKeyCode, ut, e.target.id];
            TypingDNA.history.add(arr);
            TypingDNA.prevKeyCode = keyCode;
          }
        }
        TypingDNA.wfk[keyCode] = 0;
      }
      if (TypingDNA.diagramRecording == true) {
        if (TypingDNA.drkc[keyCode] != void 0 && TypingDNA.drkc[keyCode] != 0) {
          if (TypingDNA.dwfk[keyCode] == 1) {
            var pressTime = ut - TypingDNA.dsti[keyCode];
            var seekTime = TypingDNA.dskt[keyCode];
            var realKeyCode = TypingDNA.drkc[keyCode];
            var arrD = [keyCode, seekTime, pressTime, realKeyCode, ut, e.target.id];
            TypingDNA.history.addDiagram(arrD);
          }
        }
        TypingDNA.dwfk[keyCode] = 0;
      }
    };
    TypingDNA.mouseScroll = function(e) {
      if (TypingDNA.mouseRecording == true) {
        if (TypingDNA.mouseMoveRecording == true) {
          if (TypingDNA.mouse.scrollStarted == true) {
            var currentTime = (/* @__PURE__ */ new Date()).getTime();
            TypingDNA.mouse.scrollTimes.push(currentTime);
            TypingDNA.mouse.scrollTopArr.push(TypingDNA.document.body.scrollTop);
            clearInterval(TypingDNA.scrollInterval);
            TypingDNA.scrollInterval = setInterval(TypingDNA.mouse.checkScroll, TypingDNA.maxScrollDeltaTime);
          } else {
            TypingDNA.mouse.scrollStarted = true;
          }
        }
      }
    };
    TypingDNA.mouseMove = function(e) {
      if (TypingDNA.mouseRecording == true) {
        var currentTime = (/* @__PURE__ */ new Date()).getTime();
        if (TypingDNA.mouseMoveRecording == true) {
          if (TypingDNA.mouse.started == true) {
            TypingDNA.mouse.times.push(currentTime);
            TypingDNA.mouse.xPositions.push(e.screenX);
            TypingDNA.mouse.yPositions.push(e.screenY);
            clearInterval(TypingDNA.moveInterval);
            TypingDNA.moveInterval = setInterval(TypingDNA.mouse.checkMove, TypingDNA.maxMoveDeltaTime);
          } else {
            TypingDNA.mouse.started = true;
          }
        }
        TypingDNA.lastMouseMoveTime = currentTime;
      }
    };
    TypingDNA.mouseDown = function(e) {
      if (TypingDNA.mouseRecording == true) {
        TypingDNA.mouse.checkMove();
        TypingDNA.mouse.checkScroll();
        if (e.which == 1) {
          TypingDNA.lastMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          var stopTime = TypingDNA.lastMouseDownTime - TypingDNA.lastMouseMoveTime;
          if (stopTime < TypingDNA.maxStopTime && TypingDNA.lastMouseStop == false) {
            TypingDNA.stopTimes.push(stopTime);
            if (TypingDNA.mouseMoveRecording == true) {
              var eventType = 3;
              var arr = [eventType, stopTime];
              TypingDNA.mouse.history.add(arr);
              TypingDNA.lastMouseStop = true;
            }
          }
        }
      }
    };
    TypingDNA.mouseUp = function(e) {
      if (TypingDNA.mouseRecording == true) {
        if (e.which == 1) {
          var clickTime = (/* @__PURE__ */ new Date()).getTime() - TypingDNA.lastMouseDownTime;
          if (clickTime < TypingDNA.maxClickTime && TypingDNA.lastMouseDownTime > TypingDNA.lastMouseMoveTime) {
            TypingDNA.clickTimes.push(clickTime);
            if (TypingDNA.mouseMoveRecording == true) {
              var eventType = 4;
              var arr = [eventType, clickTime];
              TypingDNA.mouse.history.add(arr);
            }
          }
        }
      }
    };
    TypingDNA.ACKeyDown = function(e) {
      if (!TypingDNA.recording && !TypingDNA.diagramRecording) {
        return;
      }
      TypingDNA.ACSeekTime = (/* @__PURE__ */ new Date()).getTime() - TypingDNA.ACLastTime;
      TypingDNA.ACLastTime = (/* @__PURE__ */ new Date()).getTime();
      if (!TypingDNA.isTarget(e.target.id)) {
        return;
      }
      if (TypingDNA.ACInputLengths.inputs.indexOf(e.target) === -1) {
        TypingDNA.ACInputLengths.inputs.push(e.target);
        TypingDNA.ACInputLengths.lastLength.push(0);
      }
    };
    TypingDNA.ACKeyUp = function(e) {
      if (!TypingDNA.recording && !TypingDNA.diagramRecording) {
        return;
      }
      TypingDNA.ACPressTime = (/* @__PURE__ */ new Date()).getTime() - TypingDNA.ACLastTime;
      TypingDNA.ACLastTime = (/* @__PURE__ */ new Date()).getTime();
      if (!TypingDNA.isTarget(e.target.id)) {
        return;
      }
      var keyCode = e.keyCode;
      var targetIndex = TypingDNA.ACInputLengths.inputs.indexOf(e.target);
      if (targetIndex === -1) {
        TypingDNA.ACInputLengths.inputs.push(e.target);
        TypingDNA.ACInputLengths.lastLength.push(0);
        targetIndex = TypingDNA.ACInputLengths.inputs.indexOf(e.target);
      }
      if (keyCode == 229 && e.target.value.length >= TypingDNA.ACInputLengths.lastLength[targetIndex]) {
        var char = e.target.value.substr(e.target.selectionStart - 1 || 0, 1);
        keyCode = char.toUpperCase().charCodeAt(0);
        TypingDNA.ACLastCharCode = char.charCodeAt(0);
        TypingDNA.ACLastKeyCode = char.toUpperCase().charCodeAt(0);
      }
      TypingDNA.ACInputLengths.lastLength[targetIndex] = e.target.value.length;
      var arr = [keyCode, TypingDNA.ACSeekTime, TypingDNA.ACPressTime, TypingDNA.ACPreviousKeyCode, TypingDNA.ACLastTime];
      TypingDNA.history.add(arr);
      TypingDNA.ACPreviousKeyCode = keyCode;
      if (TypingDNA.diagramRecording == true) {
        var arrD = [keyCode, TypingDNA.ACSeekTime, TypingDNA.ACPressTime, TypingDNA.ACLastCharCode];
        TypingDNA.history.addDiagram(arrD);
      }
    };
    TypingDNA.isTarget = function(target) {
      if (TypingDNA.lastTarget == target && TypingDNA.lastTargetFound) {
        return true;
      } else {
        var targetLength2 = TypingDNA.targetIds.length;
        var targetFound = false;
        if (targetLength2 > 0) {
          for (var i2 = 0; i2 < targetLength2; i2++) {
            if (TypingDNA.targetIds[i2] == target) {
              targetFound = true;
              break;
            }
          }
          TypingDNA.lastTarget = target;
          TypingDNA.lastTargetFound = targetFound;
          return targetFound;
        } else {
          TypingDNA.lastTarget = target;
          TypingDNA.lastTargetFound = true;
          return true;
        }
      }
    };
    if (TypingDNA.document.addEventListener) {
      TypingDNA.document.addEventListener("keydown", TypingDNA.keyDown);
      TypingDNA.document.addEventListener("keyup", TypingDNA.keyUp);
      TypingDNA.document.addEventListener("keypress", TypingDNA.keyPress);
      TypingDNA.document.addEventListener("mousemove", TypingDNA.mouseMove);
      TypingDNA.document.addEventListener("mousedown", TypingDNA.mouseDown);
      TypingDNA.document.addEventListener("mouseup", TypingDNA.mouseUp);
      TypingDNA.document.addEventListener("scroll", TypingDNA.mouseScroll);
    } else if (TypingDNA.document.attachEvent) {
      TypingDNA.document.attachEvent("onkeydown", TypingDNA.keyDown);
      TypingDNA.document.attachEvent("onkeyup", TypingDNA.keyUp);
      TypingDNA.document.attachEvent("onkeypress", TypingDNA.keyPress);
      TypingDNA.document.attachEvent("onmousemove", TypingDNA.mouseMove);
      TypingDNA.document.attachEvent("onmousedown", TypingDNA.mouseDown);
      TypingDNA.document.attachEvent("onmouseup", TypingDNA.mouseUp);
      TypingDNA.document.attachEvent("onscroll", TypingDNA.mouseScroll);
    } else
      ;
    TypingDNA.mouse = {};
    TypingDNA.mouse.times = [];
    TypingDNA.mouse.xPositions = [];
    TypingDNA.mouse.yPositions = [];
    TypingDNA.mouse.scrollTimes = [];
    TypingDNA.mouse.scrollTopArr = [];
    TypingDNA.mouse.history = {};
    TypingDNA.mouse.history.stack = [];
    TypingDNA.mouse.getDistance = function(a2, b2) {
      return Math.sqrt(a2 * a2 + b2 * b2);
    };
    TypingDNA.mouse.getTotalDistance = function(xPositions, yPositions) {
      var totalDistance = 0;
      var length = xPositions.length;
      for (i = 1; i < length - 1; i++) {
        var a2 = xPositions[i] - xPositions[i - 1];
        var b2 = yPositions[i] - yPositions[i - 1];
        totalDistance += TypingDNA.mouse.getDistance(a2, b2);
      }
      return totalDistance;
    };
    TypingDNA.mouse.getAngle = function(xPosDelta, yPosDelta) {
      var angle = 0;
      var leftRight = xPosDelta >= 0;
      var downUp = yPosDelta < 0;
      if (leftRight) {
        if (downUp) {
          angle = 180 + Math.round(Math.atan(Math.abs(xPosDelta) / (Math.abs(yPosDelta) + 1e-7)) / 0.01745329251);
        } else {
          angle = 270 + (90 - Math.round(Math.atan(Math.abs(xPosDelta) / (Math.abs(yPosDelta) + 1e-7)) / 0.01745329251));
        }
      } else {
        if (downUp) {
          angle = 90 + (90 - Math.round(Math.atan(Math.abs(xPosDelta) / (Math.abs(yPosDelta) + 1e-7)) / 0.01745329251));
        } else {
          angle = Math.round(Math.atan(Math.abs(xPosDelta) / (Math.abs(yPosDelta) + 1e-7)) / 0.01745329251);
        }
      }
      return angle;
    };
    TypingDNA.mouse.recordMoveAction = function() {
      var length = TypingDNA.mouse.times.length;
      if (length < 3) {
        return;
      }
      var deltaTime = TypingDNA.mouse.times[length - 1] - TypingDNA.mouse.times[0];
      var xPosDelta = TypingDNA.mouse.xPositions[length - 1] - TypingDNA.mouse.xPositions[0];
      var yPosDelta = TypingDNA.mouse.yPositions[length - 1] - TypingDNA.mouse.yPositions[0];
      var directDistance = Math.round(TypingDNA.mouse.getDistance(xPosDelta, yPosDelta));
      var totalDistance = Math.round(TypingDNA.mouse.getTotalDistance(TypingDNA.mouse.xPositions, TypingDNA.mouse.yPositions));
      var ratioDistance = Math.round(totalDistance * 100 / directDistance);
      var speed = Math.round(directDistance * 100 / deltaTime);
      var angle = TypingDNA.mouse.getAngle(xPosDelta, yPosDelta);
      var eventType = 1;
      var arr = [eventType, deltaTime, directDistance, speed, angle, ratioDistance];
      for (i in arr) {
        if (isNaN(arr[i])) {
          return;
        }
      }
      TypingDNA.mouse.history.add(arr);
      TypingDNA.lastMouseStop = false;
    };
    TypingDNA.mouse.recordScrollAction = function() {
      var length = TypingDNA.mouse.scrollTimes.length;
      if (length < 2) {
        return;
      }
      var deltaTime = TypingDNA.mouse.scrollTimes[length - 1] - TypingDNA.mouse.scrollTimes[0];
      var directDistance = TypingDNA.mouse.scrollTopArr[length - 1] - TypingDNA.mouse.scrollTopArr[0];
      var speed = Math.round(directDistance * 100 / deltaTime);
      var eventType = 2;
      var arr = [eventType, deltaTime, directDistance, speed];
      for (i in arr) {
        if (isNaN(arr[i]) && !isFinite(arr[i])) {
          return;
        }
      }
      TypingDNA.mouse.history.add(arr);
    };
    TypingDNA.mouse.history.add = function(arr) {
      this.stack.push(arr);
      if (this.stack.length > TypingDNA.maxMouseHistoryLength) {
        this.stack.shift();
      }
    };
    TypingDNA.mouse.history.getDiagram = function() {
      var mouseDiagram = this.stack.join("|");
      return [String(TypingDNA.isMobile()) + "," + String(TypingDNA.version), mouseDiagram].join("|");
    };
    TypingDNA.mouse.clearLastMove = function() {
      TypingDNA.mouse.times = [];
      TypingDNA.mouse.xPositions = [];
      TypingDNA.mouse.yPositions = [];
    };
    TypingDNA.mouse.checkMove = function() {
      clearInterval(TypingDNA.moveInterval);
      if (TypingDNA.mouse.started == true) {
        TypingDNA.mouse.started = false;
        TypingDNA.mouse.recordMoveAction();
        TypingDNA.mouse.clearLastMove();
      }
    };
    TypingDNA.mouse.clearLastScroll = function() {
      TypingDNA.mouse.scrollTimes = [];
      TypingDNA.mouse.scrollTopArr = [];
    };
    TypingDNA.mouse.checkScroll = function() {
      clearInterval(TypingDNA.scrollInterval);
      if (TypingDNA.mouse.scrollStarted == true) {
        TypingDNA.mouse.scrollStarted = false;
        TypingDNA.mouse.recordScrollAction();
        TypingDNA.mouse.clearLastScroll();
      }
    };
    TypingDNA.addTarget = function(target) {
      var targetLength2 = TypingDNA.targetIds.length;
      var targetFound = false;
      if (targetLength2 > 0) {
        for (var i2 = 0; i2 < targetLength2; i2++) {
          if (TypingDNA.targetIds[i2] == target) {
            targetFound = true;
            break;
          }
        }
        if (!targetFound) {
          TypingDNA.targetIds.push(target);
        }
      } else {
        TypingDNA.targetIds.push(target);
      }
    };
    TypingDNA.removeTarget = function(target) {
      var targetLength2 = TypingDNA.targetIds.length;
      if (targetLength2 > 0) {
        for (var i2 = 0; i2 < targetLength2; i2++) {
          if (TypingDNA.targetIds[i2] == target) {
            TypingDNA.targetIds.splice(i2, 1);
            break;
          }
        }
      }
    };
    TypingDNA.reset = function(all) {
      TypingDNA.history.stack = [];
      TypingDNA.history.stackDiagram = [];
      TypingDNA.clickTimes = [];
      TypingDNA.stopTimes = [];
      TypingDNA.ACInputLengths = {
        inputs: [],
        lastLength: []
      };
      if (all == true) {
        TypingDNA.mouse.history.stack = [];
      }
    };
    TypingDNA.start = function() {
      TypingDNA.diagramRecording = true;
      return TypingDNA.recording = true;
    };
    TypingDNA.stop = function() {
      TypingDNA.diagramRecording = false;
      return TypingDNA.recording = false;
    };
    TypingDNA.startMouse = function() {
      return TypingDNA.mouseRecording = TypingDNA.mouseMoveRecording = true;
    };
    TypingDNA.stopMouse = function() {
      return TypingDNA.mouseRecording = TypingDNA.mouseMoveRecording = false;
    };
    TypingDNA.getTypingPattern = function(obj) {
      if (typeof obj === "object") {
        switch (obj.type) {
          case 0:
            return TypingDNA.get(obj.length, obj.targetId);
          case 1:
            var str = obj.text != void 0 ? obj.text : obj.length;
            return TypingDNA.history.getDiagram(obj.extended, str, obj.textId, obj.targetId, obj.caseSensitive);
          case 2:
            var str = obj.text != void 0 ? obj.text : obj.length;
            return TypingDNA.history.getDiagram(true, str, obj.textId, obj.targetId, obj.caseSensitive);
          default:
            return TypingDNA.get(obj.length);
        }
      } else {
        return TypingDNA.get();
      }
    };
    TypingDNA.getDiagram = function(str, textId) {
      return TypingDNA.history.getDiagram(false, str, textId, void 0, false);
    };
    TypingDNA.getExtendedDiagram = function(str, textId) {
      return TypingDNA.history.getDiagram(true, str, textId, void 0, false);
    };
    TypingDNA.getMouseDiagram = function() {
      return TypingDNA.mouse.history.getDiagram();
    };
    TypingDNA.get = function(length, targetId) {
      var historyTotalLength = TypingDNA.history.stack.length;
      if (length == void 0 || length == 0) {
        length = TypingDNA.defaultHistoryLength;
      }
      if (length > historyTotalLength) {
        length = historyTotalLength;
      }
      var obj = {};
      [obj.arr, targetLength] = TypingDNA.history.get(length, "", targetId);
      if (targetId != void 0 && targetId != "") {
        length = targetLength;
      }
      var zl = TypingDNA.zl;
      var histRev = length;
      var histSktF = TypingDNA.math.fo(TypingDNA.history.get(length, "seek", targetId));
      var histPrtF = TypingDNA.math.fo(TypingDNA.history.get(length, "press", targetId));
      var pressHistMean = Math.round(TypingDNA.math.avg(histPrtF));
      var seekHistMean = Math.round(TypingDNA.math.avg(histSktF));
      var pressHistSD = Math.round(TypingDNA.math.sd(histPrtF));
      var seekHistSD = Math.round(TypingDNA.math.sd(histSktF));
      var charMeanTime = seekHistMean + pressHistMean;
      var pressRatio = TypingDNA.math.rd((pressHistMean + zl) / (charMeanTime + zl), 4);
      var seekToPressRatio = TypingDNA.math.rd((1 - pressRatio) / pressRatio, 4);
      var pressSDToPressRatio = TypingDNA.math.rd((pressHistSD + zl) / (pressHistMean + zl), 4);
      var seekSDToPressRatio = TypingDNA.math.rd((seekHistSD + zl) / (pressHistMean + zl), 4);
      var cpm = Math.round(6e4 / (charMeanTime + zl));
      if (histRev == 0) {
        cpm = 0;
      }
      for (var i2 in obj.arr) {
        var rev = obj.arr[i2][1].length;
        var seekMean = 0;
        var pressMean = 0;
        var postMean = 0;
        var seekSD = 0;
        var pressSD = 0;
        var postSD = 0;
        switch (obj.arr[i2][0].length) {
          case 0:
            break;
          case 1:
            var seekMean = TypingDNA.math.rd((obj.arr[i2][0][0] + zl) / (seekHistMean + zl), 4);
            break;
          default:
            var arr = TypingDNA.math.fo(obj.arr[i2][0]);
            seekMean = TypingDNA.math.rd((TypingDNA.math.avg(arr) + zl) / (seekHistMean + zl), 4);
            seekSD = TypingDNA.math.rd((TypingDNA.math.sd(arr) + zl) / (seekHistSD + zl), 4);
        }
        switch (obj.arr[i2][1].length) {
          case 0:
            break;
          case 1:
            var pressMean = TypingDNA.math.rd((obj.arr[i2][1][0] + zl) / (pressHistMean + zl), 4);
            break;
          default:
            var arr = TypingDNA.math.fo(obj.arr[i2][1]);
            pressMean = TypingDNA.math.rd((TypingDNA.math.avg(arr) + zl) / (pressHistMean + zl), 4);
            pressSD = TypingDNA.math.rd((TypingDNA.math.sd(arr) + zl) / (pressHistSD + zl), 4);
        }
        switch (obj.arr[i2][2].length) {
          case 0:
            break;
          case 1:
            var postMean = TypingDNA.math.rd((obj.arr[i2][2][0] + zl) / (seekHistMean + zl), 4);
            break;
          default:
            var arr = TypingDNA.math.fo(obj.arr[i2][2]);
            postMean = TypingDNA.math.rd((TypingDNA.math.avg(arr) + zl) / (seekHistMean + zl), 4);
            postSD = TypingDNA.math.rd((TypingDNA.math.sd(arr) + zl) / (seekHistSD + zl), 4);
        }
        delete obj.arr[i2][2];
        delete obj.arr[i2][1];
        delete obj.arr[i2][0];
        obj.arr[i2][0] = rev;
        obj.arr[i2][1] = seekMean;
        obj.arr[i2][2] = pressMean;
        obj.arr[i2][3] = postMean;
        obj.arr[i2][4] = seekSD;
        obj.arr[i2][5] = pressSD;
        obj.arr[i2][6] = postSD;
      }
      var arr = [];
      TypingDNA.apu(arr, histRev);
      TypingDNA.apu(arr, cpm);
      TypingDNA.apu(arr, charMeanTime);
      TypingDNA.apu(arr, pressRatio);
      TypingDNA.apu(arr, seekToPressRatio);
      TypingDNA.apu(arr, pressSDToPressRatio);
      TypingDNA.apu(arr, seekSDToPressRatio);
      TypingDNA.apu(arr, pressHistMean);
      TypingDNA.apu(arr, seekHistMean);
      TypingDNA.apu(arr, pressHistSD);
      TypingDNA.apu(arr, seekHistSD);
      for (var c2 = 0; c2 <= 6; c2++) {
        for (var i2 = 0; i2 < 44; i2++) {
          var keyCode = TypingDNA.keyCodes[i2];
          var val = obj.arr[keyCode][c2];
          if (val == 0 && c2 > 0) {
            val = 1;
          }
          TypingDNA.apu(arr, val);
        }
      }
      TypingDNA.apu(arr, TypingDNA.isMobile());
      TypingDNA.apu(arr, TypingDNA.version);
      TypingDNA.apu(arr, TypingDNA.flags);
      arr.push(TypingDNA.history.getSpecialKeys());
      return arr.join(",");
    };
    TypingDNA.apu = function(arr, val) {
      "NaN" == String(val) && (val = 0);
      arr.push(val);
    };
    TypingDNA.math = {};
    TypingDNA.math.rd = function(val, dec) {
      return Number(val.toFixed(dec));
    };
    TypingDNA.math.avg = function(arr) {
      var len = arr.length;
      if (len > 0) {
        var sum = 0;
        for (var i2 = 0; i2 < len; i2++) {
          sum += arr[i2];
        }
        return this.rd(sum / len, 4);
      } else {
        return 0;
      }
    };
    TypingDNA.math.sd = function(arr) {
      var len = arr.length;
      if (len < 2) {
        return 0;
      } else {
        var sumVS = 0;
        var mean = this.avg(arr);
        for (var i2 = 0; i2 < len; i2++) {
          sumVS += (arr[i2] - mean) * (arr[i2] - mean);
        }
        var sd = Math.sqrt(sumVS / len);
        return sd;
      }
    };
    TypingDNA.math.fo = function(arr) {
      if (arr.length > 1) {
        var values = arr.concat();
        var len = arr.length;
        values.sort(function(a2, b2) {
          return a2 - b2;
        });
        var asd = this.sd(values);
        var aMean = values[Math.ceil(arr.length / 2)];
        var multiplier = 2;
        var maxVal = aMean + multiplier * asd;
        var minVal = aMean - multiplier * asd;
        if (len < 20) {
          minVal = 0;
        }
        var fVal = [];
        for (var i2 = 0; i2 < len; i2++) {
          var tempval = values[i2];
          if (tempval < maxVal && tempval > minVal) {
            fVal.push(tempval);
          }
        }
        return fVal;
      } else {
        return arr;
      }
    };
    TypingDNA.math.fnv1aHash = function(str) {
      if (str == void 0 && typeof str !== "string") {
        return 0;
      }
      str = str.toLowerCase();
      var i2, l;
      var hval = 1914395348;
      for (i2 = 0, l = str.length; i2 < l; i2++) {
        hval ^= str.charCodeAt(i2);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
      }
      return hval >>> 0;
    };
    TypingDNA.history = {};
    TypingDNA.history.stack = [];
    TypingDNA.history.stackDiagram = [];
    TypingDNA.history.add = function(arr) {
      this.stack.push(arr);
      if (this.stack.length > TypingDNA.maxHistoryLength) {
        this.stack.shift();
      }
    };
    TypingDNA.history.addDiagram = function(arr) {
      this.stackDiagram.push(arr);
    };
    TypingDNA.history.getDiagram = function(extended, str, textId, targetId, caseSensitive) {
      var caseSensitive = caseSensitive != void 0 ? caseSensitive : str == void 0 || str == "";
      var returnArr = [];
      var diagramType = extended == true ? 1 : 0;
      var stackDiagram = this.stackDiagram;
      if (targetId != void 0 && targetId != "" && stackDiagram.length > 0) {
        stackDiagram = TypingDNA.sliceStackByTargetId(stackDiagram, targetId);
        if (str == void 0 || str == "") {
          var element = TypingDNA.document.getElementById(targetId);
          if (element != null) {
            str = element.value;
          }
        }
      } else {
        var targetLength2 = TypingDNA.targetIds.length;
        if (str == void 0 || str == "") {
          if (targetLength2 > 0) {
            str = "";
            for (var i2 = 0; i2 < targetLength2; i2++) {
              var element = TypingDNA.document.getElementById(TypingDNA.targetIds[i2]);
              if (element != null) {
                str += element.value;
              }
            }
          }
        }
      }
      var missingCount = 0;
      var diagramHistoryLength = stackDiagram.length;
      var strLength = diagramHistoryLength;
      if (typeof str === "string") {
        strLength = str.length;
      } else if (typeof str === "number" && str < diagramHistoryLength) {
        strLength = str;
      }
      var returnTextId = 0;
      if (textId != void 0) {
        if (isNaN(parseInt(textId))) {
          returnTextId = TypingDNA.math.fnv1aHash(textId);
        } else {
          returnTextId = parseInt(textId);
        }
      } else {
        if (typeof str === "string") {
          returnTextId = TypingDNA.math.fnv1aHash(str);
        }
      }
      returnArr.push([TypingDNA.isMobile(), TypingDNA.version, TypingDNA.flags, diagramType, strLength, returnTextId, TypingDNA.history.getSpecialKeys()]);
      if (str != void 0 && str.length > 0 && typeof str === "string") {
        var strLower = str.toLowerCase();
        var strUpper = str.toUpperCase();
        var lastFoundPos = [];
        var lastPos = 0;
        var strUpperCharCode;
        var currentSensitiveCharCode;
        for (var i2 = 0; i2 < str.length; i2++) {
          var currentCharCode = str.charCodeAt(i2);
          if (!caseSensitive) {
            strUpperCharCode = strUpper.charCodeAt(i2);
            currentSensitiveCharCode = strUpperCharCode != currentCharCode ? strUpperCharCode : strLower.charCodeAt(i2);
          }
          var startPos = lastPos;
          var finishPos = diagramHistoryLength;
          var found = false;
          while (found == false) {
            for (var j = startPos; j < finishPos; j++) {
              var arr = stackDiagram[j];
              var charCode = arr[3];
              if (charCode == currentCharCode || !caseSensitive && charCode == currentSensitiveCharCode) {
                found = true;
                if (j == lastPos) {
                  lastPos++;
                  lastFoundPos = [];
                } else {
                  lastFoundPos.push(j);
                  var len = lastFoundPos.length;
                  if (len > 1 && lastFoundPos[len - 1] == lastFoundPos[len - 2] + 1) {
                    lastPos = j + 1;
                    lastFoundPos = [];
                  }
                }
                var keyCode = arr[0];
                var seekTime = arr[1];
                var pressTime = arr[2];
                if (extended) {
                  returnArr.push([charCode, seekTime, pressTime, keyCode]);
                } else {
                  returnArr.push([seekTime, pressTime]);
                }
                break;
              }
            }
            if (found == false) {
              if (startPos != 0) {
                startPos = 0;
                finishPos = lastPos;
              } else {
                found = true;
                if (TypingDNA.replaceMissingKeys) {
                  missingCount++;
                  if (typeof TypingDNA.savedMissingAvgValues !== "object" || TypingDNA.savedMissingAvgValues.historyLength != diagramHistoryLength) {
                    var histSktF = TypingDNA.math.fo(TypingDNA.history.get(0, "seek"));
                    var histPrtF = TypingDNA.math.fo(TypingDNA.history.get(0, "press"));
                    var seekTime = Math.round(TypingDNA.math.avg(histSktF));
                    var pressTime = Math.round(TypingDNA.math.avg(histPrtF));
                    TypingDNA.savedMissingAvgValues = {
                      seekTime,
                      pressTime,
                      historyLength: diagramHistoryLength
                    };
                  } else {
                    var seekTime = TypingDNA.savedMissingAvgValues.seekTime;
                    var pressTime = TypingDNA.savedMissingAvgValues.pressTime;
                  }
                  var missing = 1;
                  if (extended) {
                    returnArr.push([currentCharCode, seekTime, pressTime, currentCharCode, missing]);
                  } else {
                    returnArr.push([seekTime, pressTime, missing]);
                  }
                  break;
                }
              }
            }
          }
          if (TypingDNA.replaceMissingKeysPerc < missingCount * 100 / strLength) {
            return null;
          }
        }
      } else {
        var startCount = 0;
        if (typeof str === "number") {
          startCount = diagramHistoryLength - str;
        }
        if (startCount < 0) {
          startCount = 0;
        }
        for (var i2 = startCount; i2 < diagramHistoryLength; i2++) {
          var arr = stackDiagram[i2];
          var keyCode = arr[0];
          var seekTime = arr[1];
          var pressTime = arr[2];
          if (extended) {
            var charCode = arr[3];
            returnArr.push([charCode, seekTime, pressTime, keyCode]);
          } else {
            returnArr.push([seekTime, pressTime]);
          }
        }
      }
      return returnArr.join("|");
    };
    TypingDNA.sliceStackByTargetId = function(stack, targetId) {
      var length = stack.length;
      var newStack = [];
      for (i = 0; i < length; i++) {
        var arr = stack[i];
        if (arr[5] == targetId) {
          newStack.push(arr);
        }
      }
      return newStack;
    };
    TypingDNA.history.get = function(length, type, targetId) {
      var stack = this.stack;
      if (targetId != void 0 && targetId != "" && stack.length > 0) {
        stack = TypingDNA.sliceStackByTargetId(stack, targetId);
      }
      var historyTotalLength = stack.length;
      if (length == 0 || length == void 0) {
        length = TypingDNA.defaultHistoryLength;
      }
      if (length > historyTotalLength) {
        length = historyTotalLength;
      }
      switch (type) {
        case "seek":
          var seekArr = [];
          for (i2 = 1; i2 <= length; i2++) {
            var seekTime = stack[historyTotalLength - i2][1];
            if (seekTime <= TypingDNA.maxSeekTime) {
              seekArr.push(seekTime);
            }
          }
          return seekArr;
        case "press":
          var pressArr = [];
          for (i2 = 1; i2 <= length; i2++) {
            var pressTime = stack[historyTotalLength - i2][2];
            if (pressTime <= TypingDNA.maxPressTime) {
              pressArr.push(pressTime);
            }
          }
          return pressArr;
        default:
          var historyStackObj = {};
          for (var i2 in TypingDNA.keyCodes) {
            historyStackObj[TypingDNA.keyCodes[i2]] = [[], [], []];
          }
          for (i2 = 1; i2 <= length; i2++) {
            var arr = stack[historyTotalLength - i2];
            var keyCode = arr[0];
            var seekTime = arr[1];
            var pressTime = arr[2];
            var prevKeyCode = arr[3];
            if (TypingDNA.keyCodesObj[keyCode]) {
              if (seekTime <= TypingDNA.maxSeekTime) {
                historyStackObj[keyCode][0].push(seekTime);
                if (prevKeyCode != 0 && TypingDNA.keyCodesObj[prevKeyCode]) {
                  historyStackObj[prevKeyCode][2].push(seekTime);
                }
              }
              if (pressTime <= TypingDNA.maxPressTime) {
                historyStackObj[keyCode][1].push(pressTime);
              }
            }
          }
          return [historyStackObj, length];
      }
    };
    TypingDNA.history.getSpecialKeys = function() {
      var returnArr = [];
      var length = this.stack.length;
      var historyStackObj = {};
      for (var i2 in TypingDNA.spKeyCodes) {
        historyStackObj[TypingDNA.spKeyCodes[i2]] = [[]];
      }
      for (i2 = 1; i2 <= length; i2++) {
        var arr = this.stack[length - i2];
        if (TypingDNA.spKeyCodesObj[arr[0]]) {
          var keyCode = arr[0];
          var pressTime = arr[2];
          if (pressTime <= TypingDNA.maxPressTime) {
            historyStackObj[keyCode][0].push(pressTime);
          }
        }
      }
      for (var i2 in TypingDNA.spKeyCodes) {
        var arr = TypingDNA.math.fo(historyStackObj[TypingDNA.spKeyCodes[i2]][0]);
        var arrLen = arr.length;
        returnArr.push(arrLen);
        if (arrLen > 1) {
          returnArr.push(Math.round(TypingDNA.math.avg(arr)));
          returnArr.push(Math.round(TypingDNA.math.sd(arr)));
        } else if (arrLen == 1) {
          returnArr.push([arr[0], -1]);
        } else {
          returnArr.push([-1, -1]);
        }
      }
      var clicksArrLen = TypingDNA.clickTimes.length;
      returnArr.push(clicksArrLen);
      if (clicksArrLen > 1) {
        returnArr.push(Math.round(TypingDNA.math.avg(TypingDNA.clickTimes)));
        returnArr.push(Math.round(TypingDNA.math.sd(TypingDNA.clickTimes)));
      } else if (clicksArrLen == 1) {
        returnArr.push(TypingDNA.clickTimes[0], -1);
      } else {
        returnArr.push([-1, -1]);
      }
      var stopArrLen = TypingDNA.stopTimes.length;
      returnArr.push(stopArrLen);
      if (stopArrLen > 1) {
        returnArr.push(Math.round(TypingDNA.math.avg(TypingDNA.stopTimes)));
        returnArr.push(Math.round(TypingDNA.math.sd(TypingDNA.stopTimes)));
      } else if (stopArrLen == 1) {
        returnArr.push(TypingDNA.stopTimes[0], -1);
      } else {
        returnArr.push([-1, -1]);
      }
      return returnArr;
    };
    TypingDNA.getQuality = function(typingPattern) {
      var obj = typingPattern.split(",");
      for (i2 = 0; i2 < obj.length; i2++) {
        obj[i2] = Number(obj[i2]);
      }
      obj[0];
      var acc = rec = avgAcc = 0;
      var avg = TypingDNA.math.avg(obj);
      var revs = obj.slice(11, 55);
      for (var i2 in revs) {
        rec += Number(revs[i2] > 0);
        acc += Number(revs[i2] > 4);
        avgAcc += Number(revs[i2] > avg);
      }
      var tReturn = Math.sqrt(rec * acc * avgAcc) / 80;
      return tReturn > 1 ? 1 : tReturn;
    };
    TypingDNA.checkMobileValidity = function(typingPattern) {
      var obj = typingPattern.split(",");
      var totalEvents = obj[0];
      if (totalEvents == 0) {
        return 0;
      }
      var rec2 = 0;
      var revs = obj.slice(11, 55);
      for (var i2 in revs) {
        rec2 += Number(revs[i2]);
      }
      return rec2 / totalEvents;
    };
    TypingDNA.getLength = function(typingPattern) {
      return Number(typingPattern.split(",")[1]);
    };
    TypingDNA.isMobile = function() {
      if (TypingDNA.mobile != void 0) {
        return TypingDNA.mobile;
      } else {
        var check = 0;
        (function(a2) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a2.substr(0, 4))) {
            check = 1;
          }
        })(navigator.userAgent || navigator.vendor || window.opera);
        TypingDNA.mobile = check;
        return check;
      }
    };
    TypingDNA.getTextId = function(str) {
      return TypingDNA.math.fnv1aHash(str);
    };
  } else {
    return TypingDNA.instance;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/util/TypingUtil.js
var tdna;
var TypingUtil = {
  track: function(selectorId) {
    try {
      tdna = new typingdna();
      tdna.addTarget(selectorId);
      tdna.start();
    } catch (e) {
    }
  },
  getTypingPattern: function() {
    try {
      return tdna.getTypingPattern({
        type: 1
      });
    } catch (e) {
      return null;
    }
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/primary-auth/PrimaryAuthForm.js
var PrimaryAuthForm = Form.extend({
  className: "primary-auth-form",
  noCancelButton: true,
  attributes: {
    novalidate: "novalidate"
  },
  save: function() {
    if (this.settings.get("features.passwordlessAuth")) {
      return loc3("oform.next", "login");
    }
    return loc3("primaryauth.submit", "login");
  },
  saveId: "okta-signin-submit",
  layout: "o-form-theme",
  // If socialAuth is configured, the title moves from the form to
  // the top of the container (and is rendered in socialAuth).
  title: function() {
    let formTitle = loc3("primaryauth.title", "login");
    if (this.settings.get("socialAuthPositionTop")) {
      formTitle = "";
    }
    return formTitle;
  },
  initialize: function() {
    const trackTypingPattern = this.settings.get("features.trackTypingPattern");
    this.listenTo(this, "save", function() {
      return __async(this, null, function* () {
        const {
          appState
        } = this.options;
        if (trackTypingPattern) {
          const typingPattern = TypingUtil.getTypingPattern();
          appState.set("typingPattern", typingPattern);
        }
        const creds = {
          username: this.model.get("username")
        };
        if (!this.settings.get("features.passwordlessAuth")) {
          creds.password = this.model.get("password");
        }
        appState.trigger("loading", true);
        this.state.trigger("togglePrimaryAuthButton", true);
        yield this.settings.processCreds(creds);
        if (this.settings.get("features.deviceFingerprinting")) {
          try {
            const fingerprint2 = yield DeviceFingerprint.generateDeviceFingerprint(this.settings.get("baseUrl"), this.$el);
            appState.set("deviceFingerprint", fingerprint2);
          } catch {
          }
        }
        this.model.save();
      });
    });
    this.stateEnableChange();
    this.stateUsernameChange();
  },
  stateEnableChange: function() {
    this.listenTo(this.state, "change:enabled", function(model, enable) {
      if (enable) {
        this.enable();
      } else {
        this.disable();
      }
    });
  },
  stateUsernameChange: function() {
    this.listenTo(this.state, "change:disableUsername", function(model, disable) {
      if (disable) {
        this.$el.find("#okta-signin-username").attr("disabled", true);
      } else {
        this.$el.find("#okta-signin-username").removeAttr("disabled");
      }
    });
  },
  inputs: function() {
    const inputs = [];
    inputs.push(this.getUsernameField());
    if (!this.settings.get("features.passwordlessAuth")) {
      inputs.push(this.getPasswordField());
    }
    if (this.settings.get("features.rememberMe")) {
      inputs.push(this.getRemeberMeCheckbox());
    }
    return inputs;
  },
  getUsernameField: function() {
    const userNameFieldObject = {
      className: "margin-btm-5",
      label: loc3("primaryauth.username.placeholder", "login"),
      "label-top": true,
      explain: () => {
        if (!this.isCustomized("primaryauth.username.tooltip")) {
          return false;
        }
        return Util2.createInputExplain("primaryauth.username.tooltip", "primaryauth.username.placeholder", "login");
      },
      "explain-top": true,
      name: "username",
      input: TextBox$1,
      inputId: "okta-signin-username",
      type: "text",
      disabled: this.options.appState.get("disableUsername"),
      autoComplete: "username",
      // TODO: support a11y attrs in Courage - OKTA-279025
      render: function() {
        const that = this;
        function clearAriaInvalid() {
          that.$(this).removeAttr("aria-invalid").off("focusout", clearAriaInvalid).off("change", clearAriaInvalid);
        }
        this.$(`input[name=${this.options.name}]`).attr({
          "aria-invalid": "false",
          "aria-required": "true"
        }).prop({
          required: true
        }).focusout(clearAriaInvalid).change(clearAriaInvalid);
      }
    };
    return userNameFieldObject;
  },
  getPasswordField: function() {
    const passwordFieldObject = {
      className: "margin-btm-30",
      label: loc3("primaryauth.password.placeholder", "login"),
      "label-top": true,
      explain: () => {
        if (!this.isCustomized("primaryauth.password.tooltip")) {
          return false;
        }
        return Util2.createInputExplain("primaryauth.password.tooltip", "primaryauth.password.placeholder", "login");
      },
      "explain-top": true,
      name: "password",
      inputId: "okta-signin-password",
      validateOnlyIfDirty: true,
      type: "password",
      autoComplete: "current-password",
      // TODO: support a11y attrs in Courage - OKTA-279025
      render: function() {
        const that = this;
        function clearAriaInvalid() {
          that.$(this).removeAttr("aria-invalid").off("focusout", clearAriaInvalid).off("change", clearAriaInvalid);
        }
        this.$(`input[name=${this.options.name}]`).attr({
          "aria-invalid": "false",
          "aria-required": "true"
        }).prop({
          required: true
        }).focusout(clearAriaInvalid).change(clearAriaInvalid);
      }
    };
    if (this.settings.get("features.showPasswordToggleOnSignInPage")) {
      passwordFieldObject.params = {};
      passwordFieldObject.params.showPasswordToggle = true;
    }
    return passwordFieldObject;
  },
  isCustomized: function(property) {
    const language = this.settings.get("language");
    const i18n2 = this.settings.get("i18n");
    const customizedProperty = i18n2 && i18n2[language] && i18n2[language][property];
    return !!customizedProperty;
  },
  // TODO fix method name typo
  getRemeberMeCheckbox: function() {
    return {
      label: false,
      placeholder: loc3("remember", "login"),
      name: "remember",
      type: "checkbox",
      "label-top": true,
      className: "margin-btm-0",
      initialize: function() {
        this.listenTo(this.model, "change:remember", function(model, val) {
          this.$(":checkbox").prop("checked", val).trigger("updateState");
        });
      }
    };
  },
  focus: function() {
    if (!this.model.get("username")) {
      this.getInputs().first().focus();
    } else if (!this.settings.get("features.passwordlessAuth")) {
      this.getInputs().toArray()[1].focus();
    }
    if (this.settings.get("features.trackTypingPattern")) {
      TypingUtil.track("okta-signin-username");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/Footer.js
var {
  Util: Util7
} = internal.util;
var Footer4 = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<li><a href="#" data-se="unlock" class="link js-unlock">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "unlockaccount"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 440
          },
          "end": {
            "line": 1,
            "column": 484
          }
        }
      })) + "</a></li>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<li><a href="' + alias4((helper = (helper = lookupProperty(helpers2, "href") || (depth0 != null ? lookupProperty(depth0, "href") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "href",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 539
          },
          "end": {
            "line": 1,
            "column": 547
          }
        }
      }) : helper)) + '" class="link js-custom" rel="noopener noreferrer" ' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "target") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(4, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 598
          },
          "end": {
            "line": 1,
            "column": 638
          }
        }
      })) != null ? stack1 : "") + ">" + alias4((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "text",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 639
          },
          "end": {
            "line": 1,
            "column": 647
          }
        }
      }) : helper)) + "</a></li>";
    },
    "4": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return 'target="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "target") || (depth0 != null ? lookupProperty(depth0, "target") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "target",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 620
          },
          "end": {
            "line": 1,
            "column": 630
          }
        }
      }) : helper)) + '"';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" data-se="needhelp" aria-expanded="false" aria-controls="help-links-container" class="link help js-help">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "needhelp"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 116
          },
          "end": {
            "line": 1,
            "column": 155
          }
        }
      })) + '</a><ul class="help-links js-help-links" id="help-links-container"><li><a href="#" data-se="forgot-password" class="link js-forgot-password">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "forgotpassword"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 296
          },
          "end": {
            "line": 1,
            "column": 341
          }
        }
      })) + "</a></li>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, (stack1 = depth0 != null ? lookupProperty(depth0, "features") : depth0) != null ? lookupProperty(stack1, "selfServiceUnlock") : stack1, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 350
          },
          "end": {
            "line": 1,
            "column": 500
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "each").call(alias1, (stack1 = depth0 != null ? lookupProperty(depth0, "helpLinks") : depth0) != null ? lookupProperty(stack1, "custom") : stack1, {
        "name": "each",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 500
          },
          "end": {
            "line": 1,
            "column": 665
          }
        }
      })) != null ? stack1 : "") + '<li><a href="' + alias3((helper = (helper = lookupProperty(helpers2, "helpLinkUrl") || (depth0 != null ? lookupProperty(depth0, "helpLinkUrl") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "helpLinkUrl",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 678
          },
          "end": {
            "line": 1,
            "column": 693
          }
        }
      }) : helper)) + '" data-se="help-link" class="link js-help-link" rel="noopener noreferrer" target="_blank">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "help"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 783
          },
          "end": {
            "line": 1,
            "column": 818
          }
        }
      })) + "</a></li></ul>";
    },
    "useData": true
  }),
  className: "auth-footer",
  initialize: function() {
    this.listenTo(this.state, "change:enabled", function(model, enable) {
      this.$(".link").toggleClass("o-form-disabled", !enable);
    });
  },
  getTemplateData: function() {
    let helpLinkUrl;
    const customHelpPage = this.settings.get("helpLinks.help");
    if (customHelpPage) {
      helpLinkUrl = customHelpPage;
    } else {
      helpLinkUrl = _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "baseUrl") || (depth0 != null ? lookupProperty(depth0, "baseUrl") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "baseUrl",
            "hash": {},
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 0
              },
              "end": {
                "line": 1,
                "column": 11
              }
            }
          }) : helper)) + "/help/login";
        },
        "useData": true
      })({
        baseUrl: this.settings.get("baseUrl")
      });
    }
    return oktaUnderscore.extend(this.settings.toJSON({
      verbose: true
    }), {
      helpLinkUrl
    });
  },
  postRender: function() {
    this.$(".js-help-links").hide();
  },
  toggleLinks: function(e) {
    e.preventDefault();
    this.$(".js-help-links").slideToggle(200, () => {
      this.$(".js-help").attr("aria-expanded", this.$(".js-help-links").is(":visible"));
    });
  },
  events: {
    "click .js-help": function(e) {
      e.preventDefault();
      if (!this.state.get("enabled")) {
        return;
      }
      this.toggleLinks(e);
    },
    "click .js-forgot-password": function(e) {
      e.preventDefault();
      if (!this.state.get("enabled")) {
        return;
      }
      const customResetPasswordPage = this.settings.get("helpLinks.forgotPassword");
      if (customResetPasswordPage) {
        Util7.redirect(customResetPasswordPage);
      } else {
        this.options.appState.trigger("navigate", "signin/forgot-password");
      }
    },
    "click .js-unlock": function(e) {
      e.preventDefault();
      if (!this.state.get("enabled")) {
        return;
      }
      const customUnlockPage = this.settings.get("helpLinks.unlock");
      if (customUnlockPage) {
        Util7.redirect(customUnlockPage);
      } else {
        this.options.appState.trigger("navigate", "signin/unlock");
      }
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FooterRegistration.js
var FooterRegistration = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="content-container"><span class="registration-label">' + alias4((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 64
          },
          "end": {
            "line": 1,
            "column": 73
          }
        }
      }) : helper)) + '</span><a title="' + alias4((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "text",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 90
          },
          "end": {
            "line": 1,
            "column": 98
          }
        }
      }) : helper)) + '" aria-label="' + alias4((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "text",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 112
          },
          "end": {
            "line": 1,
            "column": 120
          }
        }
      }) : helper)) + '" class="registration-link" href="#">' + alias4((helper = (helper = lookupProperty(helpers2, "text") || (depth0 != null ? lookupProperty(depth0, "text") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "text",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 157
          },
          "end": {
            "line": 1,
            "column": 165
          }
        }
      }) : helper)) + "</a></div>";
    },
    "useData": true
  }),
  className: "registration-container",
  events: {
    "click a.registration-link": "handleClickEvent"
  },
  handleClickEvent: function(e) {
    e.preventDefault();
    const clickHandler = this.settings.get("registration.click");
    if (clickHandler) {
      clickHandler();
    } else if (this.options.appState.get("isIdxStateToken")) {
      this.options.appState.trigger("navigate", "signin/enroll-user");
    } else {
      this.options.appState.trigger("navigate", "signin/register");
    }
  },
  getTemplateData: function() {
    const templateData = {
      label: loc3("registration.signup.label", "login"),
      text: loc3("registration.signup.text", "login")
    };
    return templateData;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/PrimaryAuthController.js
var PrimaryAuthController = BaseLoginController.extend({
  className: "primary-auth",
  state: {
    enabled: true
  },
  View: PrimaryAuthForm,
  constructor: function(options2) {
    options2.appState.unset("username");
    this.model = new PrimaryAuthModel({
      multiOptionalFactorEnroll: options2.settings.get("features.multiOptionalFactorEnroll"),
      settings: options2.settings,
      appState: options2.appState
    }, {
      parse: true
    });
    BaseLoginController.apply(this, arguments);
    this.addListeners();
    if (options2.settings.get("hasConfiguredButtons")) {
      this.add(CustomButtons, {
        prepend: options2.settings.get("socialAuthPositionTop"),
        options: {
          // To trigger an afterError event, we require the current controller
          currentController: this
        }
      });
    }
    this.addFooter(options2);
    if (this.options.appState.get("disableUsername")) {
      this.addFooterWithBackLink(this.options);
    }
    this.setUsername();
  },
  addFooter: function(options2) {
    this.add(new Footer4(this.toJSON({
      appState: options2.appState
    })));
    if (options2.settings.get("features.registration") || options2.appState.get("isIdxStateToken")) {
      this.add(new FooterRegistration({
        settings: this.settings,
        appState: options2.appState
      }));
    }
  },
  addFooterWithBackLink: function(options2) {
    if (!this.$el.find(".footer-back-link").length) {
      this.add(new FooterWithBackLink(this.toJSON({
        appState: options2.appState,
        className: "auth-footer footer-back-link"
      })));
    }
  },
  setUsername: function() {
    const username = this.model.get("username");
    if (username) {
      this.options.appState.set("username", username);
    }
  },
  events: {
    "focusout input[name=username]": function() {
      if (this.shouldComputeDeviceFingerprint() && this.model.get("username")) {
        const self2 = this;
        this.options.appState.trigger("loading", true);
        DeviceFingerprint.generateDeviceFingerprint(this.settings.get("baseUrl"), this.$el).then(function(fingerprint2) {
          self2.options.appState.set("deviceFingerprint", fingerprint2);
          self2.options.appState.set("username", self2.model.get("username"));
        }).catch(function() {
          self2.options.appState.set("username", self2.model.get("username"));
        }).finally(function() {
          self2.options.appState.trigger("loading", false);
        });
      } else {
        this.options.appState.set("username", this.model.get("username"));
      }
    },
    "focusin input": function(e) {
      oktaJQueryStatic(e.target.parentElement).addClass("focused-input");
    },
    "focusout input": function(e) {
      oktaJQueryStatic(e.target.parentElement).removeClass("focused-input");
    }
  },
  // This model and the AppState both have a username property.
  // The controller updates the AppState's username when the user is
  // done editing (on blur) or deletes the username (see below).
  initialize: function() {
    this.options.appState.unset("deviceFingerprint");
    this.listenTo(this.model, "change:username", function(model, value) {
      if (!value) {
        this.options.appState.set("username", "");
      }
    });
    this.listenTo(this.model, "save", function() {
      this.state.set("enabled", false);
    });
    this.listenTo(this.model, "error", function() {
      this.state.set("enabled", true);
      if (this.options.appState.get("disableUsername")) {
        this.state.set("disableUsername", true);
        this.addFooterWithBackLink(this.options);
      }
    });
    this.listenTo(this.state, "togglePrimaryAuthButton", function(buttonState) {
      this.toggleButtonState(buttonState);
    });
  },
  shouldComputeDeviceFingerprint: function() {
    return this.settings.get("features.securityImage") && this.settings.get("features.deviceFingerprinting") && this.settings.get("features.useDeviceFingerprintForSecurityImage");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/IDPDiscovery.js
var IDPDiscoveryModel = PrimaryAuthModel.extend({
  props: function() {
    const cookieUsername = fn8.getCookieUsername();
    const properties = this.getUsernameAndRemember(cookieUsername);
    return {
      username: ["string", true, properties.username],
      lastUsername: ["string", false, cookieUsername],
      context: ["object", false],
      remember: ["boolean", true, properties.remember]
    };
  },
  local: {},
  save: function() {
    const username = this.settings.transformUsername(this.get("username"), Enums.IDP_DISCOVERY);
    const remember2 = this.get("remember");
    const lastUsername = this.get("lastUsername");
    const resource = "okta:acct:" + username;
    const requestContext = this.get("requestContext");
    this.setUsernameCookie(username, remember2, lastUsername);
    this.trigger("save");
    this.appState.trigger("loading", true);
    const webfingerArgs = {
      resource,
      requestContext
    };
    const authClient = this.appState.settings.authClient;
    authClient.webfinger(webfingerArgs).then((res) => {
      if (res && res.links && res.links[0]) {
        if (res.links[0].properties["okta:idp:type"] === "OKTA") {
          this.trigger("goToPrimaryAuth");
        } else if (res.links[0].href) {
          const redirectFn = res.links[0].href.includes("OKTA_INVALID_SESSION_REPOST%3Dtrue") ? Util2.redirectWithFormGet.bind(Util2) : this.settings.get("redirectUtilFn");
          redirectFn(res.links[0].href);
        }
      }
    }).catch(() => {
      this.trigger("error");
      this.appState.trigger("removeLoading");
      fn8.removeUsernameCookie();
    }).finally(() => {
      this.appState.trigger("loading", false);
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/idp-discovery/IDPDiscoveryForm.js
var IDPDiscoveryForm = PrimaryAuthForm.extend({
  className: "idp-discovery-form",
  save: function() {
    return loc3("oform.next", "login");
  },
  saveId: "idp-discovery-submit",
  initialize: function() {
    this.listenTo(this, "save", oktaUnderscore.bind(this.model.save, this.model));
    this.stateEnableChange();
  },
  inputs: function() {
    const inputs = [];
    const usernameProps = {
      className: "margin-btm-30",
      label: loc3("primaryauth.username.placeholder", "login"),
      inputId: "idp-discovery-username",
      disabled: false
    };
    inputs.push(oktaUnderscore.extend(this.getUsernameField(), usernameProps));
    if (this.settings.get("features.rememberMe")) {
      inputs.push(this.getRemeberMeCheckbox());
    }
    return inputs;
  },
  focus: function() {
    if (!this.model.get("username")) {
      this.getInputs().first().focus();
    } else if (this.getInputs().toArray()[1]) {
      this.getInputs().toArray()[1].focus();
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/IDPDiscoveryController.js
var IDPDiscoveryController = PrimaryAuthController.extend({
  className: "idp-discovery",
  View: IDPDiscoveryForm,
  constructor: function(options2) {
    options2.appState.unset("username");
    let requestContext = options2.settings.get("idpDiscovery.requestContext");
    const lastAuthResponse = options2.appState.get("lastAuthResponse");
    const stateToken = lastAuthResponse && (lastAuthResponse === null || lastAuthResponse === void 0 ? void 0 : lastAuthResponse.stateToken);
    if (Util2.isV1StateToken(requestContext)) {
      requestContext = stateToken;
    }
    this.model = new IDPDiscoveryModel({
      requestContext,
      settings: options2.settings,
      appState: options2.appState
    }, {
      parse: true
    });
    BaseLoginController.apply(this, arguments);
    this.addListeners();
    if (options2.settings.get("hasConfiguredButtons")) {
      this.add(CustomButtons, {
        prepend: options2.settings.get("socialAuthPositionTop"),
        options: {
          // To trigger an afterError event, we require the current controller
          currentController: this
        }
      });
    }
    this.addFooter(options2);
    this.setUsername();
  },
  initialize: function() {
    PrimaryAuthController.prototype.initialize.apply(this);
    this.listenTo(this.model, "goToPrimaryAuth", function() {
      this.settings.set("username", this.model.get("username"));
      const self2 = this;
      if (this.settings.get("features.deviceFingerprinting")) {
        DeviceFingerprint.generateDeviceFingerprint(this.settings.get("baseUrl"), this.$el).then(function(fingerprint2) {
          self2.options.appState.set("deviceFingerprint", fingerprint2);
          self2.options.appState.set("username", self2.model.get("username"));
        }).catch(function() {
          self2.options.appState.set("username", self2.model.get("username"));
        }).finally(function() {
          self2.doPrimaryAuth();
        });
      } else {
        self2.doPrimaryAuth();
      }
    });
  },
  doPrimaryAuth: function() {
    if (this.settings.get("features.passwordlessAuth")) {
      const primaryAuthModel = new PrimaryAuthModel({
        username: this.model.get("username"),
        multiOptionalFactorEnroll: this.options.settings.get("features.multiOptionalFactorEnroll"),
        settings: this.options.settings,
        appState: this.options.appState
      }, {
        parse: true
      });
      this.listenTo(primaryAuthModel, "error", function(src, errObj) {
        this.toggleButtonState(false);
        this.model.trigger("error", this.model, errObj);
      });
      this.addModelListeners(primaryAuthModel);
      primaryAuthModel.save();
    } else {
      this.options.appState.set("disableUsername", true);
      this.options.appState.trigger("navigate", "signin");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ForceIDPDiscoveryController.js
var ForceIDPDiscoveryController = BaseLoginController.extend({
  className: "force-idp-discovery",
  View: Spinner,
  Model: {},
  initialize: function() {
    const OKTA_IDP_TYPE = "OKTA";
    const RESOURCE = "okta:acct:";
    const options2 = this.options;
    const lastAuthResponse = options2.appState.get("lastAuthResponse");
    const stateToken = lastAuthResponse && (lastAuthResponse === null || lastAuthResponse === void 0 ? void 0 : lastAuthResponse.stateToken);
    const webfingerArgs = {
      resource: RESOURCE,
      requestContext: stateToken
    };
    options2.appState.settings.authClient.webfinger(webfingerArgs).then((res) => {
      if (res !== null && res !== void 0 && res.links && res.links[0]) {
        if (res.links[0].properties["okta:idp:type"] !== OKTA_IDP_TYPE && res.links[0].href) {
          const redirectFn = res.links[0].href.includes("OKTA_INVALID_SESSION_REPOST%3Dtrue") ? Util2.redirectWithFormGet.bind(Util2) : this.settings.get("redirectUtilFn");
          redirectFn(res.links[0].href);
          return;
        }
      }
      options2.appState.trigger("navigate", "");
    }).catch(() => {
      options2.appState.trigger("navigate", "");
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/ManualSetupPushFooter.js
function goToFactorActivation(appState) {
  const url = fn3.createActivateFactorUrl(appState.get("activatedFactorProvider"), appState.get("activatedFactorType"));
  appState.trigger("navigate", url);
}
var Footer5 = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.backToFactors"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 106
          }
        }
      })) + '</a><a href="#" class="link help goto js-goto" data-se="goto-link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.scanBarcode"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 173
          },
          "end": {
            "line": 1,
            "column": 219
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    },
    "click .js-goto": function(e) {
      e.preventDefault();
      const goToFactor = oktaUnderscore.partial(goToFactorActivation, this.options.appState);
      this.options.appState.unset("factorActivationType");
      this.model.doTransaction(function(transaction) {
        return transaction.prev().then(function(trans) {
          const factor = oktaUnderscore.findWhere(trans.factors, {
            factorType: "push",
            provider: "OKTA"
          });
          return factor.enroll();
        });
      }).then(goToFactor);
    }
  },
  back: function() {
    const self2 = this;
    self2.options.appState.unset("factorActivationType");
    if (self2.options.appState.get("prevLink")) {
      this.model.doTransaction(function(transaction) {
        return transaction.prev();
      }).then(function() {
        self2.options.appState.trigger("navigate", "signin/enroll");
      });
    } else {
      self2.options.appState.trigger("navigate", "signin/enroll");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ManualSetupPushController.js
function goToFactorActivation2(view, step) {
  const url = fn3.createActivateFactorUrl(view.options.appState.get("activatedFactorProvider"), view.options.appState.get("activatedFactorType"), step);
  view.options.appState.trigger("navigate", url);
}
function setStateValues(view) {
  let userPhoneNumber;
  let userCountryCode;
  if (view.model.get("activationType") === "SMS") {
    userCountryCode = view.model.get("countryCode");
    userPhoneNumber = view.model.get("phoneNumber");
  }
  view.options.appState.set({
    factorActivationType: view.model.get("activationType"),
    userCountryCode,
    userPhoneNumber
  });
}
function enrollFactor(view, factorType) {
  return view.model.doTransaction(function(transaction) {
    return transaction.prev().then(function(trans) {
      const factor = oktaUnderscore.findWhere(trans.factors, {
        factorType,
        provider: "OKTA"
      });
      return factor.enroll();
    }).then(function(trans) {
      let textActivationLinkUrl;
      let emailActivationLinkUrl;
      let sharedSecret;
      const res = trans.data;
      if (res && res._embedded && res._embedded.factor && res._embedded.factor._embedded && res._embedded.factor._embedded.activation) {
        const factor = res._embedded.factor;
        sharedSecret = factor._embedded.activation.sharedSecret;
        if (factor._embedded.activation._links && factor._embedded.activation._links.send) {
          const activationSendLinks = factor._embedded.activation._links.send;
          const smsItem = oktaUnderscore.findWhere(activationSendLinks, {
            name: "sms"
          });
          textActivationLinkUrl = smsItem ? smsItem.href : null;
          const emailItem = oktaUnderscore.findWhere(activationSendLinks, {
            name: "email"
          });
          emailActivationLinkUrl = emailItem ? emailItem.href : null;
        }
      }
      view.model.set({
        SMS: textActivationLinkUrl,
        EMAIL: emailActivationLinkUrl,
        sharedSecret
      });
      return trans;
    });
  });
}
var ManualSetupPushController = FormController.extend({
  className: "enroll-manual-push",
  Model: function() {
    return {
      local: {
        activationType: ["string", true, this.options.appState.get("factorActivationType") || "SMS"],
        countryCode: ["string", false, this.options.appState.get("userCountryCode")],
        phoneNumber: "string",
        SMS: ["string", false, this.options.appState.get("textActivationLinkUrl")],
        EMAIL: ["string", false, this.options.appState.get("emailActivationLinkUrl")],
        sharedSecret: ["string", false, this.options.appState.get("sharedSecret")],
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      },
      derived: {
        countryCallingCode: {
          deps: ["countryCode"],
          fn: function(countryCode) {
            return "+" + fn4.getCallingCodeForCountry(countryCode);
          }
        },
        fullPhoneNumber: {
          deps: ["countryCallingCode", "phoneNumber"],
          fn: function(countryCallingCode, phoneNumber) {
            return countryCallingCode + phoneNumber;
          }
        }
      }
    };
  },
  Form: {
    title: function() {
      const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
      return loc3("enroll.totp.title", "login", [factorName]);
    },
    subtitle: oktaUnderscore.partial(loc3, "enroll.totp.cannotScanBarcode", "login"),
    noButtonBar: true,
    attributes: {
      "data-se": "step-manual-setup"
    },
    formChildren: function() {
      const instructions = this.settings.get("brandName") ? loc3("enroll.totp.sharedSecretInstructions.specific", "login", [this.settings.get("brandName")]) : loc3("enroll.totp.sharedSecretInstructions.generic", "login");
      const children = [FormType.Input({
        name: "activationType",
        label: loc3("mfa.setupOptions", "login"),
        type: "select",
        wide: true,
        options: {
          SMS: loc3("enroll.totp.sendSms", "login"),
          EMAIL: loc3("enroll.totp.sendEmail", "login"),
          MANUAL: loc3("enroll.totp.setupManually", "login")
        }
      }), FormType.Input({
        label: loc3("mfa.country", "login"),
        name: "countryCode",
        type: "select",
        wide: true,
        options: fn4.getCountries(),
        showWhen: {
          activationType: "SMS"
        }
      }), FormType.Input({
        label: loc3("mfa.phoneNumber.placeholder", "login"),
        "label-top": true,
        className: "enroll-sms-phone",
        name: "phoneNumber",
        input: PhoneTextBox,
        type: "text",
        showWhen: {
          activationType: "SMS"
        }
      }), FormType.View({
        View: View2.extend({
          className: "secret-key-instructions",
          attributes: {
            "data-se": "secret-key-instructions"
          },
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return '<section aria-live="assertive"><p class="okta-form-subtitle o-form-explain text-align-c">' + alias4((helper = (helper = lookupProperty(helpers2, "instructions") || (depth0 != null ? lookupProperty(depth0, "instructions") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "instructions",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 89
                  },
                  "end": {
                    "line": 1,
                    "column": 105
                  }
                }
              }) : helper)) + '</p><p class="shared-key margin-top-10" tabindex=0 aria-label="' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                "name": "i18n",
                "hash": {
                  "arguments": "sharedSecretKey",
                  "bundle": "login",
                  "code": "enroll.totp.sharedSecretInstructions.aria.secretKey"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 168
                  },
                  "end": {
                    "line": 1,
                    "column": 278
                  }
                }
              })) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "sharedSecretKey") || (depth0 != null ? lookupProperty(depth0, "sharedSecretKey") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "sharedSecretKey",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 280
                  },
                  "end": {
                    "line": 1,
                    "column": 299
                  }
                }
              }) : helper)) + "</p></section>";
            },
            "useData": true
          }),
          initialize: function() {
            this.listenTo(this.model, "change:sharedSecret", this.render);
          },
          getTemplateData: function() {
            return {
              instructions,
              sharedSecretKey: this.model.get("sharedSecret")
            };
          }
        }),
        showWhen: {
          activationType: "MANUAL"
        }
      }), FormType.View({
        View: View2.extend({
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              return '<div data-type="next-button-wrap"></div>';
            },
            "useData": true
          })
        }),
        showWhen: {
          activationType: "MANUAL"
        }
      }), FormType.Button({
        title: loc3("oform.next", "login"),
        className: "button button-primary button-wide button-next",
        attributes: {
          "data-se": "next-button"
        },
        click: () => {
          setStateValues(this);
          goToFactorActivation2(this, "passcode");
        }
      }, '[data-type="next-button-wrap"]'), FormType.Toolbar({
        noCancelButton: true,
        save: loc3("oform.send", "login"),
        showWhen: {
          activationType: function(val) {
            return val === "SMS" || val === "EMAIL";
          }
        }
      })];
      return children;
    }
  },
  Footer: Footer5,
  initialize: function() {
    this.setInitialModel();
    this.listenTo(this.form, "save", function() {
      const self2 = this;
      this.model.doTransaction(function(transaction) {
        const activationType = this.get("activationType").toLowerCase();
        const opts = {};
        if (activationType === "sms") {
          opts.profile = {
            phoneNumber: this.get("fullPhoneNumber")
          };
        }
        return transaction.factor.activation.send(activationType, opts).then(function(trans) {
          setStateValues(self2);
          oktaUnderscore.defer(function() {
            goToFactorActivation2(self2, "sent");
          });
          return trans;
        });
      });
    });
    this.listenTo(this.model, "change:activationType", function(model, value) {
      this.form.clearErrors();
      if (value === "MANUAL" && this.options.appState.get("activatedFactorType") !== "token:software:totp") {
        enrollFactor(this, "token:software:totp");
      } else if (this.options.appState.get("activatedFactorType") !== "push") {
        enrollFactor(this, "push");
      }
    });
  },
  setInitialModel: function() {
    if (this.options.appState.get("factorActivationType") === "SMS") {
      this.model.set({
        countryCode: this.options.appState.get("userCountryCode") || "US",
        phoneNumber: this.options.appState.get("userPhoneNumber")
      });
    }
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaEnrollActivate") || this.options.appState.get("isMfaEnroll")) {
      return true;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/ManualSetupFooter.js
var ManualSetupFooter = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.backToFactors"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 106
          }
        }
      })) + '</a><a href="#" class="link help goto js-goto" data-se="goto-link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.scanBarcode"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 173
          },
          "end": {
            "line": 1,
            "column": 219
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    },
    "click .js-goto": function(e) {
      e.preventDefault();
      this.model.startTransaction(function(authClient) {
        return authClient.tx.resume();
      });
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    if (this.options.appState.get("prevLink")) {
      this.model.doTransaction(function(transaction) {
        return transaction.prev();
      });
    } else {
      this.options.appState.trigger("navigate", "signin/enroll");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ManualSetupTotpController.js
var ManualSetupTotpController = FormController.extend({
  className: "enroll-manual-totp",
  Model: function() {
    return {
      local: {
        sharedSecret: ["string", false, this.options.appState.get("sharedSecret")],
        __factorType__: ["string", false, this.options.factorType],
        __provider__: ["string", false, this.options.provider]
      }
    };
  },
  Form: {
    title: function() {
      const factorName = fn2.getFactorLabel(this.model.get("__provider__"), this.model.get("__factorType__"));
      return loc3("enroll.totp.title", "login", [factorName]);
    },
    subtitle: oktaUnderscore.partial(loc3, "enroll.totp.cannotScanBarcode", "login"),
    noButtonBar: true,
    attributes: {
      "data-se": "step-manual-setup"
    },
    formChildren: function() {
      const instructions = this.settings.get("brandName") ? loc3("enroll.totp.manualSetupInstructions.specific", "login", [this.settings.get("brandName")]) : loc3("enroll.totp.manualSetupInstructions.generic", "login");
      return [FormType.View({
        View: View2.extend({
          className: "secret-key-instructions",
          attributes: {
            "data-se": "secret-key-instructions"
          },
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return '<section aria-live="assertive"><p class="okta-form-subtitle o-form-explain text-align-c">' + alias4((helper = (helper = lookupProperty(helpers2, "instructions") || (depth0 != null ? lookupProperty(depth0, "instructions") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "instructions",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 89
                  },
                  "end": {
                    "line": 1,
                    "column": 105
                  }
                }
              }) : helper)) + '</p><p class="shared-key margin-top-10" tabindex=0 aria-label="' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                "name": "i18n",
                "hash": {
                  "arguments": "sharedSecretKey",
                  "bundle": "login",
                  "code": "enroll.totp.sharedSecretInstructions.aria.secretKey"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 168
                  },
                  "end": {
                    "line": 1,
                    "column": 278
                  }
                }
              })) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "sharedSecretKey") || (depth0 != null ? lookupProperty(depth0, "sharedSecretKey") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "sharedSecretKey",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 280
                  },
                  "end": {
                    "line": 1,
                    "column": 299
                  }
                }
              }) : helper)) + "</p></section>";
            },
            "useData": true
          }),
          initialize: function() {
            this.listenTo(this.model, "change:sharedSecret", this.render);
          },
          getTemplateData: function() {
            return {
              instructions,
              sharedSecretKey: this.model.get("sharedSecret")
            };
          }
        })
      }), FormType.Toolbar({
        noCancelButton: true,
        save: loc3("oform.next", "login")
      })];
    }
  },
  Footer: ManualSetupFooter,
  initialize: function() {
    this.listenTo(this.form, "save", function() {
      const url = fn3.createActivateFactorUrl(this.model.get("__provider__"), this.model.get("__factorType__"), "activate");
      this.options.appState.trigger("navigate", url);
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/factor-verify/EmailMagicLinkForm.js
var import_q10 = __toESM(require_q());
var EmailMagicLinkForm = Form.extend({
  layout: "o-form-theme",
  className: "factor-verify-magiclink",
  autoSave: true,
  noCancelButton: true,
  initialize: function() {
    const form2 = this;
    this.title = this.model.get("factorLabel");
    const email2 = this.model.get("email") || this.options.appState.get("lastAuthResponse")._embedded.user.profile.login;
    this.subtitle = "(" + email2 + ")";
    this.add(createButton2({
      attributes: {
        "data-se": "email-send-code"
      },
      className: "button email-request-button",
      title: loc3("mfa.sendEmail", "login"),
      click: function() {
        form2.clearErrors();
        this.disable();
        this.options.title = loc3("mfa.sent", "login");
        this.render();
        this.model.save().then(() => {
          return import_q10.default.delay(Enums.API_RATE_LIMIT);
        }).then(() => {
          this.options.title = loc3("mfa.resendEmail", "login");
          this.enable();
          this.render();
        });
      }
    }));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/InlineTOTPForm.js
function addInlineTotp(form2) {
  form2.addDivider();
  form2.addInput({
    label: loc3("mfa.challenge.enterCode.placeholder", "login"),
    "label-top": true,
    className: "o-form-fieldset o-form-label-top inline-input auth-passcode",
    name: "answer",
    input: TextBox$1,
    type: "tel"
  });
  form2.add(createButton2({
    attributes: {
      "data-se": "inline-totp-verify"
    },
    className: "button inline-totp-verify margin-top-30",
    title: loc3("mfa.challenge.verify", "login"),
    click: function() {
      form2.clearErrors();
      if (!form2.isValid()) {
        return;
      }
      form2.model.manageTransaction(function(transaction, setTransaction) {
        if (transaction.status === "MFA_CHALLENGE" && transaction.prev) {
          form2.options.appState.set("trapMfaRequiredResponse", true);
          return transaction.prev().then(function(trans) {
            setTransaction(trans);
            form2.model.save();
          });
        } else {
          form2.model.save();
        }
      });
    }
  }));
  form2.at(1).focus();
}
var InlineTOTPForm = Form.extend({
  autoSave: true,
  noButtonBar: true,
  scrollOnError: false,
  layout: "o-form-theme",
  className: "mfa-verify-totp-inline",
  attributes: {
    "data-se": "factor-inline-totp"
  },
  initialize: function() {
    const form2 = this;
    this.listenTo(this.model, "error", function() {
      this.clearErrors();
    });
    this.add(createButton2({
      className: "link",
      attributes: {
        "data-se": "inline-totp-add"
      },
      title: loc3("mfa.challenge.orEnterCode", "login"),
      click: function() {
        this.remove();
        addInlineTotp(form2);
      }
    }));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/PassCodeForm.js
var import_q11 = __toESM(require_q());
var subtitleTpl2 = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "(" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "subtitle") || (depth0 != null ? lookupProperty(depth0, "subtitle") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "subtitle",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 13
        }
      }
    }) : helper)) + ")";
  },
  "useData": true
});
var PassCodeFormwarningTemplate = View2.extend({
  className: "okta-form-infobox-warning infobox infobox-warning login-timeout-warning",
  attributes: {
    "aria-live": "polite"
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon warning-16"></span><p>' + ((stack1 = (helper = (helper = lookupProperty(helpers2, "warning") || (depth0 != null ? lookupProperty(depth0, "warning") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "warning",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 53
          }
        }
      }) : helper)) != null ? stack1 : "") + "</p>";
    },
    "useData": true
  })
});
function getFormAndButtonDetails(factorType) {
  switch (factorType) {
    case "sms":
      return {
        buttonDataSe: "sms-send-code",
        buttonClassName: "sms-request-button",
        formSubmit: loc3("mfa.sendCode", "login"),
        formRetry: loc3("mfa.resendCode", "login"),
        formSubmitted: loc3("mfa.sent", "login"),
        subtitle: subtitleTpl2({
          subtitle: this.model.get("phoneNumber")
        }),
        warning: loc3("factor.sms.time.warning", "login")
      };
    case "call":
      return {
        buttonDataSe: "make-call",
        buttonClassName: "call-request-button",
        formSubmit: loc3("mfa.call", "login"),
        formRetry: loc3("mfa.redial", "login"),
        formSubmitted: loc3("mfa.calling", "login"),
        subtitle: subtitleTpl2({
          subtitle: this.model.get("phoneNumber")
        }),
        warning: loc3("factor.call.time.warning", "login")
      };
    case "email":
      return {
        buttonDataSe: "email-send-code",
        buttonClassName: "email-request-button",
        formSubmit: loc3("mfa.sendEmail", "login"),
        formRetry: loc3("mfa.resendEmail", "login"),
        formSubmitted: loc3("mfa.sent", "login"),
        subtitle: subtitleTpl2({
          subtitle: this.model.get("email")
        })
      };
    default:
      return {
        buttonDataSe: "",
        buttonClassName: "",
        formSubmit: "",
        formRetry: "",
        formSubmitted: ""
      };
  }
}
var PassCodeForm = Form.extend({
  className: "mfa-verify-passcode",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  disableSubmitButton: function() {
    return this.model.appState.get("isMfaChallenge") && this.model.get("answer");
  },
  showWarning: function(msg) {
    this.clearWarnings();
    this.add(PassCodeFormwarningTemplate, ".o-form-error-container", {
      options: {
        warning: msg
      }
    });
  },
  clearWarnings: function() {
    this.$(".okta-form-infobox-warning").remove();
  },
  initialize: function() {
    const form2 = this;
    this.title = this.model.get("factorLabel");
    const factorType = this.model.get("factorType");
    const formAndButtonDetails = getFormAndButtonDetails.call(this, factorType);
    const warningDetails = formAndButtonDetails.warning;
    this.$el.attr("data-se", "factor-" + factorType);
    this.subtitle = formAndButtonDetails.subtitle;
    this.listenTo(this.model, "error", function() {
      this.clearErrors();
    });
    this.addInput({
      label: loc3("mfa.challenge.enterCode.placeholder", "login"),
      "label-top": true,
      className: "o-form-fieldset o-form-label-top auth-passcode",
      name: "answer",
      input: TextBox$1,
      type: "tel"
    });
    this.add(createButton2({
      attributes: {
        "data-se": formAndButtonDetails.buttonDataSe
      },
      className: "button " + formAndButtonDetails.buttonClassName,
      title: formAndButtonDetails.formSubmit,
      click: function() {
        form2.clearErrors();
        this.disable();
        form2.clearWarnings();
        this.options.title = formAndButtonDetails.formSubmitted;
        this.render();
        this.model.set("answer", "");
        this.model.save().then(function() {
          form2.getInputs().first().render().focus();
          return import_q11.default.delay(Enums.API_RATE_LIMIT);
        }).then(() => {
          this.options.title = formAndButtonDetails.formRetry;
          this.enable();
          if (factorType === "call" || factorType === "sms") {
            form2.showWarning(warningDetails);
          }
          this.render();
        });
      }
    }));
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        className: "margin-btm-0",
        name: "rememberDevice",
        type: "checkbox"
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/PasswordForm.js
var PasswordForm = Form.extend({
  className: "mfa-verify-password",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  attributes: {
    "data-se": "factor-password"
  },
  initialize: function() {
    this.title = this.model.get("factorLabel");
    this.addInput({
      label: loc3("mfa.challenge.password.placeholder", "login"),
      "label-top": true,
      className: "auth-passcode",
      name: "password",
      type: "password",
      params: {
        showPasswordToggle: true
      }
    });
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        className: "margin-btm-0",
        name: "rememberDevice",
        type: "checkbox"
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/NumberChallengeView.js
var NumberChallengeView = View2.extend({
  className: "number-challenge-view",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p data-se="number-challenge-instruction">' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "arguments": "number",
          "bundle": "login",
          "code": "oktaverify.numberchallenge.instruction"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 42
          },
          "end": {
            "line": 1,
            "column": 132
          }
        }
      })) != null ? stack1 : "") + '</p><div class="phone"><div class="phone--body"><div class="phone--screen"><span class="phone--number" data-se="challenge-number">' + alias3((helper = (helper = lookupProperty(helpers2, "number") || (depth0 != null ? lookupProperty(depth0, "number") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "number",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 262
          },
          "end": {
            "line": 1,
            "column": 272
          }
        }
      }) : helper)) + '</span></div><div class="phone--home-button"></div></div></div><p>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oktaverify.numberchallenge.explain"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 338
          },
          "end": {
            "line": 1,
            "column": 403
          }
        }
      })) + "</p>";
    },
    "useData": true
  }),
  initialize: function() {
    this.listenTo(this.options.appState, "change:isWaitingForNumberChallenge", () => {
      if (this.options.appState.get("lastAuthResponse").status !== "SUCCESS") {
        this.render();
      }
    });
  },
  getTemplateData: function() {
    const lastAuthResponse = this.options.appState.get("lastAuthResponse");
    if (!this.options.appState.get("isWaitingForNumberChallenge")) {
      return {
        number: null
      };
    }
    return {
      number: lastAuthResponse._embedded.factor._embedded.challenge.correctAnswer
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/PushForm.js
var titleTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "factorName") || (depth0 != null ? lookupProperty(depth0, "factorName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorName",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 14
        }
      }
    }) : helper)) + " (" + ((stack1 = (helper = (helper = lookupProperty(helpers2, "deviceName") || (depth0 != null ? lookupProperty(depth0, "deviceName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "deviceName",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 16
        },
        "end": {
          "line": 1,
          "column": 32
        }
      }
    }) : helper)) != null ? stack1 : "") + ")";
  },
  "useData": true
});
var WARNING_TIMEOUT = 3e4;
var PushFormwarningTemplate = View2.extend({
  className: "okta-form-infobox-warning infobox infobox-warning",
  attributes: {
    "aria-live": "polite"
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon warning-16"></span><p>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "warning") || (depth0 != null ? lookupProperty(depth0, "warning") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "warning",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 51
          }
        }
      }) : helper)) + "</p>";
    },
    "useData": true
  })
});
var PushForm = Form.extend({
  className: "mfa-verify-push",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "oktaverify.send", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  attributes: {
    "data-se": "factor-push"
  },
  events: {
    submit: "submit"
  },
  initialize: function() {
    this.enabled = true;
    this.listenTo(this.options.appState, "change:isMfaRejected", this.handleRejectStateChange);
    this.numberChallengeView = this.add(NumberChallengeView).last();
    this.listenTo(this.options.appState, "change:isWaitingForNumberChallenge", function(state, isWaitingForNumberChallenge) {
      if (isWaitingForNumberChallenge || this.options.appState.get("lastAuthResponse").status === "SUCCESS") {
        this.clearWarnings();
        this.$el.find(".button").hide();
        this.numberChallengeView.$el.show();
      } else {
        this.numberChallengeView.$el.hide();
        this.$el.find(".button").show();
      }
    });
    this.listenTo(this.options.appState, "change:isMfaTimeout", function(state, isMfaTimeout) {
      this.setSubmitState(isMfaTimeout);
      if (isMfaTimeout) {
        this.showError(loc3("oktaverify.timeout", "login"));
      }
    });
    this.listenTo(this.options.appState, "change:isMfaRequired", function(state, isMfaRequired) {
      if (isMfaRequired) {
        this.clearErrors();
        this.clearWarnings();
      }
    });
    this.title = titleTpl({
      factorName: this.model.get("factorLabel"),
      deviceName: this.model.get("deviceName")
    });
  },
  setSubmitState: function(ableToSubmit) {
    const button = this.$el.find(".button");
    const a11ySpan = this.$el.find(".accessibility-text");
    this.enabled = ableToSubmit;
    if (ableToSubmit) {
      button.removeClass("link-button-disabled");
      button.prop("value", loc3("oktaverify.send", "login"));
      button.prop("disabled", false);
      if (a11ySpan) {
        a11ySpan.remove();
      }
    } else {
      button.addClass("link-button-disabled");
      button.prop("value", loc3("oktaverify.sent", "login"));
      button.prop("disabled", true);
      this.add(`<span class='accessibility-text' role='alert'>${loc3("oktaverify.sent", "login")}</span>`);
    }
  },
  submit: function(e) {
    if (e !== void 0) {
      e.preventDefault();
    }
    if (this.enabled) {
      this.setSubmitState(false);
      this.doSave();
    }
  },
  postRender: function() {
    const factorsPolicyInfo = this.options.appState.get("factorsPolicyInfo");
    const id = this.model.get("id");
    const isAutoPushEnabled = this.settings.get("features.autoPush") && factorsPolicyInfo && factorsPolicyInfo[id] ? factorsPolicyInfo[id]["autoPushEnabled"] : false;
    if (isAutoPushEnabled) {
      this.model.set("autoPush", true);
      oktaUnderscore.defer(oktaUnderscore.bind(this.submit, this));
    }
  },
  doSave: function() {
    let warningTimeout;
    this.clearErrors();
    this.clearWarnings();
    if (this.model.isValid()) {
      this.listenToOnce(this.model, "error", function() {
        this.setSubmitState(true);
        this.clearWarnings();
        clearTimeout(warningTimeout);
      });
      this.trigger("save", this.model);
      warningTimeout = Util2.callAfterTimeout(() => {
        if (!this.options.appState.get("isWaitingForNumberChallenge")) {
          this.showWarning(loc3("oktaverify.warning", "login"));
        }
      }, WARNING_TIMEOUT);
    }
  },
  showError: function(msg) {
    this.clearWarnings();
    this.model.trigger("error", this.model, {
      responseJSON: {
        errorSummary: msg
      }
    });
  },
  showWarning: function(msg) {
    this.clearWarnings();
    this.add(PushFormwarningTemplate, ".o-form-error-container", {
      options: {
        warning: msg
      }
    });
  },
  clearWarnings: function() {
    this.$(".okta-form-infobox-warning").remove();
  },
  handleRejectStateChange: function(state, isMfaRejected) {
    if (isMfaRejected) {
      this.setSubmitState(isMfaRejected);
      this.setRejectedErrorMessage();
    }
  },
  setRejectedErrorMessage: function() {
    if (this.options.appState.get("lastAuthResponse").factorResultMessage === "OKTA_VERIFY_UPGRADE_REQUIRED") {
      if (this.options.appState.get("factor").profile.platform === "IOS") {
        this.showError(loc3("oktaverify.rejected.upgradeRequired.ios", "login"));
      } else {
        this.showError(loc3("oktaverify.rejected.upgradeRequired.android", "login"));
      }
    } else {
      this.showError(loc3("oktaverify.rejected", "login"));
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/SecurityQuestionForm.js
var SecurityQuestionForm = Form.extend({
  className: "mfa-verify-question",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  attributes: {
    "data-se": "factor-question"
  },
  initialize: function() {
    this.title = this.model.get("factorLabel");
    this.addInput({
      label: this.model.get("securityQuestion"),
      "label-top": true,
      placeholder: loc3("mfa.challenge.answer.placeholder", "login"),
      className: "auth-passcode",
      name: "answer",
      type: "password",
      params: {
        showPasswordToggle: true
      }
    });
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        className: "margin-btm-0",
        name: "rememberDevice",
        type: "checkbox"
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/SendEmailAndVerifyCodeForm.js
var createEmailMaskElement = function() {
  const email2 = this.model.get("email");
  const emailTpl = _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="mask-email">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "email") || (depth0 != null ? lookupProperty(depth0, "email") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "email",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 25
          },
          "end": {
            "line": 1,
            "column": 34
          }
        }
      }) : helper)) + "</span>";
    },
    "useData": true
  });
  return {
    factorEmail: emailTpl({
      email: email2
    })
  };
};
var SendEmailAndVerifyCodeFormVerifyEmailCodeForm = Form.extend({
  layout: "o-form-theme",
  className: "mfa-verify-email",
  title: oktaUnderscore.partial(loc3, "email.mfa.title", "login"),
  noButtonBar: false,
  autoSave: true,
  noCancelButton: true,
  attributes: {
    "data-se": "factor-email"
  },
  save: function() {
    return this.options.appState.get("isMfaChallenge") ? loc3("mfa.challenge.verify", "login") : loc3("email.button.send", "login");
  },
  events: Object.assign({}, Form.prototype.events, {
    submit: function(e) {
      e.preventDefault();
      this.handleSubmit();
    }
  }),
  handleSubmit: function() {
    this.clearErrors();
    if (this.options.appState.get("isMfaChallenge")) {
      if (this.isValid()) {
        this.model.save();
      }
    } else {
      this.model.set("answer", "");
      this.model.save().then(this.renderChallengView.bind(this));
    }
  },
  initialize: function() {
    Form.prototype.initialize.apply(this, arguments);
    this.add(View2.extend({
      attributes: {
        "data-se": "mfa-send-email-content"
      },
      className: "mfa-send-email-content",
      template: _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "i18n",
            "hash": {
              "arguments": "factorEmail",
              "bundle": "login",
              "code": "email.mfa.description"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 0
              },
              "end": {
                "line": 1,
                "column": 78
              }
            }
          })) != null ? stack1 : "";
        },
        "useData": true
      }),
      getTemplateData: createEmailMaskElement
    }));
  },
  renderChallengView: function() {
    this.removeChildren();
    this.add(View2.extend({
      className: "mfa-email-sent-content",
      attributes: {
        "data-se": "mfa-email-sent-content"
      },
      // Why use `{{{` for the description?
      // - factorEmail is actually an HTML fragment which
      //   is created via another handlebar template and used for bold the email address.
      template: _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "i18n",
            "hash": {
              "arguments": "factorEmail",
              "bundle": "login",
              "code": "email.mfa.email.sent.description"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 0
              },
              "end": {
                "line": 1,
                "column": 89
              }
            }
          })) != null ? stack1 : "";
        },
        "useData": true
      }),
      getTemplateData: createEmailMaskElement
    }));
    this.add(ResendEmailView);
    this.addInput({
      label: loc3("email.code.label", "login"),
      "label-top": true,
      name: "answer",
      input: TextBox$1,
      wide: true,
      type: "tel"
    });
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        className: "margin-btm-0",
        name: "rememberDevice",
        type: "checkbox"
      });
    }
    this.render();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/TOTPForm.js
var TOTPForm = Form.extend({
  className: "mfa-verify-totp",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  attributes: {
    "data-se": "factor-totp"
  },
  initialize: function() {
    const factorName = this.model.get("factorLabel");
    const maskPasswordField = this.model.get("provider") === "RSA" || this.model.get("provider") === "DEL_OATH";
    this.title = factorName;
    if (this.model.get("isFactorTypeVerification")) {
      this.subtitle = loc3("mfa.challenge.totp.subtitle.multiple", "login", [factorName]);
    } else {
      this.subtitle = loc3("mfa.challenge.title", "login", [factorName]);
    }
    this.addInput({
      label: loc3("mfa.challenge.enterCode.placeholder", "login"),
      "label-top": true,
      className: "o-form-fieldset o-form-label-top auth-passcode",
      name: "answer",
      input: TextBox$1,
      type: maskPasswordField ? "password" : "tel"
    });
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        className: "margin-btm-0",
        name: "rememberDevice",
        type: "checkbox"
      });
    }
    if (this.model.get("provider") === "RSA" || this.model.get("provider") === "DEL_OATH") {
      this.listenTo(this.model, "error", (source, error) => {
        if (error && error.status === 409) {
          this.$(".auth-passcode input").val("");
          this.$(".auth-passcode input").trigger("change");
          this.$(".auth-passcode input").focus();
        }
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/YubikeyForm.js
var YubikeyForm = Form.extend({
  className: "mfa-verify-yubikey",
  autoSave: true,
  noCancelButton: true,
  save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
  scrollOnError: false,
  layout: "o-form-theme",
  attributes: {
    "data-se": "factor-yubikey"
  },
  initialize: function() {
    const factorName = this.model.get("factorLabel");
    this.title = factorName;
    this.subtitle = loc3("factor.totpHard.yubikey.description", "login");
    this.addInput({
      label: loc3("factor.totpHard.yubikey.placeholder", "login"),
      "label-top": true,
      className: "o-form-fieldset o-form-label-top auth-passcode",
      name: "answer",
      input: TextBox$1,
      inputId: "mfa-answer",
      type: "password"
    });
    if (this.options.appState.get("allowRememberDevice")) {
      this.addInput({
        label: false,
        "label-top": true,
        className: "margin-btm-0",
        placeholder: this.options.appState.get("rememberDeviceLabel"),
        name: "rememberDevice",
        type: "checkbox"
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FooterSignout.js
var {
  Util: Util8
} = internal.util;
var FooterSignout = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link ' + alias4((helper = (helper = lookupProperty(helpers2, "linkClassName") || (depth0 != null ? lookupProperty(depth0, "linkClassName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "linkClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 24
          },
          "end": {
            "line": 1,
            "column": 41
          }
        }
      }) : helper)) + '" data-se="signout-link">' + alias4((helper = (helper = lookupProperty(helpers2, "linkText") || (depth0 != null ? lookupProperty(depth0, "linkText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "linkText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 66
          },
          "end": {
            "line": 1,
            "column": 78
          }
        }
      }) : helper)) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer clearfix",
  events: {
    'click a[data-se="signout-link"]': "handleSignout"
  },
  handleSignout: function(e) {
    e.preventDefault();
    const appState = this.options.appState;
    appState.trigger("signOut");
    const isSMSPasswordRecovery = appState.get("isSMSPasswordRecovery");
    this.model.doTransaction(function(transaction) {
      return transaction.cancel().then(clearTransactionData);
    }).then(() => {
      if (this.settings.get("backToSignInUri") && !isSMSPasswordRecovery) {
        Util8.redirect(this.settings.get("backToSignInUri"));
      } else {
        this.state.set("navigateDir", Enums.DIRECTION_BACK);
        appState.trigger("navigate", "");
      }
    });
  },
  getTemplateData: function() {
    return {
      linkClassName: oktaUnderscore.isUndefined(this.options.linkClassName) ? "goto" : this.options.linkClassName,
      linkText: this.options.linkText || loc3("goback", "login")
    };
  }
});
function clearTransactionData(transaction) {
  return __spreadProps(__spreadValues({}, transaction), {
    data: null
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FooterMFA.js
var FooterMFA = FooterSignout.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="' + alias4((helper = (helper = lookupProperty(helpers2, "factorPageCustomLinkHref") || (depth0 != null ? lookupProperty(depth0, "factorPageCustomLinkHref") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "factorPageCustomLinkHref",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 68
          }
        }
      }) : helper)) + '" data-se="factor-page-custom-link" class="link js-factor-page-custom-link" rel="noopener noreferrer" target="_blank">' + alias4((helper = (helper = lookupProperty(helpers2, "factorPageCustomLinkText") || (depth0 != null ? lookupProperty(depth0, "factorPageCustomLinkText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "factorPageCustomLinkText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 186
          },
          "end": {
            "line": 1,
            "column": 214
          }
        }
      }) : helper)) + "</a>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link ' + alias4((helper = (helper = lookupProperty(helpers2, "linkClassName") || (depth0 != null ? lookupProperty(depth0, "linkClassName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "linkClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 265
          },
          "end": {
            "line": 1,
            "column": 282
          }
        }
      }) : helper)) + '" data-se="signout-link">' + alias4((helper = (helper = lookupProperty(helpers2, "linkText") || (depth0 != null ? lookupProperty(depth0, "linkText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "linkText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 307
          },
          "end": {
            "line": 1,
            "column": 319
          }
        }
      }) : helper)) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "hasFactorPageCustomLink") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 225
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "showLink") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 225
          },
          "end": {
            "line": 1,
            "column": 330
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  className: "auth-footer clearfix",
  getTemplateData: function() {
    const signoutTemplateData = FooterSignout.prototype.getTemplateData.apply(this, arguments);
    const factorPageCustomLinkHref = this.settings.get("helpLinks.factorPage.href");
    const factorPageCustomLinkText = this.settings.get("helpLinks.factorPage.text");
    const showLink = !this.settings.get("features.hideSignOutLinkInMFA") && !this.settings.get("features.mfaOnlyFlow");
    return Object.assign({}, signoutTemplateData, {
      hasFactorPageCustomLink: factorPageCustomLinkText && factorPageCustomLinkHref,
      factorPageCustomLinkHref,
      factorPageCustomLinkText,
      showLink
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/MfaVerifyController.js
var {
  CheckBox: CheckBox3
} = internal.views.forms.inputs;
var MfaVerifyController = BaseLoginController.extend({
  className: "mfa-verify",
  initialize: function(options2) {
    const factorType = options2.factorType;
    let View3;
    switch (factorType) {
      case "question":
        View3 = SecurityQuestionForm;
        break;
      case "email":
        if (this.options.appState.get("isIdxStateToken")) {
          View3 = EmailMagicLinkForm;
        } else {
          View3 = SendEmailAndVerifyCodeFormVerifyEmailCodeForm;
        }
        break;
      case "sms":
      case "call":
        View3 = PassCodeForm;
        break;
      case "token":
      case "token:software:totp":
      case "token:hotp":
        View3 = TOTPForm;
        break;
      case "token:hardware":
        View3 = YubikeyForm;
        break;
      case "push":
        View3 = PushForm;
        break;
      case "password":
        View3 = PasswordForm;
        break;
      default:
        throw new Error("Unrecognized factor type");
    }
    this.model = this.findModel(factorType, options2);
    if (!this.model) {
      throw new Error("Unrecognized factor/provider");
    }
    this.addListeners();
    this.add(new View3(this.toJSON()));
    if (factorType === "push" && this.model.get("isOktaFactor")) {
      if (this.model.get("backupFactor")) {
        this.inlineTotpForm = this.add(InlineTOTPForm, {
          options: {
            model: this.model.get("backupFactor")
          }
        }).last();
      }
      if (this.settings.get("features.autoPush")) {
        this.autoPushCheckBox = this.add(CheckBox3, {
          options: {
            model: this.model,
            name: "autoPush",
            placeholder: loc3("autoPush", "login"),
            label: false,
            "label-top": false,
            className: "margin-btm-0"
          }
        }).last();
      }
      if (this.options.appState.get("allowRememberDevice")) {
        this.rememberDeviceCheckbox = this.add(CheckBox3, {
          options: {
            model: this.model,
            name: "rememberDevice",
            placeholder: this.options.appState.get("rememberDeviceLabel"),
            label: false,
            "label-top": true,
            className: "margin-btm-0"
          }
        }).last();
      }
      if (this.model.get("backupFactor")) {
        this.listenTo(this.model, "change:rememberDevice", function(model, rememberDevice2) {
          model.get("backupFactor").set("rememberDevice", rememberDevice2);
        });
      }
    }
    this.listenTo(this.options.appState, "change:isWaitingForNumberChallenge", function(state, isWaitingForNumberChallenge) {
      if (isWaitingForNumberChallenge || this.options.appState.get("lastAuthResponse").status === "SUCCESS") {
        this.autoPushCheckBox && this.autoPushCheckBox.$el.hide();
        this.rememberDeviceCheckbox && this.rememberDeviceCheckbox.$el.hide();
        this.inlineTotpForm && this.inlineTotpForm.$el.hide();
      } else {
        this.autoPushCheckBox && this.autoPushCheckBox.$el.show();
        this.rememberDeviceCheckbox && this.rememberDeviceCheckbox.$el.show();
        this.inlineTotpForm && this.inlineTotpForm.$el.show();
      }
    });
    this.add(new FooterMFA(this.toJSON()));
  },
  findModel: function(factorType, options2) {
    const factors = options2.appState.get("factors");
    const provider = options2.provider;
    const factorIndex = options2.factorIndex;
    if (!provider) {
      return factors.findWhere({
        factorType,
        isFactorTypeVerification: true
      });
    } else if (factors.hasMultipleFactorsOfSameType(factorType) && factorIndex) {
      return factors.getFactorByTypeAndIndex(factorType, factorIndex);
    } else {
      return factors.findWhere({
        provider,
        factorType
      });
    }
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaRequired") && this.options.appState.get("trapMfaRequiredResponse") || this.options.appState.get("isMfaChallenge")) {
      this.options.appState.set("trapMfaRequiredResponse", false);
      return true;
    }
    return false;
  },
  back: function() {
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/PasswordRequirements.js
var PasswordRequirements = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="password-requirements--header">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "password.complexity.requirements.header"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 63
          },
          "end": {
            "line": 1,
            "column": 133
          }
        }
      })) + '</div><ul class="password-requirements--list">' + ((stack1 = lookupProperty(helpers2, "each").call(alias1, depth0 != null ? lookupProperty(depth0, "requirements") : depth0, {
        "name": "each",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 179
          },
          "end": {
            "line": 1,
            "column": 268
          }
        }
      })) != null ? stack1 : "") + "</ul>";
    },
    "2": function(container, depth0, helpers2, partials, data) {
      return '<li class="password-requirements--list-item">' + container.escapeExpression(container.lambda(depth0, depth0)) + "</li>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "requirements") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 280
          }
        }
      })) != null ? stack1 : "";
    },
    "useData": true
  }),
  attributes: {
    "data-se": "password-requirements-html"
  },
  allRequirements: [],
  initialize: function(options2) {
    const policy = options2.policy;
    if (!policy) {
      return;
    }
    this.allRequirements = fn2.getPasswordComplexityDescriptionForHtmlList(policy);
  },
  getTemplateData: function() {
    return {
      requirements: this.allRequirements
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/PasswordExpiredController.js
var PasswordExpiredController = FormController.extend({
  className: "password-expired",
  Model: {
    props: {
      oldPassword: ["string", true],
      newPassword: ["string", true],
      confirmPassword: ["string", true]
    },
    validate: function() {
      return fn5.validatePasswordMatch(this);
    },
    save: function() {
      this.trigger("save");
      return this.doTransaction(function(transaction) {
        return transaction.changePassword({
          oldPassword: this.get("oldPassword"),
          newPassword: this.get("newPassword")
        });
      });
    }
  },
  Form: {
    save: oktaUnderscore.partial(loc3, "password.expired.submit", "login"),
    title: function() {
      const expiringSoon = this.options.appState.get("isPwdExpiringSoon");
      const numDays = this.options.appState.get("passwordExpireDays");
      if (expiringSoon && numDays > 0) {
        return loc3("password.expiring.title", "login", [numDays]);
      } else if (expiringSoon && numDays === 0) {
        return loc3("password.expiring.today", "login");
      } else if (expiringSoon) {
        return loc3("password.expiring.soon", "login");
      } else {
        return this.settings.get("brandName") ? loc3("password.expired.title.specific", "login", [this.settings.get("brandName")]) : loc3("password.expired.title.generic", "login");
      }
    },
    subtitle: function() {
      if (this.options.appState.get("isPwdExpiringSoon")) {
        return this.settings.get("brandName") ? loc3("password.expiring.subtitle.specific", "login", [this.settings.get("brandName")]) : loc3("password.expiring.subtitle.generic", "login");
      }
      const policy = this.options.appState.get("policy");
      if (!policy || this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        return;
      }
      return fn2.getPasswordComplexityDescription(policy);
    },
    parseErrorMessage: function(responseJSON) {
      const policy = this.options.appState.get("policy");
      if (!!policy && this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        responseJSON = fn2.removeRequirementsFromError(responseJSON, policy);
      }
      return responseJSON;
    },
    formChildren: function() {
      let children = [];
      if (this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        children.push(FormType.View({
          View: new PasswordRequirements({
            policy: this.options.appState.get("policy")
          })
        }));
      }
      children = children.concat([FormType.Input({
        "label-top": true,
        label: loc3("password.oldPassword.placeholder", "login"),
        explain: Util2.createInputExplain("password.oldPassword.tooltip", "password.oldPassword.placeholder", "login"),
        "explain-top": true,
        name: "oldPassword",
        input: TextBox$1,
        type: "password"
      }), FormType.Divider(), FormType.Input({
        className: "margin-btm-5",
        "label-top": true,
        label: loc3("password.newPassword.placeholder", "login"),
        explain: Util2.createInputExplain("password.newPassword.tooltip", "password.newPassword.placeholder", "login"),
        "explain-top": true,
        name: "newPassword",
        input: TextBox$1,
        type: "password"
      }), FormType.Input({
        "label-top": true,
        label: loc3("password.confirmPassword.placeholder", "login"),
        explain: Util2.createInputExplain("password.confirmPassword.tooltip", "password.confirmPassword.placeholder", "login"),
        "explain-top": true,
        name: "confirmPassword",
        input: TextBox$1,
        type: "password"
      })]);
      return children;
    }
  },
  Footer: Footer2,
  initialize: function() {
    this.listenTo(this.form, "save", function() {
      const creds = {
        username: this.options.appState.get("userEmail"),
        password: this.model.get("newPassword")
      };
      this.settings.processCreds(creds).then(oktaUnderscore.bind(this.model.save, this.model));
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/PasswordResetController.js
var PasswordResetController = FormController.extend({
  className: "password-reset",
  Model: {
    props: {
      newPassword: ["string", true],
      confirmPassword: ["string", true]
    },
    validate: function() {
      return fn5.validatePasswordMatch(this);
    },
    save: function() {
      this.trigger("save");
      const self2 = this;
      return this.doTransaction(function(transaction) {
        return transaction.resetPassword({
          newPassword: self2.get("newPassword")
        });
      });
    }
  },
  Form: {
    save: oktaUnderscore.partial(loc3, "password.reset", "login"),
    title: function() {
      return this.settings.get("brandName") ? loc3("password.reset.title.specific", "login", [this.settings.get("brandName")]) : loc3("password.reset.title.generic", "login");
    },
    subtitle: function() {
      const policy = this.options.appState.get("policy");
      if (!policy || this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        return;
      }
      return fn2.getPasswordComplexityDescription(policy);
    },
    parseErrorMessage: function(responseJSON) {
      const policy = this.options.appState.get("policy");
      if (!!policy && this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        responseJSON = fn2.removeRequirementsFromError(responseJSON, policy);
      }
      return responseJSON;
    },
    formChildren: function() {
      let children = [];
      if (this.settings.get("features.showPasswordRequirementsAsHtmlList")) {
        children.push(FormType.View({
          View: new PasswordRequirements({
            policy: this.options.appState.get("policy")
          })
        }));
      }
      children = children.concat([FormType.Input({
        className: "margin-btm-5",
        label: loc3("password.newPassword.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("password.newPassword.tooltip", "password.newPassword.placeholder", "login"),
        "explain-top": true,
        name: "newPassword",
        input: TextBox$1,
        type: "password",
        autoComplete: "new-password"
      }), FormType.Input({
        label: loc3("password.confirmPassword.placeholder", "login"),
        "label-top": true,
        explain: Util2.createInputExplain("password.confirmPassword.tooltip", "password.confirmPassword.placeholder", "login"),
        "explain-top": true,
        name: "confirmPassword",
        input: TextBox$1,
        type: "password",
        autoComplete: "new-password"
      })]);
      return children;
    }
  },
  initialize: function() {
    this.listenTo(this.form, "save", function() {
      const creds = {
        username: this.options.appState.get("userEmail"),
        password: this.model.get("newPassword")
      };
      this.settings.processCreds(creds).then(oktaUnderscore.bind(this.model.save, this.model));
    });
    if (!this.settings.get("features.hideBackToSignInForReset")) {
      this.addFooter(FooterSignout);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/PollController.js
var PollController = FormController.extend({
  className: "poll",
  Model: {
    save: function() {
      this.trigger("cancelRequest");
      return this.appState.get("transaction").cancel().then(() => {
        this.options.appState.trigger("navigate", "");
      }).catch(() => {
        this._stopCountDown();
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: function() {
      return this.title;
    },
    className: "poll-controller",
    noCancelButton: true,
    save: loc3("oform.cancel", "login"),
    modelEvents: {
      cancelRequest: "_stopCountDown"
    },
    formChildren: [FormType.View({
      View: '<div >               <div data-se="poll-waiting" class="hide okta-waiting-spinner"></div>             </div>'
    })],
    _checkStatus: function() {
      this.transactionObject.poll().then((resp) => {
        if (resp.data && resp.status !== "POLL") {
          this.options.appState.set("transaction", resp);
          return;
        }
        this.$(".okta-waiting-spinner").hide();
        let factorPollingIntervalSeconds = Math.ceil(resp.transaction.profile.refresh / 1e3);
        this._startCountDown(factorPollingIntervalSeconds);
      }).catch(() => {
        this._stopCountDown();
      });
    },
    _startCountDown: function(factorPollingIntervalSeconds) {
      this.countDown = setInterval(() => {
        this._updateTitle(factorPollingIntervalSeconds);
        if (factorPollingIntervalSeconds === 0) {
          this._stopCountDown();
          this.$(".okta-waiting-spinner").show();
          this.checkStatusTimeout = setTimeout(() => {
            this._checkStatus();
          }, 200);
        } else {
          factorPollingIntervalSeconds = factorPollingIntervalSeconds - 1;
        }
      }, 1e3);
    },
    _updateTitle: function(factorPollingIntervalSeconds) {
      this.title = loc3("polling.title", "login", [factorPollingIntervalSeconds]);
      this.$el.find(".okta-form-title").text(this.title);
    },
    _stopCountDown: function() {
      if (this.countDown) {
        clearInterval(this.countDown);
      }
      if (this.checkStatusTimeout) {
        clearInterval(this.checkStatusTimeout);
      }
    },
    initialize: function(options2) {
      this.transactionObject = options2.appState.get("transaction");
      this.factorPollingIntervalSeconds = Math.ceil(this.transactionObject.transaction.profile.refresh / 1e3);
      this._updateTitle(this.factorPollingIntervalSeconds);
      this._startCountDown(this.factorPollingIntervalSeconds);
    }
  },
  back: function() {
  },
  remove: function() {
    this.form._stopCountDown();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/PwdResetEmailSentController.js
var PwdResetEmailSentController = FormController.extend({
  className: "password-reset-email-sent",
  Model: function() {
    return {
      local: {
        userFullName: ["string", false, this.options.appState.get("userFullName")]
      }
    };
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "password.forgot.emailSent.title", "login"),
    subtitle: function() {
      const username = this.options.appState.get("username");
      return loc3("password.forgot.emailSent.desc", "login", [username]);
    },
    noButtonBar: true,
    attributes: {
      "data-se": "pwd-reset-email-sent"
    },
    formChildren: function() {
      let children = [FormType.View({
        View: View2.extend({
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return '<span class="accessibility-text" role="status">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "alert") || (depth0 != null ? lookupProperty(depth0, "alert") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
                "name": "alert",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 47
                  },
                  "end": {
                    "line": 1,
                    "column": 56
                  }
                }
              }) : helper)) + "</span>";
            },
            "useData": true
          }),
          getTemplateData: function() {
            return {
              alert: loc3("password.forgot.emailSent.title", "login")
            };
          }
        })
      })];
      if (!this.settings.get("features.hideBackToSignInForReset")) {
        children.push(FormType.Button({
          title: loc3("goback", "login"),
          className: "button button-primary button-wide",
          attributes: {
            "data-se": "back-button"
          },
          click: function() {
            const self2 = this;
            return this.model.doTransaction(function(transaction) {
              return transaction.cancel();
            }).then(function() {
              self2.state.set("navigateDir", Enums.DIRECTION_BACK);
              self2.options.appState.trigger("navigate", "");
            });
          }
        }));
      }
      return children;
    }
  },
  initialize: function(options2) {
    this.settings.callGlobalSuccess(Enums.FORGOT_PASSWORD_EMAIL_SENT, {
      username: options2.appState.get("username")
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RecoveryChallengeController.js
var RecoveryChallengeController = FormController.extend({
  className: "recovery-challenge",
  Model: {
    props: {
      passCode: ["string", true]
    },
    local: {
      ableToResend: "boolean"
    },
    resendCode: function() {
      this.limitResending();
      return this.doTransaction(function(transaction) {
        return transaction.resend();
      });
    },
    limitResending: function() {
      this.set({
        ableToResend: false
      });
      oktaUnderscore.delay(oktaUnderscore.bind(this.set, this), Enums.API_RATE_LIMIT, {
        ableToResend: true
      });
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        return transaction.verify({
          passCode: this.get("passCode")
        });
      });
    }
  },
  Form: {
    autoSave: true,
    save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
    title: function() {
      if (this.options.appState.get("factorType") === Enums.RECOVERY_FACTOR_TYPE_CALL) {
        return loc3("recoveryChallenge.call.title", "login");
      } else {
        return loc3("recoveryChallenge.sms.title", "login");
      }
    },
    className: "recovery-challenge",
    initialize: function() {
      this.listenTo(this.model, "error", function() {
        this.clearErrors();
      });
    },
    formChildren: function() {
      return [FormType.Button({
        title: loc3("mfa.resendCode", "login"),
        attributes: {
          "data-se": "resend-button"
        },
        className: "button sms-request-button margin-top-30",
        click: function() {
          this.model.resendCode();
        },
        initialize: function() {
          this.listenTo(this.model, "change:ableToResend", function(model, ableToResend) {
            if (ableToResend) {
              this.options.title = loc3("mfa.resendCode", "login");
              this.enable();
              this.render();
            } else {
              this.options.title = loc3("mfa.sent", "login");
              this.disable();
              this.render();
            }
          });
        }
      }), FormType.Input({
        label: loc3("mfa.challenge.enterCode.placeholder", "login"),
        "label-top": true,
        className: "enroll-sms-phone",
        name: "passCode",
        input: TextBox$1,
        type: "text"
      })];
    }
  },
  events: {
    "click .send-email-link": function(e) {
      e.preventDefault();
      const settings = this.model.settings;
      const username = this.options.appState.get("username");
      const recoveryType = this.options.appState.get("recoveryType");
      this.model.startTransaction(function(authClient) {
        switch (recoveryType) {
          case Enums.RECOVERY_TYPE_PASSWORD:
            return authClient.forgotPassword({
              username: settings.transformUsername(username, Enums.FORGOT_PASSWORD),
              factorType: Enums.RECOVERY_FACTOR_TYPE_EMAIL
            });
          case Enums.RECOVERY_TYPE_UNLOCK:
            return authClient.unlockAccount({
              username: settings.transformUsername(username, Enums.UNLOCK_ACCOUNT),
              factorType: Enums.RECOVERY_FACTOR_TYPE_EMAIL
            });
          default:
            return;
        }
      });
    }
  },
  initialize: function() {
    const recoveryType = this.options.appState.get("recoveryType");
    let sendEmailLink;
    switch (recoveryType) {
      case Enums.RECOVERY_TYPE_PASSWORD:
        sendEmailLink = _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "password.forgot.code.notReceived"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 0
                },
                "end": {
                  "line": 1,
                  "column": 63
                }
              }
            }));
          },
          "useData": true
        });
        break;
      case Enums.RECOVERY_TYPE_UNLOCK:
        sendEmailLink = _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "account.unlock.code.notReceived"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 0
                },
                "end": {
                  "line": 1,
                  "column": 62
                }
              }
            }));
          },
          "useData": true
        });
        break;
    }
    if (sendEmailLink && this.settings.get("features.emailRecovery")) {
      this.add(View2.extend({
        className: "link send-email-link",
        tagName: "a",
        attributes: {
          href: "#",
          "data-se": "send-email-link"
        },
        template: sendEmailLink
      }));
    }
    if (!this.settings.get("features.hideBackToSignInForReset")) {
      this.addFooter(FooterSignout);
    }
  },
  postRender: function() {
    this.model.limitResending();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RecoveryLoadingController.js
var RecoveryLoadingController = FormController.extend({
  className: "recovery-loading",
  Model: {},
  Form: {
    noButtonBar: true
  },
  initialize: function(options2) {
    const self2 = this;
    return this.model.startTransaction(function(authClient) {
      return authClient.verifyRecoveryToken({
        recoveryToken: options2.token
      });
    }).catch(function() {
      self2.options.appState.trigger("loading", false);
      self2.options.appState.trigger("removeLoading");
    });
  },
  preRender: function() {
    this.options.appState.trigger("loading", true);
  },
  trapAuthResponse: function() {
    this.options.appState.trigger("loading", false);
    return false;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RecoveryQuestionController.js
var RecoveryQuestionController = FormController.extend({
  className: "recovery-question",
  Model: {
    props: {
      answer: ["string", true],
      showAnswer: "boolean"
    },
    save: function() {
      return this.doTransaction(function(transaction) {
        return transaction.answer({
          answer: this.get("answer")
        });
      });
    }
  },
  Form: {
    autoSave: true,
    save: function() {
      switch (this.options.appState.get("recoveryType")) {
        case "PASSWORD":
          return loc3("password.forgot.question.submit", "login");
        case "UNLOCK":
          return loc3("account.unlock.question.submit", "login");
        default:
          return loc3("mfa.challenge.verify", "login");
      }
    },
    title: function() {
      switch (this.options.appState.get("recoveryType")) {
        case "PASSWORD":
          return loc3("password.forgot.question.title", "login");
        case "UNLOCK":
          return loc3("account.unlock.question.title", "login");
        default:
          return "";
      }
    },
    formChildren: function() {
      return [FormType.Input({
        label: this.options.appState.get("recoveryQuestion"),
        placeholder: loc3("mfa.challenge.answer.placeholder", "login"),
        name: "answer",
        input: TextBox$1,
        type: "password",
        initialize: function() {
          this.listenTo(this.model, "change:showAnswer", function() {
            const type = this.model.get("showAnswer") ? "text" : "password";
            this.getInputs()[0].changeType(type);
          });
        }
      }), FormType.Input({
        label: false,
        "label-top": true,
        placeholder: loc3("mfa.challenge.answer.showAnswer", "login"),
        className: "recovery-question-show margin-btm-0",
        name: "showAnswer",
        type: "checkbox"
      })];
    }
  },
  initialize: function() {
    if (!this.settings.get("features.hideBackToSignInForReset")) {
      this.addFooter(FooterSignout);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RefreshAuthStateController.js
var RefreshAuthStateController = FormController.extend({
  className: "refresh-auth-state",
  Model: {},
  Form: {
    noButtonBar: true
  },
  preRender: function() {
    const appState = this.options.appState;
    const token = this.options.token;
    this.model.startTransaction(function(authClient) {
      appState.trigger("loading", true);
      if (token) {
        return authClient.tx.introspect({
          stateToken: token
        });
      }
      if (authClient.tx.exists()) {
        return authClient.tx.resume();
      }
      appState.trigger("navigate", "");
    });
  },
  remove: function() {
    this.options.appState.trigger("loading", false);
    return FormController.prototype.remove.apply(this, arguments);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RegistrationCompleteController.js
var RegistrationCompleteController = FormController.extend({
  events: {
    "click .back-btn": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  },
  className: "registration-complete",
  Model: function() {
  },
  initialize: function() {
    this.settings.callGlobalSuccess(Enums.ACTIVATION_EMAIL_SENT, {
      username: this.options.appState.get("username")
    });
  },
  Form: {
    noButtonBar: true,
    formChildren: function() {
      return [FormType.View({
        View: View2.extend({
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return '<div class="container"><span class="title-icon icon icon-16 confirm-16-green"></span><h2 class="title">' + alias4((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "title",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 103
                  },
                  "end": {
                    "line": 1,
                    "column": 112
                  }
                }
              }) : helper)) + '</h2><div class="desc">' + alias4((helper = (helper = lookupProperty(helpers2, "desc") || (depth0 != null ? lookupProperty(depth0, "desc") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
                "name": "desc",
                "hash": {},
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 135
                  },
                  "end": {
                    "line": 1,
                    "column": 143
                  }
                }
              }) : helper)) + '</div></div><a href="#" class="back-btn" data-se="back-link">' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                "name": "i18n",
                "hash": {
                  "bundle": "login",
                  "code": "goback"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 204
                  },
                  "end": {
                    "line": 1,
                    "column": 241
                  }
                }
              })) + "</a>";
            },
            "useData": true
          }),
          getTemplateData: function() {
            return {
              desc: loc3("registration.complete.confirm.text", "login"),
              title: loc3("registration.complete.title", "login")
            };
          }
        })
      })];
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/LoginModel.js
var LoginModel = BaseLoginModel.extend({
  constructor: function(options2) {
    this.settings = options2 && options2.settings;
    Model2.apply(this, arguments);
  },
  loginWithActivationToken: function(activationToken) {
    return this.startTransaction(function(authClient) {
      return authClient.signInWithCredentials({
        token: activationToken
      });
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/RegistrationSchema.js
var {
  BaseSchema: BaseSchema3,
  SchemaProperty: SchemaProperty2
} = internal.models;
var RegistrationSchemaRegistrationSchemaPropertyCollection = SchemaProperty2.Collection.extend({
  createModelProperties: function() {
    const modelProperties = SchemaProperty2.Collection.prototype.createModelProperties.apply(this);
    oktaUnderscore.each(modelProperties, function(modelProperty, name) {
      modelProperty.required = !!this.get(name).get("required");
    }, this);
    return modelProperties;
  }
});
var RegistrationSchema = BaseSchema3.Model.extend({
  expand: ["schema"],
  constructor: function() {
    this.properties = new RegistrationSchemaRegistrationSchemaPropertyCollection();
    BaseModel.apply(this, arguments);
  },
  parse: function(resp) {
    const parseResponseData = (resp2) => {
      const requireFields = resp2.schema.required;
      if (oktaUnderscore.isArray(requireFields)) {
        oktaUnderscore.each(requireFields, function(requireField) {
          const field = this.properties.get(requireField);
          if (field) {
            field.set("required", true);
          }
        }, this);
      }
      const fieldOrderIds = resp2.schema.fieldOrder;
      if (oktaUnderscore.isArray(fieldOrderIds)) {
        oktaUnderscore.each(fieldOrderIds, function(fieldOrderId, sortOrder) {
          const field = this.properties.get(fieldOrderId);
          if (field) {
            field.set("sortOrder", sortOrder);
          }
        }, this);
        this.properties.comparator = "sortOrder";
        this.properties.sort();
      }
      this.properties.defaultPolicyId = resp2.policyId;
      return resp2;
    };
    const self2 = this;
    this.settings.parseRegistrationSchema(resp, function(resp2) {
      if (resp2.profileSchema) {
        resp2.schema = resp2.profileSchema;
        BaseSchema3.Model.prototype.parse.apply(self2, [resp2]);
        resp2 = parseResponseData(resp2);
      }
      self2.trigger("parseComplete", {
        properties: self2.properties
      });
    }, function(error) {
      self2.trigger("parseComplete", {
        properties: self2.properties,
        error
      });
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RegistrationController.js
var import_q12 = __toESM(require_q());

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/registration/SubSchema.js
var SubSchemaSubSchema = View2.extend({
  index: "",
  message: "",
  class: function() {
    return;
  },
  className: function() {
    return "subschema-unsatisfied subschema-" + this.index;
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="default-schema"><span class="icon icon-16"></span>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "message") || (depth0 != null ? lookupProperty(depth0, "message") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "message",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 60
          },
          "end": {
            "line": 1,
            "column": 71
          }
        }
      }) : helper)) + "</p>";
    },
    "useData": true
  }),
  getTemplateData: function() {
    return {
      message: this.message
    };
  }
});
var SubSchema = View2.extend({
  className: "subschema",
  children: function() {
    return this.subSchemas.map(function(subSchema, index) {
      const description = subSchema.get("description");
      const message = description;
      return SubSchemaSubSchema.extend({
        index,
        message
      });
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/RegistrationController.js
var RegistrationControllerFooter = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "goback"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 50
          },
          "end": {
            "line": 1,
            "column": 87
          }
        }
      })) + "</a>";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .help": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  }
});
var RegistrationController = BaseLoginController.extend({
  className: "registration",
  initialize: function() {
    const RegistrationControllerSchema = RegistrationSchema.extend({
      settings: this.options.settings,
      url: this.options.settings.get("baseUrl") + "/api/v1/registration/form"
    });
    const schema = new RegistrationControllerSchema();
    this.state.set("schema", schema);
  },
  getRegistrationApiUrl: function() {
    const defaultPolicyId = this.settings.get("defaultPolicyId");
    const orgPolicyId = this.options.settings.get("policyId");
    const apiUrl = defaultPolicyId ? this.getRegistrationPolicyApi(defaultPolicyId) : this.getRegistrationPolicyApi(orgPolicyId);
    return apiUrl;
  },
  getRegistrationPolicyApi: function(policyId) {
    return this.options.settings.get("baseUrl") + "/api/v1/registration/" + policyId;
  },
  doPostSubmit: function() {
    if (this.model.get("activationToken")) {
      const self2 = this;
      self2.settings.callGlobalSuccess(Enums.REGISTRATION_COMPLETE, {
        activationToken: this.model.get("activationToken")
      });
      const loginModel = new LoginModel({
        settings: self2.model.appState.settings
      });
      loginModel.loginWithActivationToken(this.model.get("activationToken")).then(function(transaction) {
        self2.model.trigger("setTransaction", transaction);
      });
    } else {
      this.model.appState.set("username", this.model.get("email"));
      this.model.appState.trigger("navigate", "signin/register-complete");
    }
  },
  registerUser: function(postData) {
    const self2 = this;
    Object.keys(postData).forEach((k) => (oktaUnderscore.isNull(postData[k]) || oktaUnderscore.isUndefined(postData[k]) || postData[k] === "") && delete postData[k]);
    this.model.attributes = postData;
    Backbone.Model.prototype.save.call(this.model).then(function() {
      self2.model.trigger("startSaving");
      const activationToken = self2.model.get("activationToken");
      const postSubmitData = activationToken ? activationToken : self2.model.get("email");
      self2.settings.postRegistrationSubmit(postSubmitData, function() {
        self2.doPostSubmit();
      }, function(errors) {
        self2.showErrors(errors);
      });
    }).fail((err) => {
      const responseJSON = err.responseJSON;
      if (responseJSON && responseJSON.errorCauses.length) {
        const {
          errorCode,
          errorCauses
        } = responseJSON;
        const {
          errorSummary,
          reason,
          location: location2
        } = errorCauses[0];
        const isNotUniqueValue = errorCode === "E0000001" && reason === "UNIQUE_CONSTRAINT";
        if (isNotUniqueValue) {
          this.renderIsNotUniqueError(responseJSON);
        }
        this.renderLegacyLocationErrorIfNeeded(location2, errorSummary);
        Util2.triggerAfterError(this, new RegistrationError(errorSummary));
      }
    });
  },
  renderIsNotUniqueError: function(error) {
    const {
      location: location2
    } = error.errorCauses[0];
    const errorSummary = loc3("registration.error.userName.notUniqueWithinOrg", "login", [location2]);
    this.$el.find(".okta-form-infobox-error p").text(errorSummary);
  },
  renderLegacyLocationErrorIfNeeded: function(location2, errorSummary) {
    if (location2 && /^data\.userProfile.*/.test(location2)) {
      this.$el.find(".okta-form-infobox-error p").text(errorSummary);
    }
  },
  createRegistrationModel: function(modelProperties) {
    const self2 = this;
    const RegistrationControllerModel = Model2.extend({
      url: self2.getRegistrationApiUrl() + "/register",
      settings: this.settings,
      appState: this.options.appState,
      props: modelProperties,
      local: {
        activationToken: "string"
      },
      toJSON: function() {
        const data = Model2.prototype.toJSON.apply(this, arguments);
        return {
          userProfile: data,
          relayState: this.settings.get("relayState")
        };
      },
      parse: function(resp) {
        this.set("activationToken", resp.activationToken);
        delete resp.activationToken;
        return resp;
      },
      save: function() {
        this.settings.preRegistrationSubmit(this.attributes, function(postData) {
          self2.registerUser(postData);
        }, function(errors) {
          self2.showErrors(errors);
        });
      }
    });
    return new RegistrationControllerModel();
  },
  showErrors: function(error, hideRegisterButton) {
    if (error.callback === "parseRegistrationSchema" && error.errorCauses) {
      error.errorSummary = oktaUnderscore.clone(error.errorCauses[0].errorSummary);
      delete error.errorCauses;
    }
    this.model.trigger("error", this.model, {
      responseJSON: error
    });
    const errMsg = error.callback ? error.callback + ":" + error.errorSummary : error.errorSummary;
    Util2.triggerAfterError(this, new RegistrationError(errMsg));
    if (hideRegisterButton) {
      this.$el.find(".button-primary").hide();
    }
  },
  fetchInitialData: function() {
    const self2 = this;
    self2.state.get("schema").on("parseComplete", function(updatedSchema) {
      const modelProperties = updatedSchema.properties.createModelProperties();
      self2.settings.set("defaultPolicyId", updatedSchema.properties.defaultPolicyId);
      self2.model = self2.createRegistrationModel(modelProperties);
      const RegistrationControllerForm = Form.extend({
        layout: "o-form-theme",
        autoSave: true,
        noCancelButton: true,
        title: loc3("registration.form.title", "login"),
        save: loc3("registration.form.submit", "login"),
        modelEvents: {
          "invalid": "modifyErrors"
        },
        hasSavingState: true,
        customSavingState: {
          start: "startSaving",
          stop: "stopSaving"
        },
        modifyErrors: function(model, errorResp) {
          for (let formFieldName in errorResp) {
            if (errorResp[formFieldName] === "model.validation.field.string.minLength") {
              errorResp[formFieldName] = loc3("registration.model.validation.field.string.too.short", "login", [model.props[formFieldName].minLength]);
            } else if (errorResp[formFieldName] === "model.validation.field.string.maxLength") {
              errorResp[formFieldName] = loc3("registration.model.validation.field.string.too.long", "login", [model.props[formFieldName].maxLength + 1]);
            }
          }
        }
      });
      const form2 = new RegistrationControllerForm(self2.toJSON());
      self2.add(form2);
      self2.footer = new self2.Footer(self2.toJSON());
      self2.add(self2.footer);
      self2.addListeners();
      if (updatedSchema.error) {
        self2.showErrors(updatedSchema.error, true);
      } else {
        updatedSchema.properties.each(function(schemaProperty) {
          const inputOptions = RegistrationFormFactory.createInputOptions(schemaProperty);
          const subSchemas = schemaProperty.get("subSchemas");
          const name = schemaProperty.get("name");
          form2.addInput(inputOptions);
          if (name === "password" && subSchemas) {
            form2.add(SubSchema.extend({
              id: "subschemas-" + name,
              subSchemas
            }));
          }
        });
        const requiredFieldsLabel = _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return '<span class="required-fields-label">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "label",
              "hash": {},
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 36
                },
                "end": {
                  "line": 1,
                  "column": 45
                }
              }
            }) : helper)) + "</span>";
          },
          "useData": true
        })({
          label: loc3("registration.required.fields.label", "login")
        });
        form2.add(requiredFieldsLabel);
      }
    });
    return (0, import_q12.default)(this.state.get("schema").fetch());
  },
  Footer: RegistrationControllerFooter
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/UnlockAccountController.js
var UnlockAccountControllernoFactorsError = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-infobox-error infobox infobox-error" role="alert"><span class="icon error-16"></span><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "account.unlock.noFactorsEnabled"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 110
          },
          "end": {
            "line": 1,
            "column": 172
          }
        }
      })) + "</p></div>";
    },
    "useData": true
  })
});
var UnlockAccountControllerFooter = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link goto js-contact-support">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.noAccessToEmail"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 173
          },
          "end": {
            "line": 1,
            "column": 223
          }
        }
      })) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help js-back" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "goback"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 95
          }
        }
      })) + "</a>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "helpSupportNumber") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 99
          },
          "end": {
            "line": 1,
            "column": 234
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .js-back": function(e) {
      e.preventDefault();
      this.back();
    },
    "click .js-contact-support": function(e) {
      e.preventDefault();
      this.state.trigger("contactSupport");
      this.$(".js-contact-support").hide();
    }
  },
  getTemplateData: function() {
    return this.settings.pick("helpSupportNumber");
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  }
});
var UnlockAccountController = FormController.extend({
  className: "account-unlock",
  Model: {
    props: {
      username: ["string", true],
      factorType: ["string", true]
    },
    validate: function() {
      return fn5.validateUsername(this);
    },
    save: function() {
      const self2 = this;
      return this.startTransaction(function(authClient) {
        return authClient.unlockAccount({
          username: self2.settings.transformUsername(self2.get("username"), Enums.UNLOCK_ACCOUNT),
          factorType: self2.get("factorType")
        });
      }).catch(function() {
      });
    }
  },
  Form: {
    noButtonBar: true,
    title: oktaUnderscore.partial(loc3, "account.unlock.title", "login"),
    formChildren: function() {
      const smsEnabled = this.settings.get("features.smsRecovery");
      const callEnabled = this.settings.get("features.callRecovery");
      const emailEnabled = this.settings.get("features.emailRecovery");
      const noFactorsEnabled = !(smsEnabled || callEnabled || emailEnabled);
      const formChildren = [];
      const form2 = this;
      if (noFactorsEnabled) {
        this.add(UnlockAccountControllernoFactorsError, ".o-form-error-container");
      } else {
        formChildren.push(FormType.Input({
          label: loc3("account.unlock.email.or.username.placeholder", "login"),
          "label-top": true,
          explain: Util2.createInputExplain("account.unlock.email.or.username.tooltip", "account.unlock.email.or.username.placeholder", "login"),
          "explain-top": true,
          name: "username",
          input: TextBox$1,
          inputId: "account-recovery-username",
          type: "text",
          inlineValidation: false
        }));
        if (smsEnabled || callEnabled) {
          formChildren.push(FormType.View({
            View: View2.extend({
              template: _Handlebars2.template({
                "compiler": [8, ">= 4.3.0"],
                "main": function(container, depth0, helpers2, partials, data) {
                  var lookupProperty = container.lookupProperty || function(parent, propertyName) {
                    if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                      return parent[propertyName];
                    }
                    return void 0;
                  };
                  return '<p class="mobile-recovery-hint">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                    "name": "i18n",
                    "hash": {
                      "arguments": "mobileFactors",
                      "bundle": "login",
                      "code": "recovery.mobile.hint"
                    },
                    "data": data,
                    "loc": {
                      "start": {
                        "line": 1,
                        "column": 32
                      },
                      "end": {
                        "line": 1,
                        "column": 109
                      }
                    }
                  })) + "</p>";
                },
                "useData": true
              }),
              getTemplateData: function() {
                let mobileFactors;
                if (smsEnabled && callEnabled) {
                  mobileFactors = loc3("recovery.smsOrCall");
                } else if (callEnabled) {
                  mobileFactors = loc3("recovery.call");
                } else {
                  mobileFactors = loc3("recovery.sms");
                }
                return {
                  mobileFactors
                };
              }
            })
          }));
        }
        if (smsEnabled) {
          this.$el.addClass("forgot-password-sms-enabled");
          formChildren.push(this.createRecoveryFactorButton("sms-button", "account.unlock.sendText", Enums.RECOVERY_FACTOR_TYPE_SMS, form2));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_SMS);
        }
        if (callEnabled) {
          this.$el.addClass("forgot-password-call-enabled");
          formChildren.push(this.createRecoveryFactorButton("call-button", "account.unlock.voiceCall", Enums.RECOVERY_FACTOR_TYPE_CALL, form2));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_CALL);
        }
        if (emailEnabled) {
          this.$el.addClass("forgot-password-email-enabled");
          formChildren.push(this.createRecoveryFactorButton("email-button", "account.unlock.sendEmail", Enums.RECOVERY_FACTOR_TYPE_EMAIL, form2));
          this.setDefaultFactorType(Enums.RECOVERY_FACTOR_TYPE_EMAIL);
        }
      }
      return formChildren;
    },
    initialize: function() {
      this.listenTo(this, "save", function() {
        this.options.appState.set("username", this.model.get("username"));
        this.model.save();
      });
      this.listenTo(this.state, "contactSupport", function() {
        this.add(ContactSupport, ".o-form-error-container");
      });
    },
    setDefaultFactorType: function(factorType) {
      if (oktaUnderscore.isEmpty(this.model.get("factorType"))) {
        this.model.set("factorType", factorType);
      }
    },
    createRecoveryFactorButton: function(className2, labelCode, factorType, form2) {
      return FormType.Button({
        attributes: {
          "data-se": className2
        },
        className: "button button-primary button-wide " + className2,
        title: loc3(labelCode, "login"),
        click: function() {
          form2.clearErrors();
          if (this.model.isValid()) {
            this.model.set("factorType", factorType);
            form2.trigger("save", this.model);
          }
        }
      });
    }
  },
  Footer: UnlockAccountControllerFooter
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/UnlockEmailSentController.js
var UnlockEmailSentController = FormController.extend({
  className: "account-unlock-email-sent",
  Model: function() {
    return {
      local: {
        userFullName: ["string", false, this.options.appState.get("userFullName")]
      }
    };
  },
  Form: {
    title: oktaUnderscore.partial(loc3, "account.unlock.emailSent.title", "login"),
    subtitle: function() {
      const username = this.options.appState.get("username");
      return loc3("account.unlock.emailSent.desc", "login", [username]);
    },
    noButtonBar: true,
    attributes: {
      "data-se": "unlock-email-sent"
    },
    formChildren: function() {
      return [FormType.Button({
        title: loc3("goback", "login"),
        className: "button button-primary button-wide",
        attributes: {
          "data-se": "back-button"
        },
        click: function() {
          this.state.set("navigateDir", Enums.DIRECTION_BACK);
          this.options.appState.trigger("navigate", "");
        }
      })];
    }
  },
  initialize: function(options2) {
    this.settings.callGlobalSuccess(Enums.UNLOCK_ACCOUNT_EMAIL_SENT, {
      username: options2.appState.get("username")
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyCustomFactorController.js
var {
  Util: Util9
} = internal.util;
var VerifyCustomFactorController = FormController.extend({
  className: "verify-custom-factor custom-factor-form",
  Model: {
    props: {
      rememberDevice: "boolean"
    },
    initialize: function() {
      const rememberDevice2 = fn2.getRememberDeviceValue(this.appState);
      this.set("rememberDevice", rememberDevice2);
      if (this.settings.get("features.skipIdpFactorVerificationBtn") && !this.appState.get("lastFailedChallengeFactorData")) {
        this.set("provider", "CUSTOM");
        this.set("factorType", "claims_provider");
        this.save();
      }
    },
    save: function() {
      const rememberDevice2 = !!this.get("rememberDevice");
      return this.manageTransaction((transaction, setTransaction) => {
        const data = {
          rememberDevice: rememberDevice2
        };
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          provider: this.get("provider"),
          factorType: this.get("factorType")
        });
        return factor.verify(data).then((trans) => {
          setTransaction(trans);
          const url = this.appState.get("verifyCustomFactorRedirectUrl");
          if (url !== null) {
            Util9.redirect(url);
          }
        }).catch(function(err) {
          throw err;
        });
      });
    }
  },
  Form: function() {
    const factors = this.options.appState.get("factors");
    const factor = factors.findWhere({
      provider: this.options.provider,
      factorType: this.options.factorType
    });
    const vendorName = factor.get("vendorName");
    const saveText = loc3("mfa.challenge.verify", "login");
    const lastFailedChallengeFactorData = this.options.appState.get("lastFailedChallengeFactorData");
    let subtitle = loc3("verify.customFactor.subtitle", "login", [vendorName]);
    if (this.settings.get("features.skipIdpFactorVerificationBtn") && !lastFailedChallengeFactorData) {
      subtitle = loc3("verify.customFactor.subtitle.redirect", "login", [vendorName]);
      this.listenTo(this.model, "error", () => {
        subtitle = loc3("verify.customFactor.subtitle", "login", [vendorName]);
        this.$(".o-form-explain").text(subtitle);
      });
    }
    return {
      autoSave: true,
      title: vendorName,
      save: saveText,
      subtitle,
      attributes: {
        "data-se": "factor-custom"
      },
      initialize: function() {
        if (this.options.appState.get("allowRememberDevice")) {
          this.addInput({
            label: false,
            "label-top": true,
            placeholder: this.options.appState.get("rememberDeviceLabel"),
            className: "margin-btm-0",
            name: "rememberDevice",
            type: "checkbox"
          });
        }
      },
      formChildren: function() {
        const result = [];
        const lastFailedChallengeFactorData2 = this.options.appState.get("lastFailedChallengeFactorData");
        if (this.settings.get("features.skipIdpFactorVerificationBtn") && !lastFailedChallengeFactorData2) {
          result.push(FormType.View({
            View: '<div data-se="custom-factor-waiting" class="okta-waiting-spinner"></div>'
          }));
        }
        if (lastFailedChallengeFactorData2) {
          result.push(FormType.View({
            View: new HtmlErrorMessageView({
              message: lastFailedChallengeFactorData2.errorMessage
            })
          }, {
            selector: ".o-form-error-container"
          }));
        }
        return result;
      }
    };
  },
  postRender: function() {
    if (this.settings.get("features.skipIdpFactorVerificationBtn") && !this.options.appState.get("lastFailedChallengeFactorData")) {
      this.$(".o-form-button-bar").hide();
      this.$(".okta-waiting-spinner").show();
    }
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaChallenge")) {
      return true;
    }
  },
  back: function() {
  },
  initialize: function() {
    this.model.set("provider", this.options.provider);
    this.model.set("factorType", this.options.factorType);
    if (this.settings.get("features.skipIdpFactorVerificationBtn")) {
      this.listenTo(this.model, "error", () => {
        this.$(".okta-waiting-spinner").hide();
        this.$(".o-form-button-bar").show();
      });
    }
    this.addFooter(FooterMFA);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyDuoController.js
var import_q13 = __toESM(require_q());
var VerifyDuoController = FormController.extend({
  className: "mfa-verify-duo duo-form",
  Model: {
    props: {
      host: "string",
      signature: "string",
      postAction: "string",
      factorId: "string",
      stateToken: "string",
      rememberDevice: "boolean"
    },
    initialize: function() {
      const rememberDevice2 = fn2.getRememberDeviceValue(this.appState);
      this.set("rememberDevice", rememberDevice2);
    },
    getInitOptions: function() {
      const rememberDevice2 = !!this.get("rememberDevice");
      return this.doTransaction(
        function(transaction) {
          const data = {
            rememberDevice: rememberDevice2
          };
          const factor = oktaUnderscore.findWhere(transaction.factors, {
            provider: "DUO",
            factorType: "web"
          });
          return factor.verify(data).catch(function(err) {
            throw err;
          });
        },
        true
        /* rethrow errors */
      );
    },
    verify: function(signedResponse) {
      const url = this.get("postAction");
      const factorId = this.get("factorId");
      const self2 = this;
      let data = {
        id: factorId,
        stateToken: this.get("stateToken"),
        sig_response: signedResponse
      };
      const rememberDevice2 = this.get("rememberDevice");
      return (0, import_q13.default)(oktaJQueryStatic.post(url, data)).then(function() {
        return self2.doTransaction(function(transaction) {
          let data2;
          if (rememberDevice2) {
            data2 = {
              rememberDevice: rememberDevice2
            };
          }
          return transaction.poll(data2);
        });
      }).catch(function(err) {
        self2.trigger("error", self2, err.xhr);
      });
    }
  },
  Form: {
    autoSave: true,
    noButtonBar: true,
    title: oktaUnderscore.partial(loc3, "factor.duo"),
    attributes: {
      "data-se": "factor-duo"
    },
    postRender: function() {
      this.add('<iframe frameborder="0" title="' + this.title() + '"></iframe>');
      if (this.options.appState.get("allowRememberDevice")) {
        this.addInput({
          label: false,
          "label-top": true,
          placeholder: this.options.appState.get("rememberDeviceLabel"),
          className: "margin-btm-0",
          name: "rememberDevice",
          type: "checkbox"
        });
      }
      Duo.init({
        host: this.model.get("host"),
        sig_request: this.model.get("signature"),
        iframe: this.$("iframe").get(0),
        post_action: oktaUnderscore.bind(this.model.verify, this.model)
      });
    }
  },
  fetchInitialData: function() {
    const self2 = this;
    return this.model.getInitOptions().then(function(trans) {
      const res = trans.data;
      if (!res._embedded || !res._embedded.factor || !res._embedded.factor._embedded || !res._embedded.factor._embedded.verification) {
        throw new Error("Response does not have duo verification options");
      }
      const verification = res._embedded.factor._embedded.verification;
      self2.model.set({
        host: verification.host,
        signature: verification.signature,
        postAction: verification._links.complete.href,
        factorId: res._embedded.factor.id,
        stateToken: res.stateToken
      });
    });
  },
  trapAuthResponse: function() {
    if (this.options.appState.get("isMfaChallenge")) {
      return true;
    }
  },
  back: function() {
  },
  Footer: FooterMFA
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyPIVController.js
var {
  Util: Util10
} = internal.util;
var VerifyPIVController = FormController.extend({
  className: "piv-cac-card",
  Model: {
    save: function() {
      return __async(this, null, function* () {
        this.trigger("request");
        const self2 = this;
        const pivConfig = this.settings.get("piv");
        const data = {
          fromURI: this.settings.get("relayState"),
          isCustomDomain: pivConfig.isCustomDomain
        };
        try {
          yield this.getCert(pivConfig.certAuthUrl);
          const res = yield this.postCert(pivConfig.certAuthUrl, data);
          Util10.redirect(res.redirectUrl);
        } catch (err) {
          if (oktaUnderscore.isEmpty(err.responseJSON) && !err.responseText) {
            err.responseJSON = {
              errorSummary: loc3("piv.cac.error", "login")
            };
          }
          self2.trigger("error", self2, err);
        }
      });
    },
    getCert: function(certAuthUrl) {
      return oktaJQueryStatic.get({
        url: certAuthUrl,
        xhrFields: {
          withCredentials: true
        },
        beforeSend: function() {
        }
      });
    },
    postCert: function(certAuthUrl, data) {
      return oktaJQueryStatic.post({
        url: certAuthUrl,
        xhrFields: {
          withCredentials: true
        },
        data: JSON.stringify(data),
        contentType: "text/plain",
        beforeSend: function() {
        }
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: oktaUnderscore.partial(loc3, "piv.cac.title", "login"),
    className: "piv-cac-card",
    noCancelButton: true,
    save: oktaUnderscore.partial(loc3, "retry", "login"),
    modelEvents: {
      request: "_startEnrollment",
      error: "_stopEnrollment"
    },
    formChildren: [FormType.View({
      View: View2.extend({
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return '<div class="piv-verify-text"><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "piv.cac.card.insert"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 32
                },
                "end": {
                  "line": 1,
                  "column": 82
                }
              }
            })) + '</p><div data-se="piv-waiting" class="okta-waiting-spinner"></div></div>';
          },
          "useData": true
        })
      })
    })],
    _startEnrollment: function() {
      this.$(".okta-waiting-spinner").show();
      this.$(".o-form-button-bar").hide();
    },
    _stopEnrollment: function() {
      this.$(".okta-waiting-spinner").hide();
      this.$(".o-form-button-bar").show();
    },
    postRender: function() {
      oktaUnderscore.defer(() => {
        this.model.save();
      });
    }
  },
  back: function() {
  },
  Footer: FooterWithBackLink
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyU2FController.js
var import_q14 = __toESM(require_q());
function getRegisteredKeysSequence(factors) {
  const keys = [];
  oktaUnderscore.each(factors, function(factor) {
    keys.push({
      version: factor.profile.version,
      keyHandle: factor.profile.credentialId
    });
  });
  return keys;
}
var VerifyU2FController = FormController.extend({
  className: "mfa-verify verify-u2f",
  Model: {
    props: {
      rememberDevice: "boolean"
    },
    initialize: function() {
      const rememberDevice2 = fn2.getRememberDeviceValue(this.appState);
      this.set("rememberDevice", rememberDevice2);
    },
    save: function() {
      this.trigger("request");
      return this.doTransaction(function(transaction) {
        let factor;
        if (transaction.factorTypes) {
          factor = oktaUnderscore.findWhere(transaction.factorTypes, {
            factorType: "u2f"
          });
        } else {
          factor = oktaUnderscore.findWhere(transaction.factors, {
            factorType: "u2f",
            provider: "FIDO"
          });
        }
        const self2 = this;
        return factor.verify().then(function(transaction2) {
          let registeredKeys;
          let appId;
          let nonce;
          if (transaction2.factors) {
            const factors = transaction2.factors;
            appId = factors[0]["profile"]["appId"];
            nonce = transaction2.challenge.nonce;
            registeredKeys = getRegisteredKeysSequence(factors);
          } else {
            const factorData2 = transaction2.factor;
            appId = factorData2.profile.appId;
            nonce = factorData2.challenge.nonce;
            registeredKeys = [{
              version: fn6.getU2fVersion(),
              keyHandle: factorData2.profile.credentialId
            }];
          }
          self2.trigger("request");
          const deferred = import_q14.default.defer();
          u2f.sign(appId, nonce, registeredKeys, function(data) {
            self2.trigger("errors:clear");
            if (data.errorCode && data.errorCode !== 0) {
              const isOneFactor = self2.options.appState.get("factors").length === 1;
              deferred.reject(new U2FError({
                xhr: {
                  responseJSON: {
                    errorSummary: fn6.getU2fVerifyErrorMessageByCode(data.errorCode, isOneFactor)
                  }
                }
              }));
            } else {
              const rememberDevice2 = !!self2.get("rememberDevice");
              return factor.verify({
                clientData: data.clientData,
                signatureData: data.signatureData,
                rememberDevice: rememberDevice2
              }).then(deferred.resolve);
            }
          });
          return deferred.promise;
        });
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: oktaUnderscore.partial(loc3, "factor.u2f", "login"),
    className: "verify-u2f-form",
    noCancelButton: true,
    save: oktaUnderscore.partial(loc3, "verify.u2f.retry", "login"),
    noButtonBar: function() {
      return !fn6.isU2fAvailable();
    },
    modelEvents: {
      request: "_startEnrollment",
      error: "_stopEnrollment"
    },
    formChildren: function() {
      const result = [];
      if (!fn6.isU2fAvailable()) {
        let errorMessageKey = "u2f.error.factorNotSupported";
        if (this.options.appState.get("factors").length === 1) {
          errorMessageKey = "u2f.error.factorNotSupported.oneFactor";
        }
        result.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3(errorMessageKey, "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      } else {
        result.push(FormType.View({
          View: View2.extend({
            template: _Handlebars2.template({
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="u2f-verify-text"><p>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "verify.u2f.instructions"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 32
                    },
                    "end": {
                      "line": 1,
                      "column": 86
                    }
                  }
                })) + "</p><p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "verify.u2f.instructionsBluetooth"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 93
                    },
                    "end": {
                      "line": 1,
                      "column": 156
                    }
                  }
                })) + '</p><div data-se="u2f-waiting" class="okta-waiting-spinner"></div></div>';
              },
              "useData": true
            })
          })
        }));
      }
      if (this.options.appState.get("allowRememberDevice")) {
        result.push(FormType.Input({
          label: false,
          "label-top": true,
          placeholder: this.options.appState.get("rememberDeviceLabel"),
          className: "margin-btm-0",
          name: "rememberDevice",
          type: "checkbox"
        }));
      }
      return result;
    },
    postRender: function() {
      oktaUnderscore.defer(() => {
        if (fn6.isU2fAvailable()) {
          this.model.save();
        } else {
          this.$('[data-se="u2f-waiting"]').addClass("hide");
        }
      });
    },
    _startEnrollment: function() {
      this.$(".okta-waiting-spinner").removeClass("hide");
      this.$(".o-form-button-bar").hide();
    },
    _stopEnrollment: function() {
      this.$(".okta-waiting-spinner").addClass("hide");
      this.$(".o-form-button-bar").show();
    }
  },
  back: function() {
  },
  Footer: FooterMFA
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyWebauthnController.js
var import_q15 = __toESM(require_q());
function getAllowCredentials(factors) {
  const allowCredentials = [];
  oktaUnderscore.each(factors, function(factor) {
    allowCredentials.push({
      type: "public-key",
      id: fn7.strToBin(factor.profile.credentialId)
    });
  });
  return allowCredentials;
}
var VerifyWebauthnController = FormController.extend({
  className: "mfa-verify verify-webauthn",
  Model: {
    props: {
      rememberDevice: "boolean"
    },
    initialize: function() {
      const rememberDevice2 = fn2.getRememberDeviceValue(this.appState);
      this.set("rememberDevice", rememberDevice2);
      this.appState.on("factorSwitched signOut", () => {
        if (this.webauthnAbortController) {
          this.webauthnAbortController.abort();
          this.webauthnAbortController = null;
        }
      });
    },
    save: function() {
      this.trigger("request");
      return this.doTransaction(function(transaction) {
        let factor;
        if (transaction.factorTypes) {
          factor = oktaUnderscore.findWhere(transaction.factorTypes, {
            factorType: "webauthn"
          });
        } else {
          factor = oktaUnderscore.findWhere(transaction.factors, {
            factorType: "webauthn",
            provider: "FIDO"
          });
        }
        const self2 = this;
        return factor.verify().then(function(transaction2) {
          let allowCredentials;
          let challenge;
          if (transaction2.factors) {
            const factors = transaction2.factors;
            challenge = transaction2.challenge;
            allowCredentials = getAllowCredentials(factors);
          } else {
            const factorData2 = transaction2.factor;
            challenge = factorData2.challenge;
            allowCredentials = getAllowCredentials([factorData2]);
          }
          self2.trigger("request");
          const options2 = oktaUnderscore.extend({}, challenge, {
            allowCredentials,
            challenge: fn7.strToBin(challenge.challenge)
          });
          if (typeof AbortController !== "undefined") {
            self2.webauthnAbortController = new AbortController();
          }
          return new import_q15.default(
            // navigator.credentials is not supported in IE11
            // eslint-disable-next-line compat/compat
            navigator.credentials.get({
              publicKey: options2,
              signal: self2.webauthnAbortController && self2.webauthnAbortController.signal
            })
          ).then(function(assertion) {
            const rememberDevice2 = !!self2.get("rememberDevice");
            return factor.verify({
              clientData: fn7.binToStr(assertion.response.clientDataJSON),
              authenticatorData: fn7.binToStr(assertion.response.authenticatorData),
              signatureData: fn7.binToStr(assertion.response.signature),
              rememberDevice: rememberDevice2
            });
          }).catch(function(error) {
            self2.trigger("errors:clear");
            if (!self2.webauthnAbortController) {
              throw new WebauthnAbortError();
            } else {
              throw new WebAuthnError({
                xhr: {
                  responseJSON: {
                    errorSummary: error.message
                  }
                }
              });
            }
          }).finally(function() {
            self2.webauthnAbortController = null;
          });
        });
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: oktaUnderscore.partial(loc3, "factor.webauthn.biometric", "login"),
    className: "verify-webauthn-form",
    noCancelButton: true,
    save: oktaUnderscore.partial(loc3, "mfa.challenge.verify", "login"),
    noButtonBar: function() {
      return !webauthn.isNewApiAvailable();
    },
    modelEvents: {
      request: "_startEnrollment",
      error: "_stopEnrollment"
    },
    formChildren: function() {
      const children = [];
      if (webauthn.isNewApiAvailable()) {
        children.push(FormType.View({
          View: View2.extend({
            template: _Handlebars2.template({
              "compiler": [8, ">= 4.3.0"],
              "main": function(container, depth0, helpers2, partials, data) {
                var lookupProperty = container.lookupProperty || function(parent, propertyName) {
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return parent[propertyName];
                  }
                  return void 0;
                };
                return '<div class="webauthn-verify-text"><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                  "name": "i18n",
                  "hash": {
                    "bundle": "login",
                    "code": "verify.webauthn.biometric.instructions"
                  },
                  "data": data,
                  "loc": {
                    "start": {
                      "line": 1,
                      "column": 37
                    },
                    "end": {
                      "line": 1,
                      "column": 106
                    }
                  }
                })) + '</p><div data-se="webauthn-waiting" class="okta-waiting-spinner"></div></div>';
              },
              "useData": true
            })
          })
        }));
      } else {
        let errorMessageKey = "webauthn.biometric.error.factorNotSupported";
        if (this.options.appState.get("factors").length === 1) {
          errorMessageKey = "webauthn.biometric.error.factorNotSupported.oneFactor";
        }
        children.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3(errorMessageKey, "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      }
      if (this.options.appState.get("allowRememberDevice")) {
        children.push(FormType.Input({
          label: false,
          "label-top": true,
          placeholder: this.options.appState.get("rememberDeviceLabel"),
          className: "margin-btm-0",
          name: "rememberDevice",
          type: "checkbox"
        }));
      }
      return children;
    },
    _startEnrollment: function() {
      this.$(".okta-waiting-spinner").show();
      this.$(".o-form-button-bar").hide();
    },
    _stopEnrollment: function() {
      this.$(".okta-waiting-spinner").hide();
      this.$('.o-form-button-bar [type="submit"]')[0].value = loc3("verify.u2f.retry", "login");
      this.$(".o-form-button-bar").show();
    }
  },
  postRender: function() {
    oktaUnderscore.defer(() => {
      if (webauthn.isNewApiAvailable() && !fn.isSafari()) {
        this.model.save();
      }
    });
  },
  back: function() {
  },
  Footer: FooterMFA
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyWindowsHelloController.js
var VerifyWindowsHelloController = FormController.extend({
  className: "mfa-verify verify-windows-hello",
  Model: {
    local: {
      __autoTriggered__: "boolean"
    },
    save: function() {
      if (!webauthn.isAvailable()) {
        return;
      }
      this.trigger("request");
      const model = this;
      return this.doTransaction(function(transaction) {
        const factor = oktaUnderscore.findWhere(transaction.factors, {
          factorType: "webauthn",
          provider: "FIDO"
        });
        return factor.verify().then(function(verifyData) {
          const factorData2 = verifyData.factor;
          return webauthn.getAssertion(factorData2.challenge.nonce, [{
            id: factorData2.profile.credentialId
          }]).then(function(assertion) {
            return factor.verify({
              authenticatorData: assertion.authenticatorData,
              clientData: assertion.clientData,
              signatureData: assertion.signature
            });
          }).then(function(data) {
            model.trigger("sync");
            model.trigger("signIn");
            return data;
          }).catch(function(error) {
            switch (error.message) {
              case "AbortError":
              case "NotFoundError":
              case "NotSupportedError":
                model.trigger("abort", error.message);
                return transaction;
            }
            throw error;
          });
        });
      });
    }
  },
  Form: {
    autoSave: true,
    hasSavingState: false,
    title: oktaUnderscore.partial(loc3, "factor.windowsHello", "login"),
    subtitle: function() {
      return webauthn.isAvailable() ? loc3("verify.windowsHello.subtitle", "login") : "";
    },
    save: oktaUnderscore.partial(loc3, "verify.windowsHello.save", "login"),
    customSavingState: {
      stop: "abort"
    },
    modelEvents: function() {
      if (!webauthn.isAvailable()) {
        return {};
      }
      return {
        request: "_startEnrollment",
        error: "_stopEnrollment",
        abort: "_stopEnrollment",
        signIn: "_successEnrollment"
      };
    },
    noButtonBar: function() {
      return !webauthn.isAvailable();
    },
    formChildren: function() {
      const result = [];
      if (!webauthn.isAvailable()) {
        result.push(FormType.View({
          View: new HtmlErrorMessageView({
            message: loc3("enroll.windowsHello.error.notWindows", "login")
          })
        }, {
          selector: ".o-form-error-container"
        }));
      }
      result.push(FormType.View({
        View: new Spinner({
          model: this.model,
          visible: false
        })
      }));
      return result;
    },
    postRender: function() {
      if (this.options.appState.get("factors").length === 1 && !this.model.get("__autoTriggered__")) {
        this.model.set("__autoTriggered__", true);
        this.model.save();
      }
    },
    _startEnrollment: function() {
      this.subtitle = loc3("verify.windowsHello.subtitle.loading", "login");
      this.model.trigger("spinner:show");
      this._resetErrorMessage();
      this.render();
      this.$(".o-form-button-bar").addClass("hide");
    },
    _stopEnrollment: function(errorMessage) {
      this.subtitle = loc3("verify.windowsHello.subtitle", "login");
      this.model.trigger("spinner:hide");
      this.$(".o-form-button-bar").removeClass("hide");
      let message;
      switch (errorMessage) {
        case "NotFoundError":
          message = this.options.appState.get("factors").length > 1 ? loc3("verify.windowsHello.error.notFound.selectAnother", "login") : loc3("verify.windowsHello.error.notFound", "login");
          break;
        case "NotSupportedError":
          message = loc3("enroll.windowsHello.error.notConfiguredHtml", "login");
          break;
      }
      this._resetErrorMessage();
      if (message) {
        const messageView = new HtmlErrorMessageView({
          message
        });
        this.$(".o-form-error-container").addClass("o-form-has-errors");
        this.add(messageView, {
          selector: ".o-form-error-container"
        });
        this._errorMessageView = this.last();
      }
      this.render();
    },
    _successEnrollment: function() {
      this.subtitle = this.settings.get("brandName") ? loc3("verify.windowsHello.subtitle.signingIn.specific", "login", [this.settings.get("brandName")]) : loc3("verify.windowsHello.subtitle.signingIn.generic", "login");
      this.render();
      this.$(".o-form-button-bar").addClass("hide");
    },
    _resetErrorMessage: function() {
      this._errorMessageView && this._errorMessageView.remove();
      this._errorMessageView = void 0;
      this.clearErrors();
    }
  },
  back: function() {
  },
  Footer: FooterMFA
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FooterWithBackLinkOnError.js
var FooterWithBackLinkOnError = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="link help" data-se="back-link">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "goback"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 66
          },
          "end": {
            "line": 1,
            "column": 103
          }
        }
      })) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "showLink") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 114
          }
        }
      })) != null ? stack1 : "";
    },
    "useData": true
  }),
  className: "auth-footer",
  events: {
    "click .help": function(e) {
      e.preventDefault();
      this.back();
    }
  },
  back: function() {
    this.state.set("navigateDir", Enums.DIRECTION_BACK);
    this.options.appState.trigger("navigate", "");
  },
  getTemplateData: function() {
    const error = this.model.appState.get("flashError");
    const showLink = error.is && error.is("terminal");
    return {
      showLink
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/controllers/ErrorStateController.js
var ErrorStateController = FormController.extend({
  className: "error-state",
  Model: {},
  Form: {
    noButtonBar: true
  },
  Footer: FooterWithBackLinkOnError
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/models/AppState.js
var import_q16 = __toESM(require_q());
var DEFAULT_APP_LOGO = "/img/logos/default.png";
var USER_NOT_SEEN_ON_DEVICE = "/img/security/unknown.png";
var UNDEFINED_USER = "/img/security/default.png";
var NEW_USER = "/img/security/unknown-device.png";
var NEW_USER_IMAGE_DESCRIPTION = "";
var UNDEFINED_USER_IMAGE_DESCRIPTION = "";
var UNKNOWN_IMAGE_DESCRIPTION = "";
var securityImageUrlTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return alias4((helper = (helper = lookupProperty(helpers2, "baseUrl") || (depth0 != null ? lookupProperty(depth0, "baseUrl") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "baseUrl",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 11
        }
      }
    }) : helper)) + "/login/getimage?username=" + alias4((helper = (helper = lookupProperty(helpers2, "username") || (depth0 != null ? lookupProperty(depth0, "username") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "username",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 36
        },
        "end": {
          "line": 1,
          "column": 48
        }
      }
    }) : helper));
  },
  "useData": true
});
function getSecurityImage(baseUrl, username, deviceFingerprint) {
  if (oktaUnderscore.isEmpty(username) || oktaUnderscore.isUndefined(username)) {
    return (0, import_q16.default)({
      securityImage: UNDEFINED_USER,
      securityImageDescription: UNDEFINED_USER_IMAGE_DESCRIPTION
    });
  }
  username = encodeURIComponent(username);
  const url = securityImageUrlTpl({
    baseUrl,
    username
  });
  const data = {
    url,
    dataType: "json"
  };
  if (deviceFingerprint) {
    data["headers"] = {
      "X-Device-Fingerprint": deviceFingerprint
    };
  }
  return (0, import_q16.default)(oktaJQueryStatic.ajax(data)).then(function(res) {
    if (res.pwdImg === USER_NOT_SEEN_ON_DEVICE) {
      return {
        securityImage: NEW_USER,
        securityImageDescription: NEW_USER_IMAGE_DESCRIPTION
      };
    }
    return {
      securityImage: res.pwdImg,
      securityImageDescription: res.imageDescription || UNKNOWN_IMAGE_DESCRIPTION
    };
  });
}
function getMinutesString(factorLifetimeInMinutes) {
  if (factorLifetimeInMinutes > 60 && factorLifetimeInMinutes <= 1440) {
    const lifetimeInHours = factorLifetimeInMinutes / 60;
    return loc3("hours", "login", [lifetimeInHours]);
  } else if (factorLifetimeInMinutes > 1440) {
    const lifetimeInDays = factorLifetimeInMinutes / 1440;
    return loc3("days", "login", [lifetimeInDays]);
  }
  if (factorLifetimeInMinutes === 1) {
    return loc3("minutes.oneMinute", "login");
  }
  return loc3("minutes", "login", [factorLifetimeInMinutes]);
}
function getGracePeriodRemainingDays(gracePeriodEndDate) {
  const endDate = new Date(gracePeriodEndDate).getTime();
  const remainingDays = Math.floor((endDate - (/* @__PURE__ */ new Date()).getTime()) / (1e3 * 3600 * 24));
  return remainingDays;
}
function combineFactorsObjects(factorTypes, factors) {
  const addedFactorTypes = [];
  const combinedFactors = [];
  oktaUnderscore.each(factors, function(factor) {
    const factorType = factor.factorType;
    if (!oktaUnderscore.contains(addedFactorTypes, factorType)) {
      const factorTypeObj = oktaUnderscore.findWhere(factorTypes, {
        factorType
      });
      if (factorTypeObj) {
        addedFactorTypes.push(factorType);
        combinedFactors.push(factorTypeObj);
      } else {
        combinedFactors.push(factor);
      }
    }
  });
  return combinedFactors;
}
var AppState = Model2.extend({
  initialize: function() {
    if (this.settings.get("features.securityImage")) {
      const self2 = this;
      this.listenTo(this, "change:username", function(model, username) {
        getSecurityImage(this.get("baseUrl"), username, this.get("deviceFingerprint")).then(function(image) {
          model.set("securityImage", image.securityImage);
          model.set("securityImageDescription", image.securityImageDescription);
          model.unset("deviceFingerprint");
        }).fail(function(jqXhr) {
          if (fn.corsIsNotEnabled(jqXhr)) {
            self2.settings.callGlobalError(new UnsupportedBrowserError(loc3("error.enabled.cors")));
          } else {
            throw jqXhr;
          }
        }).done();
      });
    }
  },
  local: {
    baseUrl: "string",
    lastAuthResponse: ["object", true, {}],
    transaction: "object",
    transactionError: "object",
    username: "string",
    factors: "object",
    policy: "object",
    securityImage: ["string", true, UNDEFINED_USER],
    securityImageDescription: ["string", true, UNDEFINED_USER_IMAGE_DESCRIPTION],
    userCountryCode: "string",
    userPhoneNumber: "string",
    factorActivationType: "string",
    flashError: "object",
    beaconType: "string",
    deviceFingerprint: "string",
    // valid only once
    typingPattern: "string",
    // Note: languageCode is special in that it is shared between Settings
    // and AppState. Settings is the *configured* language, and is static.
    // AppState is the dynamic language state - it can be changed via a
    // language picker, etc.
    // Note: this is conceptial feasible but not yet being implemented.
    languageCode: ["string", true],
    disableUsername: ["boolean", false, false],
    trapMfaRequiredResponse: ["boolean", false, false],
    lastFailedChallengeFactorData: ["object", false]
  },
  setAuthResponse: function(res) {
    if (res._embedded && res._embedded.policy) {
      this.set("policy", res._embedded.policy);
    }
    if (res._embedded && res._embedded.factors) {
      let factors = res._embedded.factors;
      if (res._embedded.factorTypes) {
        factors = combineFactorsObjects(res._embedded.factorTypes, factors);
      }
      const factorsObject = oktaUnderscore.map(factors, (factor) => {
        factor.settings = this.settings;
        factor.appState = this;
        return factor;
      });
      this.set("factors", new Factor.Collection(factorsObject, {
        parse: true
      }));
    }
    this.set("lastAuthResponse", res);
  },
  clearLastAuthResponse: function() {
    this.set("lastAuthResponse", {});
  },
  setLastFailedChallengeFactorData: function() {
    this.set("lastFailedChallengeFactorData", {
      factor: this.get("factor"),
      errorMessage: this.get("factorResultErrorMessage")
    });
  },
  clearLastFailedChallengeFactorData: function() {
    this.unset("lastFailedChallengeFactorData");
  },
  getUser: function() {
    return this.get("user");
  },
  derived: {
    isSuccessResponse: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "SUCCESS";
      }
    },
    isMfaRequired: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "MFA_REQUIRED" || res.status === "FACTOR_REQUIRED";
      }
    },
    isProfileRequired: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "PROFILE_REQUIRED";
      }
    },
    isMfaEnroll: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "MFA_ENROLL" || res.status === "FACTOR_ENROLL";
      }
    },
    isMfaChallenge: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "MFA_CHALLENGE" || res.status === "FACTOR_CHALLENGE";
      }
    },
    isSMSPasswordRecovery: {
      deps: ["lastAuthResponse"],
      fn: function({
        status,
        factorType,
        recoveryType
      }) {
        return status === "RECOVERY_CHALLENGE" && (factorType === null || factorType === void 0 ? void 0 : factorType.toLowerCase()) === "sms" && (recoveryType === null || recoveryType === void 0 ? void 0 : recoveryType.toLowerCase()) === "password";
      }
    },
    isUnauthenticated: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "UNAUTHENTICATED";
      }
    },
    isMfaRejected: {
      // MFA failures are usually error responses
      // except in the case of Okta Push, when a
      // user clicks 'deny' on his phone or OV app
      // version is below a required version no.
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.factorResult === "REJECTED";
      }
    },
    isMfaTimeout: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.factorResult === "TIMEOUT";
      }
    },
    isMfaEnrollActivate: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "MFA_ENROLL_ACTIVATE" || res.status === "FACTOR_ENROLL_ACTIVATE";
      }
    },
    isWaitingForActivation: {
      deps: ["isMfaEnrollActivate", "lastAuthResponse"],
      fn: function(isMfaEnrollActivate, res) {
        return isMfaEnrollActivate && res.factorResult === "WAITING";
      }
    },
    isWaitingForNumberChallenge: {
      deps: ["lastAuthResponse", "isMfaChallenge"],
      fn: function(res, isMfaChallenge) {
        if (isMfaChallenge && res && res.factorResult === "WAITING" && res._embedded && res._embedded.factor && res._embedded.factor._embedded && res._embedded.factor._embedded.challenge) {
          return true;
        }
        return false;
      }
    },
    hasMultipleFactorsAvailable: {
      deps: ["factors", "isMfaRequired", "isMfaChallenge", "isUnauthenticated"],
      fn: function(factors, isMfaRequired, isMfaChallenge, isUnauthenticated) {
        if (!isMfaRequired && !isMfaChallenge && !isUnauthenticated) {
          return false;
        }
        return factors && factors.length > 1;
      }
    },
    promptForFactorInUnauthenticated: {
      deps: ["lastAuthResponse", "factors"],
      fn: function(res, factors) {
        if (res.status !== "UNAUTHENTICATED") {
          return false;
        }
        return factors && factors.length > 0;
      }
    },
    userId: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.user) {
          return null;
        }
        return res._embedded.user.id;
      }
    },
    isIdxStateToken: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res && oktaUnderscore.isString(res.stateToken) && res.stateToken.startsWith("01");
      }
    },
    isPwdExpiringSoon: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.status === "PASSWORD_WARN";
      }
    },
    passwordExpireDays: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.policy || !res._embedded.policy.expiration) {
          return null;
        }
        return res._embedded.policy.expiration.passwordExpireDays;
      }
    },
    isPwdManagedByOkta: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._links || !res._links.next || !res._links.next.title) {
          return true;
        }
        return false;
      }
    },
    passwordExpiredWebsiteName: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._links || !res._links.next || !res._links.next.title) {
          return null;
        }
        return res._links.next.title;
      }
    },
    passwordExpiredLinkUrl: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._links || !res._links.next || !res._links.next.title || !res._links.next.href) {
          return null;
        }
        return res._links.next.href;
      }
    },
    recoveryType: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.recoveryType;
      }
    },
    factorType: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.factorType;
      }
    },
    factor: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.factor) {
          return null;
        }
        return res._embedded.factor;
      }
    },
    activatedFactorId: {
      deps: ["factor"],
      fn: function(factor) {
        return factor ? factor.id : null;
      }
    },
    activatedFactorType: {
      deps: ["factor"],
      fn: function(factor) {
        return factor ? factor.factorType : null;
      }
    },
    activatedFactorProvider: {
      deps: ["factor"],
      fn: function(factor) {
        return factor ? factor.provider : null;
      }
    },
    qrcode: {
      deps: ["factor"],
      fn: function(factor) {
        try {
          return factor._embedded.activation._links.qrcode.href;
        } catch (err) {
          return null;
        }
      }
    },
    activationSendLinks: {
      deps: ["factor"],
      fn: function(factor) {
        let sendLinks;
        try {
          sendLinks = factor._embedded.activation._links.send;
        } catch (err) {
          sendLinks = [];
        }
        return sendLinks;
      }
    },
    textActivationLinkUrl: {
      deps: ["activationSendLinks"],
      fn: function(activationSendLinks) {
        const item = oktaUnderscore.findWhere(activationSendLinks, {
          name: "sms"
        });
        return item ? item.href : null;
      }
    },
    emailActivationLinkUrl: {
      deps: ["activationSendLinks"],
      fn: function(activationSendLinks) {
        const item = oktaUnderscore.findWhere(activationSendLinks, {
          name: "email"
        });
        return item ? item.href : null;
      }
    },
    sharedSecret: {
      deps: ["factor"],
      fn: function(factor) {
        try {
          return factor._embedded.activation.sharedSecret;
        } catch (err) {
          return null;
        }
      }
    },
    duoEnrollActivation: {
      deps: ["factor"],
      fn: function(factor) {
        if (!factor || !factor._embedded || !factor._embedded.activation) {
          return null;
        }
        return factor._embedded.activation;
      }
    },
    prevLink: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (res._links && res._links.prev) {
          return res._links.prev.href;
        }
        return null;
      }
    },
    skipLink: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (res._links && res._links.skip) {
          return res._links.skip.href;
        }
        return null;
      }
    },
    gracePeriodRemainingDays: {
      deps: ["policy"],
      fn: function(policy) {
        if (policy && policy.gracePeriod && policy.gracePeriod.endDate) {
          return getGracePeriodRemainingDays(policy.gracePeriod.endDate);
        }
        return null;
      }
    },
    user: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.user) {
          return null;
        }
        return res._embedded.user;
      }
    },
    recoveryQuestion: {
      deps: ["user"],
      fn: function(user) {
        if (!user || !user.recovery_question) {
          return null;
        }
        return user.recovery_question.question;
      }
    },
    userProfile: {
      deps: ["user"],
      fn: function(user) {
        if (!user || !user.profile) {
          return null;
        }
        return user.profile;
      }
    },
    userConsentName: {
      deps: ["userProfile", "username"],
      fn: function(userProfile, username) {
        if (!userProfile || oktaUnderscore.isEmpty(userProfile.firstName)) {
          return username;
        }
        if (oktaUnderscore.isEmpty(userProfile.lastName)) {
          return userProfile.firstName;
        }
        return userProfile.firstName + " " + userProfile.lastName.charAt(0) + ".";
      }
    },
    userEmail: {
      deps: ["userProfile"],
      fn: function(userProfile) {
        if (!userProfile || !userProfile.login) {
          return null;
        }
        return userProfile.login;
      }
    },
    userFullName: {
      deps: ["userProfile"],
      fn: function(userProfile) {
        if (!userProfile || !userProfile.firstName && !userProfile.lastName) {
          return "";
        }
        return userProfile.firstName + " " + userProfile.lastName;
      }
    },
    defaultAppLogo: {
      deps: ["baseUrl"],
      fn: function(baseUrl) {
        return baseUrl + DEFAULT_APP_LOGO;
      }
    },
    expiresAt: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.expiresAt;
      }
    },
    target: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded) {
          return null;
        }
        return res._embedded.target;
      }
    },
    targetLabel: {
      deps: ["target"],
      fn: function(target) {
        if (!target) {
          return null;
        }
        return target.label;
      }
    },
    targetLogo: {
      deps: ["target"],
      fn: function(target) {
        if (!target || !target._links) {
          return null;
        }
        return target._links.logo;
      }
    },
    targetTermsOfService: {
      deps: ["target"],
      fn: function(target) {
        if (!target || !target._links) {
          return null;
        }
        return target._links["terms-of-service"];
      }
    },
    targetPrivacyPolicy: {
      deps: ["target"],
      fn: function(target) {
        if (!target || !target._links) {
          return null;
        }
        return target._links["privacy-policy"];
      }
    },
    targetClientURI: {
      deps: ["target"],
      fn: function(target) {
        if (!target || !target._links) {
          return null;
        }
        return target._links["client-uri"];
      }
    },
    scopes: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded) {
          return null;
        }
        return res._embedded.scopes;
      }
    },
    issuer: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        var _res$_embedded, _res$_embedded$authen, _res$_embedded$authen2;
        return res === null || res === void 0 ? void 0 : (_res$_embedded = res._embedded) === null || _res$_embedded === void 0 ? void 0 : (_res$_embedded$authen = _res$_embedded.authentication) === null || _res$_embedded$authen === void 0 ? void 0 : (_res$_embedded$authen2 = _res$_embedded$authen.issuer) === null || _res$_embedded$authen2 === void 0 ? void 0 : _res$_embedded$authen2.uri;
      }
    },
    hasExistingPhones: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.factors) {
          return false;
        }
        const factors = res._embedded.factors;
        const factor = oktaUnderscore.findWhere(factors, {
          factorType: "sms",
          provider: "OKTA"
        });
        if (!factor || !factor._embedded) {
          return false;
        }
        return !!factor._embedded.phones.length;
      }
    },
    hasExistingPhonesForCall: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded || !res._embedded.factors) {
          return false;
        }
        const factors = res._embedded.factors;
        const factor = oktaUnderscore.findWhere(factors, {
          factorType: "call",
          provider: "OKTA"
        });
        if (!factor || !factor._embedded) {
          return false;
        }
        return !!factor._embedded.phones.length;
      }
    },
    isUndefinedUser: {
      deps: ["securityImage"],
      fn: function(securityImage) {
        return securityImage === UNDEFINED_USER;
      }
    },
    isNewUser: {
      deps: ["securityImage"],
      fn: function(securityImage) {
        return securityImage === NEW_USER;
      }
    },
    allowRememberDevice: {
      deps: ["policy"],
      fn: function(policy) {
        return policy && policy.allowRememberDevice;
      }
    },
    rememberDeviceLabel: {
      deps: ["policy"],
      fn: function(policy) {
        if (policy && policy.rememberDeviceLifetimeInMinutes > 0) {
          const timeString = getMinutesString(policy.rememberDeviceLifetimeInMinutes);
          return loc3("rememberDevice.timebased", "login", [timeString]);
        } else if (policy && policy.rememberDeviceLifetimeInMinutes === 0) {
          return loc3("rememberDevice.devicebased", "login");
        }
        return loc3("rememberDevice", "login");
      }
    },
    rememberDeviceByDefault: {
      deps: ["policy"],
      fn: function(policy) {
        return policy && policy.rememberDeviceByDefault;
      }
    },
    factorsPolicyInfo: {
      deps: ["policy"],
      fn: function(policy) {
        return policy && policy.factorsPolicyInfo ? policy.factorsPolicyInfo : null;
      }
    },
    verifyCustomFactorRedirectUrl: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._links || !res._links.next || res._links.next.name !== "redirect" || !res._links.next.href) {
          return null;
        }
        return res._links.next.href;
      }
    },
    enrollCustomFactorRedirectUrl: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._links || !res._links.next || res._links.next.name !== "activate" || !res._links.next.href) {
          return null;
        }
        return res._links.next.href;
      }
    },
    isFactorResultFailed: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return res.factorResult === "FAILED";
      }
    },
    factorResultErrorMessage: {
      deps: ["lastAuthResponse", "isFactorResultFailed"],
      fn: function(res, isFactorResultFailed) {
        if (isFactorResultFailed) {
          return res.factorResultMessage || loc3("oform.error.unexpected", "login");
        }
        return null;
      }
    },
    deviceActivationStatus: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        if (!res._embedded) {
          return null;
        }
        return res._embedded.deviceActivationStatus;
      }
    },
    usingDeviceFlow: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        return !!(res._embedded && res._embedded.usingDeviceFlow);
      }
    },
    userCode: {
      deps: ["lastAuthResponse"],
      fn: function(res) {
        var _res$_embedded2;
        return res === null || res === void 0 ? void 0 : (_res$_embedded2 = res._embedded) === null || _res$_embedded2 === void 0 ? void 0 : _res$_embedded2.userCode;
      }
    }
  },
  parse: function(options2) {
    this.settings = options2.settings;
    return oktaUnderscore.extend(oktaUnderscore.omit(options2, "settings"), {
      languageCode: this.settings.get("languageCode"),
      userCountryCode: this.settings.get("countryCode")
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/models/Settings.js
var import_q17 = __toESM(require_q());

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/IDP.js
var SUPPORTED_SOCIAL_IDPS = ["facebook", "google", "linkedin", "microsoft", "apple", "github", "gitlab", "yahoo", "line", "paypal", "paypal_sandbox", "salesforce", "amazon", "yahoojp", "discord", "adobe", "orcid", "spotify", "xero", "quickbooks"];
var IDP = {
  SUPPORTED_SOCIAL_IDPS
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/models/Settings.js
var SharedUtil2 = internal.util.Util;
var assetBaseUrlTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return "https://global.oktacdn.com/okta-signin-widget/" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "version") || (depth0 != null ? lookupProperty(depth0, "version") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "version",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 46
        },
        "end": {
          "line": 1,
          "column": 57
        }
      }
    }) : helper));
  },
  "useData": true
});
var local = {
  baseUrl: ["string", true],
  recoveryToken: ["string", false, void 0],
  stateToken: ["string", false, void 0],
  username: ["string", false],
  relayState: ["string", false],
  // These two settings are aliases. Setting either value will set `backToSignInUri` 
  signOutLink: ["string", false],
  // for backward compatibility
  backToSignInLink: ["string", false],
  // preferred setting
  redirect: {
    type: "string",
    values: ["never", "always", "auto"],
    value: "auto"
  },
  // allows bootstrapping the Widget into a specific view such
  // as register or forgot password
  flow: ["string", false, "default"],
  // Function to transform the username before passing it to the API
  // for Primary Auth, Forgot Password and Unlock Account.
  transformUsername: ["function", false],
  // CALLBACKS
  globalSuccessFn: "function",
  globalErrorFn: "function",
  processCreds: "function",
  hooks: "object",
  // IMAGES
  logo: "string",
  logoText: ["string", false],
  helpSupportNumber: "string",
  // <OIE>
  // attribute to hold proxy (fake) idx response
  // to render static pages without initiating idx pipeline
  proxyIdxResponse: ["object", false],
  // <OIE>
  // By default, state handle will be saved to session storage
  // and will be clear when terminal error or success redirect.
  // Set this flag to true if you want to override this behavior.
  // a.k.a dishonor the state handle stored in session storage.
  overrideExistingStateToken: ["boolean", false, false],
  // FEATURES
  "features.router": ["boolean", true, false],
  "features.securityImage": ["boolean", true, false],
  "features.rememberMe": ["boolean", true, true],
  "features.autoPush": ["boolean", true, false],
  "features.smsRecovery": ["boolean", true, false],
  "features.callRecovery": ["boolean", true, false],
  "features.emailRecovery": ["boolean", false, true],
  "features.webauthn": ["boolean", true, false],
  "features.selfServiceUnlock": ["boolean", true, false],
  "features.multiOptionalFactorEnroll": ["boolean", true, false],
  "features.deviceFingerprinting": ["boolean", false, false],
  "features.hideSignOutLinkInMFA": ["boolean", false, false],
  "features.skipIdpFactorVerificationBtn": ["boolean", false, false],
  "features.hideBackToSignInForReset": ["boolean", false, false],
  "features.customExpiredPassword": ["boolean", true, false],
  "features.registration": ["boolean", false, false],
  "features.idpDiscovery": ["boolean", false, false],
  "features.passwordlessAuth": ["boolean", false, false],
  "features.showPasswordToggleOnSignInPage": ["boolean", false, false],
  "features.trackTypingPattern": ["boolean", false, false],
  "features.redirectByFormSubmit": ["boolean", false, false],
  "features.useDeviceFingerprintForSecurityImage": ["boolean", false, true],
  "features.showPasswordRequirementsAsHtmlList": ["boolean", false, false],
  "features.mfaOnlyFlow": ["boolean", false, false],
  "features.scrollOnError": ["boolean", false, true],
  "features.showKeepMeSignedIn": ["boolean", false, true],
  "features.showIdentifier": ["boolean", false, true],
  "features.autoFocus": ["boolean", false, true],
  "features.rememberMyUsernameOnOIE": ["boolean", false, false],
  defaultCountryCode: ["string", false, "US"],
  // I18N
  language: ["any", false],
  // Can be a string or a function
  i18n: ["object", false],
  // ASSETS
  "assets.baseUrl": ["string", false],
  "assets.rewrite": {
    type: "function",
    value: oktaUnderscore.identity
  },
  "assets.languages": ["array", false],
  // OAUTH2
  issuer: "string",
  clientId: "string",
  redirectUri: "string",
  state: "string",
  nonce: "string",
  scopes: "array",
  codeChallenge: "string",
  codeChallengeMethod: ["string", false],
  oAuthTimeout: ["number", false],
  authScheme: ["string", false, "OAUTH2"],
  // External IdPs
  idps: ["array", false, []],
  idpDisplay: {
    type: "string",
    values: ["PRIMARY", "SECONDARY"],
    value: "SECONDARY"
  },
  // HELP LINKS
  "helpLinks.help": "string",
  "helpLinks.forgotPassword": "string",
  "helpLinks.unlock": "string",
  "helpLinks.custom": "array",
  "helpLinks.factorPage.href": "string",
  "helpLinks.factorPage.text": "string",
  //Custom Buttons
  customButtons: ["array", false, []],
  //Registration
  policyId: "string",
  "registration.click": "function",
  "registration.parseSchema": "function",
  "registration.preSubmit": "function",
  "registration.postSubmit": "function",
  //Consent
  "consent.cancel": "function",
  //IDP Discovery
  "idpDiscovery.requestContext": "string",
  //Colors
  "colors.brand": "string",
  //Descriptions
  brandName: "string",
  //PIV
  piv: ["object", false, {}],
  //Email verify callback
  otp: "string"
};
var derived = {
  backToSignInUri: {
    deps: ["backToSignInLink", "signOutLink"],
    fn: function(backToSignInLink, signOutLink) {
      return backToSignInLink || signOutLink;
    }
  },
  showPasswordToggle: {
    deps: ["features.showPasswordToggleOnSignInPage"],
    fn: function() {
      var _this$options$feature, _this$options, _this$options$feature2, _this$options2;
      const defaultValue = true;
      const customizedValue = (_this$options$feature = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : (_this$options$feature2 = _this$options.features) === null || _this$options$feature2 === void 0 ? void 0 : _this$options$feature2.showPasswordToggleOnSignInPage) !== null && _this$options$feature !== void 0 ? _this$options$feature : (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2["features.showPasswordToggleOnSignInPage"];
      return customizedValue !== null && customizedValue !== void 0 ? customizedValue : defaultValue;
    },
    cache: true
  },
  redirectUtilFn: {
    deps: ["features.redirectByFormSubmit"],
    fn: function(redirectByFormSubmit) {
      return redirectByFormSubmit ? Util2.redirectWithFormGet.bind(Util2) : SharedUtil2.redirect.bind(SharedUtil2);
    },
    cache: true
  },
  supportedLanguages: {
    deps: ["i18n", "language", "assets.languages"],
    fn: function(i18n2, language, hostedLanguages) {
      const supportedLanguages2 = hostedLanguages || config.supportedLanguages;
      return oktaUnderscore.union(supportedLanguages2, oktaUnderscore.keys(i18n2), oktaUnderscore.isString(language) ? [language] : []);
    },
    cache: true
  },
  languageCode: {
    deps: ["language", "supportedLanguages"],
    fn: function(language, supportedLanguages2) {
      const userLanguages = fn.getUserLanguages();
      userLanguages.forEach((val, idx) => {
        if (val === "nl") {
          userLanguages[idx] = "nl-NL";
        } else if (val === "pt") {
          userLanguages[idx] = "pt-BR";
        }
      });
      const preferred = oktaUnderscore.clone(userLanguages);
      const supportedLowerCase = Util2.toLower(supportedLanguages2);
      if (oktaUnderscore.isString(language)) {
        preferred.unshift(language);
      } else if (oktaUnderscore.isFunction(language)) {
        preferred.unshift(language(supportedLanguages2, userLanguages));
      }
      preferred.push(config.defaultLanguage);
      const expanded = Util2.toLower(Util2.expandLanguages(preferred));
      let i;
      let supportedPos;
      for (i = 0; i < expanded.length; i++) {
        supportedPos = supportedLowerCase.indexOf(expanded[i]);
        if (supportedPos > -1) {
          return supportedLanguages2[supportedPos];
        }
      }
    }
  },
  countryCode: {
    deps: ["defaultCountryCode"],
    fn: function(defaultCountryCode) {
      const countries = fn4.getCountries();
      return Object.keys(countries).includes(defaultCountryCode) ? defaultCountryCode : "US";
    }
  },
  mode: {
    deps: ["useInteractionCodeFlow", "codeChallenge"],
    fn: function(useInteractionCodeFlow, codeChallenge) {
      if (useInteractionCodeFlow && codeChallenge) {
        return "remediation";
      }
      return "relying-party";
    }
  },
  oauth2Enabled: {
    deps: ["clientId", "authScheme"],
    fn: function(clientId, authScheme) {
      return !!clientId && authScheme.toLowerCase() === "oauth2";
    },
    cache: true
  },
  oieEnabled: {
    deps: ["stateToken", "proxyIdxResponse", "useInteractionCodeFlow"],
    fn: function(stateToken, proxyIdxResponse, useInteractionCodeFlow) {
      return stateToken || proxyIdxResponse || useInteractionCodeFlow;
    },
    cache: true
  },
  // Redirect Uri to provide in the oauth API
  oauthRedirectUri: {
    deps: ["redirectUri"],
    fn: function(redirectUri) {
      if (redirectUri) {
        return redirectUri;
      }
      let origin = window.location.origin;
      if (!origin) {
        const href = window.location.href;
        const path = window.location.pathname;
        if (path !== "") {
          origin = href.substring(0, href.lastIndexOf(path));
        }
      }
      return encodeURI(origin);
    }
  },
  // Adjusts the idps passed into the widget based on if they get explicit support
  configuredSocialIdps: {
    deps: ["idps"],
    fn: function(idps) {
      return oktaUnderscore.map(idps, function(idpConfig) {
        const idp = oktaUnderscore.clone(idpConfig);
        let type = idp.type && idp.type.toLowerCase();
        if (!(type && oktaUnderscore.contains(IDP.SUPPORTED_SOCIAL_IDPS, type))) {
          type = "general-idp";
          idp.text = idp.text || "{ Please provide a text value }";
        }
        idp.className = ["social-auth-button", "social-auth-" + type + "-button ", idp.className ? idp.className : ""].join(" ");
        idp.dataAttr = "social-auth-" + type + "-button";
        idp.i18nKey = "socialauth." + type + ".label";
        return idp;
      });
    },
    cache: true
  },
  // Can support piv authentication
  hasPivCard: {
    deps: ["piv"],
    fn: function(piv) {
      return piv && piv.certAuthUrl;
    },
    cache: true
  },
  // social auth buttons order - 'above'/'below' the primary auth form (boolean)
  socialAuthPositionTop: {
    deps: ["configuredSocialIdps", "hasPivCard", "idpDisplay"],
    fn: function(configuredSocialIdps, hasPivCard, idpDisplay) {
      return (!oktaUnderscore.isEmpty(configuredSocialIdps) || hasPivCard) && idpDisplay.toUpperCase() === "PRIMARY";
    },
    cache: true
  },
  hasConfiguredButtons: {
    deps: ["configuredSocialIdps", "customButtons", "hasPivCard"],
    fn: function(configuredSocialIdps, customButtons, hasPivCard) {
      return !oktaUnderscore.isEmpty(configuredSocialIdps) || !oktaUnderscore.isEmpty(customButtons) || hasPivCard;
    },
    cache: true
  }
};
var Settings = class extends Model2 {
  constructor(...args) {
    super(...args);
    this.authClient = void 0;
  }
  get(attributeName) {
    return Model2.prototype.get.call(this, attributeName);
  }
  preinitialize(...args) {
    this.local = local;
    this.derived = derived;
    Model2.prototype.preinitialize.apply(this, args);
  }
  initialize(options2) {
    const {
      colors
    } = options2;
    let {
      baseUrl
    } = options2;
    if (!baseUrl) {
      const {
        authClient
      } = options2;
      if (authClient) {
        baseUrl = authClient.getIssuerOrigin();
      } else {
        var _issuer;
        const {
          authParams
        } = options2;
        let {
          issuer
        } = options2;
        issuer = issuer || (authParams === null || authParams === void 0 ? void 0 : authParams.issuer);
        baseUrl = (_issuer = issuer) === null || _issuer === void 0 ? void 0 : _issuer.split("/oauth2/")[0];
      }
      this.set("baseUrl", baseUrl);
    }
    if (!baseUrl) {
      this.callGlobalError(new ConfigError(loc3("error.required.baseUrl")));
    } else if (colors && oktaUnderscore.isString(colors.brand) && !colors.brand.match(/^#[0-9A-Fa-f]{6}$/)) {
      this.callGlobalError(new ConfigError(loc3("error.invalid.colors.brand")));
    } else if (fn.corsIsNotSupported()) {
      this.callGlobalError(new UnsupportedBrowserError(loc3("error.unsupported.cors")));
    }
  }
  setAcceptLanguageHeader(authClient) {
    if (authClient) {
      authClient.http.setRequestHeader("Accept-Language", this.get("languageCode"));
    }
  }
  setAuthClient(authClient) {
    this.setAcceptLanguageHeader(authClient);
    this.authClient = authClient;
  }
  getAuthClient() {
    return this.authClient;
  }
  set(...args) {
    try {
      return Model2.prototype.set.apply(this, args);
    } catch (e) {
      const message = e.message ? e.message : e;
      this.callGlobalError(new ConfigError(message));
    }
  }
  // Invokes the global success function. This should only be called on a
  // terminal part of the code (i.e. authStatus SUCCESS or after sending
  // a recovery email)
  callGlobalSuccess(status, data) {
    const res = oktaUnderscore.extend(data, {
      status
    });
    oktaUnderscore.defer(oktaUnderscore.partial(this.get("globalSuccessFn"), res));
  }
  // Invokes the global error function. This should only be called on non
  // recoverable errors (i.e. configuration errors, browser unsupported
  // errors, etc)
  callGlobalError(err) {
    const globalErrorFn = this.get("globalErrorFn") || this.options.globalErrorFn;
    if (globalErrorFn) {
      globalErrorFn(err);
    } else {
      throw err;
    }
  }
  // Get the username by applying the transform function if it exists.
  transformUsername(username, operation) {
    const transformFn = this.get("transformUsername");
    if (transformFn && oktaUnderscore.isFunction(transformFn)) {
      return transformFn(username, operation);
    }
    return username;
  }
  processCreds(creds) {
    const processCreds = this.get("processCreds");
    return import_q17.default.Promise(function(resolve) {
      if (!oktaUnderscore.isFunction(processCreds)) {
        resolve();
      } else if (processCreds.length === 2) {
        processCreds(creds, resolve);
      } else {
        processCreds(creds);
        resolve();
      }
    });
  }
  parseRegistrationSchema(schema, onSuccess, onFailure) {
    const parseSchema = this.get("registration.parseSchema");
    if (oktaUnderscore.isFunction(parseSchema)) {
      parseSchema(schema, function(schema2) {
        onSuccess(schema2);
      }, function(error) {
        error = error || {
          errorSummary: loc3("registration.default.callbackhook.error")
        };
        error["callback"] = "parseSchema";
        onFailure(error);
      });
    } else {
      onSuccess(schema);
    }
  }
  preRegistrationSubmit(postData, onSuccess, onFailure) {
    const preSubmit = this.get("registration.preSubmit");
    if (oktaUnderscore.isFunction(preSubmit)) {
      preSubmit(postData, function(postData2) {
        onSuccess(postData2);
      }, function(error) {
        error = error || {
          errorSummary: loc3("registration.default.callbackhook.error")
        };
        error["callback"] = "preSubmit";
        onFailure(error);
      });
    } else {
      onSuccess(postData);
    }
  }
  postRegistrationSubmit(response, onSuccess, onFailure) {
    const postSubmit = this.get("registration.postSubmit");
    if (oktaUnderscore.isFunction(postSubmit)) {
      postSubmit(response, function(response2) {
        onSuccess(response2);
      }, function(error) {
        error = error || {
          errorSummary: loc3("registration.default.callbackhook.error")
        };
        error["callback"] = "postSubmit";
        onFailure(error);
      });
    } else {
      onSuccess(response);
    }
  }
  // Use the parse function to transform config options to the standard
  // settings we currently support. This is a good place to deprecate old
  // option formats.
  parse(options2) {
    if (options2.labels || options2.country) {
      Logger.deprecate('Use "i18n" instead of "labels" and "country"');
      const overrides = options2.labels || {};
      oktaUnderscore.each(options2.country, function(val, key) {
        overrides["country." + key] = val;
      });
      options2.i18n = {};
      oktaUnderscore.each(config.supportedLanguages, function(language) {
        options2.i18n[language] = overrides;
      });
      delete options2.labels;
      delete options2.country;
    }
    if (!options2.assets) {
      options2.assets = {};
    }
    const abu = options2.assets.baseUrl;
    if (!abu) {
      options2.assets.baseUrl = assetBaseUrlTpl({
        version: config.version
      });
    } else if (abu[abu.length - 1] === "/") {
      options2.assets.baseUrl = abu.substring(0, abu.length - 1);
    }
    return options2;
  }
  isDsTheme() {
    return false;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/AuthContainer.js
var CAN_REMOVE_BEACON_CLS = "can-remove-beacon";
var AuthContainer = View2.extend({
  tagName: "main",
  className: "auth-container main-container",
  id: Enums.WIDGET_CONTAINER_ID,
  attributes: {
    "data-se": "auth-container",
    tabindex: "-1"
  },
  initialize: function(options2) {
    this.listenTo(options2.appState, "change:beaconType", function(model, type) {
      this.$el.toggleClass(CAN_REMOVE_BEACON_CLS, type === "security");
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Animations.js
var import_q18 = __toESM(require_q());
var SWAP_PAGE_TIME = 200;
var fn9 = {};
function zoom($el, start, finish) {
  const deferred = import_q18.default.defer();
  $el.animate({
    "text-indent": 1
  }, {
    duration: 200,
    easing: "swing",
    step: function(now, fx) {
      fx.start = start;
      fx.end = finish;
      $el.css("transform", "scale(" + now + ", " + now + ")");
    },
    always: function() {
      deferred.resolve($el);
    }
  });
  return deferred.promise;
}
function rotate($el, start, finish) {
  const deferred = import_q18.default.defer();
  $el.animate({
    "text-indent": 1
  }, {
    duration: 150,
    easing: "swing",
    step: function(now, fx) {
      fx.start = start;
      fx.end = finish;
      $el.css("transform", "rotate(" + now + "deg)");
    },
    always: function() {
      deferred.resolve($el);
    }
  });
  return deferred.promise;
}
fn9.swapPages = function(options2) {
  const deferred = import_q18.default.defer();
  const $parent = options2.$parent;
  const $oldRoot = options2.$oldRoot;
  const $newRoot = options2.$newRoot;
  const success = options2.success;
  const ctx = options2.ctx;
  let directionClassName = "transition-from-right";
  if (options2.dir && options2.dir === Enums.DIRECTION_BACK) {
    directionClassName = "transition-from-left";
  }
  $newRoot.addClass(directionClassName);
  $parent.append($newRoot);
  $parent.addClass("animation-container-overflow");
  $newRoot.animate({
    left: "0px",
    top: "0px",
    opacity: 1
  }, SWAP_PAGE_TIME, function() {
    $parent.removeClass("animation-container-overflow");
    $newRoot.removeClass(directionClassName);
    $newRoot.removeAttr("style");
    success.call(ctx);
    deferred.resolve();
  });
  $oldRoot.animate({
    height: $newRoot.height(),
    opacity: 0
  }, SWAP_PAGE_TIME * 0.8);
  return deferred.promise;
};
fn9.swapBeacons = function(options2) {
  const $el = options2.$el;
  const swap = options2.swap;
  const ctx = options2.ctx;
  return this.implode($el).then(function() {
    swap.call(ctx);
    return $el;
  }).then(this.explode);
};
fn9.explode = function($el) {
  return zoom($el, 0, 1);
};
fn9.implode = function($el) {
  return zoom($el, 1, 0);
};
fn9.radialProgressBar = function(options2) {
  const radialProgressBar = options2.$el;
  const swap = options2.swap;
  const circles = radialProgressBar.children();
  return rotate(circles, 0, 180).then(function() {
    radialProgressBar.css({
      clip: "auto"
    });
  }).then(function() {
    const leftHalf = circles.eq(0);
    swap();
    return rotate(leftHalf, 180, 360);
  }).then(function() {
    radialProgressBar.css({
      clip: "rect(0px, 96px, 96px, 48px)"
    });
    circles.css({
      transform: "rotate(0deg)",
      "text-indent": "1px"
    });
  });
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/LoadingBeacon.js
var LoadingBeacon = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div class="beacon-blank"></div><div class="bg-helper auth-beacon auth-beacon-security" data-se="loading-beacon"><div class="okta-sign-in-beacon-border auth-beacon-border js-auth-beacon-border"></div></div>';
    },
    "useData": true
  }),
  equals: function(Beacon) {
    return Beacon && this instanceof Beacon;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/Header.js
var NO_BEACON_CLS = "no-beacon";
var LOADING_BEACON_CLS = "beacon-small beacon-loading";
function isLoadingBeacon(beacon) {
  return beacon && beacon.equals(LoadingBeacon);
}
function removeBeacon(view) {
  if (!view.currentBeacon) {
    return;
  }
  view.currentBeacon.remove();
  view.currentBeacon = null;
}
function addBeacon(view, NextBeacon, selector, options2) {
  view.add(NextBeacon, {
    selector,
    options: options2
  });
  view.currentBeacon = view.first();
}
function typeOfTransition(currentBeacon, NextBeacon, options2) {
  if (!currentBeacon && !NextBeacon) {
    return "none";
  }
  if (!currentBeacon && options2.loading) {
    return "load";
  }
  if (currentBeacon && isLoadingBeacon(currentBeacon)) {
    return NextBeacon ? "swap" : "unload";
  }
  if (currentBeacon && currentBeacon.equals(NextBeacon, options2)) {
    return "same";
  }
  if (!currentBeacon && NextBeacon) {
    return "add";
  }
  if (currentBeacon && !NextBeacon) {
    return "remove";
  }
  if (currentBeacon instanceof NextBeacon) {
    return "fade";
  }
  return "swap";
}
var Header = class extends View2 {
  constructor(...args) {
    super(...args);
    this.currentBeacon = void 0;
  }
  preinitialize(...args) {
    this.currentBeacon = null;
    this.template = _Handlebars2.template({
      "1": function(container, depth0, helpers2, partials, data) {
        var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<h1><img src="' + alias4((helper = (helper = lookupProperty(helpers2, "logo") || (depth0 != null ? lookupProperty(depth0, "logo") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "logo",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 71
            },
            "end": {
              "line": 1,
              "column": 79
            }
          }
        }) : helper)) + '" class="auth-org-logo" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "logoText") || (depth0 != null ? lookupProperty(depth0, "logoText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "logoText",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 108
            },
            "end": {
              "line": 1,
              "column": 120
            }
          }
        }) : helper)) + ' logo" aria-label="' + alias4((helper = (helper = lookupProperty(helpers2, "logoText") || (depth0 != null ? lookupProperty(depth0, "logoText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "logoText",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 139
            },
            "end": {
              "line": 1,
              "column": 151
            }
          }
        }) : helper)) + ' logo"></h1>';
      },
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<div class="okta-sign-in-header auth-header">' + ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "logo") : depth0, {
          "name": "if",
          "hash": {},
          "fn": container.program(1, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 45
            },
            "end": {
              "line": 1,
              "column": 170
            }
          }
        })) != null ? stack1 : "") + '<div data-type="beacon-container" class="beacon-container"></div></div><div class="auth-content"><div class="auth-content-inner"></div></div>';
      },
      "useData": true
    });
    View2.prototype.preinitialize.apply(this, args);
  }
  // Attach a 'no-beacon' class if the security image feature
  // is not passed in to prevent the beacon from jumping.
  initialize(options2) {
    if (!options2.settings.get("features.securityImage")) {
      this.$el.addClass(NO_BEACON_CLS);
      this.listenTo(options2.appState, "loading", this.setLoadingBeacon);
      this.listenTo(options2.appState, "removeLoading", this.removeLoadingBeacon);
    }
  }
  /* eslint complexity: 0 */
  setBeacon(NextBeacon, options2) {
    const selector = '[data-type="beacon-container"]';
    const container = this.$(selector);
    const transition = typeOfTransition(this.currentBeacon, NextBeacon, options2);
    switch (transition) {
      case "none":
        this.$el.addClass(NO_BEACON_CLS);
        return;
      case "same":
        return;
      case "add":
        this.$el.removeClass(NO_BEACON_CLS);
        addBeacon(this, NextBeacon, selector, options2);
        return fn9.explode(container);
      case "remove":
        this.$el.addClass(NO_BEACON_CLS);
        return fn9.implode(container).then(() => {
          removeBeacon(this);
        }).done();
      case "fade":
        if (!this.currentBeacon.fadeOut) {
          throw new Error('The current beacon is missing the "fadeOut" method');
        }
        options2.animate = true;
        return this.currentBeacon.fadeOut().then(() => {
          removeBeacon(this);
          addBeacon(this, NextBeacon, selector, options2);
        }).done();
      case "swap":
        return fn9.swapBeacons({
          $el: container,
          swap: () => {
            const isLoading = isLoadingBeacon(this.currentBeacon);
            removeBeacon(this);
            if (isLoading) {
              container.removeClass(LOADING_BEACON_CLS);
              this.$el.removeClass(NO_BEACON_CLS);
            }
            addBeacon(this, NextBeacon, selector, options2);
          }
        }).done();
      case "load":
        container.addClass(LOADING_BEACON_CLS);
        addBeacon(this, NextBeacon, selector, options2);
        return fn9.explode(container);
      case "unload":
        return this.removeLoadingBeacon();
      default:
        throw new Error('the "' + transition + '" is not recognized');
    }
  }
  // Show the loading beacon when the security image feature is not enabled.
  setLoadingBeacon(isLoading) {
    if (!isLoading || isLoadingBeacon(this.currentBeacon)) {
      return;
    }
    this.setBeacon(LoadingBeacon, {
      loading: true
    });
  }
  // Hide the beacon on primary auth failure. On primary auth success, setBeacon does this job.
  removeLoadingBeacon() {
    const container = this.$('[data-type="beacon-container"]');
    return fn9.implode(container).then(() => {
      removeBeacon(this);
      container.removeClass(LOADING_BEACON_CLS);
    }).done();
  }
  getTemplateData() {
    return this.settings.toJSON({
      verbose: true
    });
  }
  getContentEl() {
    return this.$(".auth-content-inner");
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/SecurityBeacon.js
function setBackgroundImage(el, appState) {
  const imgSrc = appState.get("securityImage");
  const imgDescription = appState.get("securityImageDescription");
  const isUndefinedUser = appState.get("isUndefinedUser");
  const isNewUser = appState.get("isNewUser");
  const isSecurityImage = !isUndefinedUser && !isNewUser;
  el.css("background-image", "");
  el.removeClass("new-user undefined-user");
  if (isNewUser) {
    el.addClass("new-user");
    return;
  }
  if (isUndefinedUser) {
    el.addClass("undefined-user");
    return;
  }
  if (isSecurityImage) {
    el.removeAttr("aria-describedby");
    el.find(".accessibility-text").text(imgDescription);
    el.css("background-image", "url(" + oktaUnderscore.escape(imgSrc) + ")");
    return;
  }
}
function antiPhishingMessage(image, host) {
  oktaJQueryStatic(window).on("resize.securityBeaconQtip", oktaUnderscore.debounce(function() {
    if (image.is(":visible")) {
      image.qtip("show");
    }
  }, 300));
  image.qtip({
    prerender: true,
    content: {
      text: loc3("primaryauth.newUser.tooltip", "login", [oktaUnderscore.escape(host)]),
      button: loc3("primaryauth.newUser.tooltip.close", "login")
    },
    style: {
      classes: "okta-security-image-tooltip security-image-qtip qtip-custom qtip-shadow qtip-rounded",
      tip: {
        height: 12,
        width: 16
      }
    },
    position: {
      my: "top center",
      at: "center",
      target: oktaJQueryStatic(".auth-beacon-security"),
      adjust: {
        method: "flip",
        scroll: false,
        resize: true
      },
      effect: false
    },
    hide: {
      event: false,
      fixed: true
    },
    show: {
      event: false,
      delay: 200
    },
    events: {
      move: function(event, api2) {
        if (!api2.elements.target.is(":visible")) {
          api2.set("hide.effect", false);
          api2.hide();
          api2.set("hide.effect", true);
        }
      }
    }
  });
  setTimeout(() => {
    image.qtip("toggle", image.is(":visible"));
  }, 0);
}
function destroyAntiPhishingMessage(image) {
  image.qtip("destroy");
  oktaJQueryStatic(window).off("resize.securityBeaconQtip");
}
function updateSecurityImage($el, appState, animate) {
  return __async(this, null, function* () {
    const image = $el.find(".auth-beacon-security");
    const border = $el.find(".js-auth-beacon-border");
    const hasBorder = !appState.get("isUndefinedUser");
    const hasAntiPhishing = appState.get("isNewUser");
    const radialProgressBar = $el.find(".radial-progress-bar");
    const host = appState.get("baseUrl").match(/https?:\/\/(.[^/]+)/)[1];
    const duration = 200;
    if (!animate) {
      setBackgroundImage(image, appState);
      border.toggleClass("auth-beacon-border", hasBorder);
      return;
    }
    destroyAntiPhishingMessage(image);
    if (!hasBorder) {
      image.fadeOut(duration, function() {
        setBackgroundImage(image, appState);
        border.removeClass("auth-beacon-border");
        image.fadeIn(duration);
      });
    } else {
      border.removeClass("auth-beacon-border");
      yield fn9.radialProgressBar({
        $el: radialProgressBar,
        swap: function() {
          image.fadeOut(duration, () => {
            setBackgroundImage(image, appState);
            image.fadeIn(duration);
          });
        }
      });
      border.addClass("auth-beacon-border");
      if (hasAntiPhishing) {
        antiPhishingMessage(image, host);
      }
    }
  });
}
var SecurityBeacon = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div class="beacon-blank"><div class="radial-progress-bar"><div class="circle left"></div><div class="circle right"></div></div></div><div aria-live="polite" role="img" class="bg-helper auth-beacon auth-beacon-security" data-se="security-beacon"><span class="accessibility-text"></span><div class="okta-sign-in-beacon-border auth-beacon-border js-auth-beacon-border"></div></div>';
    },
    "useData": true
  }),
  className: "js-security-beacon",
  initialize: function(options2) {
    this.update = oktaUnderscore.partial(updateSecurityImage, this.$el, options2.appState);
    this.listenTo(options2.appState, "change:securityImage", this.update);
    this.listenTo(options2.appState, "loading", function(isLoading) {
      this.$el.toggleClass("beacon-loading", isLoading);
      this.removeAntiPhishingMessage();
    });
    this.options.appState.set("beaconType", "security");
    this.listenTo(options2.appState, "navigate", this.removeAntiPhishingMessage);
  },
  postRender: function() {
    this.update(false);
  },
  equals: function(Beacon) {
    return Beacon && this instanceof Beacon;
  },
  removeAntiPhishingMessage: function() {
    const image = this.$el.find(".auth-beacon-security");
    image.qtip("destroy");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/ColorsUtil.js
var fn10 = {};
var template7 = function(colors) {
  return `
#okta-sign-in.auth-container .button-primary,
#okta-sign-in.auth-container .button-primary:active,
#okta-sign-in.auth-container .button-primary:focus { background: ${colors.brand}; }
#okta-sign-in.auth-container .button-primary:hover { background: ${fn10.lighten(colors.brand, 0.05)}; }
#okta-sign-in.auth-container .button.button-primary.link-button-disabled {
  background: ${colors.brand};
  opacity: 0.5;
}
    `;
};
fn10.lighten = function(hex, lum) {
  lum = lum || 0;
  hex = hex.substr(1);
  let newHex = "#";
  for (var i = 0; i < 3; i++) {
    let c2 = parseInt(hex.substr(i * 2, 2), 16);
    c2 = Math.round(Math.min(Math.max(0, c2 + c2 * lum), 255)).toString(16);
    newHex += ("00" + c2).substr(c2.length);
  }
  return newHex;
};
fn10.addStyle = function(colors) {
  const css = template7(colors);
  const main = document.getElementById(Enums.WIDGET_CONTAINER_ID);
  const style = document.createElement("style");
  style.id = Enums.WIDGET_CONFIG_COLORS_ID;
  style.type = "text/css";
  style.appendChild(document.createTextNode(css));
  main.appendChild(style);
};
fn10.isLoaded = function() {
  return !!document.getElementById(Enums.WIDGET_CONFIG_COLORS_ID);
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/LanguageUtil.js
function loadLanguage(appState, settings) {
  const languageCode = appState.get("languageCode") || settings.get("languageCode") || config.defaultLanguage;
  const i18n2 = settings.get("i18n");
  const assetBaseUrl = settings.get("assets.baseUrl");
  const assetRewrite = settings.get("assets.rewrite");
  const supportedLanguages2 = settings.get("supportedLanguages");
  const timeout = setTimeout(function() {
    appState.trigger("loading", true);
  }, 200);
  return Bundles.loadLanguage(languageCode, i18n2, {
    baseUrl: assetBaseUrl,
    rewrite: assetRewrite
  }, supportedLanguages2).then(function() {
    clearTimeout(timeout);
    appState.trigger("loading", false);
  });
}
var LanguageUtil = {
  loadLanguage
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/BaseLoginRouter.js
function isStateLessRouteHandler(router, fn11) {
  return oktaUnderscore.find(router.stateLessRouteHandlers, function(routeName) {
    return fn11 === router[routeName];
  });
}
function beaconIsAvailable(Beacon, settings) {
  if (!Beacon) {
    return false;
  }
  if (Beacon === SecurityBeacon) {
    return settings.get("features.securityImage");
  }
  return true;
}
var BaseLoginRouter = Router.extend({
  Events: Backbone.Events,
  initialize: function(options2) {
    if (!options2.globalSuccessFn) {
      options2.globalSuccessFn = function() {
      };
    }
    if (!options2.globalErrorFn) {
      options2.globalErrorFn = function(err) {
        Logger.error(err);
      };
    }
    this.settings = new Settings(oktaUnderscore.omit(options2, "el", "authClient"), {
      parse: true
    });
    this.settings.setAuthClient(options2.authClient);
    if (!options2.el) {
      this.settings.callGlobalError(new ConfigError(loc3("error.required.el")));
    }
    oktaJQueryStatic("body > div").on("click", function() {
    });
    this.appState = new AppState({
      baseUrl: this.settings.get("baseUrl"),
      settings: this.settings
    }, {
      parse: true
    });
    const wrapper = new AuthContainer({
      appState: this.appState
    });
    oktaJQueryStatic(options2.el).append(wrapper.render().$el);
    this.el = `#${Enums.WIDGET_CONTAINER_ID}`;
    this.header = new Header({
      el: this.el,
      appState: this.appState,
      settings: this.settings
    });
    this.hide();
    this.listenTo(this.appState, "change:transactionError", function(appState, err) {
      fn3.routeAfterAuthStatusChangeError(this, err);
    });
    this.listenTo(this.appState, "change:transaction", function(appState, trans) {
      fn3.routeAfterAuthStatusChange(this, trans.data);
    });
    this.listenTo(this.appState, "navigate", function(url) {
      this.navigate(url, {
        trigger: true
      });
    });
  },
  execute: function(cb, args) {
    const recoveryToken = this.settings.get("recoveryToken");
    if (recoveryToken) {
      this.settings.unset("recoveryToken");
      this.navigate(fn3.createRecoveryUrl(recoveryToken), {
        trigger: true
      });
      return;
    }
    const stateToken = this.settings.get("stateToken");
    if (stateToken) {
      this.settings.unset("stateToken");
      this.navigate(fn3.createRefreshUrl(stateToken), {
        trigger: true
      });
      return;
    }
    const trans = this.appState.get("transaction");
    if (trans && trans.data || isStateLessRouteHandler(this, cb)) {
      cb.apply(this, args);
      return;
    }
    if (this.settings.getAuthClient().tx.exists()) {
      this.navigate(fn3.createRefreshUrl(), {
        trigger: true
      });
      return;
    }
    this.navigate("", {
      trigger: true
    });
  },
  // Overriding the default navigate method to allow the widget consumer
  // to "turn off" routing - if features.router is false, the browser
  // location bar will not update when the router navigates
  navigate: function(fragment, options2) {
    if (this.settings.get("features.router")) {
      return Router.prototype.navigate.apply(this, arguments);
    }
    if (options2 && options2.trigger) {
      return Backbone.history.loadUrl(fragment);
    }
  },
  render: function(Controller2, options2) {
    options2 || (options2 = {});
    let Beacon = options2.Beacon;
    const controllerOptions = oktaUnderscore.extend({
      settings: this.settings,
      appState: this.appState
    }, oktaUnderscore.omit(options2, "Beacon"));
    if (!this.header.rendered()) {
      this.el = this.header.render().getContentEl();
    }
    if (!Bundles.isLoaded(this.appState.get("languageCode"))) {
      return LanguageUtil.loadLanguage(this.appState, this.settings).then(oktaUnderscore.bind(this.render, this, Controller2, options2));
    }
    if (this.settings.get("colors.brand") && !fn10.isLoaded()) {
      const colors = {
        brand: this.settings.get("colors.brand")
      };
      fn10.addStyle(colors);
    }
    const oldController = this.controller;
    this.controller = new Controller2(controllerOptions);
    this.listenTo(this.controller, "all", this.trigger);
    return this.controller.fetchInitialData().then(() => {
      if (!beaconIsAvailable(Beacon, this.settings)) {
        Beacon = null;
      }
      this.header.setBeacon(Beacon, controllerOptions);
      this.show();
      this.controller.render();
      if (!oldController) {
        this.el.append(this.controller.el);
        this.controller.postRenderAnimation();
        return;
      }
      return fn9.swapPages({
        $parent: this.el,
        $oldRoot: oldController.$el,
        $newRoot: this.controller.$el,
        dir: oldController.state.get("navigateDir"),
        ctx: this,
        success: function() {
          const flashError = this.appState.get("flashError");
          const model = this.controller.model;
          oldController.remove();
          oldController.$el.remove();
          this.controller.postRenderAnimation();
          if (flashError) {
            let errorSummary;
            const isTerminalError = flashError.is && flashError.is("terminal");
            if (isTerminalError) {
              errorSummary = flashError.errorDetails.errorSummary;
            } else {
              errorSummary = loc3(this.settings.get("features.mfaOnlyFlow") ? "error.mfa.only.expired.session" : "error.expired.session");
            }
            model.trigger("error", model, {
              responseJSON: {
                errorSummary
              }
            });
            this.appState.unset("flashError");
            Util2.triggerAfterError(this.controller, flashError);
          }
        }
      });
    }).catch(function() {
      if (oldController) {
        oldController.remove();
        oldController.$el.remove();
      }
    });
  },
  start: function() {
    let pushState = false;
    if (window.addEventListener && this.settings.get("features.router")) {
      window.addEventListener("popstate", (e) => {
        if (this.controller.back) {
          e.preventDefault();
          e.stopImmediatePropagation();
          this.controller.back();
        }
      });
      pushState = fn.supportsPushState();
    }
    Router.prototype.start.call(this, {
      pushState
    });
  },
  hide: function() {
    this.header.$el.hide();
  },
  show: function() {
    this.header.$el.show();
  },
  remove: function() {
    if (this.controller) {
      this.controller.remove();
    }
    this.header.$el.remove();
    Bundles.remove();
    Backbone.history.stop();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FactorBeacon.js
var import_q19 = __toESM(require_q());

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/dropdown/FactorsDropDownOptions.js
var pushTitleTpl = _Handlebars2.template({
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "factorName") || (depth0 != null ? lookupProperty(depth0, "factorName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "factorName",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 14
        }
      }
    }) : helper)) + " (" + ((stack1 = (helper = (helper = lookupProperty(helpers2, "deviceName") || (depth0 != null ? lookupProperty(depth0, "deviceName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
      "name": "deviceName",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 16
        },
        "end": {
          "line": 1,
          "column": 32
        }
      }
    }) : helper)) != null ? stack1 : "") + ")";
  },
  "useData": true
});
var action = function(model) {
  let factorIndex;
  const factorType = model.get("factorType");
  const factorsList = this.options.appState.get("factors");
  if (factorsList.hasMultipleFactorsOfSameType(factorType)) {
    factorIndex = factorsList.getFactorIndex(factorType, model.get("id"));
  }
  const url = fn3.createVerifyUrl(model.get("provider"), factorType, factorIndex);
  const self2 = this;
  this.options.appState.trigger("factorSwitched");
  this.model.manageTransaction(function(transaction, setTransaction) {
    if (transaction.status === "FACTOR_CHALLENGE") {
      this.options.appState.set("trapMfaRequiredResponse", true);
    }
    if (transaction.status === "MFA_CHALLENGE" && transaction.prev) {
      this.options.appState.set("trapMfaRequiredResponse", true);
      return transaction.prev().then(function(trans) {
        self2.trigger("options:toggle");
        setTransaction(trans);
        self2.options.appState.trigger("navigate", url);
      });
    } else {
      self2.trigger("options:toggle");
      self2.options.appState.trigger("navigate", url);
    }
  });
};
var dropdownOptions = {
  TITLE: {
    title: oktaUnderscore.partial(loc3, "mfa.factors.dropdown.title", "login"),
    className: "dropdown-list-title",
    disabled: true
  },
  OKTA_VERIFY: {
    icon: "factor-icon mfa-okta-verify-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  OKTA_VERIFY_PUSH: {
    icon: "factor-icon mfa-okta-verify-30",
    className: "factor-option",
    title: function() {
      return pushTitleTpl({
        factorName: this.model.get("factorLabel"),
        deviceName: this.model.get("deviceName")
      });
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  GOOGLE_AUTH: {
    icon: "factor-icon mfa-google-auth-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  CUSTOM_HOTP: {
    icon: "factor-icon mfa-hotp-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  SYMANTEC_VIP: {
    icon: "factor-icon mfa-symantec-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  RSA_SECURID: {
    icon: "factor-icon mfa-rsa-30",
    className: "factor-option",
    title: oktaUnderscore.partial(loc3, "factor.totpHard.rsaSecurId", "login"),
    action: function() {
      action.call(this, this.model);
    }
  },
  ON_PREM: {
    icon: "factor-icon mfa-onprem-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  DUO: {
    icon: "factor-icon mfa-duo-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  DUO_PUSH: {
    icon: "duo-push-16",
    className: "suboption factor-option",
    // TODO: add phone number here
    title: oktaUnderscore.partial(loc3, "mfa.duoSecurity.push", "login", ["XXX-XXX-7890"])
  },
  DUO_SMS: {
    icon: "duo-sms-16",
    className: "suboption factor-option",
    // TODO: add phone number here
    title: oktaUnderscore.partial(loc3, "mfa.duoSecurity.sms", "login", ["XXX-XXX-7890"])
  },
  DUO_CALL: {
    icon: "duo-call-16",
    className: "suboption factor-option",
    // TODO: add phone number here
    title: oktaUnderscore.partial(loc3, "mfa.duoSecurity.call", "login", ["XXX-XXX-7890"])
  },
  YUBIKEY: {
    icon: "factor-icon mfa-yubikey-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  SMS: {
    icon: "factor-icon mfa-sms-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  CALL: {
    icon: "factor-icon mfa-call-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  QUESTION: {
    icon: "factor-icon mfa-question-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  PASSWORD: {
    icon: "factor-icon mfa-password-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  WINDOWS_HELLO: {
    icon: "factor-icon mfa-windows-hello-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  U2F: {
    icon: "factor-icon mfa-u2f-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  WEBAUTHN: {
    icon: "factor-icon mfa-webauthn-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  EMAIL: {
    icon: "factor-icon mfa-email-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  GENERIC_SAML: {
    icon: "factor-icon mfa-custom-factor-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  GENERIC_OIDC: {
    icon: "factor-icon mfa-custom-factor-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  },
  CUSTOM_CLAIMS: {
    icon: "factor-icon mfa-custom-factor-30",
    className: "factor-option",
    title: function() {
      return this.model.get("factorLabel");
    },
    action: function() {
      action.call(this, this.model);
    }
  }
};
var FactorsDropDownOptions = {
  getDropdownOption: function(factorName) {
    return dropdownOptions[factorName];
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/dropdown/FactorsDropDown.js
var {
  BaseDropDown: BaseDropDown2
} = internal.views.components;
oktaJQueryStatic(document).click(function(e) {
  const $target = oktaJQueryStatic(e.target);
  const isDropdown = $target.closest(".option-selected").length > 0 && $target.closest(".dropdown").length > 0;
  if (!isDropdown) {
    oktaJQueryStatic(".dropdown .options").hide();
    oktaJQueryStatic(".dropdown a.option-selected").attr("aria-expanded", false);
  }
});
var FactorsDropDown = BaseDropDown2.extend({
  className: "bg-helper icon-button",
  screenReaderText: function() {
    const factors = this.options.appState.get("factors");
    let factor;
    let factorLabel;
    if (factors) {
      factor = fn2.findFactorInFactorsArray(factors, this.options.provider, this.options.factorType);
    } else {
      factor = new Factor.Model(this.options.appState.get("factor"), this.toJSON());
    }
    factorLabel = factor.get("factorLabel");
    return loc3("mfa.factors.dropdown.sr.text", "login", [factorLabel]);
  },
  events: {
    "click a.option-selected": function(e) {
      e.preventDefault();
      if (oktaUnderscore.result(this, "disabled")) {
        e.stopPropagation();
      } else {
        const expanded = this.$(".options").toggle().is(":visible");
        this.$("a.option-selected").attr("aria-expanded", expanded);
        if (expanded) {
          this.$("#okta-dropdown-options").find("li.factor-option:first a").focus();
        }
      }
    },
    "click .dropdown-disabled": function(e) {
      e.preventDefault();
      e.stopPropagation();
    }
  },
  initialize: function() {
    this.addOption(FactorsDropDownOptions.getDropdownOption("TITLE"));
    const factorsList = this.options.appState.get("factors");
    const multiplePushFactors = factorsList.hasMultipleFactorsOfSameType("push");
    factorsList.each(function(factor) {
      if (!(factor.get("factorType") === "token:software:totp" && multiplePushFactors)) {
        this.addOption(FactorsDropDownOptions.getDropdownOption(factor.get("factorName")), {
          model: factor
        });
        this.listenTo(this.last(), "options:toggle", function() {
          this.$(".options").hide();
          this.$("a.option-selected").attr("aria-expanded", false);
        });
      }
    }, this);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/FactorBeacon.js
var FactorBeacon = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="beacon-blank auth-beacon"><div class="beacon-blank js-blank-beacon-border auth-beacon-border"></div></div><div class="bg-helper auth-beacon auth-beacon-factor ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "className") || (depth0 != null ? lookupProperty(depth0, "className") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "className",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 171
          },
          "end": {
            "line": 1,
            "column": 184
          }
        }
      }) : helper)) + '" data-se="factor-beacon"><div class="okta-sign-in-beacon-border auth-beacon-border"></div></div><div data-type="factor-types-dropdown" class="factors-dropdown-wrap"></div>';
    },
    "useData": true
  }),
  events: {
    "click .auth-beacon-factor": function(e) {
      e.preventDefault();
      e.stopPropagation();
      const expanded = this.$(".dropdown .options").toggle().is(":visible");
      this.$("a.option-selected").attr("aria-expanded", expanded);
      if (expanded) {
        this.$("#okta-dropdown-options").find("li.factor-option:first a").focus();
      }
    }
  },
  initialize: function() {
    this.options.appState.set("beaconType", "factor");
  },
  getTemplateData: function() {
    const factors = this.options.appState.get("factors");
    let factor;
    let className2;
    if (factors) {
      factor = fn2.findFactorInFactorsArray(factors, this.options.provider, this.options.factorType);
    } else {
      factor = new Factor.Model(this.options.appState.get("factor"));
    }
    className2 = factor.get("iconClassName");
    return {
      className: className2 || ""
    };
  },
  postRender: function() {
    if (this.options.animate) {
      this.$(".auth-beacon-factor").fadeIn(200);
    }
    const appState = this.options.appState;
    if (appState.get("hasMultipleFactorsAvailable")) {
      this.add(FactorsDropDown, '[data-type="factor-types-dropdown"]');
    }
  },
  fadeOut: function() {
    const deferred = import_q19.default.defer();
    this.$(".auth-beacon-factor").fadeOut(200, function() {
      deferred.resolve();
    });
    return deferred.promise;
  },
  equals: function(Beacon, options2) {
    return Beacon && this instanceof Beacon && options2.provider === this.options.provider && (options2.factorType === this.options.factorType || fn2.isOktaVerify(options2.provider, options2.factorType) && fn2.isOktaVerify(this.options.provider, this.options.factorType));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/views/shared/PIVBeacon.js
var PIVBeacon = View2.extend({
  className: "piv-beacon",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div class="beacon-blank auth-beacon"><div class="beacon-blank js-blank-beacon-border auth-beacon-border"></div></div><div class="bg-helper auth-beacon smartcard" data-se="piv-beacon"><div class="okta-sign-in-beacon-border auth-beacon-border"></div></div>';
    },
    "useData": true
  }),
  equals: function(Beacon) {
    return Beacon && this instanceof Beacon;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v1/LoginRouter.js
var V1Router = BaseLoginRouter.extend({
  routes: {
    "": "defaultAuth",
    signin: "primaryAuth",
    "signin/verify/duo/web": "verifyDuo",
    "signin/verify/piv": "verifyPIV",
    "signin/poll": "poll",
    "signin/verify/fido/webauthn": "verifyWebauthn",
    "signin/verify/webauthn": "verifyWebauthn",
    "signin/verify/fido/u2f": "verifyU2F",
    "signin/verify/u2f": "verifyU2F",
    "signin/verify/generic_saml/assertion:saml2": "verifySAMLFactor",
    "signin/verify/generic_oidc/assertion:oidc": "verifyOIDCFactor",
    "signin/verify/custom/claims_provider": "verifyClaimsFactor",
    "signin/verify/:factorType": "verifyNoProvider",
    "signin/verify/:provider/:factorType(/:factorIndex)": "verify",
    "signin/enroll": "enrollChoices",
    "signin/enroll/duo/web": "enrollDuo",
    "signin/enroll/okta/question": "enrollQuestion",
    "signin/enroll/okta/password": "enrollPassword",
    "signin/enroll/okta/sms": "enrollSms",
    "signin/enroll/okta/call": "enrollCall",
    "signin/enroll/okta/email": "enrollEmail",
    "signin/enroll-activate/okta/sms": "enrollSms",
    "signin/enroll-activate/okta/call": "enrollCall",
    "signin/enroll/rsa/token": "enrollRsa",
    "signin/enroll/del_oath/token": "enrollOnPrem",
    "signin/enroll/symantec/token": "enrollSymantecVip",
    "signin/enroll/yubico/token:hardware": "enrollYubikey",
    "signin/enroll/fido/webauthn": "enrollWebauthn",
    "signin/enroll/fido/u2f": "enrollU2F",
    "signin/enroll/generic_saml/assertion:saml2": "enrollSAMLFactor",
    "signin/enroll/generic_oidc/assertion:oidc": "enrollOIDCFactor",
    "signin/enroll/custom/claims_provider": "enrollClaimsFactor",
    "signin/enroll/custom/token:hotp": "enrollHotpFactor",
    "signin/enroll/:provider/:factorType": "enrollTotpFactor",
    "signin/enroll-activate/okta/email": "enrollActivateEmail",
    "signin/enroll-activate/okta/push": "scanBarcodePushFactor",
    "signin/enroll-activate/okta/push/manual": "manualSetupPushFactor",
    "signin/enroll-activate/okta/push/sent": "activationLinkSent",
    "signin/enroll-activate/okta/token:software:totp/passcode": "enterPasscodeInPushEnrollmentFlow",
    "signin/enroll-activate/custom/claims_provider": "enrollActivateClaimsFactor",
    "signin/enroll-activate/:provider/:factorType": "scanBarcodeTotpFactor",
    "signin/enroll-activate/:provider/:factorType/activate": "activateTotpFactor",
    "signin/enroll-activate/:provider/:factorType/manual": "manualSetupTotpFactor",
    "signin/password-expired": "passwordExpired",
    "signin/custom-password-expired": "customPasswordExpired",
    "signin/forgot-password": "forgotPassword",
    "signin/recovery-challenge": "recoveryChallenge",
    "signin/recovery-emailed": "recoveryEmailSent",
    "signin/recovery-question": "recoveryQuestion",
    "signin/password-reset": "passwordReset",
    "signin/reset-password/:token": "recoveryLoading",
    "signin/user-unlock/:token": "recoveryLoading",
    "signin/recovery/:token": "recoveryLoading",
    "signin/unlock-emailed": "unlockEmailSent",
    "signin/unlock": "unlockAccount",
    "signin/account-unlocked": "accountUnlocked",
    "signin/refresh-auth-state(/:token)": "refreshAuthState",
    "signin/register": "register",
    "signin/register-complete": "registerComplete",
    "signin/error": "errorState",
    "signin/consent": "consentRequired",
    "signin/admin-consent": "adminConsentRequired",
    "signin/enroll-user": "enrollUser",
    "signin/device-activate-complete": "deviceActivateComplete",
    "signin/device-activate": "deviceActivate",
    "signin/idp-discovery-check": "idpDiscoveryCheck",
    "*wildcard": "defaultAuth"
  },
  // Route handlers that do not require a stateToken. If the page is refreshed,
  // these functions will not require a status call to refresh the stateToken.
  stateLessRouteHandlers: ["defaultAuth", "idpDiscovery", "primaryAuth", "forgotPassword", "recoveryLoading", "unlockAccount", "refreshAuthState", "register", "registerComplete", "errorState", "verifyPIV"],
  defaultAuth: function() {
    if (window.location.hash === `#${Enums.WIDGET_CONTAINER_ID}`) {
      document.getElementById(Enums.WIDGET_CONTAINER_ID).focus();
      return;
    }
    if (this.settings.get("features.idpDiscovery")) {
      this.idpDiscovery();
    } else {
      this.primaryAuth();
    }
  },
  idpDiscoveryCheck: function() {
    this.render(ForceIDPDiscoveryController, {
      Beacon: SecurityBeacon
    });
  },
  idpDiscovery: function() {
    this.render(IDPDiscoveryController, {
      Beacon: SecurityBeacon
    });
  },
  primaryAuth: function() {
    this.render(PrimaryAuthController, {
      Beacon: SecurityBeacon
    });
  },
  verifyDuo: function() {
    this.render(VerifyDuoController, {
      provider: "DUO",
      factorType: "web",
      Beacon: FactorBeacon
    });
  },
  verifyPIV: function() {
    this.render(VerifyPIVController, {
      Beacon: PIVBeacon
    });
  },
  poll: function() {
    this.render(PollController);
  },
  verifyWebauthn: function() {
    if (this.settings.get("features.webauthn")) {
      this.render(VerifyWebauthnController, {
        provider: "FIDO",
        factorType: "webauthn",
        Beacon: FactorBeacon
      });
    } else {
      this.render(VerifyWindowsHelloController, {
        provider: "FIDO",
        factorType: "webauthn",
        Beacon: FactorBeacon
      });
    }
  },
  verifyU2F: function() {
    this.render(VerifyU2FController, {
      provider: "FIDO",
      factorType: "u2f",
      Beacon: FactorBeacon
    });
  },
  verifySAMLFactor: function() {
    this.render(VerifyCustomFactorController, {
      provider: "GENERIC_SAML",
      factorType: "assertion:saml2",
      Beacon: FactorBeacon
    });
  },
  verifyOIDCFactor: function() {
    this.render(VerifyCustomFactorController, {
      provider: "GENERIC_OIDC",
      factorType: "assertion:oidc",
      Beacon: FactorBeacon
    });
  },
  verifyClaimsFactor: function() {
    this.render(VerifyCustomFactorController, {
      provider: "CUSTOM",
      factorType: "claims_provider",
      Beacon: FactorBeacon
    });
  },
  verify: function(provider, factorType, factorIndex) {
    this.render(MfaVerifyController, {
      provider: provider.toUpperCase(),
      factorType,
      factorIndex,
      Beacon: FactorBeacon
    });
  },
  verifyNoProvider: function(factorType) {
    this.render(MfaVerifyController, {
      factorType,
      Beacon: FactorBeacon
    });
  },
  enrollChoices: function() {
    this.render(EnrollChoicesController, {
      Beacon: SecurityBeacon
    });
  },
  enrollDuo: function() {
    this.render(EnrollDuoController, {
      provider: "DUO",
      factorType: "web",
      Beacon: FactorBeacon
    });
  },
  enrollQuestion: function() {
    this.render(EnrollQuestionController, {
      provider: "OKTA",
      factorType: "question",
      Beacon: FactorBeacon
    });
  },
  enrollPassword: function() {
    this.render(EnrollPasswordController, {
      provider: "OKTA",
      factorType: "password",
      Beacon: FactorBeacon
    });
  },
  enrollSms: function() {
    this.render(EnrollCallAndSmsController, {
      provider: "OKTA",
      factorType: "sms",
      Beacon: FactorBeacon
    });
  },
  enrollCall: function() {
    this.render(EnrollCallAndSmsController, {
      provider: "OKTA",
      factorType: "call",
      Beacon: FactorBeacon
    });
  },
  enrollEmail: function() {
    this.render(EnrollEmailController, {
      provider: "OKTA",
      factorType: "email",
      Beacon: FactorBeacon
    });
  },
  enrollActivateEmail: function() {
    this.render(EnrollActivateEmailController, {
      provider: "OKTA",
      factorType: "email",
      Beacon: FactorBeacon
    });
  },
  enrollRsa: function() {
    this.render(EnrollOnPremController, {
      provider: "RSA",
      factorType: "token",
      Beacon: FactorBeacon
    });
  },
  enrollOnPrem: function() {
    this.render(EnrollOnPremController, {
      provider: "DEL_OATH",
      factorType: "token",
      Beacon: FactorBeacon
    });
  },
  enrollSymantecVip: function() {
    this.render(EnrollSymantecVipController, {
      provider: "SYMANTEC",
      factorType: "token",
      Beacon: FactorBeacon
    });
  },
  enrollYubikey: function() {
    this.render(EnrollYubikeyController, {
      provider: "YUBICO",
      factorType: "token:hardware",
      Beacon: FactorBeacon
    });
  },
  enrollSAMLFactor: function() {
    this.render(EnrollCustomFactorController, {
      provider: "GENERIC_SAML",
      factorType: "assertion:saml2",
      Beacon: FactorBeacon
    });
  },
  enrollOIDCFactor: function() {
    this.render(EnrollCustomFactorController, {
      provider: "GENERIC_OIDC",
      factorType: "assertion:oidc",
      Beacon: FactorBeacon
    });
  },
  enrollClaimsFactor: function() {
    this.render(EnrollCustomFactorController, {
      provider: "CUSTOM",
      factorType: "claims_provider",
      Beacon: FactorBeacon
    });
  },
  enrollActivateClaimsFactor: function() {
    this.render(EnrollActivateCustomFactorController, {
      provider: "CUSTOM",
      factorType: "claims_provider",
      Beacon: FactorBeacon
    });
  },
  enrollTotpFactor: function(provider, factorType) {
    this.render(EnrollTotpControllerEnrollTotpController, {
      provider: provider.toUpperCase(),
      factorType,
      Beacon: FactorBeacon
    });
  },
  enrollHotpFactor: function() {
    this.render(EnrollHotpController, {
      provider: "CUSTOM",
      factorType: "token:hotp",
      Beacon: FactorBeacon
    });
  },
  enrollWebauthn: function() {
    if (this.settings.get("features.webauthn")) {
      this.render(EnrollWebauthnController, {
        provider: "FIDO",
        factorType: "webauthn",
        Beacon: FactorBeacon
      });
    } else {
      this.render(EnrollWindowsHelloController, {
        provider: "FIDO",
        factorType: "webauthn",
        Beacon: FactorBeacon
      });
    }
  },
  enrollU2F: function() {
    this.render(EnrollU2FController, {
      provider: "FIDO",
      factorType: "u2f",
      Beacon: FactorBeacon
    });
  },
  scanBarcodeTotpFactor: function(provider, factorType) {
    this.render(BarcodeTotpController, {
      provider: provider.toUpperCase(),
      factorType,
      Beacon: FactorBeacon
    });
  },
  scanBarcodePushFactor: function() {
    this.render(BarcodePushController, {
      provider: "OKTA",
      factorType: "push",
      Beacon: FactorBeacon
    });
  },
  activateTotpFactor: function(provider, factorType) {
    this.render(ActivateTotpController, {
      provider: provider.toUpperCase(),
      factorType,
      Beacon: FactorBeacon
    });
  },
  manualSetupTotpFactor: function(provider, factorType) {
    this.render(ManualSetupTotpController, {
      provider: provider.toUpperCase(),
      factorType,
      Beacon: FactorBeacon
    });
  },
  manualSetupPushFactor: function() {
    this.render(ManualSetupPushController, {
      provider: "OKTA",
      factorType: "push",
      Beacon: FactorBeacon
    });
  },
  activationLinkSent: function() {
    this.render(EnrollmentLinkSentController, {
      provider: "OKTA",
      factorType: "push",
      Beacon: FactorBeacon
    });
  },
  enterPasscodeInPushEnrollmentFlow: function() {
    this.render(EnterPasscodePushFlowController, {
      provider: "OKTA",
      factorType: "token:software:totp",
      Beacon: FactorBeacon
    });
  },
  passwordExpired: function() {
    this.render(PasswordExpiredController, {
      Beacon: SecurityBeacon
    });
  },
  customPasswordExpired: function() {
    this.render(CustomPasswordExpiredController, {
      Beacon: SecurityBeacon
    });
  },
  forgotPassword: function() {
    this.render(ForgotPasswordController);
  },
  recoveryChallenge: function() {
    this.render(RecoveryChallengeController, {
      Beacon: SecurityBeacon
    });
  },
  recoveryEmailSent: function() {
    this.render(PwdResetEmailSentController, {
      Beacon: SecurityBeacon
    });
  },
  unlockEmailSent: function() {
    this.render(UnlockEmailSentController, {
      Beacon: SecurityBeacon
    });
  },
  recoveryQuestion: function() {
    this.render(RecoveryQuestionController, {
      Beacon: SecurityBeacon
    });
  },
  passwordReset: function() {
    this.render(PasswordResetController, {
      Beacon: SecurityBeacon
    });
  },
  recoveryLoading: function(token) {
    this.render(RecoveryLoadingController, {
      token,
      Beacon: SecurityBeacon
    });
  },
  unlockAccount: function() {
    this.render(UnlockAccountController);
  },
  accountUnlocked: function() {
    this.render(AccountUnlockedController, {
      Beacon: SecurityBeacon
    });
  },
  refreshAuthState: function(token) {
    this.render(RefreshAuthStateController, {
      token,
      Beacon: SecurityBeacon
    });
  },
  register: function() {
    this.render(RegistrationController);
  },
  registerComplete: function() {
    this.render(RegistrationCompleteController);
  },
  errorState: function() {
    this.render(ErrorStateController, {
      Beacon: SecurityBeacon
    });
  },
  consentRequired: function() {
    this.render(ConsentRequiredController);
  },
  adminConsentRequired: function() {
    this.render(AdminConsentRequiredController);
  },
  enrollUser: function() {
    this.render(EnrollUserController);
  },
  deviceActivate: function() {
    this.render(DeviceActivateController);
  },
  deviceActivateComplete: function() {
    this.render(DeviceActivateTerminalController);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/RemediationConstants.js
var FORMS = {
  IDENTIFY: "identify",
  SELECT_IDENTIFY: "select-identify",
  IDENTIFY_RECOVERY: "identify-recovery",
  SELECT_ENROLL_PROFILE: "select-enroll-profile",
  ENROLL_PROFILE: "enroll-profile",
  ENROLL_PROFILE_UPDATE: "profile-update",
  UNLOCK_ACCOUNT: "unlock-account",
  REQUEST_ACTIVATION: "request-activation-email",
  CONSENT_ADMIN: "admin-consent",
  CONSENT_ENDUSER: "consent",
  CONSENT_GRANULAR: "granular-consent",
  CONSENT_EMAIL_CHALLENGE: "email-challenge-consent",
  SELECT_AUTHENTICATOR_AUTHENTICATE: "select-authenticator-authenticate",
  SELECT_AUTHENTICATOR_UNLOCK: "select-authenticator-unlock-account",
  AUTHENTICATOR_VERIFICATION_DATA: "authenticator-verification-data",
  CHALLENGE_AUTHENTICATOR: "challenge-authenticator",
  CHALLENGE_POLL: "challenge-poll",
  RESEND: "resend",
  SELECT_AUTHENTICATOR_ENROLL: "select-authenticator-enroll",
  SELECT_AUTHENTICATOR_ENROLL_DATA: "select-authenticator-enroll-data",
  AUTHENTICATOR_ENROLLMENT_DATA: "authenticator-enrollment-data",
  ENROLL_AUTHENTICATOR: "enroll-authenticator",
  SELECT_ENROLLMENT_CHANNEL: "select-enrollment-channel",
  ENROLLMENT_CHANNEL_DATA: "enrollment-channel-data",
  ENROLL_POLL: "enroll-poll",
  REENROLL_AUTHENTICATOR: "reenroll-authenticator",
  REENROLL_AUTHENTICATOR_WARNING: "reenroll-authenticator-warning",
  RESET_AUTHENTICATOR: "reset-authenticator",
  SKIP: "skip",
  POLL: "poll",
  FAILURE_REDIRECT: "failure-redirect",
  SUCCESS_REDIRECT: "success-redirect",
  REDIRECT_IDP: "redirect-idp",
  PIV_IDP: "piv-idp",
  DEVICE_CHALLENGE_POLL: "device-challenge-poll",
  DEVICE_APPLE_SSO_EXTENSION: "device-apple-sso-extension",
  CANCEL_TRANSACTION: "cancel-transaction",
  LAUNCH_AUTHENTICATOR: "launch-authenticator",
  LAUNCH_WEBAUTHN_AUTHENTICATOR: "launch-webauthn-authenticator",
  ENROLL_WEBAUTHN_RESIDENTKEY: "enroll-webauthn-residentkey",
  DEVICE_ENROLLMENT_TERMINAL: "device-enrollment-terminal",
  USER_CODE: "user-code",
  // 'terminal` is not ION Form name but only coined in widget
  // for rendering a page that user has nothing to remediate.
  TERMINAL: "terminal"
};
var FORMS_WITHOUT_SIGNOUT = [FORMS.IDENTIFY, FORMS.SUCCESS_REDIRECT, FORMS.ENROLL_PROFILE, FORMS.DEVICE_ENROLLMENT_TERMINAL, FORMS.CONSENT_ADMIN, FORMS.CONSENT_ENDUSER, FORMS.CONSENT_GRANULAR, FORMS.CONSENT_EMAIL_CHALLENGE, FORMS.USER_CODE];
var FORMS_WITH_STATIC_BACK_LINK = [FORMS.SELECT_AUTHENTICATOR_ENROLL, FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE];
var FORMS_FOR_VERIFICATION = [FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE, FORMS.CHALLENGE_AUTHENTICATOR, FORMS.CHALLENGE_POLL, FORMS.RESEND];
var AUTHENTICATOR_KEY = {
  EMAIL: "okta_email",
  PASSWORD: "okta_password",
  PHONE: "phone_number",
  WEBAUTHN: "webauthn",
  SECURITY_QUESTION: "security_question",
  OV: "okta_verify",
  GOOGLE_OTP: "google_otp",
  ON_PREM: "onprem_mfa",
  RSA: "rsa_token",
  DUO: "duo",
  IDP: "external_idp",
  CUSTOM_OTP: "custom_otp",
  SYMANTEC_VIP: "symantec_vip",
  YUBIKEY: "yubikey_token",
  CUSTOM_APP: "custom_app"
};
var AUTHENTICATOR_METHODS = {
  PUSH: "push"
};
var FORM_NAME_TO_OPERATION_MAP = {
  [FORMS.SELECT_AUTHENTICATOR_UNLOCK]: Enums.UNLOCK_ACCOUNT,
  [FORMS.IDENTIFY]: Enums.PRIMARY_AUTH,
  [FORMS.IDENTIFY_RECOVERY]: Enums.FORGOT_PASSWORD
};
var ENROLLED_PASSWORD_RECOVERY_LINK = "currentAuthenticatorEnrollment-recover";
var ORG_PASSWORD_RECOVERY_LINK = "currentAuthenticator-recover";
var ACTIONS = {
  ENROLLED_PASSWORD_RECOVERY_LINK,
  ORG_PASSWORD_RECOVERY_LINK
};
var HINTS = {
  CAPTCHA: "captcha"
};
var TERMINAL_FORMS = [FORMS.TERMINAL, FORMS.DEVICE_ENROLLMENT_TERMINAL];
var IDP_FORM_TYPE = {
  X509: "X509"
};
var INTERSTITIAL_REDIRECT_VIEW = {
  DEFAULT: "DEFAULT",
  NONE: "NONE"
};
var ATTR_FORMAT = {
  COUNTRY_CODE: "country-code"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-object-handler.js
function createOVOptions(options2 = []) {
  var _ovItem$value, _ovItem$value$form, _ovItem$value$form$va;
  const ovItem = options2.find((option2) => option2.relatesTo.key === AUTHENTICATOR_KEY.OV);
  const methodTypeObj = ovItem === null || ovItem === void 0 ? void 0 : (_ovItem$value = ovItem.value) === null || _ovItem$value === void 0 ? void 0 : (_ovItem$value$form = _ovItem$value.form) === null || _ovItem$value$form === void 0 ? void 0 : (_ovItem$value$form$va = _ovItem$value$form.value) === null || _ovItem$value$form$va === void 0 ? void 0 : _ovItem$value$form$va.find((v) => v.name === "methodType");
  const methodOptions = methodTypeObj === null || methodTypeObj === void 0 ? void 0 : methodTypeObj.options;
  let signedNonceOption;
  if (methodOptions) {
    const ovOptions = [];
    methodOptions.forEach((method) => {
      const value = [...ovItem.value.form.value];
      const methodTypeIndex = ovItem.value.form.value.findIndex((v) => v.name === "methodType");
      const newMethodTypeObj = Object.assign(oktaUnderscore.omit(methodTypeObj, "options"), method);
      newMethodTypeObj.required = true;
      newMethodTypeObj.mutable = false;
      value.splice(methodTypeIndex, 1, newMethodTypeObj);
      const newItem = Object.assign({}, ovItem, {
        label: method.label,
        value: {
          form: {
            value
          }
        }
      });
      if (method.value === "signed_nonce") {
        signedNonceOption = newItem;
      } else {
        ovOptions.push(newItem);
      }
    });
    const ovIndex = options2.findIndex((option2) => option2.relatesTo.key === AUTHENTICATOR_KEY.OV);
    options2.splice(ovIndex, 1, ...ovOptions);
    if (signedNonceOption) {
      ovItem.relatesTo.deviceKnown ? options2.unshift(signedNonceOption) : options2.push(signedNonceOption);
    }
  }
}
function createAuthenticatorOptions(options2 = []) {
  createOVOptions(options2);
  return options2.map((option2) => {
    var _option$value, _option$value$form, _option$relatesTo;
    const value = ((_option$value = option2.value) === null || _option$value === void 0 ? void 0 : (_option$value$form = _option$value.form) === null || _option$value$form === void 0 ? void 0 : _option$value$form.value) || [];
    const valueObject = value.filter((v) => v.required === true && v.mutable === false).reduce((init, v) => {
      return Object.assign(init, {
        [v.name]: v.value
      });
    }, {});
    return {
      label: option2.label,
      value: valueObject,
      relatesTo: option2.relatesTo,
      authenticatorKey: (_option$relatesTo = option2.relatesTo) === null || _option$relatesTo === void 0 ? void 0 : _option$relatesTo.key
    };
  });
}
function getAuthenticatorsEnrollUiSchema({
  options: options2
}) {
  return {
    type: "authenticatorEnrollSelect",
    options: createAuthenticatorOptions(options2)
  };
}
function getAuthenticatorsVerifyUiSchema({
  options: options2
}) {
  return {
    type: "authenticatorVerifySelect",
    options: createAuthenticatorOptions(options2)
  };
}
function createUiSchemaForObject(ionFormField, remediationForm, transformedResp, createUISchema2, settings) {
  const uiSchema = {};
  if (ionFormField.name === "authenticator" && (remediationForm.name === "select-authenticator-authenticate" || remediationForm.name === "select-authenticator-unlock-account")) {
    Object.assign(uiSchema, getAuthenticatorsVerifyUiSchema(ionFormField));
  } else if (ionFormField.name === "authenticator" && remediationForm.name === "select-authenticator-enroll") {
    Object.assign(uiSchema, getAuthenticatorsEnrollUiSchema(ionFormField));
  } else if (Array.isArray(ionFormField.options)) {
    uiSchema.optionsUiSchemas = ionFormField.options.map((opt) => {
      return createUISchema2(transformedResp, {
        value: [{
          name: ionFormField.name,
          value: opt.value
        }]
      }, settings);
    });
    uiSchema.options = ionFormField.options.map((opt, index) => {
      return {
        label: opt.label,
        value: index
      };
    });
    uiSchema.type = "radio";
    uiSchema.value = "0";
    uiSchema.name = `sub_schema_local_${ionFormField.name}`;
  }
  return uiSchema;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/mixins/mixins.js
oktaUnderscore.mixin({
  nestedOmit: function(obj, names) {
    let result = oktaUnderscore.omit(obj, names);
    if (names.includes(result.name)) {
      result = oktaUnderscore.omit(result, "value");
    }
    oktaUnderscore.each(result, function(val, key) {
      if (Array.isArray(val)) {
        result[key] = val.map((v) => {
          return oktaUnderscore.nestedOmit(v, names);
        });
      } else if (typeof val === "object") {
        result[key] = oktaUnderscore.nestedOmit(val, names);
      }
    });
    return result;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/util/Hooks.js
function executeHookFunctions(functions) {
  return __async(this, null, function* () {
    for (let i = 0; i < functions.length; i++) {
      yield functions[i]();
    }
  });
}
function executeHooksBefore(hook) {
  return __async(this, null, function* () {
    if (!hook || !hook.before || !hook.before.length) {
      return;
    }
    yield executeHookFunctions(hook.before);
  });
}
function executeHooksAfter(hook) {
  return __async(this, null, function* () {
    if (!hook || !hook.after || !hook.after.length) {
      return;
    }
    yield executeHookFunctions(hook.after);
  });
}
function mergeHook(hooks, formName, hookToMerge) {
  const existingHook = hooks[formName] = hooks[formName] || {
    before: [],
    after: []
  };
  if (hookToMerge.before) {
    existingHook.before = existingHook.before.concat(hookToMerge.before);
  }
  if (hookToMerge.after) {
    existingHook.after = existingHook.after.concat(hookToMerge.after);
  }
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/models/AppState.js
var UNKNOWN_USER_I8N_KEY = "idx.unknown.user";
var local2 = {
  user: "object",
  // optional
  currentFormName: "string",
  idx: "object",
  remediations: "array",
  dynamicRefreshInterval: "number",
  deviceFingerprint: "string",
  hooks: "object"
  // instance of models/Hooks
};
var derived2 = {
  authenticatorProfile: {
    deps: ["currentAuthenticator", "currentAuthenticatorEnrollment"],
    fn: function(currentAuthenticator = {
      profile: void 0
    }, currentAuthenticatorEnrollment = {
      profile: void 0
    }) {
      return currentAuthenticator.profile || currentAuthenticatorEnrollment.profile || {};
    }
  },
  authenticatorKey: {
    deps: ["currentAuthenticator", "currentAuthenticatorEnrollment"],
    fn: function(currentAuthenticator = {
      key: void 0
    }, currentAuthenticatorEnrollment = {
      key: void 0
    }) {
      return currentAuthenticator.key || currentAuthenticatorEnrollment.key || "";
    }
  },
  authenticatorMethodType: {
    deps: ["currentAuthenticator", "currentAuthenticatorEnrollment"],
    fn: function(currentAuthenticator = {
      methods: void 0
    }, currentAuthenticatorEnrollment = {
      methods: void 0
    }) {
      return currentAuthenticator.methods && currentAuthenticator.methods[0].type || currentAuthenticatorEnrollment.methods && currentAuthenticatorEnrollment.methods[0].type || "";
    }
  },
  isPasswordRecovery: {
    deps: ["recoveryAuthenticator"],
    fn: function(recoveryAuthenticator = {
      type: void 0
    }) {
      return (recoveryAuthenticator === null || recoveryAuthenticator === void 0 ? void 0 : recoveryAuthenticator.type) === "password";
    }
  }
};
var AppState2 = class extends Model2 {
  constructor(attributes2, options2) {
    super(attributes2, options2);
    this.settings = void 0;
    this.hooks = void 0;
    this.settings = options2.settings;
    this.hooks = options2.hooks;
  }
  get(attributeName) {
    return Model2.prototype.get.call(this, attributeName);
  }
  preinitialize(...args) {
    this.local = local2;
    this.derived = derived2;
    Model2.prototype.preinitialize.apply(this, args);
  }
  isIdentifierOnlyView() {
    var _this$get, _this$get$find, _this$get$find$uiSche;
    return !((_this$get = this.get("remediations")) !== null && _this$get !== void 0 && (_this$get$find = _this$get.find(({
      name
    }) => name === "identify")) !== null && _this$get$find !== void 0 && (_this$get$find$uiSche = _this$get$find.uiSchema) !== null && _this$get$find$uiSche !== void 0 && _this$get$find$uiSche.find(({
      name
    }) => name === "credentials.passcode"));
  }
  hasRemediationObject(formName) {
    return this.get("idx").neededToProceed.find((remediation) => remediation.name === formName);
  }
  hasActionObject(actionName) {
    var _this$get2, _this$get2$actions;
    return !!((_this$get2 = this.get("idx")) !== null && _this$get2 !== void 0 && (_this$get2$actions = _this$get2.actions) !== null && _this$get2$actions !== void 0 && _this$get2$actions[actionName]);
  }
  getRemediationAuthenticationOptions(formName) {
    const form2 = this.hasRemediationObject(formName);
    if (!form2) {
      return [];
    }
    const authenticator = form2.value.find((value) => value.name === "authenticator");
    let authenticatorOptions = (authenticator === null || authenticator === void 0 ? void 0 : authenticator.options) || [];
    authenticatorOptions = [...authenticatorOptions];
    createOVOptions(authenticatorOptions);
    return authenticatorOptions;
  }
  getActionByPath(actionPath) {
    const paths = actionPath.split(".");
    let targetObject;
    if (paths.length === 1) {
      targetObject = this.get("idx").actions;
    } else {
      targetObject = this.get(paths.shift());
    }
    const actionName = paths.shift();
    if (targetObject && oktaUnderscore.isFunction(targetObject[actionName])) {
      return targetObject[actionName];
    } else {
      return null;
    }
  }
  getCurrentViewState() {
    const currentFormName = this.get("currentFormName");
    if (!currentFormName) {
      return;
    }
    const currentViewState = this.get("remediations").filter((r) => r.name === currentFormName)[0];
    if (!currentViewState) {
      Logger.error("Panic!!");
      Logger.error(`	Cannot find view state for form ${currentFormName}.`);
      const allFormNames = this.get("remediations").map((r) => r.name);
      Logger.error(`	All available form names: ${allFormNames}`);
    }
    return currentViewState;
  }
  /**
   * Returns ui schema of the form field from current view state
   * @param {string} fieldName
   * @returns {}
   */
  getSchemaByName(fieldName) {
    const currentViewState = this.getCurrentViewState();
    if (currentViewState) {
      const uiSchema = currentViewState.uiSchema;
      return uiSchema.find(({
        name
      }) => name === fieldName);
    }
  }
  /**
   * Returns the displayName of the authenticator
   * @returns {string}
   */
  getAuthenticatorDisplayName() {
    const currentAuthenticator = this.get("currentAuthenticator") || {};
    const currentAuthenticatorEnrollment = this.get("currentAuthenticatorEnrollment") || {};
    return currentAuthenticator.displayName || currentAuthenticatorEnrollment.displayName;
  }
  /**
   * Checks to see if we're in an authenticator challenge flow.
   * @returns {boolean}
   */
  isAuthenticatorChallenge() {
    const currentFormName = this.get("currentFormName");
    return FORMS_FOR_VERIFICATION.includes(currentFormName);
  }
  shouldReRenderView(transformedResponse) {
    var _transformedResponse$;
    if (transformedResponse !== null && transformedResponse !== void 0 && (_transformedResponse$ = transformedResponse.idx) !== null && _transformedResponse$ !== void 0 && _transformedResponse$.hasFormError) {
      return false;
    }
    const previousRawState = this.has("idx") ? this.get("idx").rawIdxState : null;
    const identicalResponse = oktaUnderscore.isEqual(oktaUnderscore.nestedOmit(transformedResponse.idx.rawIdxState, ["expiresAt", "refresh", "stateHandle", "headers"]), oktaUnderscore.nestedOmit(previousRawState, ["expiresAt", "refresh", "stateHandle", "headers"]));
    if (identicalResponse) {
      this.set("dynamicRefreshInterval", this.getRefreshInterval(transformedResponse));
    }
    return this._isReRenderRequired(identicalResponse, transformedResponse, previousRawState);
  }
  getRefreshInterval(transformedResponse) {
    var _transformedResponse$2, _transformedResponse$3, _transformedResponse$4, _transformedResponse$5;
    const currentFormName = this.get("currentFormName");
    const currentViewState = transformedResponse.remediations.filter((r) => r.name === currentFormName)[0];
    return currentViewState.refresh || ((_transformedResponse$2 = transformedResponse.currentAuthenticatorEnrollment) === null || _transformedResponse$2 === void 0 ? void 0 : (_transformedResponse$3 = _transformedResponse$2.poll) === null || _transformedResponse$3 === void 0 ? void 0 : _transformedResponse$3.refresh) || ((_transformedResponse$4 = transformedResponse.currentAuthenticator) === null || _transformedResponse$4 === void 0 ? void 0 : (_transformedResponse$5 = _transformedResponse$4.poll) === null || _transformedResponse$5 === void 0 ? void 0 : _transformedResponse$5.refresh);
  }
  // Sign Out link will be displayed in the footer of a form, unless:
  // - widget configuration set hideSignOutLinkInMFA or mfaOnlyFlow to true
  // - cancel remediation form is not present in the response
  // - form is part of our list FORMS_WITHOUT_SIGNOUT
  shouldShowSignOutLinkInCurrentForm(hideSignOutLinkInMFA) {
    const idxActions = this.get("idx") && this.get("idx").actions;
    const currentFormName = this.get("currentFormName");
    return !hideSignOutLinkInMFA && oktaUnderscore.isFunction(idxActions === null || idxActions === void 0 ? void 0 : idxActions.cancel) && !FORMS_WITHOUT_SIGNOUT.includes(currentFormName);
  }
  containsMessageWithI18nKey(keys) {
    if (!Array.isArray(keys)) {
      keys = [keys];
    }
    const messagesObjs = this.get("messages");
    return messagesObjs && Array.isArray(messagesObjs.value) && messagesObjs.value.some((messagesObj) => {
      var _messagesObj$i18n;
      return oktaUnderscore.contains(keys, (_messagesObj$i18n = messagesObj.i18n) === null || _messagesObj$i18n === void 0 ? void 0 : _messagesObj$i18n.key);
    });
  }
  containsMessageStartingWithI18nKey(keySubStr) {
    const messagesObjs = this.get("messages");
    return messagesObjs && Array.isArray(messagesObjs.value) && messagesObjs.value.some((messagesObj) => {
      var _messagesObj$i18n2;
      return (_messagesObj$i18n2 = messagesObj.i18n) === null || _messagesObj$i18n2 === void 0 ? void 0 : _messagesObj$i18n2.key.startsWith(keySubStr);
    });
  }
  clearAppStateCache() {
    const attrs = {};
    for (const key in this.attributes) {
      if (key !== "currentFormName") {
        attrs[key] = void 0;
      }
    }
    this.set(attrs, Object.assign({}, {
      unset: true,
      silent: true
    }));
    this.trigger("cache:clear");
  }
  setIonResponse(transformedResponse) {
    return __async(this, null, function* () {
      const doRerender = this.shouldReRenderView(transformedResponse);
      this.clearAppStateCache();
      this.set(transformedResponse);
      if (doRerender) {
        var _this$hooks;
        let currentFormName = null;
        if (!oktaUnderscore.isEmpty(transformedResponse.remediations)) {
          currentFormName = transformedResponse.remediations[0].name;
        } else {
          Logger.error("Panic!!");
          Logger.error("	No remediation found.");
          Logger.error("	Here is the entire response");
          Logger.error(JSON.stringify(transformedResponse, null, 2));
        }
        const hook = (_this$hooks = this.hooks) === null || _this$hooks === void 0 ? void 0 : _this$hooks.getHook(currentFormName);
        yield executeHooksBefore(hook);
        this.unset("currentFormName", {
          silent: true
        });
        this.set({
          currentFormName
        });
        yield executeHooksAfter(hook);
      }
    });
  }
  setNonIdxError(error) {
    this.set("remediations", [{
      name: FORMS.TERMINAL
    }]);
    this.set("messages", {
      value: [{
        message: error.errorDetails.errorSummary,
        class: "ERROR"
      }]
    });
    this.set("currentFormName", FORMS.TERMINAL);
  }
  getUser() {
    return this.get("user");
  }
  _isReRenderRequired(identicalResponse, transformedResponse, previousRawState) {
    var _this$get3;
    let reRender = true;
    const isPreviousStateError = (_this$get3 = this.get("idx")) === null || _this$get3 === void 0 ? void 0 : _this$get3.hasFormError;
    if (isPreviousStateError && this._isChallengeAuthenticatorPoll(transformedResponse, previousRawState)) {
      reRender = false;
    }
    if (identicalResponse) {
      reRender = false;
      if (this.get("currentFormName") === "poll") {
        reRender = true;
      } else if (FORMS_WITH_STATIC_BACK_LINK.includes(this.get("currentFormName"))) {
        reRender = true;
      } else if (this.containsMessageWithI18nKey(UNKNOWN_USER_I8N_KEY)) {
        reRender = true;
      }
    }
    return reRender;
  }
  /**
   * This is to account for the edge case introduced by this issue: OKTA-419210. With the current idx remediations,
   * there's no good way to generalize this as the backend handles the authenticators for phone, sms and 
   * email differently. Although not ideal, we have to keep this check in for now until we find a better solution.
   */
  _isChallengeAuthenticatorPoll(transformedResponse, previousRawState) {
    var _this$get4;
    const isSameExceptMessages = oktaUnderscore.isEqual(oktaUnderscore.nestedOmit(transformedResponse.idx.rawIdxState, ["expiresAt", "refresh", "stateHandle", "headers"]), oktaUnderscore.nestedOmit(previousRawState, ["expiresAt", "refresh", "stateHandle", "messages", "headers"]));
    const isChallengeAuthenticator = this.get("currentFormName") === "challenge-authenticator";
    const isCurrentAuthenticatorEmail = ((_this$get4 = this.get("currentAuthenticatorEnrollment")) === null || _this$get4 === void 0 ? void 0 : _this$get4.key) === AUTHENTICATOR_KEY.EMAIL;
    return isSameExceptMessages && isChallengeAuthenticator && isCurrentAuthenticatorEmail;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/sessionStorageHelper.js
var STATE_HANDLE_SESSION_STORAGE_KEY = "osw-oie-state-handle";
var LAST_INITIATED_LOGIN_URL_SESSION_STORAGE_KEY = "osw-oie-last-initiated-login-url";
var RESEND_TIMESTAMP_SESSION_STORAGE_KEY = "osw-oie-resend-timestamp";
var removeStateHandle = () => {
  sessionStorage.removeItem(STATE_HANDLE_SESSION_STORAGE_KEY);
  sessionStorage.removeItem(LAST_INITIATED_LOGIN_URL_SESSION_STORAGE_KEY);
};
var setStateHandle = (token) => {
  sessionStorage.setItem(STATE_HANDLE_SESSION_STORAGE_KEY, token);
  sessionStorage.setItem(LAST_INITIATED_LOGIN_URL_SESSION_STORAGE_KEY, window.location.href);
};
var getStateHandle = () => {
  return sessionStorage.getItem(STATE_HANDLE_SESSION_STORAGE_KEY);
};
var getLastInitiatedLoginUrl = () => {
  return sessionStorage.getItem(LAST_INITIATED_LOGIN_URL_SESSION_STORAGE_KEY);
};
var removeResendTimestamp = () => {
  sessionStorage.removeItem(RESEND_TIMESTAMP_SESSION_STORAGE_KEY);
};
var setResendTimestamp = (token) => {
  sessionStorage.setItem(RESEND_TIMESTAMP_SESSION_STORAGE_KEY, token);
};
var getResendTimestamp = () => {
  return sessionStorage.getItem(RESEND_TIMESTAMP_SESSION_STORAGE_KEY);
};
var sessionStorageHelper = {
  removeStateHandle,
  setStateHandle,
  getStateHandle,
  getLastInitiatedLoginUrl,
  removeResendTimestamp,
  setResendTimestamp,
  getResendTimestamp
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/emailVerifyCallback.js
function emailVerifyCallback(settings) {
  return __async(this, null, function* () {
    const authClient = settings.getAuthClient();
    const idxOptions = {
      exchangeCodeForTokens: false,
      // we handle this in interactionCodeFlow.js
      shouldProceedWithEmailAuthenticator: false
      // do not auto-select email authenticator
    };
    const meta = yield authClient.idx.getSavedTransactionMeta();
    if (!meta || !meta.interactionHandle) {
      const messages = {
        type: "array",
        value: [
          // terminal-return-otp-only-no-location.json
          {
            "message": "Enter the OTP in your original browser or device.",
            "i18n": {
              "key": "idx.enter.otp.in.original.tab"
            },
            "class": "INFO"
          }
        ]
      };
      const resp = {
        neededToProceed: [],
        // OKTA-382410 so bad that has to leverage rawIdxState
        rawIdxState: {
          messages
        },
        context: {
          messages
        }
      };
      return resp;
    }
    const otp = settings.get("otp");
    const idxResponse = yield authClient.idx.proceed(__spreadProps(__spreadValues({}, idxOptions), {
      otp
    }));
    return idxResponse;
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/constants.js
var CONFIGURED_FLOW = {
  DEFAULT: "default",
  PROCEED: "proceed",
  LOGIN: "login",
  REGISTRATION: "signup",
  RESET_PASSWORD: "resetPassword",
  UNLOCK_ACCOUNT: "unlockAccount"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/startLoginFlow.js
var handleProxyIdxResponse = (settings) => __async(void 0, null, function* () {
  return Promise.resolve({
    rawIdxState: settings.get("proxyIdxResponse"),
    context: settings.get("proxyIdxResponse"),
    neededToProceed: []
  });
});
function startLoginFlow(settings) {
  return __async(this, null, function* () {
    const authClient = settings.getAuthClient();
    const {
      authParams
    } = settings.toJSON({
      verbose: true
    });
    const nonce = settings.get("nonce") || (authParams === null || authParams === void 0 ? void 0 : authParams.nonce);
    const idxOptions = __spreadValues({
      exchangeCodeForTokens: false,
      // we handle this in interactionCodeFlow.js
      shouldProceedWithEmailAuthenticator: false
    }, nonce && {
      nonce
    });
    if (settings.get("proxyIdxResponse")) {
      return handleProxyIdxResponse(settings);
    }
    if (settings.get("overrideExistingStateToken")) {
      sessionStorageHelper.removeStateHandle();
    }
    if (settings.get("otp")) {
      return emailVerifyCallback(settings);
    }
    if (settings.get("useInteractionCodeFlow")) {
      const meta = yield authClient.idx.getSavedTransactionMeta();
      if (!meta) {
        const flow = authClient.idx.getFlow();
        if (flow && flow === CONFIGURED_FLOW.PROCEED) {
          throw new ConfiguredFlowError("Unable to proceed: saved transaction could not be loaded", flow);
        }
        return authClient.idx.start(idxOptions);
      }
      return authClient.idx.proceed(idxOptions);
    }
    const stateHandleFromSession = sessionStorageHelper.getStateHandle();
    if (stateHandleFromSession) {
      try {
        var _idxResp$context, _idxResp$context$mess;
        const idxResp = yield authClient.idx.start(__spreadProps(__spreadValues({}, idxOptions), {
          stateHandle: stateHandleFromSession
        }));
        const hasError = ((_idxResp$context = idxResp.context) === null || _idxResp$context === void 0 ? void 0 : (_idxResp$context$mess = _idxResp$context.messages) === null || _idxResp$context$mess === void 0 ? void 0 : _idxResp$context$mess.value.length) > 0;
        if (hasError) {
          throw new Error("saved stateToken is invalid");
        }
        settings.set("stateToken", stateHandleFromSession);
        return idxResp;
      } catch {
        sessionStorageHelper.removeStateHandle();
        return startLoginFlow(settings);
      }
    }
    const stateHandle = settings.get("stateToken");
    if (stateHandle) {
      return authClient.idx.start(__spreadProps(__spreadValues({}, idxOptions), {
        stateHandle
      }));
    }
    throw new ConfigError('Set "useInteractionCodeFlow" to true in configuration to enable the interaction_code" flow for self-hosted widget.');
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/handleConfiguredFlow.js
function proceedIfAvailable(idxState, remediation, flow) {
  return __async(this, null, function* () {
    const rem = idxState.neededToProceed.find((item) => item.name === remediation);
    if (!rem) {
      return idxState;
    }
    try {
      const nextIdxState = yield idxState.proceed(remediation);
      return nextIdxState;
    } catch (err) {
      if (typeof err === "string" && err.startsWith("Unknown remediation choice")) {
        return idxState;
      } else {
        throw err;
      }
    }
  });
}
function stepIntoSpecificIdxFlow(idxState, flow = "default") {
  return __async(this, null, function* () {
    switch (flow) {
      case CONFIGURED_FLOW.DEFAULT:
      case CONFIGURED_FLOW.PROCEED:
      case CONFIGURED_FLOW.LOGIN:
        return idxState;
      case CONFIGURED_FLOW.REGISTRATION:
      case CONFIGURED_FLOW.RESET_PASSWORD:
        return idxState;
      case CONFIGURED_FLOW.UNLOCK_ACCOUNT:
        return yield proceedIfAvailable(idxState, FORMS.UNLOCK_ACCOUNT);
      default:
        throw new ConfigError('Invalid "flow" configuration');
    }
  });
}
function handleConfiguredFlow(originalResp, settings) {
  return __async(this, null, function* () {
    const authClient = settings.getAuthClient();
    const configuredFlow = authClient.idx.getFlow();
    const idxState = yield stepIntoSpecificIdxFlow(originalResp, configuredFlow);
    return idxState;
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/interactionCodeFlow.js
function interactionCodeFlow(settings, idxResponse) {
  return __async(this, null, function* () {
    const {
      interactionCode
    } = idxResponse;
    const authClient = settings.getAuthClient();
    const transactionMeta = yield authClient.idx.getSavedTransactionMeta();
    const state = authClient.options.state || (transactionMeta === null || transactionMeta === void 0 ? void 0 : transactionMeta.state);
    const isRemediationMode = settings.get("mode") === "remediation";
    if (isRemediationMode) {
      authClient.idx.clearTransactionMeta();
    }
    const shouldRedirect = settings.get("redirect") === "always";
    if (shouldRedirect) {
      const redirectUri = settings.get("redirectUri");
      if (!redirectUri) {
        throw new ConfigError('"redirectUri" is required');
      }
      const qs = toQueryString({
        "interaction_code": interactionCode,
        state
      });
      window.location.assign(redirectUri + qs);
      return;
    }
    if (isRemediationMode) {
      settings.callGlobalSuccess(Enums.SUCCESS, {
        "interaction_code": interactionCode,
        state
      });
      return;
    }
    if (!transactionMeta) {
      throw new ConfigError("Could not load transaction data from storage");
    }
    const {
      codeVerifier
    } = transactionMeta;
    return authClient.token.exchangeCodeForTokens({
      codeVerifier,
      interactionCode
    }).then(({
      tokens
    }) => {
      settings.callGlobalSuccess(Enums.SUCCESS, {
        tokens
      });
    }).catch((err) => {
      const typedError = getTypedOAuthError(err);
      if (typedError instanceof RecoverableError && typedError.is("terminal")) {
        throw typedError;
      }
      settings.callGlobalError(err);
    }).finally(() => {
      authClient.idx.clearTransactionMeta();
    });
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/responseTransformer.js
var isObject2 = (x) => oktaUnderscore.isObject(x);
var isError = (response) => !!response.messages;
var getFirstLevelObjects = (resp) => {
  const result = {};
  oktaUnderscore.each(resp, (val = {}, key) => {
    if (key === "remediation") {
      return;
    }
    if (val.type === "array") {
      result[key] = {
        value: val.value
      };
    }
    if (val.type === "object") {
      result[key] = val.value;
    }
  });
  return result;
};
var getRemediationValues = (idx) => {
  const remediationValues = [];
  const hasSkipRemediationOnly = idx.neededToProceed.length === 1 && idx.neededToProceed[0].name === "skip";
  if (oktaUnderscore.isEmpty(idx.neededToProceed) || hasSkipRemediationOnly) {
    if (idx.context.success) {
      remediationValues.push({
        name: idx.context.success.name,
        href: idx.context.success.href,
        value: []
      });
    } else if (idx.context.messages) {
      remediationValues.push({
        name: FORMS.TERMINAL,
        // Using `value` is unnecessary as `messages` will be display via `TerminalView.showMessages`,
        // even though might sound a little counterintuitive.
        // The reason being is there is `BaseForm.showMessages` that is intended to handle
        // messages generically.
        value: []
      });
    } else if (idx.context.deviceEnrollment) {
      remediationValues.push({
        name: FORMS.DEVICE_ENROLLMENT_TERMINAL,
        value: []
      });
    }
  }
  return {
    remediations: [...remediationValues, ...idx.neededToProceed]
  };
};
var injectIdPConfigButtonToRemediation = (settings, idxResp) => {
  const widgetRemedations = idxResp.remediations;
  const hasIdentifyRemedation = widgetRemedations.filter((r) => r.name === "identify");
  if (hasIdentifyRemedation.length === 0) {
    return idxResp;
  }
  const idpsConfig = settings.get("idps");
  if (Array.isArray(idpsConfig)) {
    const existsRedirectIdpIds = {};
    widgetRemedations.forEach((r) => {
      if (r.name === FORMS.REDIRECT_IDP && r.idp) {
        existsRedirectIdpIds[r.idp.id] = true;
      }
    });
    const baseUrl = settings.get("baseUrl");
    const stateHandle = idxResp.idx.context.stateHandle;
    const redirectIdpRemedations = idpsConfig.filter((c2) => !existsRedirectIdpIds[c2.id]).map((idpConfig) => {
      const idp = {
        id: idpConfig.id,
        name: idpConfig.text
      };
      const redirectUri = `${baseUrl}/sso/idps/${idpConfig.id}?stateToken=${stateHandle}`;
      if (idpConfig.className) {
        idp.className = idpConfig.className;
      }
      return {
        name: FORMS.REDIRECT_IDP,
        type: idpConfig.type,
        idp,
        href: redirectUri
      };
    });
    idxResp.remediations = widgetRemedations.concat(redirectIdpRemedations);
  }
  return idxResp;
};
var convertRedirectIdPToSuccessRedirectIffOneIdp = (settings, result, lastResult) => {
  if (Array.isArray(result.remediations)) {
    const redirectIdpRemediations = result.remediations.filter((idp) => idp.name === FORMS.REDIRECT_IDP);
    if (redirectIdpRemediations.length !== 1 || result.remediations.length !== 1) {
      return;
    }
    const isDirectAuth = settings.get("oauth2Enabled");
    if (isDirectAuth && !lastResult) {
      return;
    }
    const successRedirect = {
      name: FORMS.SUCCESS_REDIRECT,
      href: redirectIdpRemediations[0].href,
      value: []
    };
    result.remediations = [successRedirect];
  }
};
var modifyFormNameForIdP = (result) => {
  if (Array.isArray(result.remediations)) {
    result.remediations.forEach((remediation) => {
      var _remediation$relatesT, _remediation$relatesT2;
      if (remediation.name === FORMS.REDIRECT_IDP && (remediation === null || remediation === void 0 ? void 0 : (_remediation$relatesT = remediation.relatesTo) === null || _remediation$relatesT === void 0 ? void 0 : (_remediation$relatesT2 = _remediation$relatesT.value) === null || _remediation$relatesT2 === void 0 ? void 0 : _remediation$relatesT2.key) === AUTHENTICATOR_KEY.IDP) {
        const isVerifyFlow = Object.prototype.hasOwnProperty.call(result, "currentAuthenticatorEnrollment");
        remediation.name = isVerifyFlow ? "challenge-authenticator" : "enroll-authenticator";
      }
      if (remediation.name === FORMS.REDIRECT_IDP && remediation.type === IDP_FORM_TYPE.X509) {
        remediation.name = FORMS.PIV_IDP;
      }
    });
  }
};
var isFailureRedirect = (result) => {
  const context = result.idx.context;
  return context.failure && context.failure.name === "failure-redirect";
};
var handleFailureRedirect = (settings, result) => {
  const context = result.idx.context;
  const isDirectAuth = settings.get("oauth2Enabled");
  const alwaysRedirect = settings.get("redirect") === "always";
  if (isDirectAuth && !alwaysRedirect) {
    return;
  }
  const failureRedirect = {
    name: FORMS.FAILURE_REDIRECT,
    href: context.failure.href,
    value: []
  };
  result.remediations = [failureRedirect];
};
var convert = (settings, idx = {}, lastResult = null) => {
  if (!isObject2(idx.rawIdxState)) {
    return null;
  }
  const firstLevelObjects = getFirstLevelObjects(idx.rawIdxState);
  const remediationValues = getRemediationValues(idx);
  const result = Object.assign({}, firstLevelObjects, remediationValues, {
    idx
  });
  if (isError(result) && isFailureRedirect(result)) {
    handleFailureRedirect(settings, result);
  }
  injectIdPConfigButtonToRemediation(settings, result);
  modifyFormNameForIdP(result);
  if (!isError(result)) {
    convertRedirectIdPToSuccessRedirectIffOneIdp(settings, result, lastResult);
  }
  return result;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-boolean-handler.js
var getCheckboxUiSchema = ({
  label,
  type,
  required
}) => ({
  // For Remember Me checkbox, we need the label only on the right side of it.
  placeholder: label,
  label: false,
  // Separating prop type for Backbone.Model
  // from html input type
  modelType: type,
  // uiSchema type is the html input type desired.
  type: "checkbox",
  required: required || false
});
var getRadioUiSchema = ({
  label,
  required,
  options: options2
}) => ({
  displayName: label,
  type: "radio",
  required,
  options: options2[0].value.value.options,
  sublabel: required ? null : loc3("oie.form.field.optional", "login")
});
var getCheckboxUiSchemaWithDefaultValue = ({
  label,
  type
}) => ({
  placeholder: label,
  label: false,
  modelType: type,
  type: "checkbox",
  // set required true so default value can be passed to optional attributes as well
  required: true,
  value: false
});
var createUiSchemaForBoolean = (ionFormField, remediationForm) => {
  var _ionFormField$options, _ionFormField$options2, _ionFormField$options3, _ionFormField$options4, _ionFormField$options5, _ionFormField$options6;
  if ([FORMS.CONSENT_ENDUSER, FORMS.CONSENT_ADMIN].includes(remediationForm.name)) {
    const scopes = remediationForm.scopes.map(({
      name,
      label,
      desc
    }) => {
      return {
        name,
        displayName: label,
        description: desc
      };
    });
    const type = remediationForm.name;
    return {
      type,
      scopes,
      options: ionFormField.options
    };
  } else if (Array.isArray(ionFormField.options) && ((_ionFormField$options = ionFormField.options[0]) === null || _ionFormField$options === void 0 ? void 0 : (_ionFormField$options2 = _ionFormField$options.value) === null || _ionFormField$options2 === void 0 ? void 0 : (_ionFormField$options3 = _ionFormField$options2.value) === null || _ionFormField$options3 === void 0 ? void 0 : _ionFormField$options3.inputType) === "radio") {
    return getRadioUiSchema(ionFormField);
  } else if (Array.isArray(ionFormField.options) && ((_ionFormField$options4 = ionFormField.options[0]) === null || _ionFormField$options4 === void 0 ? void 0 : (_ionFormField$options5 = _ionFormField$options4.value) === null || _ionFormField$options5 === void 0 ? void 0 : (_ionFormField$options6 = _ionFormField$options5.value) === null || _ionFormField$options6 === void 0 ? void 0 : _ionFormField$options6.inputType) === "checkbox") {
    return getCheckboxUiSchemaWithDefaultValue(ionFormField);
  } else {
    return getCheckboxUiSchema(ionFormField);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/TimeZone.js
var TimeZone = {
  GMT: "UTC",
  WET: "WET",
  CET: "CET",
  MET: "CET",
  ECT: "CET",
  EET: "EET",
  MIT: "Pacific/Apia",
  HST: "Pacific/Honolulu",
  AST: "America/Anchorage",
  PST: "America/Los_Angeles",
  MST: "America/Denver",
  PNT: "America/Phoenix",
  CST: "America/Chicago",
  EST: "America/New_York",
  IET: "America/Indiana/Indianapolis",
  PRT: "America/Puerto_Rico",
  CNT: "America/St_Johns",
  AGT: "America/Argentina/Buenos_Aires",
  BET: "America/Sao_Paulo",
  ART: "Africa/Cairo",
  CAT: "Africa/Harare",
  EAT: "Africa/Addis_Ababa",
  NET: "Asia/Yerevan",
  PLT: "Asia/Karachi",
  IST: "Asia/Kolkata",
  BST: "Asia/Dhaka",
  VST: "Asia/Ho_Chi_Minh",
  CTT: "Asia/Shanghai",
  JST: "Asia/Tokyo",
  ACT: "Australia/Darwin",
  AET: "Australia/Sydney",
  SST: "Pacific/Guadalcanal",
  NST: "Pacific/Auckland"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-string-handler.js
var ionOptionsToUiOptions = (options2) => {
  const result = {};
  options2.forEach(({
    value,
    label
  }) => {
    result[value] = label;
  });
  return result;
};
var getPasswordUiSchema = (settings) => ({
  type: "password",
  params: {
    showPasswordToggle: settings.get("showPasswordToggle")
  }
});
var getCaptchaUiSchema = () => {
  return {
    type: "captcha"
  };
};
var timezoneUISchema = {
  type: "select",
  wide: true
};
var shouldRenderAsRadio = (name) => name.indexOf("methodType") >= 0 || name.indexOf("channel") >= 0;
var optionalType = ["text", "radio", "select"];
var populateUISchemaForDisplay = (uiSchema, ionField) => {
  var _ionField$value;
  const display = ionField === null || ionField === void 0 ? void 0 : (_ionField$value = ionField.value) === null || _ionField$value === void 0 ? void 0 : _ionField$value.value;
  uiSchema.type = display.inputType;
  if (display.inputType === "radio") {
    uiSchema.options = display.options;
  } else if (display.inputType === "select") {
    uiSchema.wide = true;
    if (display.format === ATTR_FORMAT.COUNTRY_CODE) {
      uiSchema.options = Object.assign({
        "": ""
      }, fn4.getCountryCode());
    } else {
      uiSchema.options = Object.assign({
        "": ""
      }, ionOptionsToUiOptions(display.options));
    }
  }
};
var populateUISchemaForRadio = (uiSchema, ionFormField) => {
  uiSchema.type = "radio";
  ionFormField.value = ionFormField.options[0].value;
};
var createUiSchemaForString = (ionFormField, remediationForm, transformedResp, createUISchema2, settings) => {
  const uiSchema = {
    type: "text"
  };
  if (ionFormField.secret === true) {
    Object.assign(uiSchema, getPasswordUiSchema(settings));
  }
  if (ionFormField.hint === HINTS.CAPTCHA) {
    Object.assign(uiSchema, getCaptchaUiSchema());
  }
  if (ionFormField.name === "userProfile.timezone") {
    Object.assign(uiSchema, timezoneUISchema);
    uiSchema.options = Object.assign({
      "": ""
    }, TimeZone);
  }
  if (Array.isArray(ionFormField.options) && ionFormField.options[0] && ionFormField.options[0].value) {
    const ionField = ionFormField.options[0];
    if (ionField.label === "display") {
      populateUISchemaForDisplay(uiSchema, ionField);
    } else if (shouldRenderAsRadio(ionFormField.name)) {
      populateUISchemaForRadio(uiSchema, ionFormField);
    } else {
      uiSchema.type = "select";
      uiSchema.wide = true;
      uiSchema.options = ionOptionsToUiOptions(ionFormField.options);
    }
  }
  if (ionFormField.required === false && optionalType.includes(uiSchema.type)) {
    uiSchema.sublabel = loc3("oie.form.field.optional", "login");
  }
  return uiSchema;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/uiSchemaTransformer.js
var UISchemaHandlers = {
  string: createUiSchemaForString,
  boolean: createUiSchemaForBoolean,
  object: createUiSchemaForObject
};
var createUISchema = (transformedResp, remediationForm, settings) => {
  const remediationValue = oktaUnderscore.chain(remediationForm.value || []).filter((v) => v.visible !== false).map((v) => {
    var _v$value;
    let nestedForm;
    if (v.form) {
      nestedForm = v.form;
    } else if ((_v$value = v.value) !== null && _v$value !== void 0 && _v$value.form) {
      nestedForm = v.value.form;
    }
    if (nestedForm) {
      const inputGroupName = v.name;
      return nestedForm.value.map((input) => {
        return Object.assign({}, input, {
          name: inputGroupName + "." + input.name
        });
      });
    } else {
      return v;
    }
  }).flatten().value();
  return remediationValue.map((ionFormField) => {
    const uiSchemaDefaultConfig = {
      "label-top": true,
      "multirowError": true,
      "data-se": `o-form-fieldset-${ionFormField.name}`
    };
    const fieldType = ionFormField.type || "string";
    const uiSchemaHandler = UISchemaHandlers[fieldType];
    const uiSchemaResult = uiSchemaHandler(ionFormField, remediationForm, transformedResp, createUISchema, settings);
    return Object.assign({}, ionFormField, uiSchemaDefaultConfig, uiSchemaResult);
  });
};
var insertUISchema = (settings, transformedResp) => {
  if (transformedResp) {
    transformedResp.remediations = transformedResp.remediations.map((obj) => {
      obj.uiSchema = createUISchema(transformedResp, obj, settings);
      return obj;
    });
  }
  return transformedResp;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/AuthenticatorUtil.js
var {
  getPasswordComplexityDescriptionForHtmlList
} = fn2;
var getButtonDataSeAttr = function(authenticator) {
  if (authenticator.authenticatorKey) {
    var _authenticator$value, _authenticator$value2;
    const method = (_authenticator$value = authenticator.value) !== null && _authenticator$value !== void 0 && _authenticator$value.methodType ? "-" + ((_authenticator$value2 = authenticator.value) === null || _authenticator$value2 === void 0 ? void 0 : _authenticator$value2.methodType) : "";
    return authenticator.authenticatorKey + method;
  }
  return "";
};
var getAuthenticatorData = function(authenticator, isVerifyAuthenticator) {
  var _authenticator$relate, _authenticator$relate2;
  const authenticatorKey = authenticator.authenticatorKey;
  const key = oktaUnderscore.isString(authenticatorKey) ? authenticatorKey.toLowerCase() : "";
  let authenticatorData = {};
  switch (key) {
    case AUTHENTICATOR_KEY.EMAIL:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.email.authenticator.description", "login"),
        iconClassName: "mfa-okta-email",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.PASSWORD:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.password.authenticator.description", "login"),
        iconClassName: "mfa-okta-password",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.PHONE:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? (_authenticator$relate = authenticator.relatesTo) === null || _authenticator$relate === void 0 ? void 0 : (_authenticator$relate2 = _authenticator$relate.profile) === null || _authenticator$relate2 === void 0 ? void 0 : _authenticator$relate2.phoneNumber : loc3("oie.phone.authenticator.description", "login"),
        iconClassName: "mfa-okta-phone",
        noTranslateClassName: isVerifyAuthenticator ? "no-translate" : "",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.SECURITY_QUESTION:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.security.question.authenticator.description", "login"),
        iconClassName: "mfa-okta-security-question",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.WEBAUTHN:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.webauthn.description", "login"),
        iconClassName: "mfa-webauthn",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.OV:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? loc3("oie.okta_verify.label", "login") : loc3("oie.okta_verify.authenticator.description", "login"),
        iconClassName: "mfa-okta-verify",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.GOOGLE_OTP:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.google_authenticator.authenticator.description", "login"),
        iconClassName: "mfa-google-auth",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.ON_PREM: {
      var _authenticator$relate3;
      const vendorName = ((_authenticator$relate3 = authenticator.relatesTo) === null || _authenticator$relate3 === void 0 ? void 0 : _authenticator$relate3.displayName) || loc3("oie.on_prem.authenticator.default.vendorName", "login");
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.on_prem.authenticator.description", "login", [vendorName]),
        iconClassName: "mfa-onprem",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    }
    case AUTHENTICATOR_KEY.RSA:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.rsa.authenticator.description", "login"),
        iconClassName: "mfa-rsa",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.DUO:
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.duo.authenticator.description", "login"),
        iconClassName: "mfa-duo",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    case AUTHENTICATOR_KEY.IDP: {
      var _authenticator$relate4;
      const idpName = (_authenticator$relate4 = authenticator.relatesTo) === null || _authenticator$relate4 === void 0 ? void 0 : _authenticator$relate4.displayName;
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.idp.authenticator.description", "login", [idpName]),
        iconClassName: "mfa-custom-factor",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    }
    case AUTHENTICATOR_KEY.CUSTOM_OTP: {
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.custom_otp.description", "login"),
        iconClassName: "mfa-hotp",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    }
    case AUTHENTICATOR_KEY.SYMANTEC_VIP: {
      var _authenticator$relate5;
      const appName = (_authenticator$relate5 = authenticator.relatesTo) === null || _authenticator$relate5 === void 0 ? void 0 : _authenticator$relate5.displayName;
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.symantecVip.authenticator.description", "login", [appName]),
        iconClassName: "mfa-symantec",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    }
    case AUTHENTICATOR_KEY.YUBIKEY: {
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? "" : loc3("oie.yubikey.authenticator.description", "login"),
        iconClassName: "mfa-yubikey",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator)
      });
      break;
    }
    case AUTHENTICATOR_KEY.CUSTOM_APP: {
      var _authenticator$relate6, _authenticator$relate7;
      Object.assign(authenticatorData, {
        description: isVerifyAuthenticator ? authenticator === null || authenticator === void 0 ? void 0 : (_authenticator$relate6 = authenticator.relatesTo) === null || _authenticator$relate6 === void 0 ? void 0 : _authenticator$relate6.displayName : loc3("oie.custom.app.authenticator.description", "login", [authenticator.label]),
        noTranslateClassName: isVerifyAuthenticator ? "no-translate" : "",
        buttonDataSeAttr: getButtonDataSeAttr(authenticator),
        iconClassName: "mfa-custom-app-logo",
        logoUri: (authenticator === null || authenticator === void 0 ? void 0 : (_authenticator$relate7 = authenticator.relatesTo) === null || _authenticator$relate7 === void 0 ? void 0 : _authenticator$relate7.logoUri) || ""
      });
      break;
    }
  }
  return authenticatorData;
};
function getAuthenticatorDataForEnroll(authenticator) {
  return getAuthenticatorData(authenticator);
}
function getAuthenticatorDataForVerification(authenticator) {
  return getAuthenticatorData(authenticator, true);
}
function getIconClassNameForBeacon(authenticatorKey) {
  return getAuthenticatorData({
    authenticatorKey
  }).iconClassName;
}
function removeRequirementsFromError(errorJSON) {
  var _errorJSON$errorCause;
  if (((_errorJSON$errorCause = errorJSON.errorCauses) === null || _errorJSON$errorCause === void 0 ? void 0 : _errorJSON$errorCause.length) > 0 && Array.isArray(errorJSON.errorCauses[0].errorSummary) && errorJSON.errorCauses[0].errorSummary.length > 0) {
    var _errorJSON$errorCause2;
    errorJSON.errorCauses[0].errorSummary = errorJSON.errorCauses[0].errorSummary[0];
    const errorKey = ((_errorJSON$errorCause2 = errorJSON.errorCauses[0].errorKey) === null || _errorJSON$errorCause2 === void 0 ? void 0 : _errorJSON$errorCause2.length) > 0 && errorJSON.errorCauses[0].errorKey[0];
    if (errorKey === "password.passwordRequirementsNotMet") {
      errorJSON.errorCauses[0].errorSummary = loc3("registration.error.password.passwordRequirementsNotMet", "login");
    }
  }
  return errorJSON;
}
function getAuthenticatorDisplayName(remediation) {
  var _remediation$relatesT, _remediation$relatesT2;
  return (_remediation$relatesT = remediation.relatesTo) === null || _remediation$relatesT === void 0 ? void 0 : (_remediation$relatesT2 = _remediation$relatesT.value) === null || _remediation$relatesT2 === void 0 ? void 0 : _remediation$relatesT2.displayName;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/enroll-profile/i18nBaseAttributeMappings.js
var I18N_BASE_ATTRIBUTE_ENROLL_PROFILE_MAPPINGS = {
  /**
   * Mapping fields in the enroll profile remediation form to their i18n label for localization.
   */
  "enroll-profile.userProfile.lastName": "oie.user.profile.lastname",
  "enroll-profile.userProfile.firstName": "oie.user.profile.firstname",
  "enroll-profile.userProfile.email": "oie.user.profile.primary.email",
  "enroll-profile.userProfile.secondEmail": "oie.user.profile.secondary.email",
  "enroll-profile.userProfile.middleName": "oie.user.profile.middleName",
  "enroll-profile.userProfile.honorificPrefix": "oie.user.profile.honorificPrefix",
  "enroll-profile.userProfile.honorificSuffix": "oie.user.profile.honorificSuffix",
  "enroll-profile.userProfile.title": "oie.user.profile.title",
  "enroll-profile.userProfile.displayName": "oie.user.profile.displayName",
  "enroll-profile.userProfile.nickName": "oie.user.profile.nickName",
  "enroll-profile.userProfile.profileUrl": "oie.user.profile.profileUrl",
  "enroll-profile.userProfile.mobilePhone": "oie.user.profile.mobilePhone",
  "enroll-profile.userProfile.primaryPhone": "oie.user.profile.primaryPhone",
  "enroll-profile.userProfile.streetAddress": "oie.user.profile.streetAddress",
  "enroll-profile.userProfile.city": "oie.user.profile.city",
  "enroll-profile.userProfile.state": "oie.user.profile.state",
  "enroll-profile.userProfile.zipCode": "oie.user.profile.zipCode",
  "enroll-profile.userProfile.postalCode": "oie.user.profile.postalCode",
  "enroll-profile.userProfile.countryCode": "oie.user.profile.countryCode",
  "enroll-profile.userProfile.postalAddress": "oie.user.profile.postalAddress",
  "enroll-profile.userProfile.preferredLanguage": "oie.user.profile.preferredLanguage",
  "enroll-profile.userProfile.locale": "oie.user.profile.locale",
  "enroll-profile.userProfile.timezone": "oie.user.profile.timezone",
  "enroll-profile.userProfile.userType": "oie.user.profile.userType",
  "enroll-profile.userProfile.employeeNumber": "oie.user.profile.employeeNumber",
  "enroll-profile.userProfile.costCenter": "oie.user.profile.costCenter",
  "enroll-profile.userProfile.organization": "oie.user.profile.organization",
  "enroll-profile.userProfile.division": "oie.user.profile.division",
  "enroll-profile.userProfile.department": "oie.user.profile.department",
  "enroll-profile.userProfile.managerId": "oie.user.profile.managerId",
  "enroll-profile.userProfile.manager": "oie.user.profile.manager",
  "enroll-profile.credentials.passcode": "oie.password.label"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/i18nTransformer.js
var WEBAUTHN_API_GENERIC_ERROR_KEY = "authfactor.webauthn.error";
var SECURITY_QUESTION_PREFIXES = ["enroll-authenticator.security_question.credentials.questionKey.", "challenge-authenticator.security_question.credentials.questionKey."];
var I18N_OVERRIDE_MAPPINGS = __spreadValues({
  "identify.identifier": "primaryauth.username.placeholder",
  "select-authenticator-unlock-account.identifier": "primaryauth.username.placeholder",
  "identify.credentials.passcode": "primaryauth.password.placeholder",
  "identify.rememberMe": "oie.remember",
  "enroll-profile.userProfile.rememberMe": "oie.remember",
  "identify-recovery.identifier": "password.forgot.email.or.username.placeholder",
  "select-authenticator-enroll.authenticator.duo": "factor.duo",
  "select-authenticator-enroll.authenticator.google_otp": "oie.google_authenticator.label",
  "select-authenticator-enroll.authenticator.okta_email": "oie.email.label",
  "select-authenticator-enroll.authenticator.okta_password": "oie.password.label",
  "select-authenticator-enroll.authenticator.okta_verify": "oie.okta_verify.label",
  "select-authenticator-enroll.authenticator.phone_number": "oie.phone.label",
  "select-authenticator-enroll.authenticator.rsa_token": "factor.totpHard.rsaSecurId",
  "select-authenticator-enroll.authenticator.security_question": "oie.security.question.label",
  "select-authenticator-enroll.authenticator.symantec_vip": "factor.totpHard.symantecVip",
  "select-authenticator-enroll.authenticator.webauthn": "oie.webauthn.label",
  "select-authenticator-enroll.authenticator.yubikey_token": "oie.yubikey.label",
  "select-authenticator-authenticate.authenticator.duo": "factor.duo",
  "select-authenticator-authenticate.authenticator.google_otp": "oie.google_authenticator.label",
  "select-authenticator-authenticate.authenticator.okta_email": "oie.email.label",
  "select-authenticator-authenticate.authenticator.okta_password": "oie.password.label",
  "select-authenticator-authenticate.authenticator.okta_verify.push": "oie.okta_verify.push.title",
  "select-authenticator-authenticate.authenticator.okta_verify.signed_nonce": "oie.okta_verify.signed_nonce.label",
  "select-authenticator-authenticate.authenticator.okta_verify.totp": "oie.okta_verify.totp.title",
  "select-authenticator-authenticate.authenticator.phone_number": "oie.phone.label",
  "select-authenticator-authenticate.authenticator.rsa_token": "factor.totpHard.rsaSecurId",
  "select-authenticator-authenticate.authenticator.security_question": "oie.security.question.label",
  "select-authenticator-authenticate.authenticator.symantec_vip": "factor.totpHard.symantecVip",
  "select-authenticator-authenticate.authenticator.webauthn": "oie.webauthn.label",
  "select-authenticator-authenticate.authenticator.yubikey_token": "oie.yubikey.label",
  "select-authenticator-authenticate.authenticator.custom_app": "oie.custom.app.authenticator.title",
  "select-authenticator-unlock-account.authenticator.okta_email": "oie.email.label",
  "select-authenticator-unlock-account.authenticator.phone_number": "oie.phone.label",
  "select-authenticator-unlock-account.authenticator.okta_verify.push": "oie.okta_verify.push.title",
  "authenticator-verification-data.okta_verify.authenticator.methodType.signed_nonce": "oie.okta_verify.signed_nonce.label",
  "authenticator-verification-data.okta_verify.authenticator.methodType.push": "oie.okta_verify.push.title",
  "authenticator-verification-data.okta_verify.authenticator.methodType.totp": "oie.okta_verify.totp.title",
  "authenticator-enrollment-data.phone_number.authenticator.phoneNumber": "mfa.phoneNumber.placeholder",
  "authenticator-enrollment-data.phone_number.authenticator.methodType.sms": "oie.phone.enroll.sms.label",
  "authenticator-enrollment-data.phone_number.authenticator.methodType.voice": "oie.phone.enroll.voice.label",
  "enroll-authenticator.okta_password.credentials.passcode": "oie.password.passwordLabel",
  "enroll-authenticator.okta_email.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "enroll-authenticator.phone_number.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "enroll-authenticator.security_question.sub_schema_local_credentials.0": "oie.security.question.questionKey.label",
  "enroll-authenticator.security_question.sub_schema_local_credentials.1": "oie.security.question.createQuestion.label",
  "enroll-authenticator.security_question.credentials.answer": "mfa.challenge.answer.placeholder",
  "enroll-authenticator.security_question.credentials.question": "oie.security.question.createQuestion.label",
  "enroll-authenticator.security_question.credentials.questionKey": "oie.security.question.questionKey.label",
  "enroll-authenticator.google_otp.credentials.passcode": "oie.google_authenticator.otp.enterCodeText",
  "enroll-authenticator.onprem_mfa.credentials.clientData": "enroll.onprem.username.placeholder",
  "enroll-authenticator.onprem_mfa.credentials.passcode": "enroll.onprem.passcode.placeholder",
  "enroll-authenticator.rsa_token.credentials.clientData": "enroll.onprem.username.placeholder",
  "enroll-authenticator.rsa_token.credentials.passcode": "enroll.onprem.passcode.placeholder",
  "enroll-authenticator.symantec_vip.credentials.credentialId": "enroll.symantecVip.credentialId.placeholder",
  "enroll-authenticator.symantec_vip.credentials.passcode": "enroll.symantecVip.passcode1.placeholder",
  "enroll-authenticator.symantec_vip.credentials.nextPasscode": "enroll.symantecVip.passcode2.placeholder",
  "enroll-authenticator.yubikey_token.credentials.passcode": "oie.yubikey.passcode.label",
  "enrollment-channel-data.email": "oie.enroll.okta_verify.channel.email.label",
  "select-enrollment-channel.authenticator.channel.qrcode": "oie.enroll.okta_verify.select.channel.qrcode.label",
  "select-enrollment-channel.authenticator.channel.email": "oie.enroll.okta_verify.select.channel.email.label",
  "select-enrollment-channel.authenticator.channel.sms": "oie.enroll.okta_verify.select.channel.sms.label",
  "challenge-authenticator.okta_email.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "challenge-authenticator.okta_password.credentials.passcode": "mfa.challenge.password.placeholder",
  "challenge-authenticator.phone_number.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "challenge-authenticator.security_question.credentials.answer": "mfa.challenge.answer.placeholder",
  "challenge-authenticator.okta_verify.credentials.totp": "oie.okta_verify.totp.enterCodeText",
  "challenge-authenticator.google_otp.credentials.passcode": "oie.google_authenticator.otp.enterCodeText",
  "challenge-authenticator.onprem_mfa.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "challenge-authenticator.rsa_token.credentials.passcode": "mfa.challenge.enterCode.placeholder",
  "challenge-authenticator.custom_otp.credentials.passcode": "oie.custom_otp.verify.passcode.label",
  "challenge-authenticator.symantec_vip.credentials.passcode": "oie.symantecVip.verify.passcode.label",
  "challenge-authenticator.yubikey_token.credentials.passcode": "oie.yubikey.passcode.label",
  "challenge-authenticator.credentials.passcode": "oie.password.label",
  "reset-authenticator.okta_password.credentials.passcode": "oie.password.newPasswordLabel",
  "reenroll-authenticator.okta_password.credentials.passcode": "oie.password.newPasswordLabel",
  "reenroll-authenticator-warning.okta_password.credentials.passcode": "oie.password.newPasswordLabel",
  "incorrectPassword": "oie.password.incorrect.message",
  "profile-update.userProfile.secondEmail": "oie.user.profile.secondary.email",
  "user-code.userCode": "device.code.activate.label",
  // Remap authn API errors to OIE
  "api.authn.poll.error.push_rejected": "oktaverify.rejected",
  // Remap duo API errors to OIE
  "oie.authenticator.duo.method.duo.verification_timeout": "oie.authenticator.duo.error",
  "oie.authenticator.duo.method.duo.verification_failed": "oie.authenticator.duo.error",
  "idx.email.verification.required": "registration.complete.confirm.text",
  "tooManyRequests": "oie.tooManyRequests",
  "api.users.auth.error.POST_PASSWORD_UPDATE_AUTH_FAILURE": "oie.post.password.update.auth.failure.error",
  "security.access_denied": "errors.E0000006",
  "E0000009": "errors.E0000009",
  "api.factors.error.sms.invalid_phone": "oie.phone.invalid",
  "app.ldap.password.reset.failed": "errors.E0000017",
  "oie.selfservice.unlock_user.challenge.failed.permissions": "errors.E0000006",
  "core.auth.factor.signedNonce.error.invalidEnrollment": "core.auth.factor.signedNonce.error",
  "core.auth.factor.signedNonce.error.invalidFactor": "core.auth.factor.signedNonce.error",
  "core.auth.factor.signedNonce.error.deletedDevice": "core.auth.factor.signedNonce.error",
  "core.auth.factor.signedNonce.error.invalidDeviceStatus": "core.auth.factor.signedNonce.error.invalidDevice",
  // re-map autoPush: "Send push automatically"
  "challenge-poll.custom_app.autoChallenge": "autoPush",
  // authenticator-verification-custom-app-push-autochallenge
  "challenge-poll.okta_verify.autoChallenge": "autoPush",
  // authenticator-verification-okta-verify-push-autoChallenge-on
  "authenticator-verification-data.authenticator.autoChallenge": "autoPush",
  // authenticator-verification-data-okta-verify-push-autoChallenge-off.json
  "authenticator-verification-data.okta_verify.authenticator.autoChallenge": "autoPush",
  "authenticator-verification-data.custom_app.authenticator.autoChallenge": "autoPush"
}, I18N_BASE_ATTRIBUTE_ENROLL_PROFILE_MAPPINGS);
var I18N_PARAMS_MAPPING = {
  [FORMS.ENROLL_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.ON_PREM]: {
      getParam: getAuthenticatorDisplayName
    },
    [AUTHENTICATOR_KEY.RSA]: {
      getParam: getAuthenticatorDisplayName
    }
  }
};
var I18N_OVERRIDE_WITH_PARAMS_MAP = {
  "registration.error.invalidLoginEmail": {
    Email: "Email"
  },
  "registration.error.doesNotMatchPattern": {
    Email: "Email"
  },
  "registration.error.notUniqueWithinOrg": {
    Email: "Email"
  }
};
var getI8nKeyUsingParams = (key, param) => {
  let i18nKey = key;
  if (I18N_OVERRIDE_WITH_PARAMS_MAP[i18nKey][param]) {
    i18nKey += `.${param}`;
  } else {
    i18nKey += ".custom";
  }
  return i18nKey;
};
var getI18NParams = (remediation, authenticatorKey) => {
  const params = [];
  const formName = remediation.name;
  if (I18N_PARAMS_MAPPING[formName] && I18N_PARAMS_MAPPING[formName][authenticatorKey]) {
    const config2 = I18N_PARAMS_MAPPING[formName][authenticatorKey];
    const param = config2.getParam(remediation);
    params.push(param);
  }
  return params;
};
var getI18nKey = (i18nPath) => {
  let i18nKey;
  SECURITY_QUESTION_PREFIXES.forEach((prefix) => {
    if (i18nPath.indexOf(prefix) === 0) {
      const securityQuestionValue = i18nPath.replace(prefix, "");
      i18nKey = `security.${securityQuestionValue}`;
    }
  });
  if (I18N_OVERRIDE_MAPPINGS[i18nPath]) {
    i18nKey = I18N_OVERRIDE_MAPPINGS[i18nPath];
  }
  if (i18nKey && !Bundles.login[i18nKey]) {
    i18nKey = null;
  }
  return i18nKey;
};
var doesI18NKeyExist = (i18nKey) => {
  return !!Bundles.login[i18nKey];
};
var getI18NValue = (i18nPath, defaultValue, params = []) => {
  const i18nKey = getI18nKey(i18nPath);
  if (i18nKey) {
    return loc3(i18nKey, "login", params);
  } else {
    return defaultValue;
  }
};
var updateLabelForUiSchema = (remediation, uiSchema) => {
  var _remediation$relatesT, _remediation$relatesT2;
  if (uiSchema.mutable === false && uiSchema.name.indexOf("questionKey") < 0) {
    return;
  }
  const authenticatorKey = (_remediation$relatesT = remediation.relatesTo) === null || _remediation$relatesT === void 0 ? void 0 : (_remediation$relatesT2 = _remediation$relatesT.value) === null || _remediation$relatesT2 === void 0 ? void 0 : _remediation$relatesT2.key;
  const authenticatorKeyPath = authenticatorKey ? `.${remediation.relatesTo.value.key}` : "";
  const i18nPrefix = `${remediation.name}${authenticatorKeyPath}.`;
  let i18nPath = `${i18nPrefix}${uiSchema.name}`;
  if (uiSchema.type === "text" && uiSchema.name.indexOf("questionKey") >= 0 && uiSchema.value !== "custom") {
    i18nPath = `${i18nPath}.${uiSchema.value}`;
  }
  if (uiSchema.type === "checkbox" && uiSchema.placeholder) {
    uiSchema.placeholder = getI18NValue(i18nPath, uiSchema.placeholder);
  }
  if (uiSchema.label) {
    const params = getI18NParams(remediation, authenticatorKey);
    uiSchema.label = getI18NValue(i18nPath, uiSchema.label, params);
  }
  if (oktaJQueryStatic.isPlainObject(uiSchema.options)) {
    uiSchema.options = oktaUnderscore.mapObject(uiSchema.options, (value, key) => {
      const i18nPathOption = `${i18nPath}.${key}`;
      return getI18NValue(i18nPathOption, value);
    });
  }
  if (Array.isArray(uiSchema.options)) {
    uiSchema.options.forEach((o) => {
      if (!o.label) {
        return;
      }
      let i18nPathOption;
      if (o.authenticatorKey) {
        var _o$value;
        i18nPathOption = `${i18nPath}.${o.authenticatorKey}`;
        const methodType = (_o$value = o.value) === null || _o$value === void 0 ? void 0 : _o$value.methodType;
        if (o.authenticatorKey === AUTHENTICATOR_KEY.OV && methodType) {
          i18nPathOption = `${i18nPathOption}.${methodType}`;
        }
      } else if (typeof o.value === "string" || typeof o.value === "number") {
        i18nPathOption = `${i18nPath}.${o.value}`;
      } else {
        i18nPathOption = i18nPath;
      }
      o.label = getI18NValue(i18nPathOption, o.label);
    });
  }
  if (Array.isArray(uiSchema.optionsUiSchemas)) {
    uiSchema.optionsUiSchemas.forEach((optionsUiSchema) => {
      optionsUiSchema.forEach((uiSchema2) => updateLabelForUiSchema(remediation, uiSchema2));
    });
  }
};
var isWebAuthnAPIError = (i18nKey) => i18nKey.startsWith(WEBAUTHN_API_GENERIC_ERROR_KEY);
var getMessage = (message) => {
  var _message$i18n;
  if ((_message$i18n = message.i18n) !== null && _message$i18n !== void 0 && _message$i18n.key) {
    var _message$i18n2;
    let i18nKey = message.i18n.key;
    let i18nParams = message.i18n.params || [];
    if (i18nParams.length === 1 && i18nParams[0] === "") {
      i18nParams = [];
    }
    if (I18N_OVERRIDE_MAPPINGS[(_message$i18n2 = message.i18n) === null || _message$i18n2 === void 0 ? void 0 : _message$i18n2.key]) {
      var _message$i18n3;
      i18nKey = I18N_OVERRIDE_MAPPINGS[(_message$i18n3 = message.i18n) === null || _message$i18n3 === void 0 ? void 0 : _message$i18n3.key];
    } else if (I18N_OVERRIDE_WITH_PARAMS_MAP[i18nKey]) {
      var _message$i18n$params;
      const param = (_message$i18n$params = message.i18n.params) === null || _message$i18n$params === void 0 ? void 0 : _message$i18n$params[0];
      i18nKey = getI8nKeyUsingParams(i18nKey, param);
      i18nParams = i18nKey.endsWith("custom") ? [param] : [];
    }
    if (Bundles.login[i18nKey]) {
      return loc3(i18nKey, "login", i18nParams);
    }
    if (isWebAuthnAPIError(i18nKey)) {
      return loc3(WEBAUTHN_API_GENERIC_ERROR_KEY, "login");
    }
  }
  return message.message;
};
var getMessageFromBrowserError = (error) => {
  if (error.name) {
    const key = `oie.browser.error.${error.name}`;
    if (Bundles.login[key]) {
      return loc3(key, "login");
    }
  }
  return error.message;
};
var getMessageKey = (message) => {
  var _message$i18n4;
  return (message === null || message === void 0 ? void 0 : (_message$i18n4 = message.i18n) === null || _message$i18n4 === void 0 ? void 0 : _message$i18n4.key) || "";
};
var uiSchemaLabelTransformer = (transformedResp) => {
  var _transformedResp$mess;
  if (Array.isArray(transformedResp.remediations)) {
    transformedResp.remediations.filter((remediation) => Array.isArray(remediation.uiSchema) && remediation.uiSchema.length).forEach((remediation) => {
      remediation.uiSchema.forEach((uiSchema) => updateLabelForUiSchema(remediation, uiSchema));
    });
  }
  if (Array.isArray((_transformedResp$mess = transformedResp.messages) === null || _transformedResp$mess === void 0 ? void 0 : _transformedResp$mess.value)) {
    transformedResp.messages.value.forEach((message) => {
      message.message = getMessage(message);
    });
  }
  return transformedResp;
};
var isCustomizedI18nKey = (i18nKey, settings) => {
  const language = settings.get("languageCode");
  const i18n2 = settings.get("i18n");
  const customizedProperty = i18n2 && i18n2[language] && i18n2[language][i18nKey];
  return !!customizedProperty;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/transformIdxResponse.js
function transformIdxResponse(settings, curResponse, lastResponse) {
  const ionResponse = oktaUnderscore.compose(uiSchemaLabelTransformer, insertUISchema.bind({}, settings), convert.bind({}, settings))(curResponse, lastResponse);
  return ionResponse;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/updateAppState.js
function hasAuthenticationSucceeded(idxResponse) {
  var _idxResponse$rawIdxSt, _idxResponse$rawIdxSt2;
  return (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt === void 0 ? void 0 : _idxResponse$rawIdxSt.success) || (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt2 = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt2 === void 0 ? void 0 : _idxResponse$rawIdxSt2.successWithInteractionCode);
}
function updateIdentifierCookie(appState, idxResponse) {
  const settings = appState.settings;
  if (settings.get("features.rememberMe")) {
    var _idxResponse$context;
    const user = idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.user;
    const {
      identifier
    } = (user === null || user === void 0 ? void 0 : user.value) || {};
    if (identifier) {
      fn8.setUsernameCookie(identifier);
    }
  } else {
    fn8.removeUsernameCookie();
  }
}
function updateAppState(appState, idxResponse) {
  return __async(this, null, function* () {
    const settings = appState.settings;
    if (hasAuthenticationSucceeded(idxResponse) && settings.get("features.rememberMyUsernameOnOIE")) {
      updateIdentifierCookie(appState, idxResponse);
    }
    const lastResponse = appState.get("idx");
    const useInteractionCodeFlow = settings.get("useInteractionCodeFlow");
    if (useInteractionCodeFlow) {
      if (idxResponse.interactionCode) {
        sessionStorageHelper.removeStateHandle();
        const tokens = yield interactionCodeFlow(settings, idxResponse);
        if (appState.get("currentFormName") === FORMS.TERMINAL) {
          appState.unset("currentFormName", {
            silent: true
          });
        }
        return tokens;
      }
    } else {
      if (lastResponse) {
        var _idxResponse$context2;
        sessionStorageHelper.setStateHandle(idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context2 = idxResponse.context) === null || _idxResponse$context2 === void 0 ? void 0 : _idxResponse$context2.stateHandle);
      }
      if (appState.get("currentFormName") === FORMS.CANCEL_TRANSACTION) {
        sessionStorageHelper.removeStateHandle();
      }
    }
    const ionResponse = transformIdxResponse(settings, idxResponse, lastResponse);
    yield appState.setIonResponse(ionResponse);
  });
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/client/formatError.js
function isInvalidRecoveryTokenError(error) {
  return (error === null || error === void 0 ? void 0 : error.error) === "invalid_request" && error.error_description === "The recovery token is invalid";
}
function formatInvalidRecoveryTokenError(error) {
  const idxError = formatIDXError(error);
  const {
    details
  } = idxError;
  const messages = {
    type: "array",
    value: [{
      message: error.error_description,
      i18n: {
        key: "oie.invalid.recovery.token"
      },
      class: "ERROR"
    }]
  };
  details.rawIdxState.messages = messages;
  details.context.messages = messages;
  return idxError;
}
function isOIENotEnabledError(error) {
  return (error === null || error === void 0 ? void 0 : error.error) === "access_denied" && error.error_description;
}
function formatOIENotEnabledError(error) {
  const idxError = formatIDXError(error);
  const {
    details
  } = idxError;
  const messages = {
    type: "array",
    value: [{
      message: error.error_description,
      i18n: {
        key: "oie.feature.disabled"
      },
      class: "ERROR"
    }]
  };
  details.rawIdxState.messages = messages;
  details.context.messages = messages;
  return error;
}
function isOIEConfigurationError(error) {
  return (error === null || error === void 0 ? void 0 : error.error) && error.error_description;
}
function formatOIEConfigurationError(error) {
  const idxError = formatIDXError(error);
  const {
    details
  } = idxError;
  const messages = {
    type: "array",
    value: [{
      message: loc3("oie.configuration.error", "login"),
      class: "ERROR",
      i18n: void 0
    }]
  };
  details.rawIdxState.messages = messages;
  details.context.messages = messages;
  return error;
}
function formatIDXError(error) {
  const idxError = error;
  idxError.details = idxError.details || {};
  const {
    details
  } = idxError;
  details.rawIdxState = details.rawIdxState || {};
  details.context = details.context || {};
  details.neededToProceed = details.neededToProceed || [];
  if (!details.rawIdxState.messages) {
    const idxMessage = {
      type: "array",
      value: [{
        message: loc3("oform.error.unexpected", "login"),
        class: "ERROR",
        i18n: void 0
      }]
    };
    details.rawIdxState.messages = idxMessage;
    details.context.messages = idxMessage;
  }
  return idxError;
}
function formatError(error) {
  if (typeof error === "string") {
    error = new Error(error);
  }
  if (isInvalidRecoveryTokenError(error)) {
    return formatInvalidRecoveryTokenError(error);
  }
  if (isOIENotEnabledError(error)) {
    return formatOIENotEnabledError(error);
  }
  if (isOIEConfigurationError(error)) {
    return formatOIEConfigurationError(error);
  }
  error = formatIDXError(error);
  return error;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/IonResponseHelper.js
var convertErrorMessageToErrorSummary = (formName, remediationValues = []) => {
  return oktaUnderscore.chain(remediationValues).filter((field) => {
    var _field$messages;
    return Array.isArray((_field$messages = field.messages) === null || _field$messages === void 0 ? void 0 : _field$messages.value) && field.messages.value.length;
  }).map((field) => {
    return {
      property: formName ? `${formName}.${field.name}` : field.name,
      errorSummary: field.messages.value.map(getMessage),
      errorKey: field.messages.value.map(getMessageKey)
    };
  }).value();
};
var uniqWith = (array, comparator) => {
  if (!Array.isArray(array)) {
    return [];
  }
  if (!oktaUnderscore.isFunction(comparator) || array.length === 1) {
    return array;
  }
  const result = [];
  for (let i = 0; i < array.length; i++) {
    let seen = false;
    for (let j = i + 1; j < array.length; j++) {
      if (comparator(array[i], array[j])) {
        seen = true;
        break;
      }
    }
    if (!seen) {
      result.push(array[i]);
    }
  }
  return result;
};
var getRemediationErrors = (res) => {
  let errors = [];
  if (!res.remediation || !Array.isArray(res.remediation.value) || res.remediation.value.length === 0) {
    return errors;
  }
  let remediationFormFields = res.remediation.value[0].value;
  if (!Array.isArray(remediationFormFields)) {
    return errors;
  }
  errors.push(convertErrorMessageToErrorSummary(null, remediationFormFields));
  oktaUnderscore.each(remediationFormFields, (remediationForm) => {
    var _remediationForm$form;
    const formName = remediationForm.name;
    if (Array.isArray((_remediationForm$form = remediationForm.form) === null || _remediationForm$form === void 0 ? void 0 : _remediationForm$form.value)) {
      errors.push(convertErrorMessageToErrorSummary(formName, remediationForm.form.value));
    }
    if (Array.isArray(remediationForm.options)) {
      oktaUnderscore.each(remediationForm.options, (option2) => {
        var _option$value, _option$value$form;
        if (Array.isArray((_option$value = option2.value) === null || _option$value === void 0 ? void 0 : (_option$value$form = _option$value.form) === null || _option$value$form === void 0 ? void 0 : _option$value$form.value)) {
          errors.push(convertErrorMessageToErrorSummary(formName, option2.value.form.value));
        }
      });
    }
  });
  return uniqWith(oktaUnderscore.flatten(errors), oktaUnderscore.isEqual);
};
var getGlobalErrors = (res) => {
  var _res$messages;
  let allErrors = [];
  if (Array.isArray((_res$messages = res.messages) === null || _res$messages === void 0 ? void 0 : _res$messages.value)) {
    allErrors = res.messages.value.map(getMessage);
  }
  return allErrors.join(". ");
};
var getGlobalErrorKeys = (res) => {
  var _res$messages2;
  let allKeys = [];
  if (Array.isArray((_res$messages2 = res.messages) === null || _res$messages2 === void 0 ? void 0 : _res$messages2.value)) {
    allKeys = res.messages.value.map(getMessageKey);
  }
  return allKeys;
};
var convertFormErrors = (response) => {
  let errors = {
    errorCauses: getRemediationErrors(response),
    errorSummary: getGlobalErrors(response),
    errorSummaryKeys: getGlobalErrorKeys(response),
    errorIntent: response.intent
  };
  return {
    responseJSON: errors
  };
};
var isIonErrorResponse = (response = {}) => {
  return response.version;
};
var isIdxSessionExpiredError = (response) => {
  var _response$context, _response$context$mes, _response$context$mes2, _response$context$mes3;
  const errorI18NKey = response === null || response === void 0 ? void 0 : (_response$context = response.context) === null || _response$context === void 0 ? void 0 : (_response$context$mes = _response$context.messages) === null || _response$context$mes === void 0 ? void 0 : (_response$context$mes2 = _response$context$mes.value[0]) === null || _response$context$mes2 === void 0 ? void 0 : (_response$context$mes3 = _response$context$mes2.i18n) === null || _response$context$mes3 === void 0 ? void 0 : _response$context$mes3.key;
  return errorI18NKey && errorI18NKey === "idx.session.expired";
};
var IonResponseHelper = {
  convertFormErrors,
  isIonErrorResponse,
  isIdxSessionExpiredError
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/BaseLoginRouter.js
var BaseLoginRouter2 = class extends Router {
  // also set on prototype
  constructor(options2) {
    super(options2);
    this.Events = Backbone.Events;
    this.hasControllerRendered = false;
    this.settings = void 0;
    this.appState = void 0;
    this.hooks = void 0;
    this.header = void 0;
    if (!options2.globalSuccessFn) {
      options2.globalSuccessFn = function() {
      };
    }
    if (!options2.globalErrorFn) {
      options2.globalErrorFn = function(err) {
        Logger.error(err);
      };
    }
    this.settings = new Settings(oktaUnderscore.omit(options2, "el", "authClient", "hooks"), {
      parse: true
    });
    this.settings.setAuthClient(options2.authClient);
    if (!options2.el) {
      this.settings.callGlobalError(new ConfigError(loc3("error.required.el")));
    }
    oktaJQueryStatic("body > div").on("click", function() {
    });
    this.hooks = options2.hooks;
    this.appState = new AppState2({}, {
      settings: this.settings,
      hooks: this.hooks
    });
    const wrapper = new AuthContainer({
      appState: this.appState
    });
    oktaJQueryStatic(options2.el).append(wrapper.render().$el);
    this.el = `#${Enums.WIDGET_CONTAINER_ID}`;
    this.header = new Header({
      el: this.el,
      appState: this.appState,
      settings: this.settings
    });
    this.hide();
    this.listenTo(this.appState, "change:deviceFingerprint", this.updateDeviceFingerprint);
    this.listenTo(this.appState, "restartLoginFlow", this.restartLoginFlow);
  }
  updateDeviceFingerprint() {
    const authClient = this.settings.getAuthClient();
    const fingerprint2 = this.appState.get("deviceFingerprint");
    if (fingerprint2) {
      authClient.http.setRequestHeader("X-Device-Fingerprint", fingerprint2);
    }
  }
  handleIdxResponseFailure() {
    return __async(this, arguments, function* (error = {
      error: "unknown",
      details: void 0
    }) {
      error = formatError(error);
      yield updateAppState(this.appState, error.details);
    });
  }
  // Generic error handler for all exceptions
  handleError() {
    return __async(this, arguments, function* (error = {
      error: "unknown",
      details: void 0
    }) {
      const formattedError = formatError(__spreadValues({}, error));
      yield updateAppState(this.appState, formattedError.details);
    });
  }
  /* eslint max-statements: [2, 36], complexity: [2, 16] */
  render(_0) {
    return __async(this, arguments, function* (Controller2, options2 = {}) {
      if (sessionStorageHelper.getLastInitiatedLoginUrl() !== window.location.href) {
        sessionStorageHelper.removeStateHandle();
      }
      if (!this.header.rendered()) {
        this.el = this.header.render().getContentEl();
      }
      if (!Bundles.isLoaded(this.settings.get("languageCode"))) {
        yield LanguageUtil.loadLanguage(this.appState, this.settings);
      }
      let error;
      if (this.settings.get("oieEnabled")) {
        try {
          let idxResp = yield startLoginFlow(this.settings);
          if (idxResp.error) {
            yield this.handleIdxResponseFailure(idxResp.error);
          } else {
            if (this.settings.get("flow") && !this.hasControllerRendered) {
              idxResp = yield handleConfiguredFlow(idxResp, this.settings);
            }
            if (!idxResp.requestDidSucceed && IonResponseHelper.isIdxSessionExpiredError(idxResp)) {
              const authClient = this.settings.getAuthClient();
              authClient.transactionManager.clear();
            }
            yield updateAppState(this.appState, idxResp);
          }
        } catch (exception2) {
          var _exception$is;
          if ((_exception$is = exception2.is) !== null && _exception$is !== void 0 && _exception$is.call(exception2, "terminal")) {
            this.appState.setNonIdxError(exception2);
          } else {
            error = exception2;
            yield this.handleError(exception2);
          }
        } finally {
          this.settings.unset("stateToken");
          this.settings.unset("proxyIdxResponse");
        }
      }
      if (this.settings.get("colors.brand") && !fn10.isLoaded()) {
        const colors = {
          brand: this.settings.get("colors.brand")
        };
        fn10.addStyle(colors);
      }
      this.show();
      this.unload();
      const controllerOptions = oktaUnderscore.extend({
        el: this.el,
        settings: this.settings,
        appState: this.appState
      }, options2);
      this.controller = new Controller2(controllerOptions);
      this.listenTo(this.controller, "all", this.trigger);
      this.controller.render();
      this.hasControllerRendered = true;
      if (error) {
        this.settings.callGlobalError(error);
      }
    });
  }
  /**
    * When "Remember My Username" is enabled, we save the identifier in a cookie
    * so that the next time the user visits the SIW, the identifier field can be 
    * pre-filled with this value.
   */
  updateIdentifierCookie(idxResponse) {
    if (this.settings.get("features.rememberMe")) {
      var _idxResponse$context;
      const user = idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$context = idxResponse.context) === null || _idxResponse$context === void 0 ? void 0 : _idxResponse$context.user;
      const {
        identifier
      } = (user === null || user === void 0 ? void 0 : user.value) || {};
      if (identifier) {
        fn8.setUsernameCookie(identifier);
      }
    } else {
      fn8.removeUsernameCookie();
    }
  }
  hasAuthenticationSucceeded(idxResponse) {
    var _idxResponse$rawIdxSt, _idxResponse$rawIdxSt2;
    return (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt === void 0 ? void 0 : _idxResponse$rawIdxSt.success) || (idxResponse === null || idxResponse === void 0 ? void 0 : (_idxResponse$rawIdxSt2 = idxResponse.rawIdxState) === null || _idxResponse$rawIdxSt2 === void 0 ? void 0 : _idxResponse$rawIdxSt2.successWithInteractionCode);
  }
  restartLoginFlow() {
    this.settings.getAuthClient().transactionManager.clear();
    this.appState.set("idx", void 0);
    const authClient = this.settings.getAuthClient();
    delete authClient.options["recoveryToken"];
    this.settings.unset("recoveryToken");
    this.settings.unset("otp");
    this.controller.stopListening();
    this.render(this.controller.constructor);
  }
  start() {
    const pushState = fn.supportsPushState();
    Router.prototype.start.call(this, {
      pushState
    });
  }
  hide() {
    this.header.$el.hide();
  }
  show() {
    this.header.$el.show();
  }
  remove() {
    this.unload();
    this.header.$el.remove();
    this.stopListening(this.appState);
    this.stopListening(this.settings);
    Bundles.remove();
    Backbone.history.stop();
  }
};
BaseLoginRouter2.prototype.Events = Backbone.Events;

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseHeader.js
var BaseHeader = View2.extend({
  HeaderBeacon: null,
  initialize: function() {
    if (this.HeaderBeacon) {
      this.add(this.HeaderBeacon);
    }
  },
  postRender: function() {
    const mainContentContainer = oktaJQueryStatic(`#${Enums.WIDGET_CONTAINER_ID}`);
    if (this.HeaderBeacon) {
      mainContentContainer.removeClass("no-beacon");
      const beaconContainer = this.$el.find('[data-type="beacon-container"]');
      fn9.explode(beaconContainer);
    } else {
      mainContentContainer.addClass("no-beacon");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/Link.js
var Link = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 9
          }
        }
      }) : helper));
    },
    "useData": true
  }),
  tagName: "a",
  attributes: function() {
    let href = this.options.href || "#";
    return {
      "data-se": this.options.name,
      href,
      target: this.options.target
    };
  },
  className: function() {
    const names = ["link"];
    if (this.options.name) {
      const nameToClass = this.options.name.replace(/[ ]/g, "-");
      names.push(`js-${nameToClass}`);
    }
    return names.join(" ");
  },
  postRender: function() {
    if (!this.options.href) {
      this.$el.click((event) => {
        event.preventDefault();
        const {
          appState,
          formName,
          actionPath,
          clickHandler
        } = this.options;
        if (clickHandler) {
          clickHandler();
        } else if (formName) {
          appState.trigger("switchForm", formName);
        } else if (actionPath) {
          appState.trigger("invokeAction", actionPath);
        }
      });
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/ToggleTextLink.js
var ToggleTextLink = View2.extend({
  initialize: function() {
    View2.prototype.initialize.apply(this, arguments);
    const textViewOptions = this.options.additionalOptions;
    const linkName = this.options.name;
    const linkOptions = Object.assign({}, this.options, {
      "type": "link",
      "aria-expanded": false,
      "clickHandler": function() {
        oktaJQueryStatic(textViewOptions.selector).slideToggle(200, () => {
          oktaJQueryStatic(`.js-${linkName}`).attr("aria-expanded", oktaJQueryStatic(textViewOptions.selector).is(":visible"));
        });
      }
    });
    this.add(Link, {
      options: linkOptions
    });
    this.add(textViewOptions.view);
  },
  postRender: function() {
    const textViewOptions = this.options.additionalOptions;
    this.$(textViewOptions.selector).hide();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/LinksUtil.js
var {
  ENROLLED_PASSWORD_RECOVERY_LINK: ENROLLED_PASSWORD_RECOVERY_LINK2,
  ORG_PASSWORD_RECOVERY_LINK: ORG_PASSWORD_RECOVERY_LINK2
} = ACTIONS;
var getSwitchAuthenticatorLink = (appState) => {
  if (appState.getRemediationAuthenticationOptions(FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE).length > 1) {
    return [{
      "type": "link",
      "label": loc3("oie.verification.switch.authenticator", "login"),
      "name": "switchAuthenticator",
      "formName": FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE
    }];
  }
  if (appState.getRemediationAuthenticationOptions(FORMS.SELECT_AUTHENTICATOR_ENROLL).length >= 1) {
    return [{
      "type": "link",
      "label": loc3("oie.enroll.switch.authenticator", "login"),
      "name": "switchAuthenticator",
      "formName": FORMS.SELECT_AUTHENTICATOR_ENROLL
    }];
  }
  return [];
};
var getForgotPasswordLink = (appState, settings) => {
  const forgotPasswordLink = {
    "type": "link",
    "label": loc3("forgotpassword", "login"),
    "name": "forgot-password"
  };
  const customForgotPasswordHref = settings.get("helpLinks.forgotPassword");
  if (customForgotPasswordHref) {
    return [Object.assign({}, {
      "href": customForgotPasswordHref,
      "label": loc3("forgotpassword", "login"),
      "name": "forgot-password"
    })];
  } else if (appState.getActionByPath(ORG_PASSWORD_RECOVERY_LINK2)) {
    return [Object.assign({}, forgotPasswordLink, {
      actionPath: ORG_PASSWORD_RECOVERY_LINK2
    })];
  } else if (appState.getActionByPath(ENROLLED_PASSWORD_RECOVERY_LINK2)) {
    return [Object.assign({}, forgotPasswordLink, {
      actionPath: ENROLLED_PASSWORD_RECOVERY_LINK2
    })];
  }
  return [];
};
var getSkipSetupLink = (appState, linkName) => {
  if (appState.hasRemediationObject(FORMS.SKIP)) {
    return [{
      "type": "link",
      "label": linkName !== null && linkName !== void 0 ? linkName : loc3("oie.enroll.skip.setup", "login"),
      "name": "skip-setup",
      "actionPath": FORMS.SKIP
    }];
  }
  return [];
};
var getSignOutLink = (settings, options2 = {}) => {
  if (settings !== null && settings !== void 0 && settings.get("backToSignInUri")) {
    return [{
      "label": loc3("goback", "login"),
      "name": "cancel",
      "href": settings.get("backToSignInUri")
    }];
  }
  return [{
    "actionPath": "cancel",
    "label": !options2.label ? loc3("goback", "login") : options2.label,
    "name": "cancel",
    "type": "link"
  }];
};
var getBackToSignInLink = ({
  settings,
  appState
}) => {
  const link = {};
  if (settings !== null && settings !== void 0 && settings.get("backToSignInUri")) {
    link.href = settings.get("backToSignInUri");
  } else if (settings !== null && settings !== void 0 && settings.get("useInteractionCodeFlow")) {
    link.clickHandler = () => {
      appState.trigger("restartLoginFlow");
    };
  } else {
    link.href = settings === null || settings === void 0 ? void 0 : settings.get("baseUrl");
  }
  return [__spreadValues({
    "type": "link",
    "label": loc3("goback", "login"),
    "name": "go-back"
  }, link)];
};
var getReloadPageButtonLink = () => {
  return [{
    "type": "link",
    "label": loc3("oie.try.again", "login"),
    "name": "try-again",
    "href": window.location,
    "className": "button button-primary text-align-c"
  }];
};
var getSignUpLink = (appState, settings) => {
  const signupLink = [];
  if (appState.hasRemediationObject(FORMS.SELECT_ENROLL_PROFILE)) {
    const signupLinkData = {
      "type": "link",
      "label": loc3("oie.registration.form.title", "login"),
      "name": "enroll"
    };
    if (oktaUnderscore.isFunction(settings.get("registration.click"))) {
      signupLinkData.clickHandler = settings.get("registration.click");
    } else {
      signupLinkData.actionPath = FORMS.SELECT_ENROLL_PROFILE;
    }
    signupLink.push(signupLinkData);
  }
  return signupLink;
};
var getFactorPageCustomLink = (appState, settings) => {
  const factorPageCustomLink = [];
  const formsNeedFactorPageCustomLink = [FORMS.CHALLENGE_AUTHENTICATOR, FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE, FORMS.CHALLENGE_POLL, FORMS.AUTHENTICATOR_VERIFICATION_DATA];
  if (!appState.get("isPasswordRecovery") && formsNeedFactorPageCustomLink.includes(appState.get("currentFormName"))) {
    const helpLinksFactorPageLabel = settings.get("helpLinks.factorPage.text");
    const helpLinksFactorPageHref = settings.get("helpLinks.factorPage.href");
    if (helpLinksFactorPageLabel && helpLinksFactorPageHref) {
      factorPageCustomLink.push({
        type: "link",
        label: helpLinksFactorPageLabel,
        name: "factorPageHelpLink",
        href: helpLinksFactorPageHref,
        target: "_blank"
      });
    }
  }
  return factorPageCustomLink;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseFooter.js
var BaseFooter = View2.extend({
  className: "auth-footer",
  /**
   * {Link[]} links
   */
  links: [],
  /**
   * View
   * adds any view to the footer in footer info section
   */
  footerInfo: null,
  /**
   * Boolean
   * If false then 'Back to sign in' does not get added to the view
   */
  hasBackToSignInLink: true,
  initialize: function() {
    let links = oktaUnderscore.resultCtx(this, "links", this);
    const footerInfo = oktaUnderscore.resultCtx(this, "footerInfo", this);
    const hasBackToSignInLink = oktaUnderscore.resultCtx(this, "hasBackToSignInLink", this);
    if (!Array.isArray(links)) {
      links = [];
    } else {
      links = links.filter((l) => oktaJQueryStatic.isPlainObject(l));
    }
    if (this.options.appState.shouldShowSignOutLinkInCurrentForm(this.options.settings.get("features.hideSignOutLinkInMFA") || this.settings.get("features.mfaOnlyFlow")) && hasBackToSignInLink) {
      links = links.concat(getSignOutLink(this.options.settings));
    }
    links.forEach((link) => {
      let LinkView = Link;
      if (link.type === "toggle-text-link") {
        LinkView = ToggleTextLink;
      }
      this.add(LinkView, {
        options: link
      });
    });
    if (footerInfo) {
      this.add(View2.extend({
        className: "footer-info"
      }));
      this.add(footerInfo, ".footer-info");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/SkipOptionalEnrollmentButton.js
var skipAll = createButton2({
  className: "button-primary button skip-all",
  title: function() {
    return loc3("oie.optional.authenticator.button.title", "login");
  },
  click: function() {
    this.options.appState.trigger("invokeAction", FORMS.SKIP);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/Constants.js
var SHOW_RESEND_TIMEOUT = 3e4;
var WARNING_TIMEOUT2 = 3e4;
var CHALLENGE_TIMEOUT = 3e5;
var MS_PER_SEC = 1e3;
var UNIVERSAL_LINK_POST_DELAY = 500;
var CANCEL_POLLING_ACTION = "authenticatorChallenge-cancel";
var AUTHENTICATOR_CANCEL_ACTION = "currentAuthenticator-cancel";
var WIDGET_FOOTER_CLASS = "siw-main-footer";
var FASTPASS_FALLBACK_SPINNER_TIMEOUT = 4e3;
var IDENTIFIER_FLOW = "IDENTIFIER";
var OV_UV_ENABLE_BIOMETRICS_FASTPASS_DESKTOP = "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.desktop";
var OV_UV_ENABLE_BIOMETRICS_FASTPASS_MOBILE = "oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.mobile";
var AUTHENTICATOR_ALLOWED_FOR_OPTIONS = {
  ANY: "any",
  SSO: "sso",
  RECOVERY: "recovery"
};
var REQUEST_PARAM_AUTHENTICATION_CANCEL_REASON = "reason";
var LOOPBACK_RESPONSE_STATUS_CODE = "statusCode";
var AUTHENTICATION_CANCEL_REASONS = {
  LOOPBACK_FAILURE: "OV_UNREACHABLE_BY_LOOPBACK",
  OV_ERROR: "OV_RETURNED_ERROR",
  USER_CANCELED: "USER_CANCELED"
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/AuthenticatorEnrollOptions.js
var AuthenticatorRow = View2.extend({
  className: "authenticator-row clearfix",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="factor-icon authenticator-icon custom-app-logo" role="img" aria-label="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.auth.logo.aria.label"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 140
          },
          "end": {
            "line": 1,
            "column": 195
          }
        }
      })) + `" style="background-image: url('` + alias3((helper = (helper = lookupProperty(helpers2, "logoUri") || (depth0 != null ? lookupProperty(depth0, "logoUri") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "logoUri",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 227
          },
          "end": {
            "line": 1,
            "column": 238
          }
        }
      }) : helper)) + `')"></div>`;
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="factor-icon authenticator-icon ' + alias3((helper = (helper = lookupProperty(helpers2, "iconClassName") || (depth0 != null ? lookupProperty(depth0, "iconClassName") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "iconClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 299
          },
          "end": {
            "line": 1,
            "column": 316
          }
        }
      }) : helper)) + '" role="img" aria-label="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.auth.logo.aria.label"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 341
          },
          "end": {
            "line": 1,
            "column": 396
          }
        }
      })) + '"></div>';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="authenticator-description--text">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "description") || (depth0 != null ? lookupProperty(depth0, "description") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "description",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 577
          },
          "end": {
            "line": 1,
            "column": 592
          }
        }
      }) : helper)) + "</p>";
    },
    "7": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="authenticator-usage-text">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "authenticatorUsageText") || (depth0 != null ? lookupProperty(depth0, "authenticatorUsageText") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "authenticatorUsageText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 669
          },
          "end": {
            "line": 1,
            "column": 695
          }
        }
      }) : helper)) + "</p>";
    },
    "9": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return 'data-se="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "buttonDataSeAttr") || (depth0 != null ? lookupProperty(depth0, "buttonDataSeAttr") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "buttonDataSeAttr",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 773
          },
          "end": {
            "line": 1,
            "column": 793
          }
        }
      }) : helper)) + '"';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="authenticator-icon-container">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "logoUri") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 42
          },
          "end": {
            "line": 1,
            "column": 411
          }
        }
      })) != null ? stack1 : "") + '</div><div class="authenticator-description"><h3 class="authenticator-label no-translate">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 501
          },
          "end": {
            "line": 1,
            "column": 510
          }
        }
      }) : helper)) + "</h3>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "description") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 515
          },
          "end": {
            "line": 1,
            "column": 603
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "authenticatorUsageText") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 603
          },
          "end": {
            "line": 1,
            "column": 706
          }
        }
      })) != null ? stack1 : "") + '<div class="authenticator-button" ' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "buttonDataSeAttr") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 740
          },
          "end": {
            "line": 1,
            "column": 801
          }
        }
      })) != null ? stack1 : "") + "></div></div>";
    },
    "useData": true
  }),
  children: function() {
    return [[createButton2({
      className: "button select-factor",
      title: function() {
        return loc3("oie.enroll.authenticator.button.text", "login");
      },
      click: function() {
        this.model.trigger("selectAuthenticator", this.model.get("value"));
      }
    }), ".authenticator-button"]];
  },
  minimize: function() {
    this.$el.addClass("authenticator-row-min");
  },
  getTemplateData: function() {
    let authenticatorUsageText;
    const allowedFor = this.model.get("relatesTo").allowedFor;
    if (allowedFor) {
      switch (allowedFor) {
        case AUTHENTICATOR_ALLOWED_FOR_OPTIONS.ANY:
          authenticatorUsageText = loc3("oie.enroll.authenticator.usage.text.access.recovery", "login");
          break;
        case AUTHENTICATOR_ALLOWED_FOR_OPTIONS.RECOVERY:
          authenticatorUsageText = loc3("oie.enroll.authenticator.usage.text.recovery", "login");
          break;
        case AUTHENTICATOR_ALLOWED_FOR_OPTIONS.SSO:
          authenticatorUsageText = loc3("oie.enroll.authenticator.usage.text.access", "login");
          break;
      }
    }
    const data = View2.prototype.getTemplateData.apply(this, arguments);
    data.authenticatorUsageText = authenticatorUsageText;
    return data;
  }
});
var AuthenticatorEnrollOptions = Backbone_ListView.extend({
  className: "authenticator-enroll-list authenticator-list",
  item: AuthenticatorRow,
  itemSelector: ".list-content",
  initialize: function() {
    this.listenTo(this.collection, "selectAuthenticator", function(data) {
      this.model.set(this.options.name, data);
      this.options.appState.trigger("saveForm", this.model);
    });
    this.hasOptionalFactors = this.options.appState.hasRemediationObject(FORMS.SKIP);
    if (this.hasOptionalFactors) {
      this.add(skipAll);
    }
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="list-content"><div class="authenticator-list-title">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "title") || (depth0 != null ? lookupProperty(depth0, "title") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "title",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 64
          },
          "end": {
            "line": 1,
            "column": 73
          }
        }
      }) : helper)) + "</div></div>";
    },
    "useData": true
  }),
  getTemplateData: function() {
    const title = this.hasOptionalFactors ? loc3("oie.setup.optional", "login") : loc3("oie.setup.required", "login");
    return {
      title
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/AuthenticatorVerifyOptions.js
var AuthenticatorRow2 = View2.extend({
  className: "authenticator-row clearfix",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="factor-icon authenticator-icon ' + alias4((helper = (helper = lookupProperty(helpers2, "iconClassName") || (depth0 != null ? lookupProperty(depth0, "iconClassName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "iconClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 100
          },
          "end": {
            "line": 1,
            "column": 117
          }
        }
      }) : helper)) + ' custom-logo" role="img" aria-label="' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.auth.logo.aria.label"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 154
          },
          "end": {
            "line": 1,
            "column": 209
          }
        }
      })) + `" style="background-image: url('` + alias4((helper = (helper = lookupProperty(helpers2, "logoUri") || (depth0 != null ? lookupProperty(depth0, "logoUri") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "logoUri",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 241
          },
          "end": {
            "line": 1,
            "column": 252
          }
        }
      }) : helper)) + `')"></div>`;
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="factor-icon authenticator-icon ' + alias3((helper = (helper = lookupProperty(helpers2, "iconClassName") || (depth0 != null ? lookupProperty(depth0, "iconClassName") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "iconClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 313
          },
          "end": {
            "line": 1,
            "column": 330
          }
        }
      }) : helper)) + '" role="img" aria-label="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.auth.logo.aria.label"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 355
          },
          "end": {
            "line": 1,
            "column": 410
          }
        }
      })) + '"></div>';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      return "authenticator-label--small";
    },
    "7": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="authenticator-description--text ' + alias4((helper = (helper = lookupProperty(helpers2, "noTranslateClassName") || (depth0 != null ? lookupProperty(depth0, "noTranslateClassName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "noTranslateClassName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 648
          },
          "end": {
            "line": 1,
            "column": 672
          }
        }
      }) : helper)) + '">' + alias4((helper = (helper = lookupProperty(helpers2, "description") || (depth0 != null ? lookupProperty(depth0, "description") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "description",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 674
          },
          "end": {
            "line": 1,
            "column": 689
          }
        }
      }) : helper)) + "</p>";
    },
    "9": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return 'data-se="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "buttonDataSeAttr") || (depth0 != null ? lookupProperty(depth0, "buttonDataSeAttr") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "buttonDataSeAttr",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 773
          },
          "end": {
            "line": 1,
            "column": 793
          }
        }
      }) : helper)) + '"';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="authenticator-icon-container">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "logoUri") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 42
          },
          "end": {
            "line": 1,
            "column": 425
          }
        }
      })) != null ? stack1 : "") + '</div><div class="authenticator-description"><div><h3 class="authenticator-label no-translate ' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "description") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 519
          },
          "end": {
            "line": 1,
            "column": 571
          }
        }
      })) != null ? stack1 : "") + '">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 573
          },
          "end": {
            "line": 1,
            "column": 582
          }
        }
      }) : helper)) + "</h3>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "description") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 587
          },
          "end": {
            "line": 1,
            "column": 700
          }
        }
      })) != null ? stack1 : "") + '</div><div class="authenticator-button" ' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "buttonDataSeAttr") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 740
          },
          "end": {
            "line": 1,
            "column": 801
          }
        }
      })) != null ? stack1 : "") + "></div></div>";
    },
    "useData": true
  }),
  children: function() {
    return [[createButton2({
      className: "button select-factor",
      title: function() {
        return loc3("oie.verify.authenticator.button.text", "login");
      },
      click: function() {
        this.model.trigger("selectAuthenticator", this.model.get("value"));
      }
    }), ".authenticator-button"]];
  },
  minimize: function() {
    this.$el.addClass("authenticator-row-min");
  }
});
var AuthenticatorVerifyOptions = Backbone_ListView.extend({
  className: "authenticator-verify-list authenticator-list",
  item: AuthenticatorRow2,
  itemSelector: ".list-content",
  initialize: function() {
    this.listenTo(this.collection, "selectAuthenticator", this.handleSelect);
  },
  handleSelect: function(data) {
    var _this$model$getProper;
    const validationError = this.model.validateField("identifier");
    this.model.trigger("clearFormError");
    if ((_this$model$getProper = this.model.getPropertySchema("identifier")) !== null && _this$model$getProper !== void 0 && _this$model$getProper.required && validationError) {
      this.model.trigger("invalid", this.model, validationError);
    } else {
      this.model.set(this.options.name, data);
      this.options.appState.trigger("saveForm", this.model);
    }
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div class="list-content"></div>';
    },
    "useData": true
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/captcha/CaptchaView.js
var OktaSignInWidgetOnCaptchaLoadedCallback = "OktaSignInWidgetOnCaptchaLoaded";
var OktaSignInWidgetOnCaptchaSolvedCallback = "OktaSignInWidgetOnCaptchaSolved";
var HCAPTCHA_URL = `https://hcaptcha.com/1/api.js?onload=${OktaSignInWidgetOnCaptchaLoadedCallback}&render=explicit`;
var RECAPTCHAV2_URL = `https://www.google.com/recaptcha/api.js?onload=${OktaSignInWidgetOnCaptchaLoadedCallback}&render=explicit`;
var CaptchaView = View2.extend({
  className: "captcha-view",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div id ="captcha-container" class="' + alias4((helper = (helper = lookupProperty(helpers2, "className") || (depth0 != null ? lookupProperty(depth0, "className") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "className",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 63
          },
          "end": {
            "line": 1,
            "column": 76
          }
        }
      }) : helper)) + '" data-sitekey="' + alias4((helper = (helper = lookupProperty(helpers2, "siteKey") || (depth0 != null ? lookupProperty(depth0, "siteKey") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "siteKey",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 92
          },
          "end": {
            "line": 1,
            "column": 103
          }
        }
      }) : helper)) + '" data-callback="' + alias4((helper = (helper = lookupProperty(helpers2, "onCaptchaSolvedCallback") || (depth0 != null ? lookupProperty(depth0, "onCaptchaSolvedCallback") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "onCaptchaSolvedCallback",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 120
          },
          "end": {
            "line": 1,
            "column": 147
          }
        }
      }) : helper)) + '" data-size="invisible"></div>';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "isCaptchaConfigured") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 184
          }
        }
      })) != null ? stack1 : "";
    },
    "useData": true
  }),
  getTemplateData: function() {
    if (this.captchaConfig) {
      const className2 = this.captchaConfig.type === "HCAPTCHA" ? "h-captcha" : "g-recaptcha";
      return {
        siteKey: this.captchaConfig.siteKey,
        isCaptchaConfigured: true,
        onCaptchaSolvedCallback: OktaSignInWidgetOnCaptchaSolvedCallback,
        className: className2
      };
    } else {
      return {};
    }
  },
  initialize: function() {
    if (this.options.appState.get("captcha")) {
      this.captchaConfig = this.options.appState.get("captcha");
      this._addCaptcha();
    }
  },
  remove: function() {
    View2.prototype.remove.apply(this, arguments);
    if (this.captchaConfig.type === "HCAPTCHA") {
      window.hcaptcha = void 0;
    } else if (this.captchaConfig.type === "RECAPTCHA_V2") {
      window.grecaptcha = void 0;
    }
  },
  /**
   *  Load the CAPTCHA lib dynamically (either HCAPTCHA or RECAPTCHAV2). Once loaded, trigger an event to inform
   *  the parent form to actually render the CAPTCHA.
  * */
  _addCaptcha: function() {
    const onCaptchaSolved = (token) => {
      const captchaObject = this._getCaptchaOject();
      const captchaId = this.$el.find("#captcha-container").attr("data-captcha-id");
      captchaObject.reset(captchaId);
      const fieldName = this.options.name;
      this.model.set(fieldName, token);
      this.options.appState.trigger("saveForm", this.model);
    };
    const onCaptchaLoaded = () => {
      if (this.$el.find("#captcha-container").attr("data-captcha-id")) {
        return;
      }
      const captchaObject = this._getCaptchaOject();
      this.model.set(this.options.name, "tempToken");
      const captchaId = captchaObject.render("captcha-container", {
        sitekey: this.captchaConfig.siteKey,
        callback: onCaptchaSolved
      });
      this.$el.find("#captcha-container").attr("data-captcha-id", captchaId);
      this.options.appState.trigger("onCaptchaLoaded", captchaObject);
      if (this.captchaConfig.type === "HCAPTCHA") {
        this._addHCaptchaFooter();
      }
    };
    window[OktaSignInWidgetOnCaptchaLoadedCallback] = onCaptchaLoaded;
    window[OktaSignInWidgetOnCaptchaSolvedCallback] = onCaptchaSolved;
    if (this.captchaConfig.type === "HCAPTCHA") {
      this._loadCaptchaLib(this._getCaptchaUrl(HCAPTCHA_URL));
    } else if (this.captchaConfig.type === "RECAPTCHA_V2") {
      this._loadCaptchaLib(this._getCaptchaUrl(RECAPTCHAV2_URL));
    }
  },
  /**
   *  We dynamically inject <script> tag into our login container because in case the customer is hosting
   *  the SIW, we need to ensure we don't go out of scope when injecting the script.
  * */
  _loadCaptchaLib: function(url) {
    let scriptTag = document.createElement("script");
    scriptTag.src = url;
    scriptTag.async = true;
    scriptTag.defer = true;
    document.getElementById(Enums.WIDGET_CONTAINER_ID).appendChild(scriptTag);
  },
  _addHCaptchaFooter: function() {
    const footerContainer = document.getElementsByClassName(WIDGET_FOOTER_CLASS);
    if (footerContainer.length) {
      const template8 = _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return '<div class="captcha-footer"><span class="footer-text">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "i18n",
            "hash": {
              "$2": "<a href='https://hcaptcha.com/terms' target='_blank'>$2</a>",
              "$1": "<a href='https://hcaptcha.com/privacy' target='_blank'>$1</a>",
              "bundle": "login",
              "code": "hcaptcha.footer.label"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 54
              },
              "end": {
                "line": 1,
                "column": 238
              }
            }
          })) + "</span></div>";
        },
        "useData": true
      });
      footerContainer[0].insertAdjacentHTML("beforeend", template8());
    }
  },
  _getCaptchaOject: function() {
    const captchaObject = this.captchaConfig.type === "HCAPTCHA" ? window.hcaptcha : window.grecaptcha;
    return captchaObject;
  },
  _getCaptchaUrl: function(baseURL) {
    const locale = this.options.settings.get("language");
    return `${baseURL}&hl=${locale || navigator.language}`;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/FormInputFactory.js
var isTextOverflowing = (text, maxWidth) => {
  const elem = document.createElement("div");
  elem.style.position = "absolute";
  elem.style.left = "-9999px";
  elem.style.whiteSpace = "nowrap";
  elem.innerHTML = text;
  document.body.appendChild(elem);
  const result = elem.clientWidth;
  document.body.removeChild(elem);
  return result > maxWidth;
};
var createAuthenticatorEnrollSelectView = (opt) => {
  const optionItems = (opt.options || []).map((opt2) => {
    return Object.assign({}, opt2, getAuthenticatorDataForEnroll(opt2));
  });
  return {
    View: AuthenticatorEnrollOptions,
    options: {
      name: opt.name,
      collection: new Collection2(optionItems)
    }
  };
};
var createAuthenticatorVerifySelectView = (opt) => {
  let optionItems = opt.options || [];
  const authSet = /* @__PURE__ */ new Set();
  optionItems = optionItems.filter((opt2) => {
    let isDuplicate;
    if (opt2.authenticatorKey === AUTHENTICATOR_KEY.WEBAUTHN) {
      isDuplicate = authSet.has(opt2.authenticatorKey);
      authSet.add(opt2.authenticatorKey);
    } else if (opt2.authenticatorKey === AUTHENTICATOR_KEY.CUSTOM_APP) {
      var _opt$value, _opt$value2;
      isDuplicate = authSet.has(opt2 === null || opt2 === void 0 ? void 0 : (_opt$value = opt2.value) === null || _opt$value === void 0 ? void 0 : _opt$value.id);
      authSet.add(opt2 === null || opt2 === void 0 ? void 0 : (_opt$value2 = opt2.value) === null || _opt$value2 === void 0 ? void 0 : _opt$value2.id);
    }
    return !isDuplicate;
  });
  optionItems = optionItems.map((opt2) => {
    return Object.assign({}, opt2, getAuthenticatorDataForVerification(opt2));
  });
  return {
    View: AuthenticatorVerifyOptions,
    options: {
      name: opt.name,
      collection: new Collection2(optionItems)
    }
  };
};
var createAdminScopesView = () => {
  return {
    View: AdminScopeList
  };
};
var createEnduserScopesView = () => {
  return {
    View: EnduserScopeList
  };
};
var createCaptchaView = (opt) => {
  return {
    View: CaptchaView,
    options: {
      name: opt.name
    }
  };
};
var inputCreationStrategy = {
  authenticatorEnrollSelect: createAuthenticatorEnrollSelectView,
  authenticatorVerifySelect: createAuthenticatorVerifySelectView,
  ["admin-consent"]: createAdminScopesView,
  ["consent"]: createEnduserScopesView,
  ["captcha"]: createCaptchaView
};
var create2 = function(uiSchemaObj) {
  const strategyFn = inputCreationStrategy[uiSchemaObj.type] || oktaUnderscore.identity;
  return strategyFn(uiSchemaObj);
};
var createPIVButton = (settings, appState) => {
  const pivIdp = appState.get("remediations").filter((idp) => idp.name === FORMS.PIV_IDP);
  if (pivIdp.length < 1) {
    return [];
  }
  const pivConfig = settings.get("piv");
  const className2 = pivConfig.className || "";
  return [{
    attributes: {
      "data-se": "piv-card-button"
    },
    className: className2 + " piv-button",
    title: pivConfig.text || loc3("piv.cac.card", "login"),
    click: (e) => {
      e.preventDefault();
      appState.trigger("switchForm", FORMS.PIV_IDP);
    }
  }];
};
var createIdpButtons = ({
  settings,
  appState
}) => {
  const MAX_IDP_BUTTON_WIDTH = 186;
  const redirectIdpRemediations = appState.get("remediations").filter((idp) => idp.name === FORMS.REDIRECT_IDP);
  if (!Array.isArray(redirectIdpRemediations)) {
    return [];
  }
  const pivButton = createPIVButton(settings, appState);
  const idpButtons = redirectIdpRemediations.map((idpObject) => {
    var _idpObject$type;
    let type = (_idpObject$type = idpObject.type) === null || _idpObject$type === void 0 ? void 0 : _idpObject$type.toLowerCase();
    let displayName;
    if (!oktaUnderscore.contains(IDP.SUPPORTED_SOCIAL_IDPS, type)) {
      var _idpObject$idp;
      type = "general-idp";
      displayName = loc3("customauth.sign.in.with.label", "login", [(_idpObject$idp = idpObject.idp) === null || _idpObject$idp === void 0 ? void 0 : _idpObject$idp.name]);
    } else {
      displayName = loc3(`socialauth.${type}.label`, "login");
    }
    const classNames = ["social-auth-button", `social-auth-${type}-button`];
    if (type === "general-idp") {
      classNames.push("no-translate");
    }
    if (idpObject.idp.className) {
      classNames.push(idpObject.idp.className);
    }
    const button = {
      attributes: {
        "data-se": `social-auth-${type}-button`
      },
      className: classNames.join(" "),
      title: displayName,
      href: idpObject.href
    };
    if (isTextOverflowing(displayName, MAX_IDP_BUTTON_WIDTH)) {
      button.attributes.title = displayName;
    }
    return button;
  });
  return [...pivButton, ...idpButtons];
};
var createCustomButtons = (settings) => {
  const customButtons = settings.get("customButtons");
  return customButtons.map((customButton) => {
    const button = {
      attributes: {
        "data-se": customButton.dataAttr
      },
      className: customButton.className + " default-custom-button",
      title: customButton.title || loc3(customButton.i18nKey, "login"),
      click: customButton.click
    };
    return button;
  });
};
var addCustomButton = (customButtonSettings) => {
  return createButton2(__spreadProps(__spreadValues({}, customButtonSettings), {
    className: `${customButtonSettings.className} default-custom-button button-primary`
  }));
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseForm.js
var {
  FormUtil: FormUtil3
} = internal.views.forms.helpers;
var INFO_MESSAGE_CLASS = "INFO";
var BaseForm2 = Form.extend({
  layout: "o-form-theme",
  className: "ion-form",
  hasSavingState: true,
  autoSave: false,
  noCancelButton: true,
  title: function() {
    return loc3("oform.title.authenticate", "login");
  },
  save: function() {
    return loc3("oform.next", "login");
  },
  modelEvents: {
    "clearFormError": "handleClearFormError",
    "error": "triggerAfterError"
  },
  initialize: function() {
    const uiSchemas = this.getUISchema();
    const inputOptions = uiSchemas.map(create2);
    this.showMessages();
    this.listenTo(this.options.appState, "onCaptchaLoaded", (captchaObject) => {
      this.captchaObject = captchaObject;
    });
    inputOptions.forEach((input) => {
      this.addInputOrView(input);
    });
    this.listenTo(this, "save", this.saveForm);
    this.listenTo(this, "cancel", this.cancelForm);
  },
  focus: function(...args) {
    if (this.settings.get("features.autoFocus")) {
      Form.prototype.focus.apply(this, args);
    }
  },
  handleClearFormError: function() {
    const formErrorContainer = this.$(".o-form-error-container");
    formErrorContainer.empty();
    if (formErrorContainer.hasClass("o-form-has-errors")) {
      this.clearErrors();
    }
  },
  triggerAfterError: function(model, error) {
    this.options.appState.trigger("afterError", error);
  },
  saveForm: function(model) {
    this.$el.find(".o-form-error-container").empty();
    if (this.captchaObject) {
      this.captchaObject.execute();
    } else {
      this.options.appState.trigger("saveForm", model);
    }
  },
  postRender: function() {
    const infoContainer = "<div class='o-form-info-container'></div>";
    this.$el.find(".o-form-error-container").before(infoContainer);
    this.addIdentifier();
  },
  /**
   * Render user identifier below title, or if no title, render below message.
   */
  addIdentifier: function() {
    const {
      identifier
    } = this.options.appState.get("user") || {};
    if (!identifier) {
      return;
    } else if (!this.settings.get("features.showIdentifier")) {
      return;
    }
    const header = this.$el.find('[data-se="o-form-head"]');
    const identifierHTMLString = _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<div class="identifier-container"><span class="identifier no-translate" data-se="identifier" title=' + alias4((helper = (helper = lookupProperty(helpers2, "identifier") || (depth0 != null ? lookupProperty(depth0, "identifier") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "identifier",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 99
            },
            "end": {
              "line": 1,
              "column": 113
            }
          }
        }) : helper)) + ">" + alias4((helper = (helper = lookupProperty(helpers2, "identifier") || (depth0 != null ? lookupProperty(depth0, "identifier") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
          "name": "identifier",
          "hash": {},
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 114
            },
            "end": {
              "line": 1,
              "column": 128
            }
          }
        }) : helper)) + "</span></div>";
      },
      "useData": true
    })({
      identifier
    });
    if (header.length) {
      header.after(identifierHTMLString);
    } else {
      this.$el.find(".o-form-error-container").after(identifierHTMLString);
    }
  },
  cancelForm: function() {
    this.options.appState.trigger("invokeAction", "cancel");
  },
  getUISchema: function() {
    if (Array.isArray(this.options.currentViewState.uiSchema)) {
      return this.options.currentViewState.uiSchema;
    } else {
      return [];
    }
  },
  addInputOrView: function(input) {
    if (input.visible === false || input.mutable === false && input.visible !== true) {
      return;
    }
    if (input.View) {
      this.add(input.View, oktaUnderscore.omit(input, "View", "showWhen"));
      if (input.showWhen) {
        FormUtil3.applyShowWhen(this.last(), input.showWhen);
      }
    } else {
      this.addInput(input);
    }
    if (Array.isArray(input.optionsUiSchemas)) {
      if (this.options.optionUiSchemaConfig[input.name]) {
        const optionUiSchemaIndex = Number(this.options.optionUiSchemaConfig[input.name]);
        const optionUiSchemas = input.optionsUiSchemas[optionUiSchemaIndex] || [];
        optionUiSchemas.forEach(this.addInputOrView.bind(this));
      }
    }
  },
  /*
  * Views should override this function to render custom error callouts for invalid form actions.
  * Should return true when callout is customized
  */
  showCustomFormErrorCallout: null,
  /*
   * Renders the contents of messages object (if any, on error) during initialize
   * This function is called during Form.initialize, and will display
   * messages when the form reloads.
   * Note: Any user action related form errors handled by FormController.showFormErrors
   */
  showMessages: function(options2) {
    const messages = this.options.appState.get("messages") || {};
    const errContainer = ".o-form-error-container";
    if (Array.isArray(messages.value) && !(options2 instanceof View2)) {
      this.add('<div class="ion-messages-container"></div>', errContainer);
      messages.value.forEach((obj) => {
        if (!(obj !== null && obj !== void 0 && obj.class) || obj.class === INFO_MESSAGE_CLASS) {
          this.add(`<p>${obj.message}</p>`, ".ion-messages-container");
        } else {
          var _obj$class;
          const errorObj = __spreadValues({
            class: (_obj$class = obj === null || obj === void 0 ? void 0 : obj.class) !== null && _obj$class !== void 0 ? _obj$class : "",
            message: obj === null || obj === void 0 ? void 0 : obj.message,
            title: ""
          }, options2);
          this.add(createCallout({
            content: errorObj.message,
            type: errorObj.class.toLowerCase(),
            title: errorObj.title
          }), errContainer);
          options2 = null;
        }
      });
    } else if (options2 instanceof View2) {
      this.add(options2, errContainer);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/polling.js
var polling = {
  startPolling: function(newRefreshInterval) {
    this.fixedPollingInterval = this.options.currentViewState.refresh;
    this.dynamicPollingInterval = newRefreshInterval;
    this.countDownCounterValue = Math.ceil(this.pollingInterval / MS_PER_SEC);
    if (this.fixedPollingInterval) {
      this._startRemediationPolling();
    } else {
      this._startAuthenticatorPolling();
    }
  },
  _startAuthenticatorPolling: function() {
    ["currentAuthenticator", "currentAuthenticatorEnrollment"].some((responseKey) => {
      if (this.options.appState.has(responseKey)) {
        var _authenticator$poll;
        const authenticator = this.options.appState.get(responseKey);
        const authenticatorPollAction = `${responseKey}-poll`;
        const pollInterval = this.dynamicPollingInterval || (authenticator === null || authenticator === void 0 ? void 0 : (_authenticator$poll = authenticator.poll) === null || _authenticator$poll === void 0 ? void 0 : _authenticator$poll.refresh);
        if (oktaUnderscore.isNumber(pollInterval)) {
          this.polling = setTimeout(() => {
            this.options.appState.trigger("invokeAction", authenticatorPollAction);
          }, pollInterval);
        }
        return true;
      } else {
        return false;
      }
    });
  },
  _startRemediationPolling: function() {
    const pollInterval = this.dynamicPollingInterval || this.fixedPollingInterval;
    if (oktaUnderscore.isNumber(pollInterval)) {
      this.polling = setTimeout(() => {
        this.options.appState.trigger("saveForm", this.model);
      }, pollInterval);
    }
  },
  stopPolling: function() {
    if (this.polling) {
      clearTimeout(this.polling);
      this.polling = null;
    }
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseFormWithPolling.js
var BaseFormWithPolling = BaseForm2.extend(Object.assign({
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.listenTo(this.options.appState, "change:dynamicRefreshInterval", this.updateRefreshInterval);
  },
  updateRefreshInterval: function() {
    if (this.polling) {
      this.stopPolling();
      this.startPolling(this.options.appState.get("dynamicRefreshInterval"));
    }
  }
}, polling));

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseModel.js
var convertUiSchemaFieldToProp = (uiSchemaField) => {
  const config2 = Object.assign({}, oktaUnderscore.chain(uiSchemaField).pick("minLength", "maxLength", "required", "value").defaults({
    type: "string",
    required: true
  }).value());
  if (uiSchemaField.modelType) {
    config2.type = uiSchemaField.modelType;
  }
  return {
    [uiSchemaField.name]: config2
  };
};
var createPropsAndLocals = function(remediation = {}, optionUiSchemaConfig = {}, props6 = {}, local3 = {}) {
  const uiSchemas = remediation.uiSchema || [];
  uiSchemas.forEach((schema) => {
    if (Array.isArray(schema.optionsUiSchemas)) {
      let optionUiSchemaIndex;
      let optionUiSchemaValue = {};
      if (Number(schema.value) >= 0) {
        optionUiSchemaIndex = schema.value;
      }
      if (optionUiSchemaConfig[schema.name]) {
        optionUiSchemaValue = {
          value: optionUiSchemaConfig[schema.name]
        };
        optionUiSchemaIndex = Number(optionUiSchemaValue.value);
      }
      Object.assign(local3, convertUiSchemaFieldToProp(Object.assign({}, schema, optionUiSchemaValue)));
      if (optionUiSchemaIndex) {
        createPropsAndLocals({
          uiSchema: schema.optionsUiSchemas[optionUiSchemaIndex]
        }, optionUiSchemaConfig, props6, local3);
      }
    } else {
      Object.assign(props6, convertUiSchemaFieldToProp(schema));
    }
  });
};
var create3 = function(remediation = {}, optionUiSchemaConfig = {}) {
  const props6 = {};
  const local3 = {
    // current remediation form name
    formName: "string",
    // use full page redirect instead of AJAX
    useRedirect: "boolean"
  };
  createPropsAndLocals(remediation, optionUiSchemaConfig, props6, local3);
  const BaseModel3 = Model2.extend({
    props: props6,
    local: local3
  });
  return BaseModel3;
};
var BaseModel2 = {
  create: create3
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/ion/ViewClassNamesFactory.js
var FORMNAME_CLASSNAME_MAPPINGS = {
  [FORMS.IDENTIFY]: {
    [FORMS.IDENTIFY]: "primary-auth",
    [AUTHENTICATOR_KEY.PASSWORD]: "primary-auth"
  },
  [FORMS.IDENTIFY_RECOVERY]: {
    [FORMS.IDENTIFY_RECOVERY]: "forgot-password"
  },
  [FORMS.ENROLL_PROFILE]: {
    [FORMS.ENROLL_PROFILE]: "registration"
  },
  [FORMS.CHALLENGE_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.EMAIL]: "mfa-verify-passcode",
    [AUTHENTICATOR_KEY.PASSWORD]: "mfa-verify-password",
    sms: "mfa-verify-passcode",
    voice: "mfa-verify-passcode",
    [AUTHENTICATOR_KEY.SECURITY_QUESTION]: "mfa-verify-question",
    [AUTHENTICATOR_KEY.WEBAUTHN]: "mfa-verify-webauthn",
    [AUTHENTICATOR_KEY.ON_PREM]: "mfa-verify-totp",
    [AUTHENTICATOR_KEY.RSA]: "mfa-verify-totp",
    [AUTHENTICATOR_KEY.OV]: "mfa-verify",
    [AUTHENTICATOR_KEY.GOOGLE_OTP]: "mfa-verify",
    [AUTHENTICATOR_KEY.DUO]: "mfa-verify-duo",
    [AUTHENTICATOR_KEY.SYMANTEC_VIP]: "mfa-verify",
    [AUTHENTICATOR_KEY.YUBIKEY]: "mfa-verify",
    [AUTHENTICATOR_KEY.CUSTOM_APP]: "mfa-verify"
  },
  [FORMS.CHALLENGE_POLL]: {
    [AUTHENTICATOR_KEY.OV]: "mfa-verify",
    [AUTHENTICATOR_KEY.CUSTOM_APP]: "mfa-verify"
  },
  [FORMS.RESEND_PUSH]: {
    [AUTHENTICATOR_KEY.OV]: "mfa-verify",
    [AUTHENTICATOR_KEY.CUSTOM_APP]: "mfa-verify"
  },
  [FORMS.ENROLL_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.EMAIL]: "enroll-email",
    [AUTHENTICATOR_KEY.PASSWORD]: "enroll-password",
    sms: "enroll-sms",
    voice: "enroll-call",
    [AUTHENTICATOR_KEY.SECURITY_QUESTION]: "enroll-question",
    [AUTHENTICATOR_KEY.WEBAUTHN]: "enroll-webauthn",
    [AUTHENTICATOR_KEY.ON_PREM]: "enroll-onprem",
    [AUTHENTICATOR_KEY.RSA]: "enroll-rsa",
    [AUTHENTICATOR_KEY.DUO]: "enroll-duo",
    [AUTHENTICATOR_KEY.SYMANTEC_VIP]: "enroll-symantec",
    [AUTHENTICATOR_KEY.YUBIKEY]: "enroll-yubikey"
  },
  [FORMS.SELECT_AUTHENTICATOR_ENROLL]: {
    "select-authenticator-enroll": "enroll-choices"
  },
  [FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE]: {
    [AUTHENTICATOR_KEY.PASSWORD]: "forgot-password"
  },
  [FORMS.REENROLL_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.PASSWORD]: "password-expired"
  },
  [FORMS.RESET_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.PASSWORD]: "forgot-password"
  },
  [FORMS.CONSENT_ADMIN]: {
    [FORMS.CONSENT_ADMIN]: "admin-consent-required"
  },
  [FORMS.CONSENT_ENDUSER]: {
    [FORMS.CONSENT_ENDUSER]: "consent-required"
  }
};
var getV1ClassName = (formName, authenticatorKey, methodType, isPasswordRecoveryFlow) => {
  if (isPasswordRecoveryFlow && formName === FORMS.IDENTIFY) {
    return "forgot-password";
  } else {
    let key = formName;
    if (authenticatorKey === AUTHENTICATOR_KEY.PHONE) {
      key = `${methodType}`;
    } else if (authenticatorKey) {
      key = `${authenticatorKey}`;
    }
    if (FORMNAME_CLASSNAME_MAPPINGS[formName] && FORMNAME_CLASSNAME_MAPPINGS[formName][key]) {
      return FORMNAME_CLASSNAME_MAPPINGS[formName][key];
    } else {
      return null;
    }
  }
};
var getClassNameMapping = (formName, authenticatorKey, methodType, isPasswordRecoveryFlow) => {
  let v2ClassName = formName;
  if (authenticatorKey) {
    v2ClassName = v2ClassName + "--" + authenticatorKey;
  }
  let v1ClassName = getV1ClassName(formName, authenticatorKey, methodType, isPasswordRecoveryFlow);
  const result = [v2ClassName];
  if (v1ClassName) {
    result.push(v1ClassName);
  }
  return result;
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseView.js
var BaseView2 = View2.extend({
  Header: BaseHeader,
  Body: BaseForm2,
  Footer: BaseFooter,
  className: function() {
    const appState = this.options.appState;
    const formName = appState.get("currentFormName");
    const authenticatorKey = appState.get("authenticatorKey");
    const methodType = appState.get("authenticatorMethodType");
    const isPasswordRecoveryFlow = appState.get("isPasswordRecoveryFlow");
    const additionalClassNames = getClassNameMapping(formName, authenticatorKey, methodType, isPasswordRecoveryFlow);
    const classNames = ["siw-main-view"].concat(additionalClassNames);
    return classNames.join(" ");
  },
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div class="siw-main-header"></div><div class="siw-main-body"></div><div class="siw-main-footer"></div>';
    },
    "useData": true
  }),
  preRender: function() {
    View2.prototype.preRender.apply(this, arguments);
    if (this.Header !== null) {
      this.add(this.Header, {
        selector: ".siw-main-header",
        options: this.options
      });
    }
    this.renderForm();
    this.add(this.Footer, {
      selector: ".siw-main-footer",
      options: this.options
    });
  },
  renderForm: function() {
    let optionUiSchemaConfig;
    if (this.form) {
      this.form.remove();
      optionUiSchemaConfig = this.form.model.toJSON({
        verbose: true
      });
    }
    const IonModel = this.createModelClass(this.options.currentViewState, optionUiSchemaConfig, this.settings);
    const model = new IonModel({
      formName: this.options.currentViewState.name
    });
    if (!optionUiSchemaConfig) {
      optionUiSchemaConfig = model.toJSON({
        verbose: true
      });
    }
    this.model = model;
    this.form = this.add(this.Body, {
      selector: ".siw-main-body",
      options: Object.assign({}, this.options, {
        model,
        optionUiSchemaConfig
      })
    }).last();
    oktaUnderscore.each(model.attributes, (value, key) => {
      if (key.match(/sub_schema_local_[^ ]+/)) {
        this.listenTo(model, `change:${key}`, () => {
          this.renderForm();
        });
      }
    });
  },
  createModelClass: function(currentViewState, optionUiSchemaConfig = {}) {
    return BaseModel2.create(currentViewState, optionUiSchemaConfig);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/ChallengeViewUtil.js
function appendLoginHint(deviceChallengeUrl, loginHint) {
  if (deviceChallengeUrl && loginHint) {
    deviceChallengeUrl += "&login_hint=" + loginHint;
  }
  return deviceChallengeUrl;
}
function doChallenge(view, fromView) {
  var _view$options, _view$options$setting;
  const deviceChallenge = view.getDeviceChallengePayload();
  const loginHint = (_view$options = view.options) === null || _view$options === void 0 ? void 0 : (_view$options$setting = _view$options.settings) === null || _view$options$setting === void 0 ? void 0 : _view$options$setting.get("identifier");
  const HIDE_CLASS = "hide";
  switch (deviceChallenge.challengeMethod) {
    case Enums.LOOPBACK_CHALLENGE:
      view.title = loc3("deviceTrust.sso.redirectText", "login");
      view.add(View2.extend({
        className: "loopback-content",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            return '<div class="spinner"></div>';
          },
          "useData": true
        })
      }));
      view.doLoopback(deviceChallenge);
      break;
    case Enums.CUSTOM_URI_CHALLENGE:
      view.title = loc3("customUri.title", "login");
      view.add(View2.extend({
        className: "skinny-content",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "customUri.required.content.prompt"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 3
                },
                "end": {
                  "line": 1,
                  "column": 67
                }
              }
            })) + "</p>";
          },
          "useData": true
        })
      }));
      view.add(createButton2({
        className: "ul-button button button-wide button-primary",
        title: loc3("oktaVerify.open.button", "login"),
        id: "launch-ov",
        click: () => {
          view.doCustomURI();
        }
      }));
      view.add(View2.extend({
        className: "skinny-content",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return "<p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "customUri.required.content.download.title"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 3
                },
                "end": {
                  "line": 1,
                  "column": 75
                }
              }
            })) + '</p><p><a href="' + alias3((helper = (helper = lookupProperty(helpers2, "downloadOVLink") || (depth0 != null ? lookupProperty(depth0, "downloadOVLink") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
              "name": "downloadOVLink",
              "hash": {},
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 91
                },
                "end": {
                  "line": 1,
                  "column": 109
                }
              }
            }) : helper)) + '" target="_blank" id="download-ov" class="link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "customUri.required.content.download.linkText"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 157
                },
                "end": {
                  "line": 1,
                  "column": 232
                }
              }
            })) + "</a></p>";
          },
          "useData": true
        }),
        getTemplateData: function() {
          return {
            downloadOVLink: deviceChallenge.downloadHref
          };
        }
      }));
      view.customURI = appendLoginHint(deviceChallenge.href, loginHint);
      view.doCustomURI();
      break;
    case Enums.UNIVERSAL_LINK_CHALLENGE:
      view.title = loc3("universalLink.title", "login");
      view.add(View2.extend({
        className: "universal-link-content",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return '<div class="spinner"></div>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "universalLink.content"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 27
                },
                "end": {
                  "line": 1,
                  "column": 79
                }
              }
            }));
          },
          "useData": true
        })
      }));
      view.add(createButton2({
        className: "ul-button button button-wide button-primary",
        title: loc3("oktaVerify.open.button", "login"),
        click: () => {
          let deviceChallengeUrl = appendLoginHint(deviceChallenge.href, loginHint);
          Util2.redirect(deviceChallengeUrl);
        }
      }));
      break;
    case Enums.APP_LINK_CHALLENGE:
      view.title = loc3("appLink.title", "login");
      view.add(View2.extend({
        className: "app-link-content",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return '<div class="spinner ' + alias4((helper = (helper = lookupProperty(helpers2, "hideClass") || (depth0 != null ? lookupProperty(depth0, "hideClass") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
              "name": "hideClass",
              "hash": {},
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 20
                },
                "end": {
                  "line": 1,
                  "column": 33
                }
              }
            }) : helper)) + '"></div><div class="appLinkContent ' + alias4((helper = (helper = lookupProperty(helpers2, "hideClass") || (depth0 != null ? lookupProperty(depth0, "hideClass") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
              "name": "hideClass",
              "hash": {},
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 68
                },
                "end": {
                  "line": 1,
                  "column": 81
                }
              }
            }) : helper)) + '">' + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "appLink.content"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 83
                },
                "end": {
                  "line": 1,
                  "column": 129
                }
              }
            })) + "</div>";
          },
          "useData": true
        }),
        getTemplateData: function() {
          return {
            hideClass: HIDE_CLASS
          };
        },
        postRender: function() {
          if (fromView === IDENTIFIER_FLOW) {
            this.$(".spinner").removeClass(HIDE_CLASS);
            setTimeout(oktaUnderscore.bind(() => {
              const data = {
                label: loc3("goback", "login")
              };
              this.options.appState.trigger("updateFooterLink", data);
              this.$(".spinner").addClass(HIDE_CLASS);
              this.$(".appLinkContent").removeClass(HIDE_CLASS);
            }, this), FASTPASS_FALLBACK_SPINNER_TIMEOUT);
          } else {
            this.$(".appLinkContent").removeClass(HIDE_CLASS);
          }
        }
      }));
      view.add(createButton2({
        className: `${HIDE_CLASS} al-button button button-wide button-primary`,
        title: loc3("oktaVerify.open.button", "login"),
        click: () => {
          let deviceChallengeUrl = appendLoginHint(deviceChallenge.href, loginHint);
          Util2.redirect(deviceChallengeUrl, window, true);
        },
        postRender: function() {
          if (fromView === IDENTIFIER_FLOW) {
            setTimeout(oktaUnderscore.bind(() => {
              this.$el.removeClass(HIDE_CLASS);
            }, this), FASTPASS_FALLBACK_SPINNER_TIMEOUT);
          } else {
            this.$el.removeClass(HIDE_CLASS);
          }
        }
      }));
      break;
  }
}
function cancelPollingWithParams(appState, pollingCancelAction, cancelReason, statusCode) {
  const actionParams = {};
  actionParams[REQUEST_PARAM_AUTHENTICATION_CANCEL_REASON] = cancelReason;
  actionParams[LOOPBACK_RESPONSE_STATUS_CODE] = statusCode;
  appState.trigger("invokeAction", pollingCancelAction, actionParams);
}
function getBiometricsErrorOptions(error, isMessageObj) {
  let errorSummaryKeys;
  if (isMessageObj) {
    var _error$value$;
    errorSummaryKeys = Object.values(error === null || error === void 0 ? void 0 : (_error$value$ = error.value[0]) === null || _error$value$ === void 0 ? void 0 : _error$value$.i18n);
  } else {
    var _error$responseJSON;
    errorSummaryKeys = error === null || error === void 0 ? void 0 : (_error$responseJSON = error.responseJSON) === null || _error$responseJSON === void 0 ? void 0 : _error$responseJSON.errorSummaryKeys;
  }
  const isBiometricsRequiredMobile = errorSummaryKeys && errorSummaryKeys.includes(OV_UV_ENABLE_BIOMETRICS_FASTPASS_MOBILE);
  const isBiometricsRequiredDesktop = errorSummaryKeys && errorSummaryKeys.includes(OV_UV_ENABLE_BIOMETRICS_FASTPASS_DESKTOP);
  let options2 = [];
  if (!isBiometricsRequiredMobile && !isBiometricsRequiredDesktop) {
    return options2;
  }
  const bulletPoints = [loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point1", "login"), loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point2", "login"), loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point3", "login")];
  if (isBiometricsRequiredDesktop) {
    bulletPoints.push(loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.point4", "login"));
  }
  options2 = {
    type: "error",
    className: "okta-verify-uv-callout-content",
    title: loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.title", "login"),
    subtitle: loc3("oie.authenticator.oktaverify.method.fastpass.verify.enable.biometrics.description", "login"),
    bullets: bulletPoints
  };
  return options2;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseOktaVerifyChallengeView.js
var request = (opts) => {
  const ajaxOptions = Object.assign({
    method: "GET",
    contentType: "application/json"
  }, opts);
  return oktaJQueryStatic.ajax(ajaxOptions);
};
var Body = BaseFormWithPolling.extend({
  noButtonBar: true,
  className: "ion-form device-challenge-poll",
  events: {
    "click #launch-ov": function(e) {
      e.preventDefault();
      this.doCustomURI();
    }
  },
  pollingCancelAction: AUTHENTICATOR_CANCEL_ACTION,
  initialize: function() {
    BaseFormWithPolling.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "error", this.onPollingFail);
    this.doChallenge();
    this.startPolling();
  },
  doChallenge: function() {
    doChallenge(this);
  },
  onPollingFail: function() {
    this.$(".spinner").hide();
    this.stopPolling();
  },
  remove: function() {
    BaseFormWithPolling.prototype.remove.apply(this, arguments);
    this.stopProbing();
    this.stopPolling();
  },
  getDeviceChallengePayload: function() {
    throw new Error("getDeviceChallengePayload needs to be implemented");
  },
  doLoopback: function(deviceChallenge) {
    let authenticatorDomainUrl = deviceChallenge.domain !== void 0 ? deviceChallenge.domain : "";
    let ports = deviceChallenge.ports !== void 0 ? deviceChallenge.ports : [];
    let challengeRequest = deviceChallenge.challengeRequest !== void 0 ? deviceChallenge.challengeRequest : "";
    let probeTimeoutMillis = deviceChallenge.probeTimeoutMillis !== void 0 ? deviceChallenge.probeTimeoutMillis : 100;
    let currentPort;
    let foundPort = false;
    let ovFailed = false;
    let countFailedPorts = 0;
    const getAuthenticatorUrl = (path) => {
      return `${authenticatorDomainUrl}:${currentPort}/${path}`;
    };
    const checkPort = () => {
      return request({
        url: getAuthenticatorUrl("probe"),
        /*
        OKTA-278573 in loopback server, SSL handshake sometimes takes more than 100ms and thus needs additional
        timeout however, increasing timeout is a temporary solution since user will need to wait much longer in
        worst case.
        TODO: Android timeout is temporarily set to 3000ms and needs optimization post-Beta.
        OKTA-365427 introduces probeTimeoutMillis; but we should also consider probeTimeoutMillisHTTPS for
        customizing timeouts in the more costly Android and other (keyless) HTTPS scenarios.
        */
        timeout: fn.isAndroid() ? 3e3 : probeTimeoutMillis
      });
    };
    const onPortFound = () => {
      return request({
        url: getAuthenticatorUrl("challenge"),
        method: "POST",
        data: JSON.stringify({
          challengeRequest
        }),
        timeout: CHALLENGE_TIMEOUT
        // authenticator should respond within 5 min (300000ms) for challenge request
      });
    };
    const onFailure = () => {
      Logger.error(`Something unexpected happened while we were checking port ${currentPort}.`);
    };
    const doProbing = () => {
      return checkPort().done(() => {
        return onPortFound().done(() => {
          foundPort = true;
          return this.trigger("save", this.model);
        }).fail((xhr) => {
          countFailedPorts++;
          if (xhr.status !== 503) {
            ovFailed = true;
            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.OV_ERROR, xhr.status);
          } else if (countFailedPorts === ports.length) {
            cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);
          }
        });
      }).fail(onFailure);
    };
    let probeChain = Promise.resolve();
    ports.forEach((port) => {
      probeChain = probeChain.then(() => {
        if (!(foundPort || ovFailed)) {
          currentPort = port;
          return doProbing();
        }
      }).catch(() => {
        countFailedPorts++;
        Logger.error(`Authenticator is not listening on port ${currentPort}.`);
        if (countFailedPorts === ports.length) {
          Logger.error("No available ports. Loopback server failed and polling is cancelled.");
          cancelPollingWithParams(this.options.appState, this.pollingCancelAction, AUTHENTICATION_CANCEL_REASONS.LOOPBACK_FAILURE, null);
        }
      });
    });
  },
  doCustomURI: function() {
    this.ulDom && this.ulDom.remove();
    this.ulDom = this.add(`
      <iframe src="${this.customURI}" id="custom-uri-container" style="display:none;"></iframe>
    `).last();
  },
  stopProbing: function() {
    this.checkPortXhr && this.checkPortXhr.abort();
    this.probingXhr && this.probingXhr.abort();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/DeviceFingerprinting.js
function getUserAgent2() {
  return navigator.userAgent;
}
function isWindowsPhone2(userAgent) {
  return userAgent.match(/windows phone|iemobile|wpdesktop/i);
}
var DeviceFingerprinting = {
  isMessageFromCorrectSource: function($iframe, event) {
    return event.source === $iframe[0].contentWindow;
  },
  // NOTE: This utility is similar to the DeviceFingerprint.js file used for V1 authentication flows.
  generateDeviceFingerprint: function(fingerprintData) {
    return new Promise((resolve, reject) => {
      const userAgent = getUserAgent2();
      if (!userAgent) {
        return reject("user agent is not defined");
      } else if (isWindowsPhone2(userAgent)) {
        return reject("device fingerprint is not supported on Windows phones");
      }
      let $iframe;
      let iFrameTimeout;
      const self2 = this;
      function removeIframe() {
        $iframe.off();
        $iframe.remove();
        window.removeEventListener("message", onMessageReceivedFromOkta, false);
      }
      function handleError2(reason) {
        removeIframe();
        reject(reason);
      }
      function onMessageReceivedFromOkta(event) {
        if (!self2.isMessageFromCorrectSource($iframe, event)) {
          return;
        }
        clearTimeout(iFrameTimeout);
        if (!event || !event.data || event.origin !== fingerprintData.oktaDomainUrl) {
          handleError2("no data");
          return;
        }
        try {
          const message = JSON.parse(event.data);
          if (message && message.type === "FingerprintServiceReady") {
            sendMessageToOkta({
              type: "GetFingerprint"
            });
          } else if (message && message.type === "FingerprintAvailable") {
            removeIframe();
            resolve(message.fingerprint);
          } else {
            handleError2("no data");
          }
        } catch (error) {
        }
      }
      function sendMessageToOkta(message) {
        const win = $iframe[0].contentWindow;
        if (win) {
          win.postMessage(JSON.stringify(message), fingerprintData.oktaDomainUrl);
        }
      }
      window.addEventListener("message", onMessageReceivedFromOkta, false);
      $iframe = oktaJQueryStatic("<iframe>", {
        style: "display: none;",
        src: fingerprintData.oktaDomainUrl + "/auth/services/devicefingerprint"
      });
      fingerprintData.element.append($iframe);
      iFrameTimeout = setTimeout(() => {
        handleError2("service not available");
      }, 2e3);
    });
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/IdentifierFooter.js
var IdentifierFooter = BaseFooter.extend({
  showForgotPasswordLink: function() {
    return !this.options.appState.isIdentifierOnlyView();
  },
  footerInfo: function() {
    const signUpLinkData = getSignUpLink(this.options.appState, this.options.settings);
    let SignUpLinkWithText;
    if (signUpLinkData.length) {
      SignUpLinkWithText = View2.extend({
        className: "signup-info",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return "<span>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "registration.signup.label"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 6
                },
                "end": {
                  "line": 1,
                  "column": 62
                }
              }
            })) + '</span><span class="signup-link"></span>';
          },
          "useData": true
        }),
        initialize: function() {
          this.add(Link, ".signup-link", {
            options: signUpLinkData[0]
          });
        }
      });
    }
    return SignUpLinkWithText;
  },
  links: function() {
    const {
      appState,
      settings
    } = this.options;
    let helpLinkHref;
    if (settings.get("helpLinks.help")) {
      helpLinkHref = settings.get("helpLinks.help");
    } else {
      const baseUrl = settings.get("baseUrl");
      helpLinkHref = baseUrl + "/help/login";
    }
    const helpLink = [{
      "name": "help",
      "label": loc3("help", "login"),
      "href": helpLinkHref
    }];
    let forgotPasswordLink = [];
    if (this.showForgotPasswordLink()) {
      forgotPasswordLink = getForgotPasswordLink(appState, settings);
    }
    const customHelpLinks = [];
    if (settings.get("helpLinks.custom")) {
      settings.get("helpLinks.custom").forEach((customHelpLink) => {
        customHelpLink.name = "custom";
        customHelpLink.label = customHelpLink.text;
        customHelpLinks.push(customHelpLink);
      });
    }
    const unlockAccountLink = [];
    if (settings.get("helpLinks.unlock")) {
      unlockAccountLink.push({
        "type": "link",
        "label": loc3("unlockaccount", "login"),
        "name": "unlock",
        "href": settings.get("helpLinks.unlock")
      });
    } else if (appState.hasRemediationObject(FORMS.UNLOCK_ACCOUNT)) {
      unlockAccountLink.push({
        "type": "link",
        "label": loc3("unlockaccount", "login"),
        "name": "unlock",
        "actionPath": FORMS.UNLOCK_ACCOUNT
      });
    }
    return forgotPasswordLink.concat(unlockAccountLink).concat(helpLink).concat(customHelpLinks);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/signin/SignInWithIdps.js
var signInWithIdps = View2.extend({
  className: "sign-in-with-idp",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="separation-line"><span>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "socialauth.divider.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 64
          },
          "end": {
            "line": 1,
            "column": 118
          }
        }
      })) + "</span></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isSecondaryIdpDisplay") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 138
          }
        }
      })) != null ? stack1 : "") + '<div class="okta-idps-container"></div>' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isPrimaryIdpDisplay") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 177
          },
          "end": {
            "line": 1,
            "column": 313
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  initialize: function() {
    this.options.idpButtons.forEach((idpButton) => {
      this.add(createButton2(idpButton), ".okta-idps-container");
    });
  },
  getTemplateData: function() {
    const jsonData = View2.prototype.getTemplateData.apply(this, arguments);
    const addDivider = this.options.idpButtons.length > 0;
    return Object.assign(jsonData, {
      isPrimaryIdpDisplay: addDivider && this.options.isPrimaryIdpDisplay,
      isSecondaryIdpDisplay: addDivider && !this.options.isPrimaryIdpDisplay
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/signin/CustomButtons.js
var customButtonsView = View2.extend({
  className: "custom-buttons",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="separation-line"><span>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "socialauth.divider.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 112
          }
        }
      })) + "</span></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "addSeparateLine") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 132
          }
        }
      })) != null ? stack1 : "") + '<div class="okta-custom-buttons-container primary-auth-container"></div>';
    },
    "useData": true
  }),
  initialize: function(options2) {
    options2.customButtons.forEach((idpButton) => {
      this.add(createButton2(idpButton), ".okta-custom-buttons-container");
    });
  },
  getTemplateData: function() {
    const jsonData = View2.prototype.getTemplateData.apply(this, arguments);
    return Object.assign(jsonData, {
      addSeparateLine: this.options.addSeparateLine
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/signin/SignInWithDeviceOption.js
var SignInWithDeviceOption = View2.extend({
  className: "sign-in-with-device-option",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      return '<div class="signin-with-ov-description"></div>';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="separation-line"><span>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "authbutton.divider.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 201
          },
          "end": {
            "line": 1,
            "column": 255
          }
        }
      })) + "</span></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-verify-container">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "signInWithDeviceIsRequired") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 35
          },
          "end": {
            "line": 1,
            "column": 122
          }
        }
      })) != null ? stack1 : "") + "</div>" + ((stack1 = lookupProperty(helpers2, "unless").call(alias1, depth0 != null ? lookupProperty(depth0, "signInWithDeviceIsRequired") : depth0, {
        "name": "unless",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 128
          },
          "end": {
            "line": 1,
            "column": 279
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  initialize: function() {
    var _deviceChallengePollR;
    const appState = this.options.appState;
    const deviceChallengePollRemediation = appState.hasRemediationObject(FORMS.LAUNCH_AUTHENTICATOR);
    const deviceChallenge = deviceChallengePollRemediation === null || deviceChallengePollRemediation === void 0 ? void 0 : (_deviceChallengePollR = deviceChallengePollRemediation.relatesTo) === null || _deviceChallengePollR === void 0 ? void 0 : _deviceChallengePollR.value;
    this.add(createButton2({
      className: "button",
      icon: "okta-verify-authenticator",
      title: loc3("oktaVerify.button", "login"),
      click: function() {
        if (this.settings.get("features.engFastpassMultipleAccounts") && this.model.get("identifier")) {
          this.options.settings.set("identifier", encodeURIComponent(this.model.get("identifier")));
        }
        const isUVapproach = (deviceChallenge === null || deviceChallenge === void 0 ? void 0 : deviceChallenge.challengeMethod) === Enums.UNIVERSAL_LINK_CHALLENGE;
        if (isUVapproach) {
          var _this$options, _this$options$setting;
          let deviceChallengeUrl = appendLoginHint(deviceChallenge.href, (_this$options = this.options) === null || _this$options === void 0 ? void 0 : (_this$options$setting = _this$options.settings) === null || _this$options$setting === void 0 ? void 0 : _this$options$setting.get("identifier"));
          Util2.redirect(deviceChallengeUrl);
        }
        const isAppLinkapproach = (deviceChallenge === null || deviceChallenge === void 0 ? void 0 : deviceChallenge.challengeMethod) === Enums.APP_LINK_CHALLENGE;
        if (isAppLinkapproach) {
          var _this$options2, _this$options2$settin;
          let deviceChallengeUrl = appendLoginHint(deviceChallenge.href, (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : (_this$options2$settin = _this$options2.settings) === null || _this$options2$settin === void 0 ? void 0 : _this$options2$settin.get("identifier"));
          Util2.redirect(deviceChallengeUrl, window, true);
        }
        Util2.callAfterTimeout(() => {
          if (this.options.isRequired) {
            appState.trigger("saveForm", this.model);
          } else {
            appState.trigger("invokeAction", FORMS.LAUNCH_AUTHENTICATOR);
          }
        }, isUVapproach || isAppLinkapproach ? UNIVERSAL_LINK_POST_DELAY : 0);
      }
    }), ".okta-verify-container");
  },
  getTemplateData: function() {
    return {
      signInWithDeviceIsRequired: !!this.options.isRequired
    };
  },
  postRender: function() {
    if (this.options.isRequired) {
      var _this$options$appStat, _this$options$appStat2;
      const appLabel = (_this$options$appStat = this.options.appState.attributes) === null || _this$options$appStat === void 0 ? void 0 : (_this$options$appStat2 = _this$options$appStat.app) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.label;
      const resourceLabel = appLabel ? loc3("oktaVerify.appDescription", "login", [appLabel]) : loc3("oktaVerify.description", "login");
      const ovDescContainer = this.$el.find(".signin-with-ov-description");
      ovDescContainer.text(resourceLabel);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/signin/SignInWithWebAuthn.js
var signInWithWebAuthn = View2.extend({
  className: "sign-in-with-webauthn-option",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-webauthn-container"></div><div class="separation-line"><span>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "authbutton.divider.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 78
          },
          "end": {
            "line": 1,
            "column": 132
          }
        }
      })) + "</span></div>";
    },
    "useData": true
  }),
  initialize: function() {
    this.add(createButton2({
      className: "button",
      icon: "okta-webauthn-authenticator",
      title: loc3("signinWithWebAuthn.button", "login"),
      click: () => {
        this.options.appState.trigger("invokeAction", FORMS.LAUNCH_WEBAUTHN_AUTHENTICATOR);
      }
    }), ".okta-webauthn-container");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/CustomAccessDeniedErrorMessage.js
var CustomAccessDeniedErrorMessage = View2.extend({
  className: "custom-access-denied-error-message",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "message") || (depth0 != null ? lookupProperty(depth0, "message") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "message",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 18
          },
          "end": {
            "line": 1,
            "column": 29
          }
        }
      }) : helper)) + "</p>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<ul class="custom-links">' + ((stack1 = lookupProperty(helpers2, "each").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "links") : depth0, {
        "name": "each",
        "hash": {},
        "fn": container.program(4, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 78
          },
          "end": {
            "line": 1,
            "column": 182
          }
        }
      })) != null ? stack1 : "") + "</ul>";
    },
    "4": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<li><a href=" + alias4((helper = (helper = lookupProperty(helpers2, "url") || (depth0 != null ? lookupProperty(depth0, "url") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "url",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 105
          },
          "end": {
            "line": 1,
            "column": 112
          }
        }
      }) : helper)) + ' target="_blank" rel="noopener noreferrer">' + alias4((helper = (helper = lookupProperty(helpers2, "label") || (depth0 != null ? lookupProperty(depth0, "label") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "label",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 155
          },
          "end": {
            "line": 1,
            "column": 164
          }
        }
      }) : helper)) + "</a></li>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "message") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 40
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "links") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 194
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    return {
      message: this.options.message,
      links: this.options.links
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/IdentifierView.js
var CUSTOM_ACCESS_DENIED_KEY = "security.access_denied_custom_message";
var Body2 = BaseForm2.extend({
  title: function() {
    return loc3("primaryauth.title", "login");
  },
  save: function() {
    return loc3("oform.next", "login");
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const uiSchema = this.getUISchema();
    if (uiSchema.find((schema) => schema.name === "credentials.passcode")) {
      this.save = loc3("oie.primaryauth.submit", "login");
    }
    if (this._shouldAddUsername(uiSchema)) {
      this.model.set("identifier", this.settings.get("username"));
    } else if (!this.model.get("identifier") && this._shouldApplyRememberMyUsername(uiSchema)) {
      this._applyRememberMyUsername();
    }
  },
  saveForm: function() {
    if (!this.settings.get("features.deviceFingerprinting")) {
      BaseForm2.prototype.saveForm.apply(this, arguments);
      return;
    }
    const fingerprintData = {
      oktaDomainUrl: this.settings.get("baseUrl"),
      element: this.$el
    };
    DeviceFingerprinting.generateDeviceFingerprint(fingerprintData).then((fingerprint2) => {
      this.options.appState.set("deviceFingerprint", fingerprint2);
    }).catch(() => {
    }).finally(() => {
      BaseForm2.prototype.saveForm.apply(this, arguments);
    });
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    if (this.options.appState.hasRemediationObject(FORMS.LAUNCH_AUTHENTICATOR)) {
      this.add(SignInWithDeviceOption, ".o-form-fieldset-container", false, true, {
        isRequired: false
      });
    }
    if (this.options.appState.hasRemediationObject(FORMS.LAUNCH_WEBAUTHN_AUTHENTICATOR)) {
      this.add(signInWithWebAuthn, ".o-form-fieldset-container", false, true, {
        isRequired: false
      });
    }
    const idpButtons = createIdpButtons(this.options);
    if (Array.isArray(idpButtons) && idpButtons.length) {
      this._addForgotPasswordView();
      this._addIdpView(idpButtons);
    }
    const customButtons = createCustomButtons(this.options.settings);
    if (Array.isArray(customButtons) && customButtons.length) {
      this.add(customButtonsView, {
        selector: ".o-form-button-bar",
        options: {
          customButtons,
          addSeparateLine: true
        }
      });
    }
  },
  postRender: function() {
    BaseForm2.prototype.postRender.apply(this, arguments);
    this.$el.find(".identifier-container").remove();
  },
  /**
   * Update UI schemas for customization from .widgetrc.js or Admin Customization settings page.
   * @returns Array
   */
  getUISchema: function() {
    const schemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const {
      settings
    } = this.options;
    const identifierExplainLabeli18nKey = "primaryauth.username.tooltip";
    const passwordExplainLabeli18nKey = "primaryauth.password.tooltip";
    let newSchemas = schemas.map((schema) => {
      let newSchema = __spreadValues({}, schema);
      if (schema.name === "identifier") {
        if (isCustomizedI18nKey(identifierExplainLabeli18nKey, settings)) {
          newSchema = __spreadProps(__spreadValues({}, newSchema), {
            explain: loc3(identifierExplainLabeli18nKey, "login"),
            "explain-top": true
          });
        }
        newSchema = __spreadProps(__spreadValues({}, newSchema), {
          autoComplete: "identifier"
        });
      } else if (schema.name === "credentials.passcode") {
        newSchema = __spreadProps(__spreadValues({}, newSchema), {
          autoComplete: "current-password"
        });
        if (isCustomizedI18nKey(passwordExplainLabeli18nKey, settings)) {
          newSchema = __spreadProps(__spreadValues({}, newSchema), {
            explain: loc3(passwordExplainLabeli18nKey, "login"),
            "explain-top": true
          });
        }
      }
      return newSchema;
    });
    if (this.settings.get("features.showKeepMeSignedIn") === false) {
      newSchemas = newSchemas.filter((schema) => schema.name !== "rememberMe");
    }
    return newSchemas;
  },
  showCustomFormErrorCallout: function(error, messages) {
    var _error$responseJSON, _error$responseJSON$e;
    if (!(error !== null && error !== void 0 && (_error$responseJSON = error.responseJSON) !== null && _error$responseJSON !== void 0 && (_error$responseJSON$e = _error$responseJSON.errorSummaryKeys) !== null && _error$responseJSON$e !== void 0 && _error$responseJSON$e.includes(CUSTOM_ACCESS_DENIED_KEY))) {
      return false;
    }
    const message = messages.find((message2) => message2.i18n.key === CUSTOM_ACCESS_DENIED_KEY);
    if (!message) {
      return false;
    }
    const {
      errorSummary
    } = error.responseJSON;
    const options2 = {
      type: "error",
      content: new CustomAccessDeniedErrorMessage({
        message: errorSummary,
        links: message.links
      })
    };
    this.showMessages(createCallout(options2));
    return true;
  },
  _addForgotPasswordView: function() {
    const forgotPasswordLink = getForgotPasswordLink(this.options.appState, this.options.settings);
    if (forgotPasswordLink.length) {
      this.add('<div class="links-primary"></div>', {
        selector: ".o-form-button-bar"
      });
      this.add(Link, {
        selector: ".links-primary",
        options: forgotPasswordLink[0]
      });
    }
  },
  _addIdpView: function(idpButtons) {
    const idpDisplay = this.options.settings.get("idpDisplay");
    const isPrimaryIdpDisplay = idpDisplay && idpDisplay.toUpperCase() === "PRIMARY";
    this.add(signInWithIdps, {
      prepend: isPrimaryIdpDisplay,
      selector: isPrimaryIdpDisplay ? ".o-form-fieldset-container" : ".o-form-button-bar",
      options: {
        idpButtons,
        isPrimaryIdpDisplay
      }
    });
  },
  _shouldAddUsername: function(uiSchema) {
    return uiSchema.find((schema) => schema.name === "identifier") && this.settings.get("username");
  },
  _shouldApplyRememberMyUsername: function(uiSchema) {
    return uiSchema.find((schema) => schema.name === "identifier") && this.settings.get("features.rememberMe") && this.settings.get("features.rememberMyUsernameOnOIE");
  },
  /**
   * When "Remember My Username" is enabled, we pre-fill the identifier
   * field with the saved userName cookie. The cookie would have been originally
   * saved when submitting the form previously.
   */
  _applyRememberMyUsername: function() {
    const cookieUsername = fn8.getCookieUsername();
    if (cookieUsername) {
      this.model.set("identifier", cookieUsername);
    }
  }
});
var IdentifierView = BaseView2.extend({
  Body: Body2,
  createModelClass: function() {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const identifierRequiredi18nKey = "error.username.required";
    const passwordRequiredi18nKey = "error.password.required";
    const props6 = ModelClass.prototype.props;
    const validate = (attr) => {
      const inlineErrors = {};
      const isEmptyIdentifier = props6["identifier"] && !(attr !== null && attr !== void 0 && attr["identifier"]);
      const isEmptyPassword = props6["credentials.passcode"] && !(attr !== null && attr !== void 0 && attr["credentials.passcode"]);
      if (isEmptyIdentifier && isCustomizedI18nKey(identifierRequiredi18nKey, this.settings)) {
        inlineErrors["identifier"] = loc3(identifierRequiredi18nKey, "login");
      }
      if (isEmptyPassword && isCustomizedI18nKey(passwordRequiredi18nKey, this.settings)) {
        inlineErrors["credentials.passcode"] = loc3(passwordRequiredi18nKey, "login");
      }
      return inlineErrors;
    };
    return ModelClass.extend({
      validate
    });
  },
  initialize: function() {
    this.Footer = IdentifierFooter.extend({
      showForgotPasswordLink: () => {
        const idpButtons = createIdpButtons(this.options);
        return !this.options.appState.isIdentifierOnlyView() && (!Array.isArray(idpButtons) || idpButtons.length === 0);
      }
    });
  },
  postRender: function() {
    BaseView2.prototype.postRender.apply(this, arguments);
    const appState = this.options.appState;
    this.$el.find(".js-sign-up").click(function() {
      appState.trigger("invokeAction", FORMS.SELECT_ENROLL_PROFILE);
      return false;
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/RedirectIdPView.js
var RedirectIdPView = IdentifierView.extend({
  render: function() {
    IdentifierView.prototype.render.apply(this, arguments);
    this.$el.find(".sign-in-with-idp .separation-line").hide();
    this.$el.find(".button-primary").hide();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/IdentifyRecoveryView.js
var Body3 = BaseForm2.extend({
  title: function() {
    return loc3("password.reset.title.generic", "login");
  },
  save: function() {
    return loc3("oform.next", "login");
  },
  getUISchema: function() {
    const schemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    let newSchemas = schemas.map((schema) => {
      let newSchema = __spreadValues({}, schema);
      if (schema.name === "identifier") {
        newSchema = __spreadProps(__spreadValues({}, newSchema), {
          autoComplete: "identifier"
        });
      }
      return newSchema;
    });
    return newSchemas;
  }
});
var IdentifyRecoveryView = BaseView2.extend({
  Body: Body3,
  Footer: BaseFooter
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/AuthenticatorFooter.js
var AuthenticatorFooter = BaseFooter.extend({
  links: function() {
    return getFactorPageCustomLink(this.options.appState, this.options.settings).concat(getSwitchAuthenticatorLink(this.options.appState));
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/HeaderBeacon.js
var HeaderBeacon = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="bg-helper auth-beacon auth-beacon-factor custom-app-logo" data-se="factor-beacon" role="img" aria-label="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.auth.logo.aria.label"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 309
          },
          "end": {
            "line": 1,
            "column": 364
          }
        }
      })) + `" style="background-image: url('` + alias3((helper = (helper = lookupProperty(helpers2, "logoUri") || (depth0 != null ? lookupProperty(depth0, "logoUri") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "logoUri",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 396
          },
          "end": {
            "line": 1,
            "column": 407
          }
        }
      }) : helper)) + `')">`;
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="bg-helper auth-beacon auth-beacon-factor ' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "className") || (depth0 != null ? lookupProperty(depth0, "className") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "className",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 472
          },
          "end": {
            "line": 1,
            "column": 485
          }
        }
      }) : helper)) + '" data-se="factor-beacon">';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div data-type="beacon-container" class="beacon-container"><div class="beacon-blank auth-beacon"><div class="beacon-blank js-blank-beacon-border auth-beacon-border"></div></div>' + ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "logoUri") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 177
          },
          "end": {
            "line": 1,
            "column": 518
          }
        }
      })) != null ? stack1 : "") + '<div class="okta-sign-in-beacon-border auth-beacon-border"></div></div></div >';
    },
    "useData": true
  }),
  getTemplateData: function() {
    var _this$options, _appState$get, _appState$get2;
    const appState = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.appState;
    return {
      className: this.getBeaconClassName() || "",
      logoUri: (appState === null || appState === void 0 ? void 0 : (_appState$get = appState.get("currentAuthenticator")) === null || _appState$get === void 0 ? void 0 : _appState$get.logoUri) || (appState === null || appState === void 0 ? void 0 : (_appState$get2 = appState.get("currentAuthenticatorEnrollment")) === null || _appState$get2 === void 0 ? void 0 : _appState$get2.logoUri)
    };
  },
  getBeaconClassName: function() {
    return "undefined-user";
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/BaseAuthenticatorView.js
var BaseAuthenticatorBeacon = HeaderBeacon.extend({
  authenticatorKey: function() {
    return this.options.appState.get("authenticatorKey");
  },
  getBeaconClassName: function() {
    const authenticatorKey = oktaUnderscore.result(this, "authenticatorKey");
    return getIconClassNameForBeacon(authenticatorKey);
  }
});
var BaseAuthenticatorView = BaseView2.extend({
  Header: BaseHeader.extend({
    HeaderBeacon: BaseAuthenticatorBeacon
  }),
  Footer: AuthenticatorFooter
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/EmailAuthenticatorHeader.js
var EmailAuthenticatorHeader = BaseHeader.extend({
  HeaderBeacon: BaseAuthenticatorBeacon.extend({
    authenticatorKey: AUTHENTICATOR_KEY.EMAIL
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EmailMagicLinkOTPTerminalView.js
var generateGeolocationString = (location2 = {}) => {
  if (!location2.city && !location2.country) {
    return null;
  }
  return location2.state ? loc3("geolocation.formatting.all", "login", [location2.city, location2.state, location2.country]) : loc3("geolocation.formatting.partial", "login", [location2.city, location2.country]);
};
var challengeIntentToFlowMap = {
  "AUTHENTICATION": loc3("idx.return.link.otponly.enter.code.on.page.sign.in", "login"),
  "RECOVERY": loc3("idx.return.link.otponly.enter.code.on.page.password.reset", "login"),
  "UNLOCK_ACCOUNT": loc3("idx.return.link.otponly.enter.code.on.page.account.unlock", "login"),
  "ENROLLMENT": loc3("idx.return.link.otponly.enter.code.on.page.registration", "login")
};
var getTerminalOtpEmailMagicLinkContext = (settings, appState) => {
  var _appState$get, _appState$get$context;
  const app = appState.get("app");
  const client = appState.get("client");
  const challengeIntent = challengeIntentToFlowMap[appState.get("idx").context.intent];
  let enterCodeOnFlowPage, appName, browserOnOsString, isMobileDevice, geolocation;
  enterCodeOnFlowPage = challengeIntent ? loc3("idx.return.link.otponly.enter.code.on.page", "login", [challengeIntent]) : loc3("idx.enter.otp.in.original.tab", "login");
  if (app) {
    appName = loc3("idx.return.link.otponly.app", "login", [app.label]);
  }
  if (client) {
    browserOnOsString = loc3("idx.return.link.otponly.browser.on.os", "login", [client.browser, client.os]);
    isMobileDevice = browserOnOsString.includes("Android") || browserOnOsString.includes("iOS");
    geolocation = generateGeolocationString(client.location);
  }
  const otp = settings.get("otp") || ((_appState$get = appState.get("currentAuthenticator")) === null || _appState$get === void 0 ? void 0 : (_appState$get$context = _appState$get.contextualData) === null || _appState$get$context === void 0 ? void 0 : _appState$get$context.otp);
  return {
    showRequestInfo: appName || browserOnOsString || geolocation,
    appName,
    browserOnOsString,
    isMobileDevice,
    geolocation,
    otp,
    enterCodeOnFlowPage
  };
};
var BaseEmailMagicLinkOTPTerminalView = View2.extend({
  getTemplateData: function() {
    return getTerminalOtpEmailMagicLinkContext(this.options.settings, this.options.appState);
  }
});
var OTPInformationTerminalView = BaseEmailMagicLinkOTPTerminalView.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="enduser-email-otp-only--info"><div class="okta-form-label">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "idx.return.link.otponly.request"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 198
          },
          "end": {
            "line": 1,
            "column": 260
          }
        }
      })) + "</div></div>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="enduser-email-otp-only--info">' + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isMobileDevice") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(4, data, 0),
        "inverse": container.program(6, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 346
          },
          "end": {
            "line": 1,
            "column": 540
          }
        }
      })) != null ? stack1 : "") + '<div data-se="otp-browser-os">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "browserOnOsString") || (depth0 != null ? lookupProperty(depth0, "browserOnOsString") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(alias1, {
        "name": "browserOnOsString",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 570
          },
          "end": {
            "line": 1,
            "column": 591
          }
        }
      }) : helper)) + "</div></div>";
    },
    "4": function(container, depth0, helpers2, partials, data) {
      return '<i class="enduser-email-otp-only--icon icon--smartphone" aria-hidden="true"></i>';
    },
    "6": function(container, depth0, helpers2, partials, data) {
      return '<i class="enduser-email-otp-only--icon icon--desktop" aria-hidden="true"></i>';
    },
    "8": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="enduser-email-otp-only--info"><i class="enduser-email-otp-only--icon icon--app" aria-hidden="true"></i><div data-se="otp-app">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "appName") || (depth0 != null ? lookupProperty(depth0, "appName") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "appName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 763
          },
          "end": {
            "line": 1,
            "column": 774
          }
        }
      }) : helper)) + "</div></div>";
    },
    "10": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="enduser-email-otp-only--info"><i class="enduser-email-otp-only--icon icon--location" aria-hidden="true"></i><div data-se="otp-geolocation">' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "geolocation") || (depth0 != null ? lookupProperty(depth0, "geolocation") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "geolocation",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 963
          },
          "end": {
            "line": 1,
            "column": 978
          }
        }
      }) : helper)) + "</div></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="enter-code-on-page">' + alias4((helper = (helper = lookupProperty(helpers2, "enterCodeOnFlowPage") || (depth0 != null ? lookupProperty(depth0, "enterCodeOnFlowPage") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "enterCodeOnFlowPage",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 30
          },
          "end": {
            "line": 1,
            "column": 53
          }
        }
      }) : helper)) + "</p><h1 class='otp-value no-translate'>" + alias4((helper = (helper = lookupProperty(helpers2, "otp") || (depth0 != null ? lookupProperty(depth0, "otp") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "otp",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 92
          },
          "end": {
            "line": 1,
            "column": 99
          }
        }
      }) : helper)) + "</h1>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "showRequestInfo") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 104
          },
          "end": {
            "line": 1,
            "column": 279
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "browserOnOsString") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 279
          },
          "end": {
            "line": 1,
            "column": 610
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "appName") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(8, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 610
          },
          "end": {
            "line": 1,
            "column": 793
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "geolocation") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(10, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 793
          },
          "end": {
            "line": 1,
            "column": 997
          }
        }
      })) != null ? stack1 : "") + "<br><p class='otp-warning'>" + alias4((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "idx.return.link.otponly.warning.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 1024
          },
          "end": {
            "line": 1,
            "column": 1091
          }
        }
      })) + "</p>";
    },
    "useData": true
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/TerminalView.js
var RETURN_LINK_EXPIRED_KEY = "idx.return.link.expired";
var IDX_RETURN_LINK_OTP_ONLY = "idx.enter.otp.in.original.tab";
var SAFE_MODE_KEY_PREFIX = "idx.error.server.safe.mode";
var UNLOCK_ACCOUNT_TERMINAL_KEY = "oie.selfservice.unlock_user.success.message";
var UNLOCK_ACCOUNT_FAILED_PERMISSIONS = "oie.selfservice.unlock_user.challenge.failed.permissions";
var RESET_PASSWORD_NOT_ALLOWED = "oie.selfservice.reset.password.not.allowed";
var RETURN_TO_ORIGINAL_TAB_KEY = "idx.return.to.original.tab";
var OPERATION_CANCELED_ON_OTHER_DEVICE_KEY = "idx.operation.cancelled.on.other.device";
var OPERATION_CANCELED_BY_USER_KEY = "idx.operation.cancelled.by.user";
var DEVICE_ACTIVATED2 = "idx.device.activated";
var DEVICE_NOT_ACTIVATED_CONSENT_DENIED2 = "idx.device.not.activated.consent.denied";
var DEVICE_NOT_ACTIVATED_INTERNAL_ERROR = "idx.device.not.activated.internal.error";
var FLOW_CONTINUE_IN_NEW_TAB = "idx.transferred.to.new.tab";
var EMAIL_LINK_OUT_OF_DATE = "idx.return.stale";
var EMAIL_LINK_CANT_BE_PROCESSED = "idx.return.error";
var EMAIL_VERIFICATION_REQUIRED = "idx.email.verification.required";
var EMAIL_ACTIVATION_EMAIL_EXPIRE = "idx.expired.activation.token";
var EMAIL_ACTIVATION_EMAIL_INVALID = "idx.missing.activation.token";
var EMAIL_ACTIVATION_EMAIL_SUBMITTED = "idx.request.activation.email";
var EMAIL_ACTIVATION_EMAIL_SUSPENDED = "idx.activating.inactive.user";
var CUSTOM_ACCESS_DENIED_KEY2 = "security.access_denied_custom_message";
var REGISTRATION_NOT_ENABLED = "oie.registration.is.not.enabled";
var FORGOT_PASSWORD_NOT_ENABLED = "oie.forgot.password.is.not.enabled";
var EMAIL_AUTHENTICATOR_TERMINAL_KEYS = [FLOW_CONTINUE_IN_NEW_TAB, EMAIL_LINK_OUT_OF_DATE, EMAIL_LINK_CANT_BE_PROCESSED, EMAIL_VERIFICATION_REQUIRED, RETURN_TO_ORIGINAL_TAB_KEY, RETURN_LINK_EXPIRED_KEY, OPERATION_CANCELED_ON_OTHER_DEVICE_KEY, OPERATION_CANCELED_BY_USER_KEY, IDX_RETURN_LINK_OTP_ONLY];
var DEVICE_CODE_ERROR_KEYS2 = [DEVICE_NOT_ACTIVATED_CONSENT_DENIED2, DEVICE_NOT_ACTIVATED_INTERNAL_ERROR];
var DEVICE_CODE_FLOW_TERMINAL_KEYS = [DEVICE_ACTIVATED2, ...DEVICE_CODE_ERROR_KEYS2];
var NO_BACKTOSIGNIN_LINK_VIEWS = [UNLOCK_ACCOUNT_TERMINAL_KEY, RETURN_TO_ORIGINAL_TAB_KEY, FLOW_CONTINUE_IN_NEW_TAB, OPERATION_CANCELED_ON_OTHER_DEVICE_KEY, ...DEVICE_CODE_FLOW_TERMINAL_KEYS, UNLOCK_ACCOUNT_FAILED_PERMISSIONS, RESET_PASSWORD_NOT_ALLOWED, IDX_RETURN_LINK_OTP_ONLY];
var terminalViewTitles = {
  [RETURN_LINK_EXPIRED_KEY]: "oie.email.return.link.expired.title",
  [UNLOCK_ACCOUNT_TERMINAL_KEY]: "account.unlock.unlocked.title",
  [DEVICE_ACTIVATED2]: "device.code.activated.success.title",
  [REGISTRATION_NOT_ENABLED]: "oie.registration.form.title",
  [FORGOT_PASSWORD_NOT_ENABLED]: "password.reset.title.generic",
  [EMAIL_ACTIVATION_EMAIL_EXPIRE]: "oie.activation.request.email.title.expire",
  [EMAIL_ACTIVATION_EMAIL_SUBMITTED]: "oie.activation.request.email.title.submitted",
  [EMAIL_ACTIVATION_EMAIL_SUSPENDED]: "oie.activation.request.email.title.suspended",
  [EMAIL_ACTIVATION_EMAIL_INVALID]: "oie.activation.request.email.title.invalid",
  [DEVICE_NOT_ACTIVATED_CONSENT_DENIED2]: "device.code.activated.error.title",
  [DEVICE_NOT_ACTIVATED_INTERNAL_ERROR]: "device.code.activated.error.title",
  [RETURN_TO_ORIGINAL_TAB_KEY]: "oie.consent.enduser.email.allow.title",
  [IDX_RETURN_LINK_OTP_ONLY]: "idx.return.link.otponly.your.verification.code"
};
var Body4 = BaseForm2.extend({
  noButtonBar: true,
  postRender: function() {
    BaseForm2.prototype.postRender.apply(this, arguments);
    this.$el.addClass("terminal-state");
    if (this.options.appState.containsMessageWithI18nKey(DEVICE_CODE_FLOW_TERMINAL_KEYS)) {
      const iconClass = this.options.appState.containsMessageWithI18nKey(DEVICE_ACTIVATED2) ? "success-24-green" : "error-24-red";
      this.$(".o-form-head").before('<div class="device-code-terminal--icon-container"><span class="device-code-terminal--icon ' + iconClass + '"></span></div>');
    }
  },
  title: function() {
    return this.getTerminalViewTitle();
  },
  getTerminalViewTitle: function() {
    if (this.options.appState.containsMessageStartingWithI18nKey(SAFE_MODE_KEY_PREFIX)) {
      return loc3("oie.safe.mode.title", "login");
    }
    const apiKeys = Object.keys(terminalViewTitles);
    const key = apiKeys.find((key2) => this.options.appState.containsMessageWithI18nKey(key2));
    if (key) {
      return loc3(terminalViewTitles[key], "login");
    }
  },
  showMessages: function() {
    const messagesObjs = this.options.appState.get("messages");
    let hasCustomView = false;
    let description;
    if (this.options.appState.containsMessageWithI18nKey(OPERATION_CANCELED_ON_OTHER_DEVICE_KEY)) {
      description = loc3("idx.operation.cancelled.on.other.device", "login");
      messagesObjs.value.push({
        message: loc3("oie.consent.enduser.deny.description", "login")
      });
    } else if (this.options.appState.containsMessageWithI18nKey(RETURN_TO_ORIGINAL_TAB_KEY)) {
      description = loc3("oie.consent.enduser.email.allow.description", "login");
      messagesObjs.value.push({
        message: loc3("oie.return.to.original.tab", "login")
      });
    } else if (this.options.appState.containsMessageWithI18nKey("tooManyRequests")) {
      description = loc3("oie.tooManyRequests", "login");
    } else if (this.options.appState.containsMessageWithI18nKey(RETURN_LINK_EXPIRED_KEY)) {
      messagesObjs.value[0].class = "ERROR";
    } else if (this.options.appState.containsMessageWithI18nKey(IDX_RETURN_LINK_OTP_ONLY)) {
      this.add(OTPInformationTerminalView);
      hasCustomView = true;
    } else if (this.options.appState.containsMessageStartingWithI18nKey(CUSTOM_ACCESS_DENIED_KEY2)) {
      this.add(createCallout({
        type: "error",
        content: new CustomAccessDeniedErrorMessage({
          message: messagesObjs.value[0].message,
          links: messagesObjs.value[0].links
        })
      }));
      hasCustomView = true;
    }
    if (description && Array.isArray(messagesObjs === null || messagesObjs === void 0 ? void 0 : messagesObjs.value)) {
      messagesObjs.value[0].message = description;
    }
    this.options.appState.set("messages", messagesObjs);
    if (!hasCustomView) {
      BaseForm2.prototype.showMessages.call(this);
    }
  }
});
var Footer6 = BaseFooter.extend({
  // All terminal views should have Back to sign in link either widget configured or server configured.
  links: function() {
    if (this.options.appState.containsMessageStartingWithI18nKey(SAFE_MODE_KEY_PREFIX)) {
      return getSkipSetupLink(this.options.appState);
    }
    if (this.options.appState.containsMessageWithI18nKey(DEVICE_CODE_ERROR_KEYS2)) {
      return getReloadPageButtonLink();
    }
    if (!this.options.appState.hasActionObject("cancel") && !this.options.appState.containsMessageWithI18nKey(NO_BACKTOSIGNIN_LINK_VIEWS)) {
      return getBackToSignInLink(this.options);
    }
  }
});
var TerminalView = BaseView2.extend({
  initialize: function() {
    BaseView2.prototype.initialize.apply(this, arguments);
    if (this.options.appState.containsMessageWithI18nKey(EMAIL_AUTHENTICATOR_TERMINAL_KEYS)) {
      this.Header = EmailAuthenticatorHeader;
    }
  },
  Body: Body4,
  Footer: Footer6
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/AutoRedirectView.js
var CUSTOM_ACCESS_DENIED_KEY3 = "security.access_denied_custom_message";
var UNLOCK_USER_SUCCESS_MESSAGE = "oie.selfservice.unlock_user.landing.to.app.success.message";
var Body5 = BaseForm2.extend({
  title: function() {
    let titleString = loc3("oie.success.text.signingIn", "login");
    const app = this.options.appState.get("app");
    const user = this.options.appState.get("user");
    if (!this.redirectView || this.redirectView === INTERSTITIAL_REDIRECT_VIEW.NONE) {
      titleString = loc3("oie.success.text.signingIn.with.ellipsis", "login");
      return titleString;
    }
    if (oktaUnderscore.isEmpty(app)) {
      return titleString;
    }
    const {
      label: appInstanceName,
      name: appDisplayName
    } = app;
    const {
      identifier: userEmail
    } = user || {};
    const appName = appInstanceName ? appInstanceName : appDisplayName;
    if (appName && userEmail && !this.settings.get("features.showIdentifier")) {
      titleString = loc3("oie.success.text.signingIn.with.appName.and.identifier", "login", [appName, userEmail]);
    } else if (appName) {
      titleString = loc3("oie.success.text.signingIn.with.appName", "login", [appName]);
    }
    return titleString;
  },
  showMessages: function() {
    if (this.isUnlockSuccess()) {
      const container = ".o-form-error-container";
      const text = loc3("oie.selfservice.unlock_user.landing.to.app.signing.in.message", "login");
      this.add(`<div class="ion-messages-container"><p>${text}</p></div>`, container);
      return;
    } else if (this.options.appState.containsMessageStartingWithI18nKey(CUSTOM_ACCESS_DENIED_KEY3)) {
      const {
        message,
        links
      } = this.options.appState.get("messages").value.find((msg) => msg.i18n.key === CUSTOM_ACCESS_DENIED_KEY3);
      this.add(createCallout({
        type: "error",
        content: new CustomAccessDeniedErrorMessage({
          message,
          links
        })
      }));
      return;
    }
    BaseForm2.prototype.showMessages.call(this);
  },
  isUnlockSuccess: function() {
    return this.options.appState.containsMessageWithI18nKey(UNLOCK_USER_SUCCESS_MESSAGE);
  },
  noButtonBar: true,
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.redirectView = this.settings.get("interstitialBeforeLoginRedirect");
    this.model.set("useRedirect", true);
    this.trigger("save", this.model);
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    if (this.redirectView === INTERSTITIAL_REDIRECT_VIEW.DEFAULT) {
      this.add('<div class="okta-waiting-spinner"></div>');
    }
  }
});
var AutoRedirectView = BaseView2.extend({
  Body: Body5
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/PollView.js
var PollMessageView = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="ion-messages-container"><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "$1": "<span class='strong'>$1</span>",
          "arguments": "countDownCounterValue",
          "bundle": "login",
          "code": "poll.form.message"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 39
          },
          "end": {
            "line": 1,
            "column": 157
          }
        }
      })) + '</p></div><div class="hide okta-waiting-spinner"></div>';
    },
    "useData": true
  }),
  getTemplateData: function() {
    const countDownCounterValue = this.options;
    return {
      countDownCounterValue
    };
  }
});
var Body6 = BaseForm2.extend(Object.assign({
  title: function() {
    return loc3("poll.form.title", "login");
  },
  noButtonBar: true,
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const refreshInterval = this.options.appState.getCurrentViewState().refresh;
    this.refreshTimeout = setTimeout(() => {
      this.$el.find(".okta-waiting-spinner").show();
      setTimeout(() => this.saveForm(this.model), 200);
    }, refreshInterval);
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    this.countDownCounterValue = Math.ceil(this.options.appState.getCurrentViewState().refresh / MS_PER_SEC);
    this.add(new PollMessageView(this.countDownCounterValue));
    this.startCountDown(".ion-messages-container span", MS_PER_SEC);
  },
  remove: function() {
    BaseForm2.prototype.remove.apply(this, arguments);
    clearTimeout(this.refreshTimeout);
  },
  triggerAfterError: function() {
    BaseForm2.prototype.triggerAfterError.apply(this, arguments);
    clearTimeout(this.refreshTimeout);
    this.stopCountDown();
    this.$el.find(".o-form-fieldset-container").empty();
  },
  startCountDown: function(selector, interval) {
    if (this.countDown) {
      clearInterval(this.countDown);
    }
    this.counterEl = this.$el.find(selector);
    this.countDown = setInterval(() => {
      if (this.counterEl.text() !== "0") {
        this.counterEl.text(this.counterEl.text() - 1);
      }
    }, interval, this);
  },
  stopCountDown: function() {
    if (this.countDown) {
      clearInterval(this.countDown);
    }
  }
}));
var PollView = BaseView2.extend({
  Body: Body6
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/AdminConsentViewHeader.js
var defaultLogo = "/img/logos/default.png";
var AdminConsentViewHeader = View2.extend({
  className: "consent-title detail-row",
  titleText: () => loc3("oie.consent.scopes.admin.title", "login"),
  hasIssuer: true,
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "clientURI") || (depth0 != null ? lookupProperty(depth0, "clientURI") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "clientURI",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 26
          },
          "end": {
            "line": 1,
            "column": 39
          }
        }
      }) : helper)) + '" class="client-logo-link" target="_blank">';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<img class="client-logo custom-logo" src="' + alias4((helper = (helper = lookupProperty(helpers2, "customLogo") || (depth0 != null ? lookupProperty(depth0, "customLogo") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "customLogo",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 149
          },
          "end": {
            "line": 1,
            "column": 163
          }
        }
      }) : helper)) + '" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "altText") || (depth0 != null ? lookupProperty(depth0, "altText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "altText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 170
          },
          "end": {
            "line": 1,
            "column": 181
          }
        }
      }) : helper)) + '" aria-hidden="true" />';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<img class="client-logo default-logo" src="' + alias4((helper = (helper = lookupProperty(helpers2, "defaultLogo") || (depth0 != null ? lookupProperty(depth0, "defaultLogo") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "defaultLogo",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 255
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      }) : helper)) + '" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "altText") || (depth0 != null ? lookupProperty(depth0, "altText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "altText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 277
          },
          "end": {
            "line": 1,
            "column": 288
          }
        }
      }) : helper)) + '" aria-hidden="true" />';
    },
    "7": function(container, depth0, helpers2, partials, data) {
      return "</a>";
    },
    "9": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="issuer no-translate"><span>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "issuer") || (depth0 != null ? lookupProperty(depth0, "issuer") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "issuer",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 493
          },
          "end": {
            "line": 1,
            "column": 503
          }
        }
      }) : helper)) + "</span></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 89
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "customLogo") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.program(5, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 89
          },
          "end": {
            "line": 1,
            "column": 318
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 318
          },
          "end": {
            "line": 1,
            "column": 346
          }
        }
      })) != null ? stack1 : "") + '<h1><span class="title-text"><b class="no-translate">' + alias4((helper = (helper = lookupProperty(helpers2, "appName") || (depth0 != null ? lookupProperty(depth0, "appName") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "appName",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 399
          },
          "end": {
            "line": 1,
            "column": 410
          }
        }
      }) : helper)) + "</b>&nbsp;" + alias4((helper = (helper = lookupProperty(helpers2, "titleText") || (depth0 != null ? lookupProperty(depth0, "titleText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "titleText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 420
          },
          "end": {
            "line": 1,
            "column": 433
          }
        }
      }) : helper)) + "</span>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "issuer") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 440
          },
          "end": {
            "line": 1,
            "column": 523
          }
        }
      })) != null ? stack1 : "") + "</h1>";
    },
    "useData": true
  }),
  getTemplateData: function() {
    const {
      appState
    } = this.options;
    const {
      label,
      clientUri,
      logo
    } = appState.get("app");
    const {
      issuer: issuerObj
    } = appState.get("authentication");
    const customLogo = logo === null || logo === void 0 ? void 0 : logo.href;
    const altText = loc3("logo.for.the.app.alt.text", "login");
    const appName = oktaUnderscore.escape(label);
    const clientURI = clientUri === null || clientUri === void 0 ? void 0 : clientUri.href;
    const issuer = this.hasIssuer ? issuerObj === null || issuerObj === void 0 ? void 0 : issuerObj.uri : null;
    const titleText = this.titleText();
    return {
      customLogo,
      defaultLogo,
      clientURI,
      issuer,
      altText,
      appName,
      titleText
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/ConsentViewForm.js
var ConsentViewForm = BaseForm2.extend({
  noButtonBar: false,
  noCancelButton: false,
  buttonOrder: ["cancel", "save"],
  save: () => loc3("consent.required.consentButton", "login"),
  cancel: () => loc3("consent.required.cancelButton", "login"),
  title: false,
  events: {
    'click input[data-type="save"]': function() {
      this.setConsent(true);
    }
  },
  setConsent: function(bool) {
    this.model.set("consent", bool);
  },
  cancelForm: function() {
    this.setConsent(false);
    this.options.appState.trigger("saveForm", this.model);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/AdminConsentView.js
var AdminConsentView = BaseView2.extend({
  Header: AdminConsentViewHeader,
  Body: ConsentViewForm,
  createModelClass: function(currentViewState) {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const {
      uiSchema
    } = currentViewState;
    const {
      scopes
    } = uiSchema[0];
    const i18nKeyPrefix = "consent.scopes";
    const localizedScopes = scopes.map(({
      name,
      displayName,
      description
    }) => {
      const scopeKey = `${i18nKeyPrefix}.${name}`;
      const labelKey = `${scopeKey}.label`;
      const descKey = `${scopeKey}.desc`;
      const doesLabelExist = doesI18NKeyExist(labelKey);
      const doesDescExist = doesI18NKeyExist(descKey);
      const i18nDisplayName = doesLabelExist ? loc3(labelKey, "login") : displayName;
      const i18nDescription = doesDescExist ? loc3(descKey, "login") : description;
      return {
        name,
        displayName: i18nDisplayName,
        description: i18nDescription,
        isCustomized: !doesLabelExist
      };
    });
    return ModelClass.extend({
      props: {
        scopes: {
          type: "array",
          value: localizedScopes
        }
      },
      local: {
        consent: {
          type: "boolean",
          value: false
        }
      },
      toJSON: function() {
        return {
          consent: this.get("consent")
        };
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EnduserConsentViewFooter.js
var ConsentViewFooter = View2.extend({
  className: "consent-footer",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a class="terms-of-service" href="' + alias3((helper = (helper = lookupProperty(helpers2, "termsOfService") || (depth0 != null ? lookupProperty(depth0, "termsOfService") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "termsOfService",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 56
          },
          "end": {
            "line": 1,
            "column": 74
          }
        }
      }) : helper)) + '" target="_blank">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "consent.required.termsOfService"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 92
          },
          "end": {
            "line": 1,
            "column": 154
          }
        }
      })) + "</a>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 158
          },
          "end": {
            "line": 1,
            "column": 226
          }
        }
      })) != null ? stack1 : "");
    },
    "2": function(container, depth0, helpers2, partials, data) {
      return '<span class="no-translate">&#8226</span>';
    },
    "4": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a class="privacy-policy" href="' + alias3((helper = (helper = lookupProperty(helpers2, "privacyPolicy") || (depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "privacyPolicy",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 286
          },
          "end": {
            "line": 1,
            "column": 303
          }
        }
      }) : helper)) + '" target="_blank">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "consent.required.privacyPolicy"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 321
          },
          "end": {
            "line": 1,
            "column": 382
          }
        }
      })) + "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "termsOfService") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 233
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "privacyPolicy") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(4, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 233
          },
          "end": {
            "line": 1,
            "column": 393
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    const appState = this.options.appState;
    const app = appState.get("app");
    return {
      termsOfService: app.termsOfService && app.termsOfService.href,
      privacyPolicy: app.privacyPolicy && app.privacyPolicy.href
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EnduserConsentViewHeader.js
var EnduserConsentViewHeader = AdminConsentViewHeader.extend({
  titleText: () => loc3("oie.consent.scopes.enduser.title", "login"),
  hasIssuer: false
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EnduserConsentAgreementText.js
var EnduserConsentAgreementText = View2.extend({
  className: "consent-description detail-row",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "consent.required.description"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 3
          },
          "end": {
            "line": 1,
            "column": 62
          }
        }
      })) + "</p>";
    },
    "useData": true
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EnduserConsentView.js
var EnduserConsentView = AdminConsentView.extend({
  Header: EnduserConsentViewHeader,
  Footer: ConsentViewFooter,
  postRender: function() {
    const scopeList = this.$el.find(".scope-list");
    const consentAgreementText = new EnduserConsentAgreementText().render().el;
    scopeList.after(consentAgreementText);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/ScopeCheckBox.js
var CheckBox4 = internal.views.forms.inputs.CheckBox;
var ScopeCheckBox2 = CheckBox4.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<input type="checkbox" name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 29
          },
          "end": {
            "line": 1,
            "column": 37
          }
        }
      }) : helper)) + '" id="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 54
          }
        }
      }) : helper)) + '"/><label for="' + alias4((helper = (helper = lookupProperty(helpers2, "inputId") || (depth0 != null ? lookupProperty(depth0, "inputId") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "inputId",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 69
          },
          "end": {
            "line": 1,
            "column": 80
          }
        }
      }) : helper)) + '" data-se-for-name="' + alias4((helper = (helper = lookupProperty(helpers2, "name") || (depth0 != null ? lookupProperty(depth0, "name") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "name",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 100
          },
          "end": {
            "line": 1,
            "column": 108
          }
        }
      }) : helper)) + '"><b>' + alias4((helper = (helper = lookupProperty(helpers2, "placeholder") || (depth0 != null ? lookupProperty(depth0, "placeholder") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "placeholder",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 113
          },
          "end": {
            "line": 1,
            "column": 128
          }
        }
      }) : helper)) + "</b><p>" + alias4((helper = (helper = lookupProperty(helpers2, "desc") || (depth0 != null ? lookupProperty(depth0, "desc") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "desc",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 135
          },
          "end": {
            "line": 1,
            "column": 143
          }
        }
      }) : helper)) + "</p></label>";
    },
    "useData": true
  }),
  getLocalizedLabel: function() {
    const key = `consent.scopes.${this.options.options.scopeName}.label`;
    return doesI18NKeyExist(key) ? loc3(key, "login") : this.options.placeholder || this.options.options.scopeName;
  },
  getLocalizedDesc: function() {
    const key = `consent.scopes.${this.options.options.scopeName}.desc`;
    return doesI18NKeyExist(key) ? loc3(key, "login") : this.options.options.desc;
  },
  isCustomizedScope: function() {
    return !doesI18NKeyExist(`consent.scopes.${this.options.options.scopeName}.label`);
  },
  /**
   * @Override
   */
  enable: function() {
    if (this.options.options.mutable) {
      this.$(":input").prop("disabled", false);
    }
  },
  /**
   * @Override
   */
  editMode: function() {
    this.$el.html(this.template(oktaUnderscore.extend(oktaUnderscore.omit(this.options, "placeholder"), {
      placeholder: this.getLocalizedLabel(),
      desc: this.getLocalizedDesc()
    })));
    this.$(":checkbox").prop("checked", this.getModelValue() || false);
    this.$("input").customInput();
    this.model.trigger("form:resize");
    if (!this.options.options.mutable) {
      const input = this.$("input").get(0);
      this.$(input.parentElement).addClass("o-form-read-mode");
      this.$(":checkbox").prop("disabled", true);
    }
    if (this.options.options.scopeName === "openid" || this.isCustomizedScope()) {
      this.$("label > b").addClass("no-translate");
      if (this.isCustomizedScope()) {
        this.$("label > p").addClass("no-translate");
      }
    }
    return this;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/GranularConsentView.js
var granularConsentViewHeader = AdminConsentViewHeader.extend({
  hasIssuer: false,
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "clientURI") || (depth0 != null ? lookupProperty(depth0, "clientURI") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "clientURI",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 26
          },
          "end": {
            "line": 1,
            "column": 39
          }
        }
      }) : helper)) + '" class="client-logo-link" target="_blank">';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<img class="client-logo custom-logo" src="' + alias4((helper = (helper = lookupProperty(helpers2, "customLogo") || (depth0 != null ? lookupProperty(depth0, "customLogo") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "customLogo",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 149
          },
          "end": {
            "line": 1,
            "column": 163
          }
        }
      }) : helper)) + '" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "altText") || (depth0 != null ? lookupProperty(depth0, "altText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "altText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 170
          },
          "end": {
            "line": 1,
            "column": 181
          }
        }
      }) : helper)) + '" aria-hidden="true" />';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = "function", alias4 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<img class="client-logo default-logo" src="' + alias4((helper = (helper = lookupProperty(helpers2, "defaultLogo") || (depth0 != null ? lookupProperty(depth0, "defaultLogo") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "defaultLogo",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 255
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      }) : helper)) + '" alt="' + alias4((helper = (helper = lookupProperty(helpers2, "altText") || (depth0 != null ? lookupProperty(depth0, "altText") : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, {
        "name": "altText",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 277
          },
          "end": {
            "line": 1,
            "column": 288
          }
        }
      }) : helper)) + '" aria-hidden="true" />';
    },
    "7": function(container, depth0, helpers2, partials, data) {
      return "</a>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 89
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "customLogo") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.program(5, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 89
          },
          "end": {
            "line": 1,
            "column": 318
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "clientURI") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 318
          },
          "end": {
            "line": 1,
            "column": 346
          }
        }
      })) != null ? stack1 : "") + '<h1><span class="title-text">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
        "name": "i18n",
        "hash": {
          "$2": "<p>$2</p>",
          "$1": "<b class='no-translate'>$1</b>",
          "arguments": "appName",
          "bundle": "login",
          "code": "oie.consent.scopes.granular.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 375
          },
          "end": {
            "line": 1,
            "column": 511
          }
        }
      })) + "</span></h1>";
    },
    "useData": true
  })
});
var granularConsentViewForm = ConsentViewForm.extend({
  cancel: BaseForm2.prototype.cancel,
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    uiSchemas.forEach((schema) => {
      if (schema.type === "checkbox") {
        oktaUnderscore.assign(schema, {
          input: ScopeCheckBox2,
          options: {
            desc: schema.desc,
            mutable: schema.mutable,
            // need to extract scope name because it is in a subform (optedScopes.name)
            scopeName: schema.name.substring(schema.name.indexOf(".") + 1)
          }
        });
      }
    });
    return uiSchemas;
  }
});
var GranularConsentAgreementText = View2.extend({
  className: "consent-description",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.consent.scopes.granular.description"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 3
          },
          "end": {
            "line": 1,
            "column": 73
          }
        }
      })) + "</p>";
    },
    "useData": true
  })
});
var GranularConsentView = BaseView2.extend({
  Header: granularConsentViewHeader,
  Body: granularConsentViewForm,
  Footer: ConsentViewFooter,
  postRender: function() {
    const scopeList = this.$el.find(".o-form-fieldset-container");
    scopeList.before(new GranularConsentAgreementText().render().el);
    this.$(":disabled").each(function() {
      scopeList.append(oktaJQueryStatic(this).closest(".o-form-fieldset"));
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/consent/EnduserEmailConsentView.js
var getInfo = _Handlebars2.template({
  "1": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="enduser-email-consent--info no-translate"><i class="enduser-email-consent--icon icon--desktop"></i><div>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "browser") || (depth0 != null ? lookupProperty(depth0, "browser") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "browser",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 131
        },
        "end": {
          "line": 1,
          "column": 142
        }
      }
    }) : helper)) + "</div></div>";
  },
  "3": function(container, depth0, helpers2, partials, data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return '<div class="enduser-email-consent--info no-translate"><i class="enduser-email-consent--icon icon--app"></i><div>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "app") || (depth0 != null ? lookupProperty(depth0, "app") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
      "name": "app",
      "hash": {},
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 284
        },
        "end": {
          "line": 1,
          "column": 291
        }
      }
    }) : helper)) + "</div></div>";
  },
  "compiler": [8, ">= 4.3.0"],
  "main": function(container, depth0, helpers2, partials, data) {
    var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return parent[propertyName];
      }
      return void 0;
    };
    return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "browser") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(1, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 161
        }
      }
    })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "app") : depth0, {
      "name": "if",
      "hash": {},
      "fn": container.program(3, data, 0),
      "inverse": container.noop,
      "data": data,
      "loc": {
        "start": {
          "line": 1,
          "column": 161
        },
        "end": {
          "line": 1,
          "column": 310
        }
      }
    })) != null ? stack1 : "");
  },
  "useData": true
});
var enduserEmailConsentViewBody = ConsentViewForm.extend({
  className: "enduser-email-consent",
  title: function() {
    return loc3("oie.consent.enduser.title", "login");
  },
  save: function() {
    return loc3("oie.consent.enduser.accept.label", "login");
  },
  cancel: function() {
    return loc3("oie.consent.enduser.deny.label", "login");
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const info = getInfo(this.model.pick("browser", "app"));
    this.add(info);
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    return uiSchemas.filter((uiSchema) => uiSchema.name !== "consent");
  }
});
var EnduserEmailConsentView = BaseAuthenticatorView.extend({
  Header: EmailAuthenticatorHeader,
  buttonOrder: ["cancel", "save"],
  postRender: function() {
    const buttonContainer = this.$el.find(".o-form-button-bar");
    buttonContainer.find(".button-primary").removeClass("button-primary");
  },
  Body: enduserEmailConsentViewBody,
  createModelClass: function({
    requestInfo
  }) {
    const ModelClass = BaseAuthenticatorView.prototype.createModelClass.apply(this, arguments);
    const browser = requestInfo.find(({
      name
    }) => name === "browser");
    const app = requestInfo.find(({
      name
    }) => name === "appName");
    const local3 = Object.assign({
      browser: {
        type: "string",
        value: browser === null || browser === void 0 ? void 0 : browser.value
      },
      app: {
        type: "string",
        value: app === null || app === void 0 ? void 0 : app.value
      }
    }, ModelClass.prototype.local);
    return ModelClass.extend({
      local: local3,
      toJSON: function() {
        return {
          consent: this.get("consent")
        };
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/OktaVerifyAuthenticatorHeader.js
var OktaVerifyAuthenticatorHeader = BaseHeader.extend({
  HeaderBeacon: BaseAuthenticatorBeacon.extend({
    authenticatorKey: AUTHENTICATOR_KEY.OV
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/device/DeviceChallengePollView.js
var Body7 = Body.extend({
  pollingCancelAction: CANCEL_POLLING_ACTION,
  getDeviceChallengePayload: function() {
    return this.options.currentViewState.relatesTo.value;
  },
  doChallenge: function() {
    doChallenge(this, IDENTIFIER_FLOW);
  },
  onPollingFail: function() {
    Body.prototype.onPollingFail.apply(this, arguments);
    const data = {
      label: loc3("loopback.polling.cancel.link.with.form.error", "login")
    };
    this.options.appState.trigger("updateFooterLink", data);
  },
  showCustomFormErrorCallout: function(error) {
    const responseJSON = error.responseJSON;
    const options2 = {
      type: "error",
      className: "okta-verify-uv-callout-content",
      subtitle: responseJSON.errorSummary
    };
    const containsSignedNonceError = responseJSON.errorSummaryKeys && responseJSON.errorSummaryKeys.some((key) => key.includes("auth.factor.signedNonce.error"));
    if (containsSignedNonceError) {
      options2.title = loc3("user.fail.verifyIdentity", "login");
    }
    this.showMessages(createCallout(options2));
    return true;
  }
});
var Footer7 = BaseFooter.extend({
  initialize: function() {
    this.listenTo(this.options.appState, "updateFooterLink", this.handleUpdateFooterLink);
    if (this.isFallbackApproach() && !this.isFallbackDelayed()) {
      BaseFooter.prototype.initialize.apply(this, arguments);
    } else {
      this.backLink = this.add(Link, {
        options: {
          name: "cancel-authenticator-challenge",
          label: loc3("loopback.polling.cancel.link", "login"),
          clickHandler: () => {
            cancelPollingWithParams(this.options.appState, CANCEL_POLLING_ACTION, AUTHENTICATION_CANCEL_REASONS.USER_CANCELED, null);
          }
        }
      }).last();
    }
  },
  handleUpdateFooterLink: function(data) {
    if (!this.isFallbackApproach() || this.isFallbackDelayed()) {
      this.backLink && this.backLink.remove();
      this.backLink = this.add(Link, {
        options: getSignOutLink(this.options.settings, data)[0]
      }).last();
    }
  },
  isFallbackApproach: function() {
    return [Enums.CUSTOM_URI_CHALLENGE, Enums.UNIVERSAL_LINK_CHALLENGE, Enums.APP_LINK_CHALLENGE].includes(this.options.currentViewState.relatesTo.value.challengeMethod);
  },
  isFallbackDelayed: function() {
    return this.options.currentViewState.relatesTo.value.challengeMethod === Enums.APP_LINK_CHALLENGE;
  }
});
var DeviceChallengePollView = BaseView2.extend({
  Header: OktaVerifyAuthenticatorHeader,
  Body: Body7,
  Footer: Footer7
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/device/SSOExtensionView.js
var Body8 = BaseForm2.extend({
  noButtonBar: true,
  className: "ion-form device-challenge-poll",
  title: function() {
    return loc3("deviceTrust.sso.redirectText", "login");
  },
  initialize: function() {
    var _this$options$current, _this$options$current2;
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "error", () => {
      this.$(".spinner").hide();
    });
    this.add('<div class="spinner"></div>');
    const isGetMethod = ((_this$options$current = this.options.currentViewState) === null || _this$options$current === void 0 ? void 0 : (_this$options$current2 = _this$options$current.method) === null || _this$options$current2 === void 0 ? void 0 : _this$options$current2.toLowerCase()) === "get";
    this.model.set("useRedirect", isGetMethod);
    this.trigger("save", this.model);
  }
});
var SSOExtensionView = BaseView2.extend({
  Body: Body8
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/device/SignInDeviceView.js
var Body9 = BaseForm2.extend({
  title: function() {
    return loc3("primaryauth.title", "login");
  },
  noButtonBar: true,
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.add(SignInWithDeviceOption, {
      selector: ".o-form-fieldset-container",
      bubble: false,
      prepend: true,
      options: {
        isRequired: true
      }
    });
  }
});
var Footer8 = IdentifierFooter.extend({
  hasBackToSignInLink: false
});
var SignInDeviceView = BaseView2.extend({
  Body: Body9,
  Footer: Footer8
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/OdaOktaVerifyTerminalView.js
var {
  Notification: Notification2
} = internal.views.components;
var {
  Clipboard: Clipboard2
} = internal.util;
var getDeviceEnrollmentContext = (deviceEnrollment) => {
  const platform = (deviceEnrollment.platform || "").toLowerCase();
  const challengeMethod = deviceEnrollment.challengeMethod;
  const enrollmentType = deviceEnrollment.name;
  const isIOS = platform === Enums.IOS;
  const isAndroidAppLink = platform === Enums.ANDROID && challengeMethod === "APP_LINK";
  const isAndroidLoopback = platform === Enums.ANDROID && challengeMethod === "LOOPBACK";
  return {
    signInUrl: deviceEnrollment.signInUrl,
    isIOS,
    enrollmentType,
    isAndroidLoopback,
    isAndroidAppLink,
    appStoreLink: isIOS ? Enums.OKTA_VERIFY_APPLE_APP_STORE_URL : Enums.OKTA_VERIFY_GOOGLE_PLAY_STORE_URL,
    orgName: deviceEnrollment.orgName
  };
};
var BaseOdaOktaVerifyTerminalView = View2.extend({
  getTemplateData: function() {
    const deviceEnrollment = this.options.appState.get("deviceEnrollment");
    return getDeviceEnrollmentContext(deviceEnrollment);
  }
});
var IosAndAndroidLoopbackOdaTerminalView = BaseOdaOktaVerifyTerminalView.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.step.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 120
          },
          "end": {
            "line": 1,
            "column": 175
          }
        }
      })) + '<a data-clipboard-text="' + alias3((helper = (helper = lookupProperty(helpers2, "appStoreLink") || (depth0 != null ? lookupProperty(depth0, "appStoreLink") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "appStoreLink",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 199
          },
          "end": {
            "line": 1,
            "column": 215
          }
        }
      }) : helper)) + '" class="button link-button copy-clipboard-button">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 266
          },
          "end": {
            "line": 1,
            "column": 316
          }
        }
      })) + "</a></li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.step.pasteLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 329
          },
          "end": {
            "line": 1,
            "column": 385
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step3"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 394
          },
          "end": {
            "line": 1,
            "column": 441
          }
        }
      })) + "</li>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<li>" + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.android.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 482
          },
          "end": {
            "line": 1,
            "column": 537
          }
        }
      })) + "</li>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, alias4 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="explanation" data-se="subheader">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.explanation.p1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 95
          }
        }
      })) + "</p><ol>" + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isIOS") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 103
          },
          "end": {
            "line": 1,
            "column": 453
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "isAndroidLoopback") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 453
          },
          "end": {
            "line": 1,
            "column": 549
          }
        }
      })) != null ? stack1 : "") + "<li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 553
          },
          "end": {
            "line": 1,
            "column": 600
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 609
          },
          "end": {
            "line": 1,
            "column": 656
          }
        }
      })) + '<p class="org-signin-link"><span class="no-translate">' + alias3((helper = (helper = lookupProperty(helpers2, "signInUrl") || (depth0 != null ? lookupProperty(depth0, "signInUrl") : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, {
        "name": "signInUrl",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 710
          },
          "end": {
            "line": 1,
            "column": 723
          }
        }
      }) : helper)) + '</span></p><a data-clipboard-text="' + alias3((helper = (helper = lookupProperty(helpers2, "signInUrl") || (depth0 != null ? lookupProperty(depth0, "signInUrl") : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, {
        "name": "signInUrl",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 758
          },
          "end": {
            "line": 1,
            "column": 771
          }
        }
      }) : helper)) + '" class="button link-button copy-org-clipboard-button">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.org.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 826
          },
          "end": {
            "line": 1,
            "column": 880
          }
        }
      })) + "</a></li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step6"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 893
          },
          "end": {
            "line": 1,
            "column": 940
          }
        }
      })) + "</li></ol>";
    },
    "useData": true
  }),
  postRender: function() {
    Clipboard2.attach(".copy-clipboard-button").done(() => {
      let notification = new Notification2({
        message: loc3("enroll.mdm.copyLink.success", "login"),
        level: "success"
      });
      this.el.prepend(notification.render().el);
      return false;
    });
    Clipboard2.attach(".copy-org-clipboard-button").done(() => {
      let notification = new Notification2({
        message: loc3("enroll.oda.org.copyLink.success", "login"),
        level: "success"
      });
      this.el.prepend(notification.render().el);
      return false;
    });
  }
});
var AndroidAppLinkWithAccountOdaTerminalView = BaseOdaOktaVerifyTerminalView.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="explanation" data-se="subheader">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.explanation"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 109
          }
        }
      })) + '</p><p class="subtitle">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.subtitile1 "
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 133
          },
          "end": {
            "line": 1,
            "column": 199
          }
        }
      })) + "</p><ul><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 211
          },
          "end": {
            "line": 1,
            "column": 271
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 280
          },
          "end": {
            "line": 1,
            "column": 340
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step3"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 349
          },
          "end": {
            "line": 1,
            "column": 409
          }
        }
      })) + '</li></ul><p class="subtitle">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.subtitile2 "
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 439
          },
          "end": {
            "line": 1,
            "column": 505
          }
        }
      })) + "</p><ol><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step4"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 517
          },
          "end": {
            "line": 1,
            "column": 577
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "arguments": "signInUrl",
          "bundle": "login",
          "code": "enroll.oda.with.account.step5"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 586
          },
          "end": {
            "line": 1,
            "column": 668
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step6"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 677
          },
          "end": {
            "line": 1,
            "column": 737
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.with.account.step7"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 746
          },
          "end": {
            "line": 1,
            "column": 806
          }
        }
      })) + "</li></ol>";
    },
    "useData": true
  })
});
var AndroidAppLinkWithoutAccountOdaTerminalView = BaseOdaOktaVerifyTerminalView.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, alias4 = "function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="explanation" data-se="subheader">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.without.account.explanation"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 43
          },
          "end": {
            "line": 1,
            "column": 112
          }
        }
      })) + "</p><ol><li>" + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "arguments": "appStoreLink",
          "bundle": "login",
          "code": "enroll.oda.without.account.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 124
          },
          "end": {
            "line": 1,
            "column": 214
          }
        }
      })) != null ? stack1 : "") + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 223
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.step2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 279
          },
          "end": {
            "line": 1,
            "column": 326
          }
        }
      })) + '<p class="org-signin-link"><span class="no-translate">' + alias3((helper = (helper = lookupProperty(helpers2, "signInUrl") || (depth0 != null ? lookupProperty(depth0, "signInUrl") : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, {
        "name": "signInUrl",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 380
          },
          "end": {
            "line": 1,
            "column": 393
          }
        }
      }) : helper)) + '</span></p><a data-clipboard-text="' + alias3((helper = (helper = lookupProperty(helpers2, "signInUrl") || (depth0 != null ? lookupProperty(depth0, "signInUrl") : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, {
        "name": "signInUrl",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 428
          },
          "end": {
            "line": 1,
            "column": 441
          }
        }
      }) : helper)) + '" class="button link-button copy-org-clipboard-button">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.org.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 496
          },
          "end": {
            "line": 1,
            "column": 550
          }
        }
      })) + "</a></li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.oda.without.account.step4"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 563
          },
          "end": {
            "line": 1,
            "column": 626
          }
        }
      })) + "</li></ol>";
    },
    "useData": true
  }),
  postRender: function() {
    Clipboard2.attach(".copy-org-clipboard-button").done(() => {
      let notification = new Notification2({
        message: loc3("enroll.oda.org.copyLink.success", "login"),
        level: "success"
      });
      this.el.prepend(notification.render().el);
      return false;
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/MdmOktaVerifyTerminalView.js
var {
  Notification: Notification3
} = internal.views.components;
var {
  Clipboard: Clipboard3
} = internal.util;
var MdmOktaVerifyTerminalView = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<div>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.explanation.mdm"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 5
          },
          "end": {
            "line": 1,
            "column": 58
          }
        }
      })) + "</div><ol><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.step.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 72
          },
          "end": {
            "line": 1,
            "column": 127
          }
        }
      })) + '<a data-clipboard-text="' + alias3((helper = (helper = lookupProperty(helpers2, "enrollmentLink") || (depth0 != null ? lookupProperty(depth0, "enrollmentLink") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "enrollmentLink",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 151
          },
          "end": {
            "line": 1,
            "column": 169
          }
        }
      }) : helper)) + '" class="button link-button copy-clipboard-button">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.copyLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 220
          },
          "end": {
            "line": 1,
            "column": 270
          }
        }
      })) + "</a></li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.step.pasteLink"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 283
          },
          "end": {
            "line": 1,
            "column": 339
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "$1": "<span class='semi-strong'>$1</span>",
          "arguments": "vendor",
          "bundle": "login",
          "code": "enroll.mdm.step.followInstructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 348
          },
          "end": {
            "line": 1,
            "column": 473
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.mdm.step.relogin"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 482
          },
          "end": {
            "line": 1,
            "column": 536
          }
        }
      })) + "</li></ol>";
    },
    "useData": true
  }),
  getTemplateData: function() {
    return this.options.appState.get("deviceEnrollment");
  },
  postRender: function() {
    Clipboard3.attach(".copy-clipboard-button").done(() => {
      let notification = new Notification3({
        message: loc3("enroll.mdm.copyLink.success", "login"),
        level: "success"
      });
      this.el.prepend(notification.render().el);
      return false;
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/device/DeviceEnrollmentTerminalView.js
var BaseDeviceEnrollTerminalForm = BaseForm2.extend({
  noButtonBar: true,
  className: "device-enrollment-terminal"
});
var AndroidAppLinkPreselectForm = BaseForm2.extend({
  attributes: {
    "data-se": "android-app-link-setup-options-terminal"
  },
  title: function() {
    return loc3("enroll.title.oda.with.account", "login");
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const deviceEnrollmentContext = getDeviceEnrollmentContext(this.options.appState.get("deviceEnrollment"));
    this.model.set("hasOVAccount", "no");
    this.addInput({
      label: () => loc3("enroll.subtitle.fastpass", "login", [deviceEnrollmentContext.orgName]),
      "label-top": true,
      options: {
        "no": loc3("enroll.option.noaccount.fastpass", "login"),
        "yes": loc3("enroll.option.account.fastpass", "login")
      },
      name: "hasOVAccount",
      type: "radio"
    });
  },
  saveForm: function() {
    this.$el.find(".o-form-error-container").empty();
    this.options.appState.trigger("updateDeviceEnrollmentView", this.model.get("hasOVAccount") === "yes");
  }
});
var AndroidAppLinkWithAccountOdaTerminalForm = BaseDeviceEnrollTerminalForm.extend({
  attributes: {
    "data-se": "android-oda-app-link-with-ov-account-terminal"
  },
  title: function() {
    return loc3("enroll.title.oda.with.account", "login");
  },
  initialize: function() {
    BaseDeviceEnrollTerminalForm.prototype.initialize.apply(this, arguments);
    this.add(AndroidAppLinkWithAccountOdaTerminalView);
  }
});
var AndroidAppLinkWithoutAccountOdaTerminalForm = BaseDeviceEnrollTerminalForm.extend({
  attributes: {
    "data-se": "android-oda-app-link-without-ov-account-terminal"
  },
  title: function() {
    return loc3("enroll.title.oda.without.account", "login");
  },
  initialize: function() {
    BaseDeviceEnrollTerminalForm.prototype.initialize.apply(this, arguments);
    this.add(AndroidAppLinkWithoutAccountOdaTerminalView);
  }
});
var IosAndAndroidLoopbackOdaTerminalForm = BaseDeviceEnrollTerminalForm.extend({
  attributes: {
    "data-se": "loopback-terminal"
  },
  title: function() {
    return loc3("enroll.title.oda", "login");
  },
  initialize: function() {
    BaseDeviceEnrollTerminalForm.prototype.initialize.apply(this, arguments);
    this.add(IosAndAndroidLoopbackOdaTerminalView);
  }
});
var MdmTerminalForm = BaseDeviceEnrollTerminalForm.extend({
  attributes: {
    "data-se": "mdm-terminal"
  },
  title: function() {
    return loc3("enroll.title.mdm", "login");
  },
  initialize: function() {
    BaseDeviceEnrollTerminalForm.prototype.initialize.apply(this, arguments);
    this.add(MdmOktaVerifyTerminalView);
  }
});
var AndroidAppLinkTerminalViewFooter = Link.extend({
  postRender: function() {
    this.$el.click((event) => {
      event.preventDefault();
      this.options.appState.trigger("switchBackToPreselect");
    });
  }
});
var DeviceEnrollmentTerminalView = BaseView2.extend({
  initialize: function() {
    BaseView2.prototype.initialize.apply(this, arguments);
    this.listenTo(this.options.appState, "updateDeviceEnrollmentView", this.handleUpdateDeviceEnrollmentView);
    this.listenTo(this.options.appState, "switchBackToPreselect", this.handleSwitchBackToPreselect);
    const deviceEnrollmentContext = getDeviceEnrollmentContext(this.options.appState.get("deviceEnrollment"));
    this.enrollmentType = (deviceEnrollmentContext.enrollmentType || "").toLowerCase();
    switch (this.enrollmentType) {
      case Enums.ODA:
        this.Header = OktaVerifyAuthenticatorHeader;
        this.Body = deviceEnrollmentContext.isAndroidAppLink ? AndroidAppLinkPreselectForm : IosAndAndroidLoopbackOdaTerminalForm;
        break;
      case Enums.MDM:
        this.Body = MdmTerminalForm;
        break;
    }
  },
  handleUpdateDeviceEnrollmentView: function(withAccount) {
    this.Body = withAccount ? AndroidAppLinkWithAccountOdaTerminalForm : AndroidAppLinkWithoutAccountOdaTerminalForm;
    this.backLink = this.add(AndroidAppLinkTerminalViewFooter, {
      options: {
        name: "back-to-preselect",
        label: loc3("oform.back", "login")
      }
    }).last();
    this.renderForm();
  },
  handleSwitchBackToPreselect: function() {
    this.Body = AndroidAppLinkPreselectForm;
    this.backLink && this.backLink.remove();
    this.render();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/PasswordPolicyUtil.js
var generatePasswordPolicyHtml = function(form2, rulesList, prepend) {
  form2.add(View2.extend({
    tagName: "section",
    template: _Handlebars2.template({
      "1": function(container, depth0, helpers2, partials, data) {
        return "<li>" + container.escapeExpression(container.lambda(depth0, depth0)) + "</li>";
      },
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<div class="password-authenticator--heading">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(alias1, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "password.complexity.requirements.header"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 45
            },
            "end": {
              "line": 1,
              "column": 115
            }
          }
        })) + '</div><ul class="password-authenticator--list">' + ((stack1 = lookupProperty(helpers2, "each").call(alias1, depth0 != null ? lookupProperty(depth0, "rulesList") : depth0, {
          "name": "each",
          "hash": {},
          "fn": container.program(1, data, 0),
          "inverse": container.noop,
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 162
            },
            "end": {
              "line": 1,
              "column": 207
            }
          }
        })) != null ? stack1 : "") + "</ul>";
      },
      "useData": true
    }),
    getTemplateData: () => ({
      rulesList
    }),
    attributes: {
      "data-se": "password-authenticator--rules"
    }
  }), {
    prepend,
    selector: ".o-form-fieldset-container"
  });
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/EnrollProfileView.js
var Body10 = BaseForm2.extend({
  title: function() {
    if (this.options.appState.getCurrentViewState().href.endsWith("idp/idx/enroll/update")) {
      var _attributes$uiDisplay;
      const attributes2 = this.options.appState.attributes;
      if (attributes2 !== null && attributes2 !== void 0 && (_attributes$uiDisplay = attributes2.uiDisplay) !== null && _attributes$uiDisplay !== void 0 && _attributes$uiDisplay.label) {
        return loc3("oie.registration.form.customize.label", "login", [attributes2.uiDisplay.label]);
      } else {
        return loc3("oie.primaryauth.submit", "login");
      }
    }
    return loc3("oie.registration.form.title", "login");
  },
  save: function() {
    if (this.options.appState.getCurrentViewState().href.endsWith("idp/idx/enroll/update")) {
      var _attributes$uiDisplay2;
      const attributes2 = this.options.appState.attributes;
      if (attributes2 !== null && attributes2 !== void 0 && (_attributes$uiDisplay2 = attributes2.uiDisplay) !== null && _attributes$uiDisplay2 !== void 0 && _attributes$uiDisplay2.buttonLabel) {
        return loc3("oie.registration.form.customize.buttonLabel", "login", [attributes2.uiDisplay.buttonLabel]);
      } else {
        return loc3("oie.registration.form.update.submit", "login");
      }
    }
    return loc3("oie.registration.form.submit", "login");
  },
  saveForm: function() {
    this.settings.preRegistrationSubmit(this.model.toJSON(), (postData) => {
      this.model.attributes = __spreadValues(__spreadValues({}, this.model.attributes), this.model.parse(postData));
      BaseForm2.prototype.saveForm.call(this, this.model);
    }, (error) => this.model.trigger("error", this.model, {
      responseJSON: error
    }));
  },
  triggerAfterError: function(model, error) {
    var _error$responseJSON;
    const hasErrors = (error === null || error === void 0 ? void 0 : (_error$responseJSON = error.responseJSON) === null || _error$responseJSON === void 0 ? void 0 : _error$responseJSON.errorCauses) && Array.isArray(error.responseJSON.errorCauses);
    if (hasErrors) {
      error.responseJSON.errorCauses.forEach((err) => {
        var _err$errorKey;
        if ((_err$errorKey = err.errorKey) !== null && _err$errorKey !== void 0 && _err$errorKey.includes("password.passwordRequirementsNotMet")) {
          err.errorSummary = loc3("registration.error.password.passwordRequirementsNotMet", "login");
        }
      });
    }
    this.options.appState.trigger("afterError", error);
  }
});
var Footer9 = BaseFooter.extend({
  links: function() {
    const links = [];
    if (this.options.appState.hasRemediationObject(FORMS.SELECT_IDENTIFY)) {
      links.push({
        "type": "link",
        "label": loc3("haveaccount", "login"),
        "name": "back",
        "actionPath": FORMS.SELECT_IDENTIFY
      });
    }
    return links;
  }
});
var EnrollProfileView = BaseView2.extend({
  Body: Body10,
  Footer: Footer9,
  createModelClass: function(currentViewState, optionUiSchemaConfig, settings) {
    const currentSchema = JSON.parse(JSON.stringify(currentViewState.uiSchema));
    let ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments, currentViewState);
    ModelClass = ModelClass.extend({
      toJSON: function() {
        const modelJSON = Model2.prototype.toJSON.call(this, arguments, currentViewState);
        if (modelJSON.userProfile) {
          const uiSchema = currentViewState.uiSchema;
          const userProfile = modelJSON.userProfile;
          oktaUnderscore.each(userProfile, (value, name) => {
            if (oktaUnderscore.isEmpty(value)) {
              const uiSchemaProperty = uiSchema.find((schema) => schema.name === `userProfile.${name}`);
              if (!oktaUnderscore.isUndefined(uiSchemaProperty) && !uiSchemaProperty.required) {
                delete userProfile[name];
              }
            }
          });
        }
        return modelJSON;
      }
    });
    settings.parseRegistrationSchema(currentSchema, (schema) => {
      if (!oktaUnderscore.isEqual(schema, currentViewState.uiSchema)) {
        currentViewState.uiSchema = schema;
        ModelClass = BaseView2.prototype.createModelClass.call(this, currentViewState, optionUiSchemaConfig);
      }
    }, (error) => {
      ModelClass = ModelClass.extend({
        local: __spreadValues({
          parseSchemaError: {
            value: error,
            type: "object"
          }
        }, ModelClass.prototype.local)
      });
    });
    return ModelClass;
  },
  postRender: function() {
    BaseView2.prototype.postRender.apply(this, arguments);
    const modelError = this.model.get("parseSchemaError");
    if (modelError) {
      this.model.trigger("error", this.model, {
        responseJSON: modelError
      });
    }
    this.renderPasswordPolicySettings();
    const idpButtons = createIdpButtons(this.options);
    if (Array.isArray(idpButtons) && idpButtons.length) {
      this._addIdpView(idpButtons);
    }
  },
  renderPasswordPolicySettings: function() {
    var _credentials$form;
    const currentViewState = this.options.currentViewState.value;
    const credentials = currentViewState.filter((obj) => {
      return obj.name === "credentials";
    })[0];
    const form2 = credentials === null || credentials === void 0 ? void 0 : (_credentials$form = credentials.form) === null || _credentials$form === void 0 ? void 0 : _credentials$form.value;
    if (form2 && form2.filter((obj) => {
      return obj.name === "passcode";
    })) {
      var _credentials$relatesT, _credentials$relatesT2;
      generatePasswordPolicyHtml(this, getPasswordComplexityDescriptionForHtmlList(credentials === null || credentials === void 0 ? void 0 : (_credentials$relatesT = credentials.relatesTo) === null || _credentials$relatesT === void 0 ? void 0 : (_credentials$relatesT2 = _credentials$relatesT.value) === null || _credentials$relatesT2 === void 0 ? void 0 : _credentials$relatesT2.settings), false);
    }
  },
  _addIdpView: function(idpButtons) {
    const idpDisplay = this.options.settings.get("idpDisplay");
    const isPrimaryIdpDisplay = idpDisplay && idpDisplay.toUpperCase() === "PRIMARY";
    this.add(signInWithIdps, {
      prepend: isPrimaryIdpDisplay,
      selector: isPrimaryIdpDisplay ? ".o-form-fieldset-container" : ".o-form-button-bar",
      options: {
        idpButtons,
        isPrimaryIdpDisplay
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/EnrollProfileUpdateView.js
var Body11 = BaseForm2.extend({
  className: "profile-update",
  title: function() {
    return loc3("oie.profile.additional.title", "login");
  },
  save: function() {
    return loc3("enroll.choices.submit.finish", "login");
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    uiSchemas.forEach((input) => {
      if (input.name === "userProfile.secondEmail") {
        input.explain = View2.extend({
          template: _Handlebars2.template({
            "compiler": [8, ">= 4.3.0"],
            "main": function(container, depth0, helpers2, partials, data) {
              var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                  return parent[propertyName];
                }
                return void 0;
              };
              return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
                "name": "i18n",
                "hash": {
                  "$1": "<span class='strong'>$1</span>",
                  "bundle": "login",
                  "code": "oie.profile.additional.secondemail.subtitle"
                },
                "data": data,
                "loc": {
                  "start": {
                    "line": 1,
                    "column": 0
                  },
                  "end": {
                    "line": 1,
                    "column": 112
                  }
                }
              })) != null ? stack1 : "";
            },
            "useData": true
          })
        });
      }
    });
    return uiSchemas;
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
  }
});
var Footer10 = BaseFooter.extend({
  className: "auth-footer side-by-side-links",
  links: function() {
    const {
      uiSchema
    } = this.options.currentViewState;
    const optionalParams = uiSchema.filter((item) => item.required === false);
    if (uiSchema.length === optionalParams.length) {
      return getSkipSetupLink(this.options.appState, loc3("oie.enroll.skip.profile", "login"));
    } else {
      this.$el.removeClass(".side-by-side-links");
    }
  }
});
var EnrollProfileUpdateView = BaseView2.extend({
  Body: Body11,
  Footer: Footer10,
  postRender: function() {
    BaseView2.prototype.postRender.apply(this, arguments);
    if (this.options.appState.getSchemaByName("userProfile.secondEmail")) {
      this.model.set("userProfile.secondEmail", "");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/activation/RequestActivationEmailView.js
var Body12 = BaseForm2.extend({
  title: function() {
    return loc3("oie.activation.request.email.title.expire", "login");
  },
  save: function() {
    return loc3("oie.activation.request.email.button", "login");
  }
});
var RequestActivationEmail = BaseView2.extend({
  Body: Body12
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/SelectAuthenticatorEnrollView.js
var Body13 = BaseForm2.extend({
  title: function() {
    return loc3("oie.select.authenticators.enroll.title", "login");
  },
  subtitle: function() {
    const subtitle = this.options.settings.get("brandName") ? loc3("oie.select.authenticators.enroll.subtitle.custom", "login", [this.options.settings.get("brandName")]) : loc3("oie.select.authenticators.enroll.subtitle", "login");
    return subtitle;
  },
  noButtonBar: true
});
var SelectAuthenticatorEnrollView = BaseView2.extend({
  Body: Body13
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/SelectAuthenticatorVerifyView.js
var UNLOCK_USER_SUCCESS_MESSAGE2 = "oie.selfservice.unlock_user.landing.to.app.success.message";
var Body14 = BaseForm2.extend({
  title: function() {
    if (this.isPasswordRecoveryFlow()) {
      return loc3("password.reset.title.generic", "login");
    }
    return loc3("oie.select.authenticators.verify.title", "login");
  },
  subtitle: function() {
    if (this.isPasswordRecoveryFlow()) {
      return loc3("oie.password.reset.verification", "login");
    }
    if (this.isUnlockSuccess()) {
      const container = ".o-form-error-container";
      const text = loc3("oie.select.authenticators.verify.subtitle", "login");
      this.add(`<div class="ion-messages-container"><p>${text}</p></div>`, container);
      return;
    }
    return loc3("oie.select.authenticators.verify.subtitle", "login");
  },
  isPasswordRecoveryFlow: function() {
    return this.options.appState.get("isPasswordRecovery");
  },
  noButtonBar: true,
  showMessages: function() {
    if (this.isUnlockSuccess()) {
      let options2 = {};
      options2.subtitle = loc3("oie.selfservice.unlock_user.landing.to.app.success.message", "login");
      options2.type = "success";
      options2 = createCallout(options2);
      BaseForm2.prototype.showMessages.call(this, options2);
      return;
    }
    BaseForm2.prototype.showMessages.call(this);
  },
  isUnlockSuccess: function() {
    return this.options.appState.containsMessageWithI18nKey(UNLOCK_USER_SUCCESS_MESSAGE2);
  }
});
var SelectAuthenticatorVerifyView = BaseView2.extend({
  Body: Body14,
  Footer: BaseFooter.extend({
    links: function() {
      return getFactorPageCustomLink(this.options.appState, this.options.settings);
    }
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/authenticator/SelectAuthenticatorUnlockAccountView.js
var UnlockAccountView = BaseForm2.extend({
  noButtonBar: true,
  title: () => {
    return loc3("unlockaccount", "login");
  }
});
var SelectAuthenticatorUnlockAccountView = BaseView2.extend({
  initialize: function() {
    BaseView2.prototype.initialize.apply(this, arguments);
    this.Body = UnlockAccountView;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/EnrollAuthenticatorPasswordView.js
var Body15 = BaseForm2.extend({
  title: function() {
    return loc3("oie.password.enroll.title", "login");
  },
  save: function() {
    return loc3("oform.next", "login");
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const policy = this.getPasswordPolicySettings();
    this.displayPasswordPolicy(policy);
  },
  displayPasswordPolicy: function(policy) {
    if (policy) {
      const rulesList = getPasswordComplexityDescriptionForHtmlList(policy);
      generatePasswordPolicyHtml(this, rulesList, true);
    }
  },
  triggerAfterError: function(model, error) {
    error.responseJSON = removeRequirementsFromError(error.responseJSON);
    this.options.appState.trigger("afterError", error);
  },
  getPasswordPolicySettings: function() {
    var _relatesToObject$valu;
    const relatesToObject = this.options.currentViewState.relatesTo;
    return relatesToObject === null || relatesToObject === void 0 ? void 0 : (_relatesToObject$valu = relatesToObject.value) === null || _relatesToObject$valu === void 0 ? void 0 : _relatesToObject$valu.settings;
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const confirmPassword = {
      name: "confirmPassword",
      label: loc3("oie.password.confirmPasswordLabel", "login"),
      type: "password",
      "label-top": true,
      params: {
        showPasswordToggle: this.settings.get("showPasswordToggle")
      }
    };
    const updatedSchema = [];
    for (let field of uiSchemas) {
      updatedSchema.push(field);
      if (field.name === "credentials.passcode") {
        updatedSchema.push(confirmPassword);
      }
    }
    return updatedSchema;
  }
});
var EnrollAuthenticatorPasswordView = BaseAuthenticatorView.extend({
  Body: Body15,
  createModelClass: function() {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const local3 = Object.assign({
      confirmPassword: {
        type: "string",
        required: true
      }
    }, ModelClass.prototype.local);
    return ModelClass.extend({
      local: local3,
      validate: function() {
        if (this.get("credentials.passcode") !== this.get("confirmPassword") && this.get("credential.value") !== this.get("confirmPassword")) {
          const errors = {
            "confirmPassword": loc3("password.error.match", "login")
          };
          return errors;
        } else {
          return null;
        }
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/ChallengeAuthenticatorPasswordView.js
var Body16 = BaseForm2.extend({
  title: function() {
    return loc3("oie.password.challenge.title", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  /**
   * Update UI schemas for customization from .widgetrc.js or Admin Customization settings page.
   * @returns Array
   */
  getUISchema: function() {
    const schemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const {
      settings
    } = this.options;
    const passwordExplainLabeli18nKey = "primaryauth.password.tooltip";
    const passwordSchema = schemas.find(({
      name
    }) => name === "credentials.passcode");
    if (passwordSchema && isCustomizedI18nKey(passwordExplainLabeli18nKey, settings)) {
      passwordSchema.explain = loc3(passwordExplainLabeli18nKey, "login");
      passwordSchema["explain-top"] = true;
    }
    return schemas;
  }
});
var Footer11 = AuthenticatorFooter.extend({
  links: function() {
    let links = AuthenticatorFooter.prototype.links.apply(this, arguments);
    links = getForgotPasswordLink(this.options.appState, this.options.settings).concat(links);
    return links;
  }
});
var ChallengeAuthenticatorPasswordView = BaseAuthenticatorView.extend({
  Body: Body16,
  Footer: Footer11
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/ReEnrollAuthenticatorPasswordView.js
var Body17 = EnrollAuthenticatorPasswordView.prototype.Body.extend({
  className: "password-authenticator",
  title: function() {
    const title = this.options.settings.get("brandName") ? loc3("password.expired.title.specific", "login", [this.options.settings.get("brandName")]) : loc3("password.expired.title.generic", "login");
    return title;
  },
  save: function() {
    return loc3("password.expired.submit", "login");
  },
  getPasswordPolicySettings: function() {
    var _this$options$appStat, _this$options$appStat2;
    return ((_this$options$appStat = this.options.appState.get("recoveryAuthenticator")) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.settings) || ((_this$options$appStat2 = this.options.appState.get("enrollmentAuthenticator")) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.settings);
  }
});
var ReEnrollAuthenticatorPasswordView = EnrollAuthenticatorPasswordView.extend({
  Body: Body17
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/ReEnrollAuthenticatorWarningPasswordView.js
var Body18 = EnrollAuthenticatorPasswordView.prototype.Body.extend({
  className: "password-authenticator",
  subtitle: function() {
    if (this.options.settings.get("brandName")) {
      return loc3("password.expiring.subtitle.specific", "login", [this.options.settings.get("brandName")]);
    }
  },
  title: function() {
    const passwordPolicy = this.getPasswordPolicySettings() || {};
    const daysToExpiry = passwordPolicy.daysToExpiry;
    if (daysToExpiry > 0) {
      return loc3("password.expiring.title", "login", [daysToExpiry]);
    } else if (daysToExpiry === 0) {
      return loc3("password.expiring.today", "login");
    } else {
      return loc3("password.expiring.soon", "login");
    }
  },
  save: function() {
    return loc3("password.expired.submit", "login");
  },
  showMessages: function() {
    if (this.options.settings.get("brandName")) {
      return null;
    }
    EnrollAuthenticatorPasswordView.prototype.Body.prototype.showMessages.apply(this, arguments);
  }
});
var Footer12 = BaseFooter.extend({
  links: function() {
    const links = [];
    if (this.options.appState.hasRemediationObject("skip")) {
      links.push({
        "type": "link",
        "label": loc3("password.expiring.later", "login"),
        "name": "skip",
        "actionPath": "skip"
      });
    }
    return links;
  }
});
var ReEnrollAuthenticatorWarningPasswordView = EnrollAuthenticatorPasswordView.extend({
  Body: Body18,
  Footer: Footer12
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/password/ResetAuthenticatorPasswordView.js
var Body19 = EnrollAuthenticatorPasswordView.prototype.Body.extend({
  className: "password-authenticator",
  title: function() {
    const title = this.options.settings.get("brandName") ? loc3("password.reset.title.specific", "login", [this.options.settings.get("brandName")]) : loc3("password.reset.title.generic", "login");
    return title;
  },
  save: function() {
    return loc3("password.reset", "login");
  }
});
var ResetAuthenticatorPasswordView = EnrollAuthenticatorPasswordView.extend({
  Body: Body19
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/BaseResendView.js
var BaseResendView = View2.extend({
  postRender: function() {
    this.showCalloutAfterTimeout();
  },
  showCalloutAfterTimeout: function() {
    const timeStamp = sessionStorageHelper.getResendTimestamp();
    if (!timeStamp) {
      sessionStorageHelper.setResendTimestamp(Date.now());
    }
    this.showMeInterval = setInterval(() => {
      const start = sessionStorageHelper.getResendTimestamp();
      const now = Date.now();
      if (now - start >= SHOW_RESEND_TIMEOUT) {
        this.$el.removeClass("hide");
        clearInterval(this.showMeInterval);
        sessionStorageHelper.removeResendTimestamp();
      }
    }, 250);
  },
  remove: function() {
    var _this$options$appStat, _this$options$appStat2;
    View2.prototype.remove.apply(this, arguments);
    clearInterval(this.showMeInterval);
    const formName = this.options.appState.get("currentFormName");
    const resendContext = ((_this$options$appStat = this.options.appState.get("currentAuthenticator")) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.resend) || ((_this$options$appStat2 = this.options.appState.get("currentAuthenticatorEnrollment")) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.resend);
    const didFormNameChange = this.options.model.get("formName") !== formName;
    if (sessionStorageHelper.getResendTimestamp() && (!resendContext || didFormNameChange)) {
      sessionStorageHelper.removeResendTimestamp();
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/phone/ChallengeAuthenticatorPhoneView.js
var ResendView = BaseResendView.extend({
  // To be shown after a timeout
  className: "phone-authenticator-challenge__resend-warning hide",
  events: {
    "click a.resend-link": "handleResendLink"
  },
  // Override this to change the resend action location from response
  resendActionKey: "currentAuthenticatorEnrollment-resend",
  initialize: function() {
    const resendText = this.model.get("mode") === "sms" ? loc3("oie.phone.verify.sms.resendText", "login") : loc3("oie.phone.verify.call.resendText", "login");
    const linkText = this.model.get("mode") === "sms" ? loc3("oie.phone.verify.sms.resendLinkText", "login") : loc3("oie.phone.verify.call.resendLinkText", "login");
    this.add(createCallout({
      content: `${resendText}&nbsp;<a class='resend-link'>${linkText}</a>`,
      type: "warning"
    }));
  },
  handleResendLink: function() {
    this.options.appState.trigger("invokeAction", this.resendActionKey);
    if (!this.el.classList.contains("hide")) {
      this.el.classList.add("hide");
    }
    this.showCalloutAfterTimeout();
  }
});
var Body20 = BaseForm2.extend(Object.assign({
  className: "phone-authenticator-challenge",
  title: function() {
    return loc3("oie.phone.verify.title", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    const sendText = this.model.get("mode") === "sms" ? loc3("oie.phone.verify.sms.codeSentText", "login") : loc3("mfa.calling", "login");
    const enterCodeText = loc3("oie.phone.verify.enterCodeText", "login");
    const carrierChargesText = loc3("oie.phone.carrier.charges", "login");
    const strongClass = this.model.get("phoneNumber") !== loc3("oie.phone.alternate.title", "login") ? "strong no-translate" : "";
    this.add(`<div class="okta-form-subtitle" data-se="o-form-explain">
        ${sendText}&nbsp;<span class='${strongClass}'>${this.model.escape("phoneNumber")}.</span>
        &nbsp;${enterCodeText}
        <p>${carrierChargesText}</p>
        </div>`, {
      prepend: true,
      selector: ".o-form-fieldset-container"
    });
  },
  postRender: function() {
    BaseForm2.prototype.postRender.apply(this, arguments);
    this.add(ResendView, {
      selector: ".o-form-info-container",
      prepend: true
    });
  }
}));
var ChallengeAuthenticatorPhoneView = BaseAuthenticatorView.extend({
  Body: Body20,
  createModelClass: function() {
    const relatesToObject = this.options.currentViewState.relatesTo;
    const {
      methods: methods2,
      profile
    } = (relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value) || {};
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const local3 = Object.assign({
      mode: {
        "value": methods2[0].type,
        "type": "string"
      },
      phoneNumber: {
        "value": profile !== null && profile !== void 0 && profile.phoneNumber ? profile.phoneNumber : loc3("oie.phone.alternate.title", "login"),
        "type": "string"
      }
    }, ModelClass.prototype.local);
    return ModelClass.extend({
      local: local3
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/phone/EnrollAuthenticatorPhoneView.js
var EnrollResendView = ResendView.extend({
  // To be shown after a timeout
  className: "phone-authenticator-enroll--warning hide",
  resendActionKey: "currentAuthenticator-resend"
});
var Body21 = ChallengeAuthenticatorPhoneView.prototype.Body.extend({
  className: "phone-authenticator-enroll",
  title: function() {
    return loc3("oie.phone.enroll.title", "login");
  },
  postRender: function() {
    BaseForm2.prototype.postRender.apply(this, arguments);
    this.add(EnrollResendView, {
      selector: ".o-form-info-container",
      prepend: true
    });
  }
});
var EnrollAuthenticatorPhoneView = ChallengeAuthenticatorPhoneView.extend({
  Body: Body21
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/phone/EnrollAuthenticatorDataPhoneView.js
var Body22 = BaseForm2.extend({
  className: "phone-authenticator-enroll",
  title: function() {
    return loc3("oie.phone.enroll.title", "login");
  },
  subtitle: function() {
    return this.model.get("authenticator.methodType") === "voice" ? loc3("oie.phone.enroll.call.subtitle", "login") : loc3("oie.phone.enroll.sms.subtitle", "login");
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    const selectedMethod = this.model.get("authenticator.methodType");
    const phoneField = this.el.querySelector(".phone-authenticator-enroll__phone");
    const extensionField = this.el.querySelector(".phone-authenticator-enroll__phone-ext");
    if (selectedMethod === "voice") {
      if (!phoneField.classList.contains("phone-authenticator-enroll__phone--small")) {
        phoneField.classList.add("phone-authenticator-enroll__phone--small");
      }
      extensionField.classList.remove("hide");
    }
    if (selectedMethod === "sms") {
      phoneField.classList.remove("phone-authenticator-enroll__phone--small");
      if (!extensionField.classList.contains("hide")) {
        extensionField.classList.add("hide");
      }
    }
    this.el.querySelector(".phone-authenticator-enroll__phone-code").innerText = `+${this.model.get("phoneCode")}`;
  },
  handlePhoneCodeChange: function() {
    const countryCodeField = this.el.querySelector(".phone-authenticator-enroll__phone-code");
    countryCodeField.innerText = `+${this.model.get("phoneCode")}`;
  },
  save: function() {
    return this.model.get("authenticator.methodType") === "voice" ? loc3("oie.phone.call.primaryButton", "login") : loc3("oie.phone.sms.primaryButton", "login");
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const phoneNumberUISchemaIndex = oktaUnderscore.findIndex(uiSchemas, ({
      name
    }) => name === "authenticator.phoneNumber");
    const countryUISchema = {
      "label-top": true,
      label: loc3("country.label", "login"),
      type: "select",
      options: fn4.getCountries(),
      name: "country",
      wide: true
    };
    const phoneNumberWithCodeUISchema = {
      label: loc3("mfa.phoneNumber.placeholder", "login"),
      type: "group",
      modelType: "string",
      "label-top": true,
      name: "phoneCode",
      className: "phone-authenticator-enroll__phone",
      input: [{
        type: "label",
        /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
        label: `+${this.model.get("phoneCode")}`,
        className: "phone-authenticator-enroll__phone-code no-translate"
      }, Object.assign({}, uiSchemas[phoneNumberUISchemaIndex])]
    };
    const extensionUISchema = {
      label: loc3("phone.extention.label", "login"),
      type: "text",
      // Need to manually hide and show
      // - toggleWhen puts display: block on the element when it unhides hence can't be used.
      //   Because in this case, the element needs to be rendered as an inline-block.
      // - showWhen has an animation on the element when unhiding
      //   The animation makes the element look weird because of the way it is positioned,
      //   hence can't be used
      className: "phone-authenticator-enroll__phone-ext hide",
      "label-top": true,
      name: "extension"
    };
    if (phoneNumberUISchemaIndex !== -1) {
      uiSchemas.splice(phoneNumberUISchemaIndex, 1, phoneNumberWithCodeUISchema);
      uiSchemas.splice(phoneNumberUISchemaIndex, 0, countryUISchema);
      uiSchemas.splice(phoneNumberUISchemaIndex + 2, 0, extensionUISchema);
    }
    const methodType = oktaUnderscore.find(uiSchemas, ({
      name
    }) => name === "authenticator.methodType");
    if (methodType && methodType.options.length === 1) {
      methodType.className = "hide";
    }
    return uiSchemas;
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "change:authenticator.methodType", this.render.bind(this));
    this.listenTo(this.model, "change:phoneCode", this.handlePhoneCodeChange.bind(this));
  }
});
var EnrollAuthenticatorDataPhoneView = BaseAuthenticatorView.extend({
  Body: Body22,
  createModelClass: function() {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const local3 = Object.assign({
      country: {
        // Set default country to "US"
        "value": "US",
        "type": "string"
      },
      extension: {
        "type": "string"
      }
    }, ModelClass.prototype.local);
    const derived3 = Object.assign({
      phoneCode: {
        deps: ["country"],
        fn: function(country2) {
          return fn4.getCallingCodeForCountry(country2);
        }
      }
    }, ModelClass.prototype.derived);
    return ModelClass.extend({
      local: local3,
      derived: derived3,
      toJSON: function() {
        const modelJSON = Model2.prototype.toJSON.call(this, arguments);
        const extension = this.get("extension");
        const phoneCode = this.get("phoneCode");
        let formattedPhoneNumber = `+${phoneCode}${modelJSON.authenticator.phoneNumber}`;
        if (modelJSON.authenticator.methodType === "voice" && extension !== null && extension !== void 0 && extension.trim().length) {
          formattedPhoneNumber = `${formattedPhoneNumber}x${extension}`;
        }
        modelJSON.authenticator.phoneNumber = formattedPhoneNumber;
        return modelJSON;
      }
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/phone/ChallengeAuthenticatorDataPhoneView.js
var Body23 = BaseForm2.extend({
  className: "phone-authenticator-challenge",
  events: {
    "click a.phone-authenticator-challenge__link": "handleSecondaryLinkClick"
  },
  title: function() {
    return loc3("oie.phone.verify.title", "login");
  },
  save: function() {
    return this.model.get("primaryMode") === "sms" ? loc3("oie.phone.sms.primaryButton", "login") : loc3("oie.phone.call.primaryButton", "login");
  },
  handleSecondaryLinkClick: function(e) {
    e.preventDefault();
    const secondaryMode = this.model.get("secondaryMode");
    this.model.set("authenticator.methodType", secondaryMode);
    this.saveForm(this.model);
  },
  initialize: function() {
    this.model.on("error", () => this.model.set("authenticator.methodType", this.model.get("primaryMode")));
    BaseForm2.prototype.initialize.apply(this, arguments);
    const sendText = this.model.get("primaryMode") === "sms" ? loc3("oie.phone.verify.sms.sendText", "login") : loc3("oie.phone.verify.call.sendText", "login");
    const carrierChargesText = loc3("oie.phone.carrier.charges", "login");
    const extraCssClasses = this.model.get("phoneNumber") !== loc3("oie.phone.alternate.title", "login") ? "strong no-translate" : "";
    this.add(`<div class="okta-form-subtitle" data-se="o-form-explain">${sendText}
        <span ${extraCssClasses ? 'class="' + extraCssClasses + '"' : ""}>${this.model.escape("phoneNumber")}</span>
        <p>${carrierChargesText}</p>
      </div>`);
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    return uiSchemas.filter((schema) => schema.name !== "authenticator.methodType");
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    const secondaryMode = this.model.get("secondaryMode");
    if (secondaryMode) {
      const secondaryButtonTitle = secondaryMode === "sms" ? loc3("oie.phone.sms.secondaryButton", "login") : loc3("oie.phone.call.secondaryButton", "login");
      this.add(`<a href="#"
            class="link phone-authenticator-challenge__link"
            data-se="phone-authenticator-challenge__link">${secondaryButtonTitle}</a>`, ".o-form-button-bar");
    }
  }
});
var ChallengeAuthenticatorDataPhoneView = BaseAuthenticatorView.extend({
  Body: Body23,
  createModelClass: function({
    uiSchema
  }) {
    const {
      options: methods2
    } = oktaUnderscore.find(uiSchema, (schema) => schema.name === "authenticator.methodType");
    const relatesToObject = this.options.currentViewState.relatesTo;
    const {
      profile
    } = (relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value) || {};
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const local3 = Object.assign({
      primaryMode: {
        "value": methods2[0].value,
        "type": "string"
      },
      secondaryMode: {
        "value": methods2[1] && methods2[1].value,
        "type": "string"
      },
      phoneNumber: {
        "value": profile !== null && profile !== void 0 && profile.phoneNumber ? profile.phoneNumber : loc3("oie.phone.alternate.title", "login"),
        "type": "string"
      }
    }, ModelClass.prototype.local);
    return ModelClass.extend({
      local: local3
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/security-question/EnrollAuthenticatorSecurityQuestionView.js
var Body24 = BaseForm2.extend({
  title: function() {
    return loc3("oie.security.question.enroll.title", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
});
var EnrollAuthenticatorSecurityQuestion = BaseAuthenticatorView.extend({
  Body: Body24
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/security-question/ChallengeAuthenticatorSecurityQuestion.js
var Body25 = BaseForm2.extend({
  title: function() {
    return loc3("oie.security.question.challenge.title", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const questionKey = uiSchemas.filter((s) => s.name.indexOf("questionKey") >= 0);
    const answer = uiSchemas.filter((s) => s.name.indexOf("answer") >= 0);
    if (questionKey.length === 1 && answer.length === 1) {
      answer[0].label = questionKey[0].label;
    }
    return uiSchemas;
  }
});
var ChallengeAuthenticatorSecurityQuestion = BaseAuthenticatorView.extend({
  Body: Body25
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/webauthn/EnrollWebauthnInfoView.js
var EnrollWebauthnInfoView = View2.extend({
  // eslint-disable-next-line max-len
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="idx-webauthn-enroll-text">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.webauthn.instructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 36
          },
          "end": {
            "line": 1,
            "column": 99
          }
        }
      })) + "</p>";
    },
    "useData": true
  }),
  initialize: function() {
    const relatesToObject = this.options.currentViewState.relatesTo;
    const activationData = relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value.contextualData.activationData;
    if (fn.isEdge()) {
      this.add(View2.extend({
        tagName: "p",
        className: "idx-webauthn-enroll-text-edge",
        template: _Handlebars2.template({
          "compiler": [8, ">= 4.3.0"],
          "main": function(container, depth0, helpers2, partials, data) {
            var lookupProperty = container.lookupProperty || function(parent, propertyName) {
              if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                return parent[propertyName];
              }
              return void 0;
            };
            return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
              "name": "i18n",
              "hash": {
                "bundle": "login",
                "code": "oie.enroll.webauthn.instructions.edge"
              },
              "data": data,
              "loc": {
                "start": {
                  "line": 1,
                  "column": 0
                },
                "end": {
                  "line": 1,
                  "column": 68
                }
              }
            }));
          },
          "useData": true
        })
      }));
    }
    if (activationData.authenticatorSelection.userVerification === "required") {
      this.add(createCallout({
        className: "uv-required-callout",
        size: "slim",
        type: "warning",
        subtitle: loc3("oie.enroll.webauthn.uv.required.instructions", "login")
      }));
    }
    this.add('<div data-se="webauthn-waiting" class="okta-waiting-spinner"></div>');
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/webauthn/EnrollWebauthnView.js
function getExcludeCredentials2(authenticatorEnrollments = []) {
  const credentials = [];
  authenticatorEnrollments.forEach((enrollement) => {
    if (enrollement.key === "webauthn") {
      credentials.push({
        type: "public-key",
        id: fn7.strToBin(enrollement.credentialId)
      });
    }
  });
  return credentials;
}
var Body26 = BaseForm2.extend({
  title: function() {
    return loc3("oie.enroll.webauthn.title", "login");
  },
  className: "oie-enroll-webauthn",
  modelEvents: {
    "error": "_stopEnrollment"
  },
  getUISchema: function() {
    const schema = [];
    if (webauthn.isNewApiAvailable()) {
      schema.push({
        View: EnrollWebauthnInfoView
      });
      schema.push({
        View: createButton2({
          className: "webauthn-setup button button-primary button-wide",
          title: loc3("oie.enroll.webauthn.save", "login"),
          click: () => {
            this.triggerWebauthnPrompt();
          }
        })
      });
    } else {
      schema.push({
        View: createCallout({
          className: "webauthn-not-supported",
          type: "error",
          subtitle: loc3("oie.webauthn.error.not.supported", "login")
        })
      });
    }
    return schema;
  },
  triggerWebauthnPrompt: function() {
    this.$el.find(".o-form-error-container").empty();
    this._startEnrollment();
    const relatesToObject = this.options.currentViewState.relatesTo;
    const activationData = relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value.contextualData.activationData;
    if (webauthn.isNewApiAvailable()) {
      var _activationData$authe;
      const excludeCredentials = ((_activationData$authe = activationData.authenticatorSelection) === null || _activationData$authe === void 0 ? void 0 : _activationData$authe.requireResidentKey) === true ? [] : getExcludeCredentials2(this.options.appState.get("authenticatorEnrollments").value);
      const options2 = oktaUnderscore.extend({}, activationData, {
        challenge: fn7.strToBin(activationData.challenge),
        user: {
          id: fn7.strToBin(activationData.user.id),
          name: activationData.user.name,
          displayName: activationData.user.displayName
        },
        excludeCredentials
      });
      if (typeof AbortController !== "undefined") {
        this.webauthnAbortController = new AbortController();
      }
      navigator.credentials.create({
        publicKey: options2,
        signal: this.webauthnAbortController && this.webauthnAbortController.signal
      }).then((newCredential) => {
        this.model.set({
          credentials: {
            clientData: fn7.binToStr(newCredential.response.clientDataJSON),
            attestation: fn7.binToStr(newCredential.response.attestationObject)
          }
        });
        this.saveForm(this.model);
      }).catch((error) => {
        this.model.trigger("error", this.model, {
          responseJSON: {
            errorSummary: getMessageFromBrowserError(error)
          }
        });
      }).finally(() => {
        this.webauthnAbortController = null;
      });
    }
  },
  _startEnrollment: function() {
    this.$(".okta-waiting-spinner").show();
    this.$(".webauthn-setup").hide();
  },
  _stopEnrollment: function() {
    this.$(".okta-waiting-spinner").hide();
    this.$(".webauthn-setup").show();
  }
});
var EnrollWebauthnView = BaseAuthenticatorView.extend({
  Body: Body26,
  postRender: function() {
    BaseAuthenticatorView.prototype.postRender.apply(this, arguments);
    this.$el.find('.o-form-button-bar [type="submit"]').remove();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/webauthn/ChallengeWebauthnInfoView.js
var ChallengeWebauthnInfoView = View2.extend({
  // eslint-disable-next-line max-len
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<p class="idx-webauthn-verify-text">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.instructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 36
          },
          "end": {
            "line": 1,
            "column": 99
          }
        }
      })) + "</p>";
    },
    "useData": true
  }),
  initialize: function() {
    const relatesToObject = this.options.currentViewState.relatesTo;
    const challengeData = relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value.contextualData.challengeData;
    if (challengeData.userVerification === "required") {
      this.add(createCallout({
        className: "uv-required-callout",
        size: "slim",
        type: "warning",
        subtitle: loc3("oie.verify.webauthn.uv.required.instructions", "login")
      }));
    }
    this.add('<div data-se="webauthn-waiting" class="okta-waiting-spinner"></div>');
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/ChallengeWebauthnFooter.js
var OKTA_AUTHENTICATOR = "Okta_Authenticator";
var CantVerifyInfoVerifyFlowView = View2.extend({
  id: "help-description-container",
  className: "help-description js-help-description",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<h3>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.biometric.authenticator.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 4
          },
          "end": {
            "line": 1,
            "column": 96
          }
        }
      })) + "</h3><br><p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.biometric.authenticator.description1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 108
          },
          "end": {
            "line": 1,
            "column": 207
          }
        }
      })) + "</p><br><p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.biometric.authenticator.description2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 218
          },
          "end": {
            "line": 1,
            "column": 317
          }
        }
      })) + "</p><br><h3>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.security.key.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 329
          },
          "end": {
            "line": 1,
            "column": 410
          }
        }
      })) + "</h3><br><p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.security.key.description"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 422
          },
          "end": {
            "line": 1,
            "column": 509
          }
        }
      })) + "</p><br>";
    },
    "useData": true
  })
});
var CantVerifyInfoOVEnrollmentFlowView = View2.extend({
  id: "help-description-container",
  className: "help-description js-help-description",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<ol class="ov-enrollment-info"><li>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.enrollment.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 35
          },
          "end": {
            "line": 1,
            "column": 114
          }
        }
      })) + "</li><br><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.enrollment.step2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 127
          },
          "end": {
            "line": 1,
            "column": 206
          }
        }
      })) + "</li><br><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.enrollment.step3"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 219
          },
          "end": {
            "line": 1,
            "column": 298
          }
        }
      })) + "</li><br><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.verify.webauthn.cant.verify.enrollment.step4"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 311
          },
          "end": {
            "line": 1,
            "column": 390
          }
        }
      })) + "</><br></ol>";
    },
    "useData": true
  })
});
var ChallengeWebauthnFooter = AuthenticatorFooter.extend({
  links: function() {
    const links = AuthenticatorFooter.prototype.links.apply(this, arguments);
    const cantVerifyInfoView = this.options.appState.get("app") && this.options.appState.get("app").name === OKTA_AUTHENTICATOR ? CantVerifyInfoOVEnrollmentFlowView : CantVerifyInfoVerifyFlowView;
    links.unshift({
      "label": loc3("oie.verify.webauthn.cant.verify", "login"),
      "name": "cant-verify",
      "aria-controls": "help-description-container",
      "class": "link help js-help",
      "type": "toggle-text-link",
      "additionalOptions": {
        view: cantVerifyInfoView,
        selector: ".js-help-description"
      }
    });
    return links;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/webauthn/EnrollWebAuthnResidentkeyLinkView.js
var EnrollWebAuthnResidentKeyLinkView = View2.extend({
  className: "setup-webauthn-residentkey-text",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<div>" + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.webauthn.rk.link"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 5
          },
          "end": {
            "line": 1,
            "column": 65
          }
        }
      })) != null ? stack1 : "") + "</div>";
    },
    "useData": true
  }),
  events: {
    "click .setup-webauthn-residentkey-link": function(e) {
      e.preventDefault();
      this.options.appState.trigger("invokeAction", FORMS.ENROLL_WEBAUTHN_RESIDENTKEY);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/webauthn/ChallengeWebauthnView.js
var Body27 = BaseForm2.extend({
  title: function() {
    return loc3("oie.verify.webauth.title", "login");
  },
  className: "oie-verify-webauthn",
  getUISchema: function() {
    const schema = [];
    if (webauthn.isNewApiAvailable()) {
      const retryButton = createButton2({
        className: "retry-webauthn button-primary default-custom-button",
        title: loc3("mfa.challenge.verify", "login"),
        click: () => {
          this.getCredentialsAndSave();
        }
      });
      schema.push({
        View: ChallengeWebauthnInfoView
      }, {
        View: retryButton
      });
      if (this._canSetupWebAuthnResidentKey()) {
        schema.push({
          View: EnrollWebAuthnResidentKeyLinkView
        });
      }
    } else {
      schema.push({
        View: createCallout({
          className: "webauthn-not-supported",
          type: "error",
          subtitle: loc3("oie.webauthn.error.not.supported", "login")
        })
      });
    }
    return schema;
  },
  remove: function() {
    BaseForm2.prototype.remove.apply(this, arguments);
    if (this.webauthnAbortController) {
      this.webauthnAbortController.abort();
      this.webauthnAbortController = null;
    }
  },
  noButtonBar: true,
  modelEvents: {
    "error": "_stopVerification"
  },
  getCredentialsAndSave: function() {
    var _this$options$appStat;
    this.clearErrors();
    this._startVerification();
    if (typeof AbortController !== "undefined") {
      this.webauthnAbortController = new AbortController();
    }
    const relatesToObject = this.options.currentViewState.relatesTo;
    const authenticatorData = (relatesToObject === null || relatesToObject === void 0 ? void 0 : relatesToObject.value) || {};
    const allowCredentials = [];
    const authenticatorEnrollments = ((_this$options$appStat = this.options.appState.get("authenticatorEnrollments")) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.value) || [];
    authenticatorEnrollments.forEach((enrollement) => {
      if (enrollement.key === "webauthn") {
        allowCredentials.push({
          type: "public-key",
          id: fn7.strToBin(enrollement.credentialId)
        });
      }
    });
    const challengeData = authenticatorData.contextualData.challengeData;
    const options2 = oktaUnderscore.extend({}, challengeData, {
      allowCredentials,
      challenge: fn7.strToBin(challengeData.challenge)
    });
    navigator.credentials.get({
      publicKey: options2,
      signal: this.webauthnAbortController && this.webauthnAbortController.signal
    }).then((assertion) => {
      const credentials = {
        clientData: fn7.binToStr(assertion.response.clientDataJSON),
        authenticatorData: fn7.binToStr(assertion.response.authenticatorData),
        signatureData: fn7.binToStr(assertion.response.signature)
      };
      const hasUserHandleSchema = this.options.appState.getSchemaByName("credentials.userHandle");
      if (hasUserHandleSchema) {
        var _assertion$response$u;
        oktaUnderscore.extend(credentials, {
          userHandle: fn7.binToStr((_assertion$response$u = assertion.response.userHandle) !== null && _assertion$response$u !== void 0 ? _assertion$response$u : "")
        });
      }
      this.model.set({
        credentials
      });
      this.saveForm(this.model);
    }, (error) => {
      if (this.webauthnAbortController) {
        this.model.trigger("error", this.model, {
          responseJSON: {
            errorSummary: getMessageFromBrowserError(error)
          }
        });
      }
    }).finally(() => {
      this.webauthnAbortController = null;
    });
  },
  _startVerification: function() {
    this.$(".okta-waiting-spinner").show();
    this.$(".retry-webauthn").hide();
    this.$(".setup-webauthn-residentkey-text").hide();
    this.$(".retry-webauthn")[0].textContent = loc3("retry", "login");
  },
  _stopVerification: function() {
    this.$(".okta-waiting-spinner").hide();
    this.$(".retry-webauthn").show();
    this.$(".setup-webauthn-residentkey-text").show();
  },
  _canSetupWebAuthnResidentKey: function() {
    return this.options.appState.hasRemediationObject(FORMS.ENROLL_WEBAUTHN_RESIDENTKEY);
  }
});
var ChallengeWebauthnView = BaseAuthenticatorView.extend({
  Body: Body27,
  Footer: ChallengeWebauthnFooter,
  postRender: function() {
    BaseAuthenticatorView.prototype.postRender.apply(this, arguments);
    if (webauthn.isNewApiAvailable() && !fn.isSafari()) {
      this.form.getCredentialsAndSave();
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/email.js
var email = {
  title: function() {
    return loc3("oie.email.mfa.title", "login");
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/email/BaseAuthenticatorEmailView.js
var ResendView2 = BaseResendView.extend({
  className: "hide resend-email-view",
  events: {
    "click a.resend-link": "handelResendLink"
  },
  initialize: function() {
    this.add(createCallout({
      content: `${loc3("email.code.not.received", "login")}
        <a class='resend-link'>${loc3("email.button.resend", "login")}</a>`,
      type: "warning"
    }));
  },
  handelResendLink: function() {
    this.options.appState.trigger("invokeAction", this.options.resendEmailAction);
    if (!this.$el.hasClass("hide")) {
      this.$el.addClass("hide");
    }
    this.showCalloutAfterTimeout();
  }
});
var Body28 = BaseFormWithPolling.extend(Object.assign({
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  initialize: function() {
    BaseFormWithPolling.prototype.initialize.apply(this, arguments);
    this.add(ResendView2, {
      selector: ".o-form-error-container",
      options: {
        resendEmailAction: this.resendEmailAction
      }
    });
    this.startPolling();
  },
  saveForm: function() {
    BaseForm2.prototype.saveForm.apply(this, arguments);
    this.stopPolling();
  },
  remove: function() {
    BaseForm2.prototype.remove.apply(this, arguments);
    this.stopPolling();
  },
  triggerAfterError: function(model, error) {
    var _error$responseJSON, _error$responseJSON$e;
    BaseForm2.prototype.triggerAfterError.apply(this, arguments);
    const isFormPolling = !!this.polling;
    this.stopPolling();
    if ((_error$responseJSON = error.responseJSON) !== null && _error$responseJSON !== void 0 && (_error$responseJSON$e = _error$responseJSON.errorSummaryKeys) !== null && _error$responseJSON$e !== void 0 && _error$responseJSON$e.includes("idx.session.expired")) {
      return;
    }
    if (this.isRateLimitError(error)) {
      if (isFormPolling) {
        setTimeout(() => {
          model.trigger("clearFormError");
        }, 0);
      }
      this.startPolling(6e4);
    } else {
      this.startPolling(this.options.appState.get("dynamicRefreshInterval"));
    }
  },
  isRateLimitError: function(error) {
    var _error$responseJSON2, _error$responseJSON2$, _error$responseJSON3, _error$responseJSON4;
    return ((_error$responseJSON2 = error.responseJSON) === null || _error$responseJSON2 === void 0 ? void 0 : (_error$responseJSON2$ = _error$responseJSON2.errorSummaryKeys) === null || _error$responseJSON2$ === void 0 ? void 0 : _error$responseJSON2$.includes("tooManyRequests")) || ((_error$responseJSON3 = error.responseJSON) === null || _error$responseJSON3 === void 0 ? void 0 : _error$responseJSON3.errorCode) === "E0000047" && !((_error$responseJSON4 = error.responseJSON) !== null && _error$responseJSON4 !== void 0 && _error$responseJSON4.errorIntent);
  }
}, email));
var BaseAuthenticatorEmailView = BaseAuthenticatorView.extend({
  Body: Body28
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/email/AuthenticatorEmailViewUtil.js
var CheckYourEmailTitle = View2.extend({
  className: "okta-form-subtitle",
  attributes: {
    "data-se": "o-form-explain"
  },
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "$1": "<span class='strong'>$1</span>",
          "arguments": "email",
          "bundle": "login",
          "code": "oie.email.verify.alternate.magicLinkToEmailAddress"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 13
          },
          "end": {
            "line": 1,
            "column": 149
          }
        }
      }));
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.email.verify.alternate.magicLinkToYourEmail"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 157
          },
          "end": {
            "line": 1,
            "column": 236
          }
        }
      }));
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.email.verify.alternate.instructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 273
          },
          "end": {
            "line": 1,
            "column": 344
          }
        }
      }));
    },
    "7": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.email.verify.alternate.verificationCode.instructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 352
          },
          "end": {
            "line": 1,
            "column": 440
          }
        }
      }));
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "email") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 243
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "useEmailMagicLinkValue") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.program(7, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 243
          },
          "end": {
            "line": 1,
            "column": 447
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    return this.options;
  }
});
var EnterCodeLink = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<button class="button-link enter-auth-code-instead-link" >' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "code": "oie.email.verify.alternate.show.verificationCode.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 58
          },
          "end": {
            "line": 1,
            "column": 127
          }
        }
      })) + "</button>";
    },
    "useData": true
  })
});
function getCheckYourEmailTitle() {
  return CheckYourEmailTitle;
}
function getEnterCodeLink() {
  return EnterCodeLink;
}

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/email/EnrollAuthenticatorEmailView.js
var BaseAuthenticatorEmailForm = BaseAuthenticatorEmailView.prototype.Body;
var Body29 = BaseAuthenticatorEmailForm.extend(Object.assign({
  resendEmailAction: "currentAuthenticator-resend",
  initialize: function() {
    var _this$options$appStat;
    BaseAuthenticatorEmailForm.prototype.initialize.apply(this, arguments);
    const email2 = ((_this$options$appStat = this.options.appState.get("user")) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.identifier) || {};
    const useEmailMagicLinkValue = this.isUseEmailMagicLink();
    if (useEmailMagicLinkValue !== void 0) {
      this.noButtonBar = true;
      this.events["click .enter-auth-code-instead-link"] = "showAuthCodeEntry";
      if (useEmailMagicLinkValue) {
        this.add(getEnterCodeLink(), {
          prepend: true,
          selector: ".o-form-error-container"
        });
      }
      this.add(getCheckYourEmailTitle(), {
        prepend: true,
        selector: ".o-form-error-container",
        options: {
          email: email2,
          useEmailMagicLinkValue
        }
      });
    } else {
      this.subtitle = loc3("oie.email.enroll.subtitle", "login");
    }
  },
  postRender: function() {
    if (this.isUseEmailMagicLink() !== void 0) {
      BaseAuthenticatorEmailForm.prototype.postRender.apply(this, arguments);
      if (this.isUseEmailMagicLink()) {
        this.showCodeEntryField(false);
      } else {
        this.noButtonBar = false;
      }
    }
  },
  isUseEmailMagicLink: function() {
    var _this$options$appStat2, _this$options$appStat3;
    return (_this$options$appStat2 = this.options.appState.get("currentAuthenticator")) === null || _this$options$appStat2 === void 0 ? void 0 : (_this$options$appStat3 = _this$options$appStat2.contextualData) === null || _this$options$appStat3 === void 0 ? void 0 : _this$options$appStat3.useEmailMagicLink;
  },
  showAuthCodeEntry: function() {
    this.noButtonBar = false;
    this.render();
    this.showCodeEntryField(true);
    this.removeEnterAuthCodeInsteadLink();
  },
  showCodeEntryField: function(show = true) {
    const $textField = this.$el.find(".o-form-fieldset-container");
    $textField.toggle(show);
  },
  removeEnterAuthCodeInsteadLink: function() {
    this.$el.find(".enter-auth-code-instead-link").remove();
  }
}));
var EnrollAuthenticatorEmailView = BaseAuthenticatorEmailView.extend({
  Body: Body29
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/email/ChallengeAuthenticatorEmailView.js
var BaseAuthenticatorEmailForm2 = BaseAuthenticatorEmailView.prototype.Body;
var Body30 = BaseAuthenticatorEmailForm2.extend(Object.assign({
  noButtonBar: true,
  resendEmailAction: "currentAuthenticatorEnrollment-resend",
  events: {
    "click .enter-auth-code-instead-link": "showAuthCodeEntry"
  },
  initialize: function() {
    var _this$options$current, _this$options$current2;
    BaseAuthenticatorEmailForm2.prototype.initialize.apply(this, arguments);
    const {
      email: email2
    } = ((_this$options$current = this.options.currentViewState.relatesTo) === null || _this$options$current === void 0 ? void 0 : (_this$options$current2 = _this$options$current.value) === null || _this$options$current2 === void 0 ? void 0 : _this$options$current2.profile) || {};
    const useEmailMagicLinkValue = this.isUseEmailMagicLink();
    if (useEmailMagicLinkValue) {
      this.add(getEnterCodeLink(), {
        prepend: true,
        selector: ".o-form-error-container"
      });
    }
    this.add(getCheckYourEmailTitle(), {
      prepend: true,
      selector: ".o-form-error-container",
      options: {
        email: email2,
        useEmailMagicLinkValue
      }
    });
  },
  postRender: function() {
    BaseAuthenticatorEmailForm2.prototype.postRender.apply(this, arguments);
    if (this.isUseEmailMagicLink()) {
      this.showCodeEntryField(false);
    } else {
      this.noButtonBar = false;
    }
  },
  isUseEmailMagicLink: function() {
    var _this$options$appStat, _this$options$appStat2;
    const useEmailMagicLink = (_this$options$appStat = this.options.appState.get("currentAuthenticatorEnrollment")) === null || _this$options$appStat === void 0 ? void 0 : (_this$options$appStat2 = _this$options$appStat.contextualData) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.useEmailMagicLink;
    return useEmailMagicLink !== void 0 ? useEmailMagicLink : true;
  },
  showAuthCodeEntry: function() {
    this.noButtonBar = false;
    this.render();
    this.showCodeEntryField(true);
    this.removeEnterAuthCodeInsteadLink();
  },
  showCodeEntryField: function(show = true) {
    const $textField = this.$el.find(".o-form-fieldset-container");
    $textField.toggle(show);
  },
  removeEnterAuthCodeInsteadLink: function() {
    this.$el.find(".enter-auth-code-instead-link").remove();
  }
}));
var ChallengeAuthenticatorEmailView = BaseAuthenticatorEmailView.extend({
  Body: Body30
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/email/ChallengeAuthenticatorDataEmailView.js
var BaseAuthenticatorEmailForm3 = BaseAuthenticatorView.prototype.Body;
var SubtitleView = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "$1": "<span class='strong no-translate'>$1</span>",
          "arguments": "email",
          "bundle": "login",
          "code": "oie.email.verify.subtitle.text.with.email"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 70
          },
          "end": {
            "line": 1,
            "column": 210
          }
        }
      }));
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.email.verify.subtitle.text.without.email"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 218
          },
          "end": {
            "line": 1,
            "column": 294
          }
        }
      }));
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-subtitle" data-se="o-form-explain">' + ((stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "email") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 57
          },
          "end": {
            "line": 1,
            "column": 301
          }
        }
      })) != null ? stack1 : "") + "</div>";
    },
    "useData": true
  }),
  getTemplateData: function() {
    var _this$options$appStat, _this$options$appStat2;
    const email2 = (_this$options$appStat = this.options.appState.get("currentAuthenticatorEnrollment")) === null || _this$options$appStat === void 0 ? void 0 : (_this$options$appStat2 = _this$options$appStat.profile) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.email;
    return {
      email: email2
    };
  }
});
var Body31 = BaseAuthenticatorEmailForm3.extend({
  title: function() {
    return loc3("oie.email.challenge.mfa.title", "login");
  },
  save: function() {
    return loc3("oie.email.verify.primaryButton", "login");
  },
  postRender: function() {
    BaseAuthenticatorEmailForm3.prototype.postRender.apply(this, arguments);
    this.add(SubtitleView, {
      prepend: true,
      selector: ".o-form-info-container"
    });
  },
  getUISchema: function() {
    const uiSchemas = BaseAuthenticatorEmailForm3.prototype.getUISchema.apply(this, arguments);
    return uiSchemas.filter((schema) => schema.name !== "authenticator.methodType");
  }
});
var ChallengeAuthenticatorDataEmailView = BaseAuthenticatorView.extend({
  Body: Body31
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/OVResendView.js
var OVResendView = BaseResendView.extend({
  //only show after certain threshold of polling
  className: "hide resend-ov-link-view",
  events: {
    "click a.resend-link": "handelResendLink"
  },
  initialize: function() {
    const selectedChannel = this.options.appState.get("currentAuthenticator").contextualData.selectedChannel;
    this.add(createCallout({
      content: selectedChannel === "email" ? _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "i18n",
            "hash": {
              "bundle": "login",
              "code": "oie.enroll.okta_verify.email.notReceived"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 0
              },
              "end": {
                "line": 1,
                "column": 73
              }
            }
          })) != null ? stack1 : "";
        },
        "useData": true
      }) : _Handlebars2.template({
        "compiler": [8, ">= 4.3.0"],
        "main": function(container, depth0, helpers2, partials, data) {
          var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return void 0;
          };
          return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
            "name": "i18n",
            "hash": {
              "bundle": "login",
              "code": "oie.enroll.okta_verify.sms.notReceived"
            },
            "data": data,
            "loc": {
              "start": {
                "line": 1,
                "column": 0
              },
              "end": {
                "line": 1,
                "column": 71
              }
            }
          })) != null ? stack1 : "";
        },
        "useData": true
      }),
      type: "warning"
    }));
  },
  handelResendLink: function() {
    this.options.appState.trigger("invokeAction", "currentAuthenticator-resend");
    this.$el.addClass("hide");
    this.showCalloutAfterTimeout();
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/SwitchEnrollChannelLinkView.js
var SwitchEnrollChannelLinkView = View2.extend({
  className: "switch-channel-text",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<a href="#" class="switch-channel-link" aria-label="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.totp.aria.cannotScan"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 75
          },
          "end": {
            "line": 1,
            "column": 134
          }
        }
      })) + '">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "enroll.totp.cannotScan"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 136
          },
          "end": {
            "line": 1,
            "column": 189
          }
        }
      })) + "</a>";
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.okta_verify.switch.channel.link.text"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 201
          },
          "end": {
            "line": 1,
            "column": 281
          }
        }
      })) != null ? stack1 : "";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "isQRcodeChannel") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(3, data, 0),
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 288
          }
        }
      })) != null ? stack1 : "";
    },
    "useData": true
  }),
  getTemplateData: function() {
    return {
      isQRcodeChannel: this.options.appState.get("currentAuthenticator").contextualData.selectedChannel === "qrcode"
    };
  },
  postRender: function() {
    this.$el.find(".switch-channel-link").on("click", (event) => {
      const appState = this.options.appState;
      event.preventDefault();
      appState.trigger("switchForm", FORMS.SELECT_ENROLLMENT_CHANNEL);
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/EnrollChannelPollDescriptionView.js
var EnrollChannelPollDescriptionView = View2.extend({
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<ol class="qrcode-info ov-info"><li>' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.okta_verify.qrcode.step1"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 48
          },
          "end": {
            "line": 1,
            "column": 114
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.okta_verify.qrcode.step2"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 123
          },
          "end": {
            "line": 1,
            "column": 189
          }
        }
      })) + "</li><li>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.okta_verify.qrcode.step3"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 198
          },
          "end": {
            "line": 1,
            "column": 264
          }
        }
      })) + '</li></ol><div class="qrcode-container"><img class="qrcode" src=' + alias3((helper = (helper = lookupProperty(helpers2, "href") || (depth0 != null ? lookupProperty(depth0, "href") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "href",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 328
          },
          "end": {
            "line": 1,
            "column": 336
          }
        }
      }) : helper)) + ' alt="' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "mfa.altQrCode"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 342
          },
          "end": {
            "line": 1,
            "column": 387
          }
        }
      })) + '"></img></div>';
    },
    "3": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<ul class="email-info ov-info"><li>' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "arguments": "email",
          "bundle": "login",
          "code": "oie.enroll.okta_verify.email.info"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 456
          },
          "end": {
            "line": 1,
            "column": 540
          }
        }
      })) != null ? stack1 : "") + '</li><li class="switch-channel-content"></li></ul>';
    },
    "5": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<ul class="sms-info ov-info"><li>' + ((stack1 = (lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "arguments": "phoneNumber",
          "bundle": "login",
          "code": "oie.enroll.okta_verify.sms.info"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 649
          },
          "end": {
            "line": 1,
            "column": 737
          }
        }
      })) != null ? stack1 : "") + '</li><li class="switch-channel-content"></li></ul>';
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, alias1 = depth0 != null ? depth0 : container.nullContext || {}, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "href") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 408
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "email") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 408
          },
          "end": {
            "line": 1,
            "column": 597
          }
        }
      })) != null ? stack1 : "") + ((stack1 = lookupProperty(helpers2, "if").call(alias1, depth0 != null ? lookupProperty(depth0, "phoneNumber") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 597
          },
          "end": {
            "line": 1,
            "column": 794
          }
        }
      })) != null ? stack1 : "");
    },
    "useData": true
  }),
  getTemplateData: function() {
    var _contextualData$qrcod;
    const contextualData = this.options.appState.get("currentAuthenticator").contextualData;
    return {
      href: (_contextualData$qrcod = contextualData.qrcode) === null || _contextualData$qrcod === void 0 ? void 0 : _contextualData$qrcod.href,
      email: oktaUnderscore.escape(contextualData === null || contextualData === void 0 ? void 0 : contextualData.email),
      phoneNumber: oktaUnderscore.escape(contextualData === null || contextualData === void 0 ? void 0 : contextualData.phoneNumber)
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/EnrollPollOktaVerifyView.js
var OV_FORCE_FIPS_COMPLIANCE_UPGRAGE_KEY_IOS = "oie.authenticator.app.non_fips_compliant_enrollment_device_incompatible";
var OV_FORCE_FIPS_COMPLIANCE_UPGRAGE_KEY_NON_IOS = "oie.authenticator.app.non_fips_compliant_enrollment_app_update_required";
var OV_QR_ENROLL_ENABLE_BIOMETRICS_KEY = "oie.authenticator.app.method.push.enroll.enable.biometrics";
var Body32 = BaseFormWithPolling.extend(Object.assign({
  title: function() {
    const selectedChannel = this.options.appState.get("currentAuthenticator").contextualData.selectedChannel;
    let title;
    switch (selectedChannel) {
      case "email":
        title = loc3("oie.enroll.okta_verify.setup.email.title", "login");
        break;
      case "sms":
        title = loc3("oie.enroll.okta_verify.setup.sms.title", "login");
        break;
      default:
        title = loc3("oie.enroll.okta_verify.setup.title", "login");
    }
    return title;
  },
  className: "oie-enroll-ov-poll",
  noButtonBar: true,
  initialize: function() {
    BaseFormWithPolling.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "error", this.stopPolling);
    this.startPolling();
  },
  postRender: function() {
    BaseFormWithPolling.prototype.postRender.apply(this, arguments);
    if ((fn.isAndroid() || fn.isIOS()) & this.options.appState.get("currentAuthenticator").contextualData.selectedChannel === "qrcode") {
      this.options.appState.trigger("switchForm", FORMS.SELECT_ENROLLMENT_CHANNEL);
    }
  },
  showMessages: function() {
    const calloutOptions = {};
    if (this.options.appState.containsMessageWithI18nKey(OV_FORCE_FIPS_COMPLIANCE_UPGRAGE_KEY_IOS) || this.options.appState.containsMessageWithI18nKey(OV_FORCE_FIPS_COMPLIANCE_UPGRAGE_KEY_NON_IOS)) {
      calloutOptions.title = loc3("oie.okta_verify.enroll.force.upgrade.title", "login");
    } else if (this.options.appState.containsMessageWithI18nKey(OV_QR_ENROLL_ENABLE_BIOMETRICS_KEY)) {
      calloutOptions.title = loc3("oie.authenticator.app.method.push.enroll.enable.biometrics.title", "login");
    }
    BaseFormWithPolling.prototype.showMessages.call(this, calloutOptions);
  },
  getUISchema: function() {
    const schema = [];
    const contextualData = this.options.appState.get("currentAuthenticator").contextualData;
    const selectedChannel = contextualData.selectedChannel;
    schema.push({
      View: EnrollChannelPollDescriptionView
    });
    schema.push({
      View: SwitchEnrollChannelLinkView,
      options: {
        selectedChannel
      },
      selector: selectedChannel === "qrcode" ? ".qrcode-container" : ".switch-channel-content"
    });
    if (["email", "sms"].includes(selectedChannel)) {
      schema.push({
        View: OVResendView,
        selector: ".o-form-error-container"
      });
    }
    return schema;
  },
  remove: function() {
    BaseFormWithPolling.prototype.remove.apply(this, arguments);
    this.stopPolling();
  }
}, polling));
var EnrollPollOktaVerifyView = BaseAuthenticatorView.extend({
  Body: Body32
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/SelectEnrollmentChannelOktaVerifyView.js
var Body33 = BaseForm2.extend({
  title: function() {
    return fn.isAndroid() || fn.isIOS() ? loc3("oie.enroll.okta_verify.setup.title", "login") : loc3("oie.enroll.okta_verify.select.channel.title", "login");
  },
  getUISchema: function() {
    var _channelField$options;
    const schemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const channelField = oktaUnderscore.find(schemas, (schema) => schema.name === "authenticator.channel");
    channelField.options = oktaUnderscore.filter(channelField === null || channelField === void 0 ? void 0 : channelField.options, (option2) => {
      var _this$options$appStat, _this$options$appStat2;
      return option2.value !== ((_this$options$appStat = this.options.appState.get("currentAuthenticator")) === null || _this$options$appStat === void 0 ? void 0 : (_this$options$appStat2 = _this$options$appStat.contextualData) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.selectedChannel);
    });
    channelField.value = (_channelField$options = channelField.options[0]) === null || _channelField$options === void 0 ? void 0 : _channelField$options.value;
    channelField.sublabel = null;
    this.model.set("authenticator.channel", channelField.value);
    const description = {
      View: loc3("oie.enroll.okta_verify.select.channel.description", "login"),
      selector: ".o-form-fieldset-container"
    };
    return [description, ...schemas];
  }
});
var SelectEnrollmentChannelOktaVerifyView = BaseAuthenticatorView.extend({
  Body: Body33
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/EnrollementChannelDataOktaVerifyView.js
var Body34 = BaseForm2.extend({
  className: "oie-enroll-ov-data",
  title: function() {
    return this.options.appState.get("currentAuthenticator").contextualData.selectedChannel === "email" ? loc3("oie.enroll.okta_verify.enroll.channel.email.title", "login") : loc3("oie.enroll.okta_verify.enroll.channel.sms.title", "login");
  },
  save: function() {
    return loc3("oie.enroll.okta_verify.setupLink", "login");
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const phoneNumberUISchema = oktaUnderscore.find(uiSchemas, ({
      name
    }) => name === "phoneNumber");
    const phoneNumberUISchemaIndex = oktaUnderscore.findIndex(uiSchemas, ({
      name
    }) => name === "phoneNumber");
    const countryUISchema = {
      "label-top": true,
      label: loc3("country.label", "login"),
      type: "select",
      options: fn4.getCountries(),
      name: "country",
      wide: true
    };
    const phoneNumberWithCodeUISchema = {
      label: loc3("mfa.phoneNumber.placeholder", "login"),
      type: "group",
      modelType: "string",
      "label-top": true,
      name: "phoneCode",
      input: [{
        type: "label",
        /* eslint-disable-next-line @okta/okta/no-unlocalized-text */
        label: `+${this.model.get("phoneCode")}`,
        className: "country-code-label no-translate"
      }, Object.assign({}, phoneNumberUISchema)]
    };
    if (phoneNumberUISchemaIndex !== -1) {
      uiSchemas.splice(phoneNumberUISchemaIndex, 1, countryUISchema, phoneNumberWithCodeUISchema);
    }
    const description = {
      View: this.options.appState.get("currentAuthenticator").contextualData.selectedChannel === "email" ? loc3("oie.enroll.okta_verify.channel.email.description", "login") : loc3("oie.enroll.okta_verify.channel.sms.description", "login"),
      selector: ".o-form-fieldset-container"
    };
    uiSchemas.push(description);
    return uiSchemas;
  },
  handlePhoneCodeChange: function() {
    const countryCodeField = this.el.querySelector(".country-code-label");
    countryCodeField.innerText = `+${this.model.get("phoneCode")}`;
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    if (this.options.appState.get("currentAuthenticator").contextualData.selectedChannel === "sms") {
      this.listenTo(this.model, "change:phoneCode", this.handlePhoneCodeChange.bind(this));
    }
  }
});
var EnrollementChannelDataOktaVerifyView = BaseAuthenticatorView.extend({
  Body: Body34,
  createModelClass: function() {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    if (this.options.appState.get("currentAuthenticator").contextualData.selectedChannel !== "sms") {
      return ModelClass;
    }
    const local3 = Object.assign({
      country: {
        // Set default country to "US"
        "value": "US",
        "type": "string"
      }
    }, ModelClass.prototype.local);
    const derived3 = Object.assign({
      phoneCode: {
        deps: ["country"],
        fn: function(country2) {
          return fn4.getCallingCodeForCountry(country2);
        }
      }
    }, ModelClass.prototype.derived);
    return ModelClass.extend({
      local: local3,
      derived: derived3,
      toJSON: function() {
        const modelJSON = Model2.prototype.toJSON.call(this, arguments);
        const phoneCode = this.get("phoneCode");
        let formattedPhoneNumber = `+${phoneCode}${modelJSON.phoneNumber}`;
        modelJSON.phoneNumber = formattedPhoneNumber;
        return modelJSON;
      }
    });
  },
  postRender: function() {
    this.add(SwitchEnrollChannelLinkView, "form");
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/ChallengePushView.js
var warningTemplate = View2.extend({
  className: "okta-form-infobox-warning infobox infobox-warning",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<span class="icon warning-16"></span><p>' + container.escapeExpression((helper = (helper = lookupProperty(helpers2, "warning") || (depth0 != null ? lookupProperty(depth0, "warning") : depth0)) != null ? helper : container.hooks.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "warning",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 40
          },
          "end": {
            "line": 1,
            "column": 51
          }
        }
      }) : helper)) + "</p>";
    },
    "useData": true
  })
});
var Body35 = BaseFormWithPolling.extend(Object.assign({
  noButtonBar: true,
  title: function() {
    return this.isOV() ? loc3("oie.okta_verify.push.title", "login") : loc3("oie.verify.custom_app.title", "login", [this.options.appState.getAuthenticatorDisplayName()]);
  },
  initialize: function() {
    BaseFormWithPolling.prototype.initialize.apply(this, arguments);
    if ((this.isOV() || this.isCustomApp()) && this.isAutoChallengeSupported()) {
      this.hasSavingState = false;
    }
    this.listenTo(this.model, "error", this.stopPoll);
    this.addView();
  },
  addView: function() {
    this.add(createButton2({
      className: "button button-wide button-primary send-push link-button-disabled",
      title: this.isOV() ? loc3("oie.okta_verify.push.sent", "login") : loc3("oie.custom_app.push.sent", "login"),
      click: (e) => {
        e.preventDefault();
      }
    }));
    this.add(`<span class='accessibility-text' role='alert'>
        ${this.isOV() ? loc3("oie.okta_verify.push.sent", "login") : loc3("oie.custom_app.push.sent", "login")}</span>`);
  },
  render: function() {
    BaseFormWithPolling.prototype.render.apply(this, arguments);
    const checkbox = this.$el.find('[data-se="o-form-fieldset-autoChallenge"]');
    if (!this.isAutoChallengeSupported()) {
      checkbox.length && checkbox.hide();
    } else if (this.isOV() || this.isCustomApp()) {
      checkbox.length && this.$el.find(".o-form-fieldset-container").append(checkbox);
    }
  },
  postRender: function() {
    BaseFormWithPolling.prototype.postRender.apply(this, arguments);
    const className2 = this.isOV() ? "okta-verify-push-challenge" : " custom-app-push-challenge";
    this.$el.addClass(className2);
    this.startPoll();
  },
  startPoll: function() {
    this.startPolling();
    this.warningTimeout = setTimeout(() => {
      const warningText = this.isOV() ? loc3("oktaverify.warning", "login") : loc3("oie.custom_app.push.warning", "login", [this.options.appState.getAuthenticatorDisplayName()]);
      this.showWarning(warningText);
    }, WARNING_TIMEOUT2);
  },
  stopPoll: function() {
    this.stopPolling();
    this.clearWarning();
  },
  showWarning: function(msg) {
    this.clearWarning();
    this.add(warningTemplate, ".o-form-error-container", {
      options: {
        warning: msg
      }
    });
  },
  clearWarning: function() {
    if (this.$(".o-form-error-container div").hasClass("okta-form-infobox-warning")) {
      this.$(".okta-form-infobox-warning").remove();
    }
    clearTimeout(this.warningTimeout);
  },
  remove: function() {
    BaseFormWithPolling.prototype.remove.apply(this, arguments);
    this.stopPolling();
  },
  isOV: function() {
    return this.options.appState.get("authenticatorKey") === AUTHENTICATOR_KEY.OV;
  },
  isCustomApp: function() {
    return this.options.appState.get("authenticatorKey") === AUTHENTICATOR_KEY.CUSTOM_APP;
  },
  isAutoChallengeSupported: function() {
    return this.options.appState.getSchemaByName("autoChallenge") !== null && this.options.appState.getSchemaByName("autoChallenge") !== void 0;
  }
}, polling));
var AuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body35
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ChallengeOktaVerifyFastPassView.js
var Body36 = Body.extend({
  getDeviceChallengePayload: function() {
    return this.options.currentViewState.relatesTo.value.contextualData.challenge.value;
  },
  showCustomFormErrorCallout: function(error) {
    const options2 = getBiometricsErrorOptions(error, false);
    if (oktaUnderscore.isEmpty(options2)) {
      return false;
    }
    this.showMessages(createCallout(options2));
    return true;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ResendNumberChallengeView.js
var ResendNumberChallengeView = View2.extend({
  initialize: function() {
    this.listenTo(this.options.appState, "showNumberChallengeWarning", () => {
      this.startWarningTimeout();
    });
    this.listenTo(this.options.appState, "hideNumberChallengeWarning", () => {
      this.clearWarning();
    });
  },
  className: "resend-number-challenge-warning hide",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="okta-form-infobox-warning infobox infobox-warning"><span class="icon warning-16"></span><p>' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
        "name": "i18n",
        "hash": {
          "$1": "<a href='#' class='resend-number-challenge'>$1</a>",
          "bundle": "login",
          "code": "oie.numberchallenge.warning"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 103
          },
          "end": {
            "line": 1,
            "column": 217
          }
        }
      })) + "</p></div>";
    },
    "useData": true
  }),
  showWarning: function() {
    this.$el.removeClass("hide");
  },
  clearWarning: function() {
    this.$el.addClass("hide");
    clearTimeout(this.warningTimeout);
    this.startWarningTimeout();
  },
  startWarningTimeout: function() {
    this.warningTimeout = setTimeout(oktaUnderscore.bind(function() {
      this.showWarning();
    }, this), WARNING_TIMEOUT2);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/NumberChallengePhoneView.js
var NumberChallengePhoneView = View2.extend({
  className: "number-challenge-section",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return "<p>" + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "$1": "<span class='strong'>$1</span>",
          "arguments": "correctAnswer",
          "bundle": "login",
          "code": "oie.numberchallenge.instruction"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 3
          },
          "end": {
            "line": 1,
            "column": 127
          }
        }
      })) + '</p><div class="phone no-translate"><div class="phone--body"><div class="phone--screen"><span class="phone--number" data-se="challenge-number">' + alias3((helper = (helper = lookupProperty(helpers2, "correctAnswer") || (depth0 != null ? lookupProperty(depth0, "correctAnswer") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "correctAnswer",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 270
          },
          "end": {
            "line": 1,
            "column": 287
          }
        }
      }) : helper)) + '</span></div><div class="phone--home-button"></div></div></div>';
    },
    "useData": true
  }),
  getTemplateData: function() {
    var _this$options$appStat, _this$options$appStat2;
    const correctAnswer = (_this$options$appStat = this.options.appState.get("currentAuthenticator")) === null || _this$options$appStat === void 0 ? void 0 : (_this$options$appStat2 = _this$options$appStat.contextualData) === null || _this$options$appStat2 === void 0 ? void 0 : _this$options$appStat2.correctAnswer;
    return {
      correctAnswer
    };
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/NumberChallengePushView.js
var Body37 = BaseFormWithPolling.extend(Object.assign({
  noButtonBar: true,
  className: "okta-verify-number-challenge",
  events: {
    "click a.resend-number-challenge": "handleResendNumberChallenge"
  },
  handleResendNumberChallenge: function() {
    this.options.appState.trigger("invokeAction", "currentAuthenticator-resend");
    this.options.appState.trigger("hideNumberChallengeWarning");
  },
  title: function() {
    return loc3("oie.okta_verify.push.sent", "login");
  },
  initialize: function() {
    BaseFormWithPolling.prototype.initialize.apply(this, arguments);
    this.add(NumberChallengePhoneView);
  },
  triggerAfterError: function() {
    BaseFormWithPolling.prototype.triggerAfterError.apply(this, arguments);
    this.stopPolling();
    this.$el.find(".o-form-fieldset-container").empty();
  },
  postRender: function() {
    BaseFormWithPolling.prototype.postRender.apply(this, arguments);
    this.startPoll();
  },
  startPoll: function() {
    this.startPolling();
    this.addWarning();
  },
  stopPoll: function() {
    this.stopPolling();
  },
  addWarning: function() {
    this.add(ResendNumberChallengeView, ".o-form-error-container");
    this.options.appState.trigger("showNumberChallengeWarning");
  },
  remove: function() {
    BaseFormWithPolling.prototype.remove.apply(this, arguments);
    this.stopPolling();
  }
}, polling));

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ChallengeOktaVerifyView.js
var ChallengeOktaVerifyView = BaseAuthenticatorView.extend({
  initialize: function() {
    var _this$options, _this$options$appStat, _currentAuthenticator;
    BaseAuthenticatorView.prototype.initialize.apply(this, arguments);
    const currentAuthenticator = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : (_this$options$appStat = _this$options.appState) === null || _this$options$appStat === void 0 ? void 0 : _this$options$appStat.get("currentAuthenticator");
    const selectedMethod = currentAuthenticator === null || currentAuthenticator === void 0 ? void 0 : currentAuthenticator.methods[0];
    if ((selectedMethod === null || selectedMethod === void 0 ? void 0 : selectedMethod.type) === AUTHENTICATOR_METHODS.PUSH && currentAuthenticator !== null && currentAuthenticator !== void 0 && (_currentAuthenticator = currentAuthenticator.contextualData) !== null && _currentAuthenticator !== void 0 && _currentAuthenticator.correctAnswer) {
      this.Body = Body37;
    } else if ((selectedMethod === null || selectedMethod === void 0 ? void 0 : selectedMethod.type) === AUTHENTICATOR_METHODS.PUSH) {
      this.Body = Body35;
    } else {
      this.Body = Body36;
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ChallengeOktaVerifyTotpView.js
var OV_UV_ENABLE_BIOMETRIC_SERVER_KEY = "oie.authenticator.oktaverify.method.totp.verify.enable.biometrics";
var Body38 = BaseForm2.extend(Object.assign({
  className: "okta-verify-totp-challenge",
  title: function() {
    return loc3("oie.okta_verify.totp.title", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  showCustomFormErrorCallout: function(error) {
    var _error$responseJSON;
    const errorSummaryKeys = error === null || error === void 0 ? void 0 : (_error$responseJSON = error.responseJSON) === null || _error$responseJSON === void 0 ? void 0 : _error$responseJSON.errorSummaryKeys;
    let options2;
    if (errorSummaryKeys && errorSummaryKeys.includes(OV_UV_ENABLE_BIOMETRIC_SERVER_KEY)) {
      options2 = {
        type: "error",
        className: "okta-verify-uv-callout-content",
        title: loc3("oie.authenticator.app.method.push.verify.enable.biometrics.title", "login"),
        subtitle: loc3("oie.authenticator.app.method.push.verify.enable.biometrics.description", "login"),
        bullets: [loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point1", "login"), loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point2", "login"), loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point3", "login")]
      };
      this.showMessages(createCallout(options2));
      return true;
    }
  }
}));
var ChallengeOktaVerifyTotpView = BaseAuthenticatorView.extend({
  Body: Body38
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ChallengeOktaVerifyResendPushView.js
var OV_NMC_FORCE_UPGRAGE_SERVER_KEY = "oie.authenticator.app.method.push.force.upgrade.number_challenge";
var OV_UV_ENABLE_BIOMETRIC_SERVER_KEY2 = "oie.authenticator.app.method.push.verify.enable.biometrics";
var Body39 = BaseForm2.extend(Object.assign({
  className: "okta-verify-resend-push",
  title: function() {
    return loc3("oie.okta_verify.push.title", "login");
  },
  save: function() {
    return loc3("oie.okta_verify.push.resend", "login");
  },
  showMessages: function() {
    let options2 = {};
    if (this.options.appState.containsMessageWithI18nKey(OV_NMC_FORCE_UPGRAGE_SERVER_KEY)) {
      options2.title = loc3("oie.numberchallenge.force.upgrade.title", "login");
    } else if (this.options.appState.containsMessageWithI18nKey(OV_UV_ENABLE_BIOMETRIC_SERVER_KEY2)) {
      options2.content = null;
      options2.className = "okta-verify-uv-callout-content";
      options2.title = loc3("oie.authenticator.app.method.push.verify.enable.biometrics.title", "login");
      options2.subtitle = loc3("oie.authenticator.app.method.push.verify.enable.biometrics.description", "login");
      options2.type = "error";
      options2.bullets = [loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point1", "login"), loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point2", "login"), loc3("oie.authenticator.app.method.push.verify.enable.biometrics.point3", "login")];
      options2 = createCallout(options2);
    }
    BaseForm2.prototype.showMessages.call(this, options2);
  }
}));
var ChallengeOktaVerifyResendPushView = BaseAuthenticatorView.extend({
  Body: Body39
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/ChallengeOktaVerifyCustomAppPushOnlyFormView.js
var Body40 = BaseForm2.extend(Object.assign({
  className: function() {
    return this.isOV() ? "okta-verify-send-push-form" : "custom-app-send-push-form";
  },
  save: function() {
    return this.options.appState.get("authenticatorKey") === AUTHENTICATOR_KEY.OV ? loc3("oie.okta_verify.sendPushButton", "login") : loc3("oie.custom_app.sendPushButton", "login");
  },
  title: function() {
    return this.isOV() ? loc3("oie.okta_verify.push.title", "login") : loc3("oie.custom_app.push.title", "login");
  },
  render: function() {
    BaseForm2.prototype.render.apply(this, arguments);
    const checkbox = this.$el.find('[data-se="o-form-fieldset-authenticator.autoChallenge"]');
    checkbox.length && this.$el.find(".o-form-button-bar").after(checkbox);
  },
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    return uiSchemas.filter((schema) => schema.name !== "authenticator.methodType");
  },
  isOV: function() {
    return this.options.appState.get("authenticatorKey") === AUTHENTICATOR_KEY.OV;
  }
}));

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/ChallengeOktaVerifyCustomAppFormView.js
var Body41 = Body14.extend({
  getUISchema: function() {
    const uiSchemas = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const methodsSchema = uiSchemas.find((schema) => schema.name === "authenticator.methodType");
    this._sortMethodOptionsIfDeviceKnown(methodsSchema.options);
    const methodOptions = methodsSchema.options.map((option2) => {
      return Object.assign({}, option2, getAuthenticatorDataForVerification({
        authenticatorKey: this.isOV() ? AUTHENTICATOR_KEY.OV : AUTHENTICATOR_KEY.CUSTOM_APP
      }));
    });
    return [{
      View: AuthenticatorVerifyOptions,
      options: {
        name: methodsSchema.name,
        collection: new Collection2(methodOptions)
      }
    }];
  },
  // If the `deviceKnown` attribute is true, we should put the signed_nonce method to the top of authenticator list.
  // This is in sync with v2/ion/ui-schema/ion-object-handler.js - createOVOptions
  _sortMethodOptionsIfDeviceKnown: function(methodOptions) {
    var _this$options, _this$options$current, _this$options$current2, _this$options$current3;
    const deviceKnown = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : (_this$options$current = _this$options.currentViewState) === null || _this$options$current === void 0 ? void 0 : (_this$options$current2 = _this$options$current.relatesTo) === null || _this$options$current2 === void 0 ? void 0 : (_this$options$current3 = _this$options$current2.value) === null || _this$options$current3 === void 0 ? void 0 : _this$options$current3.deviceKnown;
    if (deviceKnown) {
      const signedNonceIndex = methodOptions.findIndex((e) => e.value === "signed_nonce");
      if (signedNonceIndex > 0) {
        const signedNonceModel = methodOptions[signedNonceIndex];
        methodOptions.splice(signedNonceIndex, 1);
        methodOptions.unshift(signedNonceModel);
      }
    }
  },
  isOV: function() {
    return this.options.appState.get("authenticatorKey") === AUTHENTICATOR_KEY.OV;
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/shared/ChallengeOktaVerifyCustomAppDataView.js
var ChallengeOktaVerifyCustomAppDataView = BaseAuthenticatorView.extend({
  initialize: function() {
    BaseAuthenticatorView.prototype.initialize.apply(this, arguments);
    if (this.isPushOnlyWithAutoChallengeFlow()) {
      this.Body = Body40;
    } else {
      this.Body = Body41;
      this.Footer = BaseFooter;
    }
  },
  isPushOnlyWithAutoChallengeFlow: function() {
    const methodType = this.options.appState.getSchemaByName("authenticator.methodType");
    const hasAutoChallengeSchema = this.options.appState.getSchemaByName("authenticator.autoChallenge");
    const methodTypeOptions = methodType === null || methodType === void 0 ? void 0 : methodType.options;
    return hasAutoChallengeSchema && methodTypeOptions.length === 1 && methodTypeOptions[0].value === "push";
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/ov/ChallengeOktaVerifySSOExtensionView.js
var Body42 = BaseForm2.extend({
  noButtonBar: true,
  className: "ion-form device-challenge-poll",
  title: function() {
    return loc3("deviceTrust.sso.redirectText", "login");
  },
  initialize: function() {
    var _this$options$current, _this$options$current2;
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, "error", () => {
      this.$(".spinner").hide();
    });
    this.add('<div class="credential-sso-extension"><div class="spinner"></div></div>');
    const isGetMethod = ((_this$options$current = this.options.currentViewState) === null || _this$options$current === void 0 ? void 0 : (_this$options$current2 = _this$options$current.method) === null || _this$options$current2 === void 0 ? void 0 : _this$options$current2.toLowerCase()) === "get";
    this.model.set("useRedirect", isGetMethod);
    this.trigger("save", this.model);
  },
  showCustomFormErrorCallout: function(error) {
    const options2 = getBiometricsErrorOptions(error, false);
    if (oktaUnderscore.isEmpty(options2)) {
      return false;
    }
    this.showMessages(createCallout(options2));
    return true;
  }
});
var ChallengeOktaVerifySSOExtensionView = BaseAuthenticatorView.extend({
  Body: Body42
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/google-authenticator/EnrollGoogleAuthenticatorBarcodeView.js
var EnrollGoogleAuthenticatorBarcodeView = View2.extend({
  className: "oie-enroll-google-authenticator-barcode",
  template: _Handlebars2.template({
    "1": function(container, depth0, helpers2, partials, data) {
      var helper, alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="google-authenticator-setup-info-title barcode-setup-title">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.google_authenticator.scanBarcode.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 83
          },
          "end": {
            "line": 1,
            "column": 163
          }
        }
      })) + '</div><div class="qrcode-info-container"><p class="google-authenticator-setup-info">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.google_authenticator.scanBarcode.description"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 247
          },
          "end": {
            "line": 1,
            "column": 333
          }
        }
      })) + '</p><div class="qrcode-container"><img class="qrcode" src=' + alias3((helper = (helper = lookupProperty(helpers2, "href") || (depth0 != null ? lookupProperty(depth0, "href") : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, {
        "name": "href",
        "hash": {},
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 391
          },
          "end": {
            "line": 1,
            "column": 399
          }
        }
      }) : helper)) + ' alt="qr code"></img><a href="#" class="cannot-scan-link">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.google_authenticator.scanBarcode.cannotScan"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 457
          },
          "end": {
            "line": 1,
            "column": 542
          }
        }
      })) + "</a></div></div>";
    },
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return (stack1 = lookupProperty(helpers2, "if").call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? lookupProperty(depth0, "href") : depth0, {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 1,
            "column": 565
          }
        }
      })) != null ? stack1 : "";
    },
    "useData": true
  }),
  getTemplateData: function() {
    var _contextualData$qrcod;
    const contextualData = this.options.appState.get("currentAuthenticator").contextualData;
    return {
      href: (_contextualData$qrcod = contextualData.qrcode) === null || _contextualData$qrcod === void 0 ? void 0 : _contextualData$qrcod.href
    };
  },
  events: {
    "click .cannot-scan-link": function(e) {
      e.preventDefault();
      this.options.model.set("viewToDisplay", "manual");
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/google-authenticator/EnrollAuthenticatorManualSetupView.js
var EnrollAuthenticatorManualSetupView = View2.extend({
  className: "oie-enroll-google-authenticator-manual-setup",
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      var alias1 = depth0 != null ? depth0 : container.nullContext || {}, alias2 = container.hooks.helperMissing, alias3 = container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return void 0;
      };
      return '<div class="google-authenticator-setup-info-title manual-setup-title">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.google_authenticator.cannotScanBarcode.title"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 70
          },
          "end": {
            "line": 1,
            "column": 156
          }
        }
      })) + '</div><p class="google-authenticator-setup-info">' + alias3((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || alias2).call(alias1, {
        "name": "i18n",
        "hash": {
          "bundle": "login",
          "code": "oie.enroll.google_authenticator.manualSetupInstructions"
        },
        "data": data,
        "loc": {
          "start": {
            "line": 1,
            "column": 205
          },
          "end": {
            "line": 1,
            "column": 291
          }
        }
      })) + "</p>";
    },
    "useData": true
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/google-authenticator/EnrollAuthenticatorGoogleAuthenticatorView.js
var VIEW_TO_DISPLAY = "viewToDisplay";
var viewToDisplayState = {
  BARCODE: "barcode",
  MANUAL: "manual",
  ENTER_CODE: "enterCode"
};
var Body43 = BaseForm2.extend({
  title: function() {
    return loc3("oie.enroll.google_authenticator.setup.title", "login");
  },
  noButtonBar: true,
  className: "oie-enroll-google-authenticator",
  enterCodeSubtitle: View2.extend({
    template: _Handlebars2.template({
      "compiler": [8, ">= 4.3.0"],
      "main": function(container, depth0, helpers2, partials, data) {
        var lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return void 0;
        };
        return '<div class="google-authenticator-setup-info-title enter-code-title">' + container.escapeExpression((lookupProperty(helpers2, "i18n") || depth0 && lookupProperty(depth0, "i18n") || container.hooks.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, {
          "name": "i18n",
          "hash": {
            "bundle": "login",
            "code": "oie.enroll.google_authenticator.enterCode.title"
          },
          "data": data,
          "loc": {
            "start": {
              "line": 1,
              "column": 68
            },
            "end": {
              "line": 1,
              "column": 146
            }
          }
        })) + "</div>";
      },
      "useData": true
    })
  }),
  getUISchema: function() {
    const schema = BaseForm2.prototype.getUISchema.apply(this, arguments);
    const nextButton = addCustomButton({
      className: "google-authenticator-next",
      title: loc3("oform.next", "login"),
      attributes: {
        style: "display: block"
      },
      click: () => {
        this.model.set(VIEW_TO_DISPLAY, viewToDisplayState.ENTER_CODE);
      }
    });
    const verifyButton = addCustomButton({
      className: "google-authenticator-verify",
      title: loc3("oform.verify", "login"),
      click: () => {
        this.$el.submit();
      }
    });
    schema[0].showWhen = {
      viewToDisplay: viewToDisplayState.ENTER_CODE
    };
    schema.unshift({
      View: this.enterCodeSubtitle,
      selector: ".o-form-fieldset-container",
      showWhen: {
        viewToDisplay: viewToDisplayState.ENTER_CODE
      }
    });
    schema.push({
      View: EnrollGoogleAuthenticatorBarcodeView,
      selector: ".o-form-fieldset-container",
      showWhen: {
        viewToDisplay: viewToDisplayState.BARCODE
      }
    }, {
      View: EnrollAuthenticatorManualSetupView,
      selector: ".o-form-fieldset-container",
      showWhen: {
        viewToDisplay: viewToDisplayState.MANUAL
      }
    }, {
      label: false,
      className: "shared-secret",
      type: "text",
      placeholder: this.options.appState.get("currentAuthenticator").contextualData.sharedSecret,
      disabled: true,
      showWhen: {
        viewToDisplay: viewToDisplayState.MANUAL
      }
    }, {
      View: nextButton,
      showWhen: {
        viewToDisplay: (val) => val === viewToDisplayState.BARCODE || val === viewToDisplayState.MANUAL
      }
    }, {
      View: verifyButton,
      showWhen: {
        viewToDisplay: (val) => val === viewToDisplayState.ENTER_CODE
      }
    });
    return schema;
  }
});
var EnrollAuthenticatorGoogleAuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body43,
  createModelClass: function() {
    const ModelClass = BaseView2.prototype.createModelClass.apply(this, arguments);
    const local3 = Object.assign({
      viewToDisplay: {
        value: "barcode",
        type: "string",
        required: true,
        values: [viewToDisplayState.BARCODE, viewToDisplayState.MANUAL, viewToDisplayState.ENTER_CODE]
      }
    }, ModelClass.prototype.local);
    return ModelClass.extend({
      local: local3
    });
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/google-authenticator/ChallengeGoogleAuthenticatorView.js
var Body44 = BaseForm2.extend(Object.assign({
  className: "google-authenticator-challenge",
  title: function() {
    return loc3("oie.verify.google_authenticator.otp.title", "login");
  },
  subtitle: function() {
    return loc3("oie.verify.google_authenticator.otp.description", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
}));
var ChallengeGoogleAuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body44
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/on-prem/EnrollAuthenticatorOnPremView.js
var ON_PREM_TOKEN_CHANGE_KEY = "errors.E0000113";
var Body45 = BaseForm2.extend({
  className: "on-prem-authenticator-enroll",
  modelEvents: {
    "error": "_checkTokenChange"
  },
  title: function() {
    const vendorName = this.options.appState.getAuthenticatorDisplayName() || loc3("oie.on_prem.authenticator.default.vendorName", "login");
    return loc3("oie.on_prem.enroll.title", "login", [vendorName]);
  },
  _checkTokenChange: function(model, convertedErrors) {
    var _convertedErrors$resp;
    const errorSummaryKeys = convertedErrors === null || convertedErrors === void 0 ? void 0 : (_convertedErrors$resp = convertedErrors.responseJSON) === null || _convertedErrors$resp === void 0 ? void 0 : _convertedErrors$resp.errorSummaryKeys;
    if (errorSummaryKeys && errorSummaryKeys.includes(ON_PREM_TOKEN_CHANGE_KEY)) {
      this.model.set("credentials.passcode", "");
      this.render();
    }
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
});
var EnrollAuthenticatorOnPremView = BaseAuthenticatorView.extend({
  Body: Body45
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/on-prem/ChallengeAuthenticatorOnPremView.js
var ON_PREM_TOKEN_CHANGE_KEY2 = "errors.E0000113";
var Body46 = BaseForm2.extend({
  className: "on-prem-authenticator-verify",
  modelEvents: {
    "error": "_checkTokenChange"
  },
  title: function() {
    const vendorName = this.options.appState.getAuthenticatorDisplayName() || loc3("oie.on_prem.authenticator.default.vendorName", "login");
    return loc3("oie.on_prem.verify.title", "login", [vendorName]);
  },
  _checkTokenChange: function(model, convertedErrors) {
    var _convertedErrors$resp;
    const errorSummaryKeys = convertedErrors === null || convertedErrors === void 0 ? void 0 : (_convertedErrors$resp = convertedErrors.responseJSON) === null || _convertedErrors$resp === void 0 ? void 0 : _convertedErrors$resp.errorSummaryKeys;
    if (errorSummaryKeys && errorSummaryKeys.includes(ON_PREM_TOKEN_CHANGE_KEY2)) {
      this.model.set("credentials.passcode", "");
      this.render();
    }
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
});
var ChallengeAuthenticatorOnPremView = BaseAuthenticatorView.extend({
  Body: Body46
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/duo/BaseDuoAuthenticatorForm.js
var BaseDuoAuthenticatorForm = BaseForm2.extend({
  noButtonBar: true,
  postRender: function() {
    const contextualData = this.getContextualData();
    const duoFrame = this.add(`<iframe frameborder="0" title="'${this.title()}'"></iframe>`).last();
    try {
      Duo.init({
        host: contextualData.host,
        sig_request: contextualData.signedToken,
        // eslint-disable-line camelcase
        iframe: duoFrame.el,
        post_action: (signedData) => {
          this.model.set("credentials.signatureData", signedData);
          this.saveForm(this.model);
        }
      });
    } catch (e) {
      duoFrame.remove();
      this.add(createCallout({
        type: "error",
        subtitle: loc3("oie.duo.iFrameError", "login")
      }), ".o-form-error-container");
    }
  },
  getContextualData: function() {
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/duo/EnrollDuoAuthenticatorView.js
var Body47 = BaseDuoAuthenticatorForm.extend({
  title: function() {
    return loc3("oie.duo.enroll.title", "login");
  },
  getContextualData: function() {
    return this.options.appState.get("currentAuthenticator").contextualData;
  }
});
var EnrollDuoAuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body47
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/duo/ChallengeDuoAuthenticatorView.js
var Body48 = BaseDuoAuthenticatorForm.extend({
  title: function() {
    return loc3("oie.duo.verify.title", "login");
  },
  getContextualData: function() {
    return this.options.appState.get("currentAuthenticatorEnrollment").contextualData;
  }
});
var ChallengeDuoAuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body48
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/idp/BaseIdpAuthenticator.js
var BaseIdPAuthenticatorBody = BaseForm2.extend({
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.model.set("useRedirect", true);
    this.add('<div class="okta-waiting-spinner"></div>');
  }
});
var BaseIdpAuthenticatorView = BaseAuthenticatorView.extend({
  postRender: function() {
    BaseAuthenticatorView.prototype.postRender.apply(this, arguments);
    const messages = this.options.appState.get("messages") || {};
    if (this.settings.get("features.skipIdpFactorVerificationBtn") && !Array.isArray(messages.value)) {
      this.$(".o-form-button-bar").hide();
      this.$(".okta-waiting-spinner").show();
      this.form.trigger("save", this.model);
    } else {
      this.$(".okta-waiting-spinner").hide();
      this.$(".o-form-button-bar").show();
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/idp/AuthenticatorIdPVerifyView.js
var Body49 = BaseIdPAuthenticatorBody.extend({
  title: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return loc3("oie.idp.challenge.title", "login", [displayName]);
  },
  subtitle: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return loc3("oie.idp.challenge.description", "login", [displayName]);
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
});
var AuthenticatorIdPVerifyView = BaseIdpAuthenticatorView.extend({
  Body: Body49
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/idp/AuthenticatorIdPEnrollView.js
var Body50 = BaseIdPAuthenticatorBody.extend({
  title: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return loc3("oie.idp.enroll.title", "login", [displayName]);
  },
  subtitle: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return loc3("oie.idp.enroll.description", "login", [displayName]);
  },
  save: function() {
    return loc3("mfa.enroll", "login");
  }
});
var AuthenticatorIdPEnrollView = BaseIdpAuthenticatorView.extend({
  Body: Body50
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/custom-otp/ChallengeCustomOTPAuthenticatorView.js
var Body51 = BaseForm2.extend(Object.assign({
  className: "mfa-verify-custom-otp",
  title: function() {
    const vendorName = this.options.appState.getAuthenticatorDisplayName() || loc3("oie.custom_otp.authenticator.default.vendorName", "login");
    return loc3("oie.verify.custom_otp.title", "login", [vendorName]);
  },
  subtitle: function() {
    return loc3("oie.verify.custom_otp.description", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  }
}));
var ChallengeCustomOTPAuthenticatorView = BaseAuthenticatorView.extend({
  Body: Body51
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/symantec/AuthenticatorSymantecView.js
var Body52 = BaseForm2.extend({
  title: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return this.options.appState.isAuthenticatorChallenge() ? loc3("oie.symantecVip.challenge.title", "login", [displayName]) : loc3("oie.symantecVip.enroll.title", "login", [displayName]);
  },
  subtitle: function() {
    const displayName = this.options.appState.getAuthenticatorDisplayName();
    return this.options.appState.isAuthenticatorChallenge() ? loc3("oie.symantecVip.challenge.description", "login", [displayName]) : loc3("oie.symantecVip.enroll.description", "login", [displayName]);
  },
  save: function() {
    return this.options.appState.isAuthenticatorChallenge() ? loc3("mfa.challenge.verify", "login") : loc3("mfa.enroll", "login");
  }
});
var AuthenticatorSymantecView = BaseAuthenticatorView.extend({
  Body: Body52
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/device/DeviceCodeActivateView.js
var Body53 = BaseForm2.extend({
  title: function() {
    return loc3("device.code.activate.title", "login");
  },
  subtitle: function() {
    return loc3("device.code.activate.subtitle", "login");
  },
  events: {
    'keyup input[name="userCode"]': function(e) {
      e.preventDefault();
      this.addHyphen(e);
    }
  },
  addHyphen: function(evt) {
    const currentVal = evt.target.value;
    if (currentVal && currentVal.length === 4 && !["Backspace", "Delete", "-"].includes(evt.key)) {
      evt.target.value = currentVal.concat("-");
    }
  }
});
var DeviceCodeActivateView = BaseView2.extend({
  Body: Body53
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/piv/PIVHeader.js
var PIVHeader = BaseHeader.extend({
  HeaderBeacon: HeaderBeacon.extend({
    getBeaconClassName: function() {
      return "smartcard";
    }
  })
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/piv/ChallengePIVView.js
var Body54 = BaseForm2.extend({
  className: "piv-cac-card",
  modelEvents: {
    request: "startAuthentication",
    error: "stopAuthentication"
  },
  initialize: function() {
    BaseForm2.prototype.initialize.apply(this, arguments);
    this.model.set("useRedirect", true);
    this.addInstructions();
  },
  title: function() {
    return loc3("piv.cac.title", "login");
  },
  save: function() {
    return loc3("retry", "login");
  },
  addInstructions: function() {
    this.add(`<div class='piv-verify-text'>
        <p>${loc3("piv.cac.card.insert", "login")}</p>
        <div data-se='piv-waiting' class='okta-waiting-spinner'></div>
      </div>`);
  },
  startAuthentication: function() {
    this.$(".okta-waiting-spinner").show();
    this.$(".o-form-button-bar").hide();
  },
  stopAuthentication: function() {
    this.$(".okta-waiting-spinner").hide();
    this.$(".o-form-button-bar").show();
  }
});
var ChallengePIVView = BaseAuthenticatorView.extend({
  Header: PIVHeader,
  Body: Body54,
  postRender: function() {
    BaseAuthenticatorView.prototype.postRender.apply(this, arguments);
    const messages = this.options.appState.get("messages") || {};
    if (Array.isArray(messages.value)) {
      this.form.stopAuthentication();
    } else {
      this.form.startAuthentication();
      this.form.trigger("save", this.model);
    }
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/yubikey/AuthenticatorYubiKeyView.js
var ExampleView = View2.extend({
  template: _Handlebars2.template({
    "compiler": [8, ">= 4.3.0"],
    "main": function(container, depth0, helpers2, partials, data) {
      return '<div aria-hidden="true" class="yubikey-demo"></div>';
    },
    "useData": true
  })
});
var Body55 = BaseForm2.extend({
  title: function() {
    return this.options.appState.isAuthenticatorChallenge() ? loc3("oie.yubikey.challenge.title", "login") : loc3("oie.yubikey.enroll.title", "login");
  },
  subtitle: function() {
    return loc3("oie.yubikey.description", "login");
  },
  save: function() {
    return loc3("mfa.challenge.verify", "login");
  },
  getUISchema: function() {
    const schema = BaseForm2.prototype.getUISchema.apply(this, arguments);
    schema.unshift({
      View: ExampleView,
      selector: ".o-form-fieldset-container"
    });
    return schema;
  }
});
var AuthenticatorYubiKeyView = BaseAuthenticatorView.extend({
  Body: Body55
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/views/custom-app/ChallengeCustomAppResendPushView.js
var CUSTOM_APP_UV_ENABLE_BIOMETRIC_SERVER_KEY = "oie.authenticator.custom_app.method.push.verify.enable.biometrics";
var Body56 = BaseForm2.extend(Object.assign({
  className: "custom-app-verify-resend-push",
  title: function() {
    return loc3("oie.verify.custom_app.title", "login", [this.options.appState.getAuthenticatorDisplayName()]);
  },
  save: function() {
    return loc3("oie.custom_app.push.resend", "login");
  },
  showMessages: function() {
    let options2 = {};
    if (this.options.appState.containsMessageWithI18nKey(CUSTOM_APP_UV_ENABLE_BIOMETRIC_SERVER_KEY)) {
      options2.content = null;
      options2.className = "okta-verify-uv-callout-content";
      options2.title = loc3("oie.authenticator.custom_app.method.push.verify.enable.biometrics.title", "login", [this.options.appState.getAuthenticatorDisplayName()]);
      options2.subtitle = loc3("oie.authenticator.custom_app.method.push.verify.enable.biometrics.description", "login");
      options2.type = "error";
      options2.bullets = [loc3("oie.authenticator.custom_app.method.push.verify.enable.biometrics.point1", "login"), loc3("oie.authenticator.custom_app.method.push.verify.enable.biometrics.point2", "login", [this.options.appState.getAuthenticatorDisplayName()]), loc3("oie.authenticator.custom_app.method.push.verify.enable.biometrics.point3", "login", [this.options.appState.getAuthenticatorDisplayName()])];
      options2 = createCallout(options2);
    }
    BaseForm2.prototype.showMessages.call(this, options2);
  }
}));
var ChallengeCustomAppResendPushView = BaseAuthenticatorView.extend({
  Body: Body56
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/view-builder/ViewFactory.js
var DEFAULT = "_";
var VIEWS_MAPPING = {
  [FORMS.IDENTIFY]: {
    [DEFAULT]: IdentifierView
  },
  [FORMS.IDENTIFY_RECOVERY]: {
    [DEFAULT]: IdentifyRecoveryView
  },
  [FORMS.DEVICE_CHALLENGE_POLL]: {
    [DEFAULT]: DeviceChallengePollView
  },
  [FORMS.LAUNCH_AUTHENTICATOR]: {
    [DEFAULT]: SignInDeviceView
  },
  [FORMS.DEVICE_APPLE_SSO_EXTENSION]: {
    [DEFAULT]: SSOExtensionView,
    [AUTHENTICATOR_KEY.OV]: ChallengeOktaVerifySSOExtensionView
  },
  [FORMS.CANCEL_TRANSACTION]: {
    [DEFAULT]: SSOExtensionView
  },
  [FORMS.ENROLL_PROFILE]: {
    [DEFAULT]: EnrollProfileView
  },
  [FORMS.ENROLL_PROFILE_UPDATE]: {
    [DEFAULT]: EnrollProfileUpdateView
  },
  [FORMS.POLL]: {
    [DEFAULT]: PollView
  },
  [FORMS.REQUEST_ACTIVATION]: {
    [DEFAULT]: RequestActivationEmail
  },
  [FORMS.SELECT_AUTHENTICATOR_ENROLL]: {
    [DEFAULT]: SelectAuthenticatorEnrollView
  },
  [FORMS.AUTHENTICATOR_ENROLLMENT_DATA]: {
    [AUTHENTICATOR_KEY.PHONE]: EnrollAuthenticatorDataPhoneView
  },
  [FORMS.CONSENT_ADMIN]: {
    [DEFAULT]: AdminConsentView
  },
  [FORMS.CONSENT_ENDUSER]: {
    [DEFAULT]: EnduserConsentView
  },
  [FORMS.CONSENT_GRANULAR]: {
    [DEFAULT]: GranularConsentView
  },
  [FORMS.CONSENT_EMAIL_CHALLENGE]: {
    [DEFAULT]: EnduserEmailConsentView
  },
  [FORMS.ENROLL_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.DUO]: EnrollDuoAuthenticatorView,
    [AUTHENTICATOR_KEY.EMAIL]: EnrollAuthenticatorEmailView,
    [AUTHENTICATOR_KEY.GOOGLE_OTP]: EnrollAuthenticatorGoogleAuthenticatorView,
    [AUTHENTICATOR_KEY.IDP]: AuthenticatorIdPEnrollView,
    [AUTHENTICATOR_KEY.ON_PREM]: EnrollAuthenticatorOnPremView,
    [AUTHENTICATOR_KEY.PASSWORD]: EnrollAuthenticatorPasswordView,
    [AUTHENTICATOR_KEY.PHONE]: EnrollAuthenticatorPhoneView,
    [AUTHENTICATOR_KEY.RSA]: EnrollAuthenticatorOnPremView,
    [AUTHENTICATOR_KEY.SECURITY_QUESTION]: EnrollAuthenticatorSecurityQuestion,
    [AUTHENTICATOR_KEY.SYMANTEC_VIP]: AuthenticatorSymantecView,
    [AUTHENTICATOR_KEY.WEBAUTHN]: EnrollWebauthnView,
    [AUTHENTICATOR_KEY.YUBIKEY]: AuthenticatorYubiKeyView
  },
  [FORMS.CHALLENGE_AUTHENTICATOR]: {
    [AUTHENTICATOR_KEY.CUSTOM_OTP]: ChallengeCustomOTPAuthenticatorView,
    [AUTHENTICATOR_KEY.DUO]: ChallengeDuoAuthenticatorView,
    [AUTHENTICATOR_KEY.EMAIL]: ChallengeAuthenticatorEmailView,
    [AUTHENTICATOR_KEY.GOOGLE_OTP]: ChallengeGoogleAuthenticatorView,
    [AUTHENTICATOR_KEY.IDP]: AuthenticatorIdPVerifyView,
    [AUTHENTICATOR_KEY.ON_PREM]: ChallengeAuthenticatorOnPremView,
    [AUTHENTICATOR_KEY.OV]: ChallengeOktaVerifyTotpView,
    [AUTHENTICATOR_KEY.PASSWORD]: ChallengeAuthenticatorPasswordView,
    [AUTHENTICATOR_KEY.PHONE]: ChallengeAuthenticatorPhoneView,
    [AUTHENTICATOR_KEY.RSA]: ChallengeAuthenticatorOnPremView,
    [AUTHENTICATOR_KEY.SECURITY_QUESTION]: ChallengeAuthenticatorSecurityQuestion,
    [AUTHENTICATOR_KEY.SYMANTEC_VIP]: AuthenticatorSymantecView,
    [AUTHENTICATOR_KEY.WEBAUTHN]: ChallengeWebauthnView,
    [AUTHENTICATOR_KEY.YUBIKEY]: AuthenticatorYubiKeyView
  },
  [FORMS.ENROLL_POLL]: {
    [AUTHENTICATOR_KEY.OV]: EnrollPollOktaVerifyView
  },
  [FORMS.SELECT_ENROLLMENT_CHANNEL]: {
    [AUTHENTICATOR_KEY.OV]: SelectEnrollmentChannelOktaVerifyView
  },
  [FORMS.ENROLLMENT_CHANNEL_DATA]: {
    [AUTHENTICATOR_KEY.OV]: EnrollementChannelDataOktaVerifyView
  },
  // Expired scenarios for authenticators..
  [FORMS.REENROLL_AUTHENTICATOR]: {
    // Password expired scenario..
    [AUTHENTICATOR_KEY.PASSWORD]: ReEnrollAuthenticatorPasswordView
  },
  // Will expire soon warnings for authenticators..
  [FORMS.REENROLL_AUTHENTICATOR_WARNING]: {
    // Password will expire soon scenario..
    [AUTHENTICATOR_KEY.PASSWORD]: ReEnrollAuthenticatorWarningPasswordView
  },
  // Reset forms for authenticators..
  [FORMS.RESET_AUTHENTICATOR]: {
    // Admin driven password reset..
    [AUTHENTICATOR_KEY.PASSWORD]: ResetAuthenticatorPasswordView
  },
  [FORMS.SELECT_AUTHENTICATOR_AUTHENTICATE]: {
    [DEFAULT]: SelectAuthenticatorVerifyView
  },
  [FORMS.SELECT_AUTHENTICATOR_UNLOCK]: {
    [DEFAULT]: SelectAuthenticatorUnlockAccountView
  },
  [FORMS.CHALLENGE_POLL]: {
    [AUTHENTICATOR_KEY.OV]: ChallengeOktaVerifyView,
    [AUTHENTICATOR_KEY.CUSTOM_APP]: AuthenticatorView
  },
  [FORMS.RESEND]: {
    [AUTHENTICATOR_KEY.OV]: ChallengeOktaVerifyResendPushView,
    [AUTHENTICATOR_KEY.CUSTOM_APP]: ChallengeCustomAppResendPushView
  },
  [FORMS.AUTHENTICATOR_VERIFICATION_DATA]: {
    [AUTHENTICATOR_KEY.PHONE]: ChallengeAuthenticatorDataPhoneView,
    [AUTHENTICATOR_KEY.OV]: ChallengeOktaVerifyCustomAppDataView,
    [AUTHENTICATOR_KEY.EMAIL]: ChallengeAuthenticatorDataEmailView,
    [AUTHENTICATOR_KEY.CUSTOM_APP]: ChallengeOktaVerifyCustomAppDataView
  },
  [FORMS.FAILURE_REDIRECT]: {
    [DEFAULT]: AutoRedirectView
  },
  [FORMS.SUCCESS_REDIRECT]: {
    [DEFAULT]: AutoRedirectView
  },
  [FORMS.REDIRECT_IDP]: {
    [DEFAULT]: RedirectIdPView
  },
  [FORMS.PIV_IDP]: {
    [DEFAULT]: ChallengePIVView
  },
  [FORMS.DEVICE_ENROLLMENT_TERMINAL]: {
    [DEFAULT]: DeviceEnrollmentTerminalView
  },
  [FORMS.USER_CODE]: {
    [DEFAULT]: DeviceCodeActivateView
  },
  [FORMS.TERMINAL]: {
    [DEFAULT]: TerminalView
  }
};
var ViewFactory = {
  create: function(formName, authenticatorKey = DEFAULT) {
    const config2 = VIEWS_MAPPING[formName];
    if (!config2) {
      Logger.warn(`Cannot find customized View for ${formName}.`);
      return BaseView2;
    }
    const View3 = config2[authenticatorKey] || config2[DEFAULT];
    if (!View3) {
      Logger.warn(`Cannot find customized View for ${formName} + ${authenticatorKey}.`);
      return BaseView2;
    }
    return View3;
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/controllers/FormController.js
var FormController2 = Controller.extend({
  className: "form-controller",
  appStateEvents: {
    "change:currentFormName": "handleFormNameChange",
    "afterError": "handleAfterError",
    "invokeAction": "handleInvokeAction",
    "saveForm": "handleSaveForm",
    "switchForm": "handleSwitchForm"
  },
  preRender: function() {
    this.removeChildren();
  },
  postRender: function() {
    const currentViewState = this.options.appState.getCurrentViewState();
    if (!currentViewState) {
      return;
    }
    this.clearMetadata();
    let formName = currentViewState.name;
    if (formName === "identify" && this.options.settings.get("flow") === CONFIGURED_FLOW.RESET_PASSWORD) {
      formName = "identify-recovery";
    }
    const TheView = ViewFactory.create(formName, this.options.appState.get("authenticatorKey"));
    try {
      this.formView = this.add(TheView, {
        options: {
          currentViewState
        }
      }).last();
    } catch (error) {
      this.options.settings.callGlobalError(error);
      return;
    }
    this.triggerAfterRenderEvent();
  },
  clearMetadata: function() {
    const formName = this.options.appState.get("currentFormName");
    if (TERMINAL_FORMS.includes(formName)) {
      sessionStorageHelper.removeStateHandle();
    }
  },
  triggerAfterRenderEvent: function() {
    const contextData = this.createAfterEventContext();
    this.trigger("afterRender", contextData);
  },
  handleFormNameChange: function() {
    this.render();
  },
  handleAfterError: function(error) {
    const contextData = this.createAfterEventContext();
    const errorContextData = {
      xhr: error,
      errorSummary: error.responseJSON && error.responseJSON.errorSummary
    };
    this.trigger("afterError", contextData, errorContextData);
  },
  createAfterEventContext: function() {
    const formName = this.options.appState.get("currentFormName");
    const authenticatorKey = this.options.appState.get("authenticatorKey");
    const methodType = this.options.appState.get("authenticatorMethodType");
    const isPasswordRecoveryFlow = this.options.appState.get("isPasswordRecoveryFlow");
    const v1ControllerClassName = getV1ClassName(formName, authenticatorKey, methodType, isPasswordRecoveryFlow);
    const eventData = {
      controller: v1ControllerClassName,
      formName
    };
    if (authenticatorKey) {
      eventData.authenticatorKey = authenticatorKey;
    }
    if (methodType) {
      eventData.methodType = methodType;
    }
    return eventData;
  },
  handleSwitchForm: function(formName) {
    if (this.options.appState.get("messages")) {
      this.options.appState.unset("messages");
    }
    this.options.appState.set("currentFormName", formName);
  },
  // eslint-disable-next-line max-statements
  handleInvokeAction: function() {
    return __async(this, arguments, function* (actionPath = "", actionParams = {}) {
      const {
        appState,
        settings
      } = this.options;
      const idx = appState.get("idx");
      const {
        stateHandle
      } = idx.context;
      let invokeOptions = {
        exchangeCodeForTokens: false,
        // we handle this in interactionCodeFlow.js
        shouldProceedWithEmailAuthenticator: false,
        // do not auto-select email authenticator
        stateHandle
      };
      let error;
      if (actionPath === "cancel") {
        settings.getAuthClient().transactionManager.clear({
          clearIdxResponse: false
        });
        sessionStorageHelper.removeStateHandle();
        appState.clearAppStateCache();
        if (settings.get("useInteractionCodeFlow")) {
          appState.trigger("restartLoginFlow");
          return;
        }
      }
      if (idx["neededToProceed"].find((item) => item.name === actionPath)) {
        invokeOptions = __spreadProps(__spreadValues({}, invokeOptions), {
          step: actionPath
        });
      } else if (oktaUnderscore.isFunction(idx["actions"][actionPath])) {
        invokeOptions = __spreadProps(__spreadValues({}, invokeOptions), {
          actions: [{
            name: actionPath,
            params: actionParams
          }]
        });
      } else {
        error = new ConfigError(`Invalid action selected: ${actionPath}`);
        this.options.settings.callGlobalError(error);
        yield this.showFormErrors(this.formView.model, error, this.formView.form);
        return;
      }
      yield this.invokeAction(invokeOptions);
    });
  },
  invokeAction: function(invokeOptions) {
    return __async(this, null, function* () {
      const authClient = this.options.settings.getAuthClient();
      let resp;
      let error;
      try {
        resp = yield authClient.idx.proceed(invokeOptions);
        if (resp.requestDidSucceed === false) {
          error = resp;
        }
      } catch (e) {
        error = e;
      }
      if (error) {
        yield this.showFormErrors(this.formView.model, error, this.formView.form);
        return;
      }
      yield this.handleIdxResponse(resp);
    });
  },
  // eslint-disable-next-line max-statements, complexity
  handleSaveForm: function(model) {
    return __async(this, null, function* () {
      const formName = model.get("formName");
      this.toggleFormButtonState(true);
      model.trigger("request");
      if (model.get("useRedirect")) {
        sessionStorageHelper.removeStateHandle();
        const currentViewState = this.options.appState.getCurrentViewState();
        Util2.redirectWithFormGet(currentViewState.href);
        return;
      }
      const values = this.transformIdentifier(formName, model);
      if (!this.options.appState.hasRemediationObject(formName)) {
        this.options.settings.callGlobalError(`Cannot find http action for "${formName}".`);
        yield this.showFormErrors(this.formView.model, "Cannot find action to proceed.", this.formView.form);
        return;
      }
      if (formName === "identify" && this.options.settings.get("flow") === CONFIGURED_FLOW.RESET_PASSWORD) {
        values.authenticator = "okta_password";
      }
      const authClient = this.options.settings.getAuthClient();
      const idxOptions = {
        exchangeCodeForTokens: false,
        // we handle this in interactionCodeFlow.js
        shouldProceedWithEmailAuthenticator: false
        // do not auto-select email authenticator
      };
      try {
        const idx = this.options.appState.get("idx");
        const {
          stateHandle
        } = idx.context;
        const resp = yield authClient.idx.proceed(__spreadValues(__spreadProps(__spreadValues({}, idxOptions), {
          step: formName,
          stateHandle
        }), values));
        if (resp.status === IdxStatus.FAILURE) {
          throw resp.error;
        }
        if (IonResponseHelper.isIdxSessionExpiredError(resp)) {
          const authClient2 = this.settings.getAuthClient();
          authClient2.transactionManager.clear();
          yield this.handleIdxResponse(resp);
          return;
        }
        if (resp.requestDidSucceed === false && !resp.stepUp) {
          yield this.showFormErrors(model, resp, this.formView.form);
          return;
        }
        const onSuccess = this.handleIdxResponse.bind(this, resp);
        if (formName === FORMS.ENROLL_PROFILE) {
          var _values$userProfile;
          this.settings.postRegistrationSubmit(values === null || values === void 0 ? void 0 : (_values$userProfile = values.userProfile) === null || _values$userProfile === void 0 ? void 0 : _values$userProfile.email, onSuccess, (error) => {
            model.trigger("error", model, {
              responseJSON: error
            });
          });
        } else {
          yield onSuccess();
        }
      } catch (error) {
        var _error$is;
        if ((_error$is = error.is) !== null && _error$is !== void 0 && _error$is.call(error, "terminal")) {
          this.options.appState.setNonIdxError(error);
        } else {
          yield this.showFormErrors(model, error, this.formView.form);
        }
      } finally {
        this.toggleFormButtonState(false);
      }
    });
  },
  transformIdentifier: function(formName, model) {
    const modelJSON = model.toJSON();
    if (Object.prototype.hasOwnProperty.call(modelJSON, "identifier")) {
      const operation = FORM_NAME_TO_OPERATION_MAP[formName];
      modelJSON.identifier = this.settings.transformUsername(modelJSON.identifier, operation);
    }
    return modelJSON;
  },
  /**
   * @param model current form model
   * @param error any errors after user action
   * @param form current form
   * Handle errors that get displayed right after any user action. After such form errors widget doesn't
   * reload or re-render, but updates the AppSate with latest remediation.
   */
  showFormErrors: function(model, error, form2) {
    return __async(this, null, function* () {
      var _error, _idxStateError, _idxStateError2;
      let errorObj;
      let idxStateError;
      let showErrorBanner = true;
      model.trigger("clearFormError");
      if (!error) {
        error = "FormController - unknown error found";
        this.options.settings.callGlobalError(error);
      }
      if ((_error = error) !== null && _error !== void 0 && _error.rawIdxState) {
        idxStateError = error;
        error = error.rawIdxState;
      }
      if (IonResponseHelper.isIonErrorResponse(error)) {
        errorObj = IonResponseHelper.convertFormErrors(error);
      } else if (error.errorSummary) {
        errorObj = {
          responseJSON: error
        };
      } else {
        Util2.logConsoleError(error);
        errorObj = {
          responseJSON: {
            errorSummary: loc3("error.unsupported.response", "login")
          }
        };
      }
      if (oktaUnderscore.isFunction(form2 === null || form2 === void 0 ? void 0 : form2.showCustomFormErrorCallout)) {
        showErrorBanner = !form2.showCustomFormErrorCallout(errorObj, idxStateError.messages);
      }
      model.trigger("error", model, errorObj, showErrorBanner);
      idxStateError = Object.assign({}, idxStateError, {
        hasFormError: true
      });
      if (Array.isArray((_idxStateError = idxStateError) === null || _idxStateError === void 0 ? void 0 : _idxStateError.neededToProceed) && (_idxStateError2 = idxStateError) !== null && _idxStateError2 !== void 0 && _idxStateError2.neededToProceed.length) {
        yield this.handleIdxResponse(idxStateError);
      }
    });
  },
  handleIdxResponse: function(idxResp) {
    return __async(this, null, function* () {
      yield updateAppState(this.options.appState, idxResp);
    });
  },
  /**
   * SignIn widget has its own (hacky) way to customize the button disabled state:
   * adding `link-button-disabled` despite the name was intend only to disable
   * `link-button`.
   * Instead of doing decent refactor, we want to follow the convention for now.
   *
   * @param {boolean} disabled whether add extra disable CSS class.
   */
  toggleFormButtonState: function(disabled) {
    const button = this.$el.find(".o-form-button-bar .button");
    button.toggleClass("link-button-disabled", disabled);
  }
});

// node_modules/@okta/okta-signin-widget/dist/esm/src/v2/WidgetRouter.js
var routes = {
  "": "defaultAuth",
  "*wildcard": "defaultAuth"
};
var WidgetRouter = class extends BaseLoginRouter2 {
  constructor(options2) {
    super(__spreadValues({
      routes
    }, options2));
  }
  defaultAuth() {
    this.render(FormController2);
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/models/Hooks.js
var Hooks = class extends Model2 {
  mergeHook(formName, hookToMerge) {
    const hooks = this.get("hooks") || {};
    mergeHook(hooks, formName, hookToMerge);
    this.set("hooks", hooks);
  }
  getHook(formName) {
    const hooks = this.get("hooks") || {};
    return hooks[formName];
  }
};

// node_modules/@okta/okta-signin-widget/dist/esm/src/widget/OktaSignIn.js
var EVENTS_LIST = ["ready", "afterError", "afterRender"];
var OktaSignIn = class {
  constructor(options2) {
    this.Router = void 0;
    this.options = void 0;
    this.hooks = void 0;
    this.router = void 0;
    this.authClient = void 0;
    Util2.debugMessage(`
        The Okta Sign-In Widget is running in development mode.
        When you are ready to publish your app, embed the minified version to turn on production mode.
        See: https://developer.okta.com/code/javascript/okta_sign-in_widget#cdn
      `);
    this.options = options2;
    this.authClient = getAuthClient(options2);
    if (options2.useInteractionCodeFlow && this.authClient.isPKCE() === false) {
      throw new ConfigError('The "useInteractionCodeFlow" option requires PKCE to be enabled on the authClient.');
    }
    this.hooks = new Hooks({
      hooks: options2.hooks
    });
    let Router2;
    if (options2.stateToken && !Util2.isV1StateToken(options2.stateToken) || options2.useInteractionCodeFlow || options2.proxyIdxResponse) {
      Router2 = WidgetRouter;
    } else {
      Router2 = V1Router;
    }
    this.Router = Router2;
    this.Router.prototype.Events.listenTo.call(this, Router2.prototype, "all", this.trigger);
    this.once("afterRender", function(context) {
      this.trigger("ready", context);
    });
  }
  /**
   * Render the sign in widget to an element. Returns a promise that will resolve on success or reject on error.
   * @param options - options for the signin widget.
   *        Must have an el or $el property to render the widget to.
   * @param success - success callback function
   * @param error - error callback function
   */
  renderEl(renderOptions, successFn, errorFn) {
    if (this.router) {
      throw new Error("An instance of the widget has already been rendered. Call remove() first.");
    }
    const res = createRouter(this.Router, this.options, renderOptions, this.authClient, successFn, errorFn, this.hooks);
    this.router = res.router;
    return res.promise;
  }
  hide() {
    if (this.router) {
      this.router.hide();
    }
  }
  show() {
    if (this.router) {
      this.router.show();
    }
  }
  remove() {
    if (this.router) {
      this.router.remove();
      this.router = void 0;
    }
  }
  /**
   * Renders the Widget and returns a promise that resolves to OAuth tokens
   * @param options - options for the signin widget
   */
  showSignInToGetTokens(options2) {
    const renderOptions = Object.assign(buildRenderOptions(this.options, options2), {
      redirect: "never"
    });
    const promise = this.renderEl(renderOptions).then((res) => {
      return res.tokens;
    });
    const authClient = this.router.settings.getAuthClient();
    if (authClient.isAuthorizationCodeFlow() && !authClient.isPKCE()) {
      throw new ConfigError('"showSignInToGetTokens()" should not be used for authorization_code flow. Use "showSignInAndRedirect()" instead');
    }
    return promise;
  }
  /**
   * Renders the widget and redirects to the OAuth callback
   * @param options - options for the signin widget
   */
  showSignInAndRedirect(options2) {
    const renderOptions = Object.assign(buildRenderOptions(this.options, options2), {
      redirect: "always"
    });
    return this.renderEl(renderOptions).then(() => {
      return;
    });
  }
  /**
   * Renders the widget. Either resolves the returned promise, or redirects.
   * @param options - options for the signin widget
   */
  showSignIn(options2) {
    const renderOptions = Object.assign(buildRenderOptions(this.options, options2));
    return this.renderEl(renderOptions);
  }
  // Hook convenience functions
  before(formName, callbackFn) {
    this.hooks.mergeHook(formName, {
      before: [callbackFn]
    });
  }
  after(formName, callbackFn) {
    this.hooks.mergeHook(formName, {
      after: [callbackFn]
    });
  }
  getUser() {
    var _this$router, _this$router$appState;
    return (_this$router = this.router) === null || _this$router === void 0 ? void 0 : (_this$router$appState = _this$router.appState) === null || _this$router$appState === void 0 ? void 0 : _this$router$appState.getUser();
  }
  // Events API
  on(event, callback) {
    if (EVENTS_LIST.includes(event)) {
      const origCallback = callback;
      callback = function(...callbackArgs) {
        try {
          origCallback.apply(this, callbackArgs);
        } catch (err) {
          Logger.error(`[okta-signin-widget] "${event}" event handler error:`, err);
        }
      };
    }
    this.Router.prototype.Events.on.call(this, event, callback);
  }
  off(event, callback) {
    this.Router.prototype.Events.off.call(this, event, callback);
  }
  once(event, callback) {
    this.Router.prototype.Events.once.call(this, event, callback);
  }
  stopListening(event, callback) {
    this.Router.prototype.Events.stopListening.call(this, event, callback);
  }
  listenTo(object, event, callback) {
    this.Router.prototype.Events.listenTo.call(this, object, event, callback);
  }
  trigger(event, ...args) {
    this.Router.prototype.Events.trigger.apply(this, [event, ...args]);
  }
};
export {
  OktaSignIn,
  OktaSignIn as default
};
/*! Bundled license information:

q/q.js:
  (*!
   *
   * Copyright 2009-2012 Kris Kowal under the terms of the MIT
   * license found at http://github.com/kriskowal/q/raw/master/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/lib/jquery-1.12.4.js:
  (*!
   * jQuery JavaScript Library v1.12.4
   * http://jquery.com/
   *
   * Includes Sizzle.js
   * http://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2017-10-25T15:48Z
   *)

@okta/okta-signin-widget/dist/esm/src/util/BrowserFeatures.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Logger.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Bundles.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/lib/js.cookie.js:
  (*!
   * JavaScript Cookie v2.1.0
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   *)

@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/courage/vendor/plugins/jquery.placeholder.js:
  (*! http://mths.be/placeholder v2.0.7 by @mathias *)

@okta/okta-signin-widget/dist/esm/packages/@okta/courage-dist/esm/src/util/scrollParent.js:
  (*!
   * jQuery UI Scroll Parent @VERSION
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * Modifications Copyright 2021 Okta, Inc.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Enums.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Errors.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/CustomError.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/AuthSdkError.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/browser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/base64.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/oidcHash.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/object.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/verifyToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/_virtual/_tslib.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@okta/okta-auth-js/esm/browser/constants.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/types.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/url.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/AuthApiError.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/OAuthError.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/http/request.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/tx/util.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/tx/api.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/misc.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/AuthPollStopError.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/tx/poll.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/tx/AuthTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/http/headers.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/pkce.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/session.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/oauth.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/features.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/errors/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/errors.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/loginRedirect.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/endpoints/well-known.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/defaultTokenParams.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/prepareTokenParams.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/types/api.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/types.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/decodeToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/revokeToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/types/Token.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/browser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/endpoints/authorize.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/validateClaims.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/verifyToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/handleOAuthResponse.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/getToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/getWithoutPrompt.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/refreshToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/endpoints/token.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/renewTokensWithRefresh.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/renewToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/renewTokens.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/getUserInfo.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/exchangeCodeForTokens.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/getWithPopup.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/oauthMeta.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/getWithRedirect.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/urlParams.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/parseFromUrl.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/crypto/webauthn.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/console.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/browser/browserStorage.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/oidc/util/validateToken.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/clock.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/types/TokenManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/TokenManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/services/AutoRenewService.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/services/SyncStorageService.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/services/LeaderElectionService.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/ServiceManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/PromiseQueue.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/browser/fingerprint.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/AuthStateManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/storage.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/SavedObject.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/StorageManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/types/Transaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/types/idx-js.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/util/sharedStorage.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/TransactionManager.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/builderUtil.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/fetch/fetchRequest.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/options/browser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/options/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/transactionMeta.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/interact.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/actionParser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/generateIdxAction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/remediationParser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/idxResponseParser.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/makeIdxState.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/v1/parsers.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/idxState/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/introspect.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/util.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/util.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Base/Remediator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/Authenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/VerificationCodeAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/OktaVerifyTotp.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/OktaPassword.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/SecurityQuestionEnrollment.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/SecurityQuestionVerification.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/WebauthnEnrollment.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/WebauthnVerification.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticator/getAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Base/VerifyAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/EnrollAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/EnrollPoll.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/SelectEnrollmentChannel.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/EnrollmentChannelData.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/ChallengeAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/ChallengePoll.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/ResetAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/EnrollProfile.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Identify.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/ReEnrollAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/RedirectIdp.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Base/SelectAuthenticator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorAuthenticate.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorEnroll.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/SelectAuthenticatorUnlockAccount.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/SelectEnrollProfile.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Base/AuthenticatorData.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/AuthenticatorVerificationData.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/AuthenticatorEnrollmentData.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/Skip.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/GenericRemediator/util.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/GenericRemediator/GenericRemediator.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediators/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/util.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/remediate.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/flow/AuthenticationFlow.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/flow/PasswordRecoveryFlow.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/flow/RegistrationFlow.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/flow/AccountUnlockFlow.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/flow/FlowSpecification.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/run.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/authenticate.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/cancel.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/emailVerify.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/proceed.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/poll.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/startTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/register.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/recoverPassword.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/handleInteractionCodeRedirect.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/idx/unlockAccount.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/OktaUserAgent.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/OktaAuth.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/Base.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/ProfileTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/ProfileSchemaTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/EmailTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/EmailStatusTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/EmailChallengeTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/transactions/PhoneTransaction.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/request.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/profileApi.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/emailApi.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/myaccount/phoneApi.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-auth-js/esm/browser/index.js:
  (*!
   * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * 
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/OAuth2Util.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/BaseLoginModel.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/BaseLoginController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/FormType.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/FormController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/AccountUnlockedController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/FactorUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/shared/TextBox.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-factors/EnterPasscodeForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/ActivateTotpController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/AdminConsentRequiredController.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/ErrorCodes.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/BarcodePushController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/BarcodeTotpController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/consent/ScopeList.js:
  (*!
   * Copyright (c) 2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/CustomPasswordExpiredController.js:
  (*!
   * Copyright (c) 2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollCustomFactorController.js:
  (*!
   * Copyright (c) 2018-2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/Factor.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollActivateCustomFactorController.js:
  (*!
   * Copyright (c) 2019-2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/countryCallingCodes.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/CountryUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/enroll-choices/RequiredFactorList.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollDuoController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollHotpController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollOnPremController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/ValidationUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollPasswordController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollQuestionController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollSymantecVipController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/StoreLinks.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/FidoUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/EnrollUser.js:
  (*!
   * Copyright (c) 2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the 'License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/ProfileSchema.js:
  (*!
   * Copyright (c) 2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollUserController.js:
  (*!
   * Copyright (c) 2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/CryptoUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/webauthn.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/shared/Spinner.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollWindowsHelloController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/EnrollYubikeyController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/CookieUtil.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/PrimaryAuth.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/DeviceFingerprint.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/packages/vendor/TypingDnaRecorder-JavaScript/typingdna.js:
  (**
   * TypingDNA - Typing Biometrics JavaScript API
   * https://api.typingdna.com/scripts/typingdna.js
   * https://typingdna.com/scripts/typingdna.js (alternative)
   *
   * @version 2.15
   * @author Raul Popa
   * @copyright SC TypingDNA SRL, http://typingdna.com
   * @license http://www.apache.org/licenses/LICENSE-2.0
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * Typical usage:
   * var tdna = new TypingDNA(); // creates a new TypingDNA object and starts recording
   * var typingPattern = tdna.getTypingPattern({type=1, text="Hello5g21?*"});
   * returns a type 1 typing pattern (and continues recording afterwards)
   *
   * Optional:
   * tdna.stop(); // ends recording and clears history stack (returns recording flag: false)
   * tdna.start(); // restarts the recording after a stop (returns recording flag: true)
   * tdna.reset(); // restarts the recording anytime, clears history stack and starts from scratch (returns nothing)
   * var typingPatternQuality = TypingDNA.getQuality(typingPattern); //returns the quality/strength of any typing pattern
   * (there is no need to initialize the class to do pattern quality checking)
   *)

@okta/okta-signin-widget/dist/esm/src/v1/util/TypingUtil.js:
  (*!
   * Copyright (c) 2018, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/primary-auth/PrimaryAuthForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/PrimaryAuthController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/IDPDiscovery.js:
  (*!
   * Copyright (c) 2015-2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/idp-discovery/IDPDiscoveryForm.js:
  (*!
   * Copyright (c) 2015-2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/IDPDiscoveryController.js:
  (*!
   * Copyright (c) 2015-2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/ForceIDPDiscoveryController.js:
  (*!
   * Copyright (c) 2015-2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/factor-verify/EmailMagicLinkForm.js:
  (*!
   * Copyright (c) 2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/InlineTOTPForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/PasswordForm.js:
  (*!
   * Copyright (c) 2016-2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/SecurityQuestionForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/TOTPForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/YubikeyForm.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/MfaVerifyController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/PasswordExpiredController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/PasswordResetController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/PollController.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/RecoveryLoadingController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/RecoveryQuestionController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/LoginModel.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/models/RegistrationSchema.js:
  (*!
   * Copyright (c) 2017, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/UnlockEmailSentController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyCustomFactorController.js:
  (*!
   * Copyright (c) 2018-2019, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyDuoController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/VerifyWindowsHelloController.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/controllers/ErrorStateController.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/shared/AuthContainer.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Animations.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/ColorsUtil.js:
  (*!
   * Copyright (c) 2018-Present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/BaseLoginRouter.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/views/mfa-verify/dropdown/FactorsDropDown.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v1/LoginRouter.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/RemediationConstants.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-object-handler.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/util/Hooks.js:
  (*!
   * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/models/AppState.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/sessionStorageHelper.js:
  (*!
   * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/emailVerifyCallback.js:
  (*!
   * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/constants.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/startLoginFlow.js:
  (*!
   * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/handleConfiguredFlow.js:
  (*!
   * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/interactionCodeFlow.js:
  (*!
   * Copyright (c) 2021, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/responseTransformer.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-boolean-handler.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/ui-schema/ion-string-handler.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/uiSchemaTransformer.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/AuthenticatorUtil.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/transformIdxResponse.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/client/formatError.js:
  (*!
   * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/ion/IonResponseHelper.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/view-builder/components/ToggleTextLink.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/view-builder/internals/BaseModel.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/view-builder/utils/DeviceFingerprinting.js:
  (*!
   * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/controllers/FormController.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/v2/WidgetRouter.js:
  (*!
   * Copyright (c) 2020, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)

@okta/okta-signin-widget/dist/esm/src/models/Hooks.js:
  (*!
   * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
   * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
   *
   * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *
   * See the License for the specific language governing permissions and limitations under the License.
   *)
*/
//# sourceMappingURL=@okta_okta-signin-widget.js.map
